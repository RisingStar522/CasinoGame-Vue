"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __importDefault(require("assert"));
var tronweb = __importStar(require("tronweb"));
var tron_1 = require("../../../resources/trx/protobuf/tron");
var errors_1 = require("../baseCoin/errors");
var enum_1 = require("./enum");
/**
 * @param address
 */
function isBase58Address(address) {
    return tronweb.utils.crypto.isAddressValid(address);
}
exports.isBase58Address = isBase58Address;
/**
 * @param str
 */
function getByteArrayFromHexAddress(str) {
    return tronweb.utils.code.hexStr2byteArray(str);
}
exports.getByteArrayFromHexAddress = getByteArrayFromHexAddress;
/**
 * @param arr
 */
function getHexAddressFromByteArray(arr) {
    return tronweb.utils.code.byteArray2hexStr(arr);
}
exports.getHexAddressFromByteArray = getHexAddressFromByteArray;
/**
 * @param messageToVerify
 * @param base58Address
 * @param sigHex
 * @param useTronHeader
 */
function verifySignature(messageToVerify, base58Address, sigHex, useTronHeader) {
    if (useTronHeader === void 0) { useTronHeader = true; }
    if (!isValidHex(sigHex)) {
        throw new errors_1.UtilsError('signature is not in a valid format, needs to be hexadecimal');
    }
    if (!isValidHex(messageToVerify)) {
        throw new errors_1.UtilsError('message is not in a valid format, needs to be hexadecimal');
    }
    if (!isBase58Address(base58Address)) {
        throw new errors_1.UtilsError('address needs to be base58 encoded');
    }
    return tronweb.Trx.verifySignature(messageToVerify, base58Address, sigHex, useTronHeader);
}
exports.verifySignature = verifySignature;
/**
 * @param base58
 */
function getHexAddressFromBase58Address(base58) {
    // pulled from: https://github.com/TRON-US/tronweb/blob/dcb8efa36a5ebb65c4dab3626e90256a453f3b0d/src/utils/help.js#L17
    // but they don't surface this call in index.js
    var bytes = tronweb.utils.crypto.decodeBase58Address(base58);
    return getHexAddressFromByteArray(bytes);
}
exports.getHexAddressFromBase58Address = getHexAddressFromBase58Address;
/**
 * @param privateKey
 */
function getPubKeyFromPriKey(privateKey) {
    return tronweb.utils.crypto.getPubKeyFromPriKey(privateKey);
}
exports.getPubKeyFromPriKey = getPubKeyFromPriKey;
/**
 * @param privateKey
 */
function getAddressFromPriKey(privateKey) {
    return tronweb.utils.crypto.getAddressFromPriKey(privateKey);
}
exports.getAddressFromPriKey = getAddressFromPriKey;
/**
 * @param address
 */
function getBase58AddressFromByteArray(address) {
    return tronweb.utils.crypto.getBase58CheckAddress(address);
}
exports.getBase58AddressFromByteArray = getBase58AddressFromByteArray;
/**
 * @param hex
 */
function getBase58AddressFromHex(hex) {
    var arr = getByteArrayFromHexAddress(hex);
    return getBase58AddressFromByteArray(arr);
}
exports.getBase58AddressFromHex = getBase58AddressFromHex;
/**
 * @param privateKey
 * @param transaction
 */
function signTransaction(privateKey, transaction) {
    return tronweb.utils.crypto.signTransaction(privateKey, transaction);
}
exports.signTransaction = signTransaction;
/**
 * @param message
 * @param privateKey
 * @param useTronHeader
 */
function signString(message, privateKey, useTronHeader) {
    if (useTronHeader === void 0) { useTronHeader = true; }
    return tronweb.Trx.signString(message, privateKey, useTronHeader);
}
exports.signString = signString;
/**
 * @param pubBytes
 */
function getRawAddressFromPubKey(pubBytes) {
    return tronweb.utils.crypto.computeAddress(pubBytes);
}
exports.getRawAddressFromPubKey = getRawAddressFromPubKey;
/**
 * Decodes a hex encoded transaction in its protobuf representation.
 *
 * @param hexString raw_data_hex field from tron transactions
 */
function decodeTransaction(hexString) {
    var rawTransaction = decodeRawTransaction(hexString);
    // there should not be multiple contracts in this data
    if (rawTransaction.contracts.length !== 1) {
        throw new errors_1.UtilsError('Number of contracts is greater than 1.');
    }
    var contract;
    var contractType;
    // ensure the contract type is supported
    switch (rawTransaction.contracts[0].parameter.type_url) {
        case 'type.googleapis.com/protocol.TransferContract':
            contractType = enum_1.ContractType.Transfer;
            contract = exports.decodeTransferContract(rawTransaction.contracts[0].parameter.value);
            break;
        case 'type.googleapis.com/protocol.AccountPermissionUpdateContract':
            contractType = enum_1.ContractType.AccountPermissionUpdate;
            contract = exports.decodeAccountPermissionUpdateContract(rawTransaction.contracts[0].parameter.value);
            break;
        default:
            throw new errors_1.UtilsError('Unsupported contract type');
    }
    return {
        contractType: contractType,
        contract: contract,
        expiration: rawTransaction.expiration,
        timestamp: rawTransaction.timestamp,
    };
}
exports.decodeTransaction = decodeTransaction;
/**
 * Decodes a transaction's raw field from a base64 encoded string. This is a protobuf representation.
 *
 * @param hexString this is the raw hexadecimal encoded string. Doc found in the following link.
 * @example
 * @see {@link https://github.com/BitGo/bitgo-account-lib/blob/5f282588701778a4421c75fa61f42713f56e95b9/resources/trx/protobuf/tron.proto#L319}
 */
function decodeRawTransaction(hexString) {
    var bytes = Buffer.from(hexString, 'hex');
    var raw;
    try {
        // we need to decode our raw_data_hex field first
        raw = tron_1.protocol.Transaction.raw.decode(bytes);
    }
    catch (e) {
        throw new errors_1.UtilsError('There was an error decoding the initial raw_data_hex from the serialized tx.');
    }
    return {
        expiration: Number(raw.expiration),
        timestamp: Number(raw.timestamp),
        contracts: raw.contract,
    };
}
exports.decodeRawTransaction = decodeRawTransaction;
/**
 * Indicates whether the passed string is a safe hex string for tron's purposes.
 *
 * @param hex A valid hex string must be a string made of numbers and characters and has an even length.
 */
function isValidHex(hex) {
    return /^(0x)?([0-9a-f]{2})+$/i.test(hex);
}
exports.isValidHex = isValidHex;
/** Deserialize the segment of the txHex which corresponds with the details of the transfer
 *
 * @param transferHex is the value property of the "parameter" field of contractList[0]
 * */
function decodeTransferContract(transferHex) {
    var contractBytes = Buffer.from(transferHex, 'base64');
    var transferContract;
    try {
        transferContract = tron_1.protocol.TransferContract.decode(contractBytes);
    }
    catch (e) {
        throw new errors_1.UtilsError('There was an error decoding the transfer contract in the transaction.');
    }
    if (!transferContract.ownerAddress) {
        throw new errors_1.UtilsError('Owner address does not exist in this transfer contract.');
    }
    if (!transferContract.toAddress) {
        throw new errors_1.UtilsError('Destination address does not exist in this transfer contract.');
    }
    if (!transferContract.hasOwnProperty('amount')) {
        throw new errors_1.UtilsError('Amount does not exist in this transfer contract.');
    }
    // deserialize attributes
    var owner_address = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(transferContract.ownerAddress, 'base64').toString('hex')));
    var to_address = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(transferContract.toAddress, 'base64').toString('hex')));
    var amount = transferContract.amount;
    return [
        {
            parameter: {
                value: {
                    amount: Number(amount),
                    owner_address: owner_address,
                    to_address: to_address,
                },
            },
        },
    ];
}
exports.decodeTransferContract = decodeTransferContract;
/**
 * Deserialize the segment of the txHex corresponding with the details of the contract which updates
 * account permission
 *
 * @param {string} base64
 * @returns {AccountPermissionUpdateContract}
 */
function decodeAccountPermissionUpdateContract(base64) {
    var accountUpdateContract = tron_1.protocol.AccountPermissionUpdateContract.decode(Buffer.from(base64, 'base64')).toJSON();
    assert_1.default(accountUpdateContract.ownerAddress);
    assert_1.default(accountUpdateContract.owner);
    assert_1.default(accountUpdateContract.hasOwnProperty('actives'));
    var ownerAddress = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(accountUpdateContract.ownerAddress, 'base64').toString('hex')));
    var owner = createPermission(accountUpdateContract.owner);
    var witness = undefined;
    if (accountUpdateContract.witness) {
        witness = createPermission(accountUpdateContract.witness);
    }
    var activeList = accountUpdateContract.actives.map(function (active) { return createPermission(active); });
    return {
        ownerAddress: ownerAddress,
        owner: owner,
        witness: witness,
        actives: activeList,
    };
}
exports.decodeAccountPermissionUpdateContract = decodeAccountPermissionUpdateContract;
/**
 * @param raw
 */
function createPermission(raw) {
    var permissionType;
    var permission = raw.permissionName.toLowerCase().trim();
    if (permission === 'owner') {
        permissionType = enum_1.PermissionType.Owner;
    }
    else if (permission === 'witness') {
        permissionType = enum_1.PermissionType.Witness;
    }
    else if (permission.substr(0, 6) === 'active') {
        permissionType = enum_1.PermissionType.Active;
    }
    else {
        throw new errors_1.UtilsError('Permission type not parseable.');
    }
    return { type: permissionType, threshold: raw.threshold };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi90cngvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsa0RBQTRCO0FBQzVCLCtDQUFtQztBQUNuQyw2REFBZ0U7QUFFaEUsNkNBQWdEO0FBRWhELCtCQUFzRDtBQVF0RDs7R0FFRztBQUNILFNBQWdCLGVBQWUsQ0FBQyxPQUFlO0lBQzdDLE9BQU8sT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3RELENBQUM7QUFGRCwwQ0FFQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsMEJBQTBCLENBQUMsR0FBVztJQUNwRCxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2xELENBQUM7QUFGRCxnRUFFQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsMEJBQTBCLENBQUMsR0FBYztJQUN2RCxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2xELENBQUM7QUFGRCxnRUFFQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsZUFBZSxDQUM3QixlQUF1QixFQUN2QixhQUFxQixFQUNyQixNQUFjLEVBQ2QsYUFBb0I7SUFBcEIsOEJBQUEsRUFBQSxvQkFBb0I7SUFFcEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUN2QixNQUFNLElBQUksbUJBQVUsQ0FBQyw2REFBNkQsQ0FBQyxDQUFDO0tBQ3JGO0lBRUQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsRUFBRTtRQUNoQyxNQUFNLElBQUksbUJBQVUsQ0FBQywyREFBMkQsQ0FBQyxDQUFDO0tBQ25GO0lBRUQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsRUFBRTtR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QUFDLEdBQUcsQ0FBQyxVQUFBLE1BQU0sSUFBSSxPQUFBLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxFQUF4QixDQUF3QixDQUFDLENBQUM7SUFFekYsT0FBTztRQUNMLFlBQVksY0FBQTtRQUNaLEtBQUssT0FBQTtRQUNMLE9BQU8sU0FBQTtRQUNQLE9BQU8sRUFBRSxVQUFVO0tBQ3BCLENBQUM7QUFDSixDQUFDO0FBdEJELHNGQXNCQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxnQkFBZ0IsQ0FBQyxHQUFrRDtJQUMxRSxJQUFJLGNBQThCLENBQUM7SUFDbkMsSUFBTSxVQUFVLEdBQUcsR0FBRyxDQUFDLGNBQWMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUMzRCxJQUFJLFVBQVUsS0FBSyxPQUFPLEVBQUU7UUFDMUIsY0FBYyxHQUFHLHFCQUFjLENBQUMsS0FBSyxDQUFDO0tBQ3ZDO1NBQU0sSUFBSSxVQUFVLEtBQUssU0FBUyxFQUFFO1FBQ25DLGNBQWMsR0FBRyxxQkFBYyxDQUFDLE9BQU8sQ0FBQztLQUN6QztTQUFNLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssUUFBUSxFQUFFO1FBQy9DLGNBQWMsR0FBRyxxQkFBYyxDQUFDLE1BQU0sQ0FBQztLQUN4QztTQUFNO1FBQ0wsTUFBTSxJQUFJLG1CQUFVLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztLQUN4RDtJQUNELE9BQU8sRUFBRSxJQUFJLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFBRSxHQUFHLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDNUQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCAqIGFzIHRyb253ZWIgZnJvbSAndHJvbndlYic7XG5pbXBvcnQgeyBwcm90b2NvbCB9IGZyb20gJy4uLy4uLy4uL3Jlc291cmNlcy90cngvcHJvdG9idWYvdHJvbic7XG5cbmltcG9ydCB7IFV0aWxzRXJyb3IgfSBmcm9tICcuLi9iYXNlQ29pbi9lcnJvcnMnO1xuaW1wb3J0IHsgVHJhbnNmZXJDb250cmFjdCwgUmF3RGF0YSwgQWNjb3VudFBlcm1pc3Npb25VcGRhdGVDb250cmFjdCwgVHJhbnNhY3Rpb25SZWNlaXB0LCBQZXJtaXNzaW9uIH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBDb250cmFjdFR5cGUsIFBlcm1pc3Npb25UeXBlIH0gZnJvbSAnLi9lbnVtJztcblxuLyoqXG4gKiBUcm9uLXNwZWNpZmljIGhlbHBlciBmdW5jdGlvbnNcbiAqL1xuZXhwb3J0IHR5cGUgVHJvbkJpbmFyeUxpa2UgPSBCeXRlQXJyYXkgfCBCdWZmZXIgfCBVaW50OEFycmF5IHwgc3RyaW5nO1xuZXhwb3J0IHR5cGUgQnl0ZUFycmF5ID0gbnVtYmVyW107XG5cbi8qKlxuICogQHBhcmFtIGFkZHJlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmFzZTU4QWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIHRyb253ZWIudXRpbHMuY3J5cHRvLmlzQWRkcmVzc1ZhbGlkKGFkZHJlc3MpO1xufVxuXG4vKipcbiAqIEBwYXJhbSBzdHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ5dGVBcnJheUZyb21IZXhBZGRyZXNzKHN0cjogc3RyaW5nKTogQnl0ZUFycmF5IHtcbiAgcmV0dXJuIHRyb253ZWIudXRpbHMuY29kZS5oZXhTdHIyYnl0ZUFycmF5KHN0cik7XG59XG5cbi8qKlxuICogQHBhcmFtIGFyclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGV4QWRkcmVzc0Zyb21CeXRlQXJyYXkoYXJyOiBCeXRlQXJyYXkpOiBzdHJpbmcge1xuICByZXR1cm4gdHJvbndlYi51dGlscy5jb2RlLmJ5dGVBcnJheTJoZXhTdHIoYXJyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gbWVzc2FnZVRvVmVyaWZ5XG4gKiBAcGFyYW0gYmFzZTU4QWRkcmVzc1xuICogQHBhcmFtIHNpZ0hleFxuICogQHBhcmFtIHVzZVRyb25IZWFkZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZShcbiAgbWVzc2FnZVRvVmVyaWZ5OiBzdHJpbmcsXG4gIGJhc2U1OEFkZHJlc3M6IHN0cmluZyxcbiAgc2lnSGV4OiBzdHJpbmcsXG4gIHVzZVRyb25IZWFkZXIgPSB0cnVlLFxuKTogYm9vbGVhbiB7XG4gIGlmICghaXNWYWxpZEhleChzaWdIZXgpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ3NpZ25hdHVyZSBpcyBub3QgaW4gYSB2YWxpZCBmb3JtYXQsIG5lZWRzIHRvIGJlIGhleGFkZWNpbWFsJyk7XG4gIH1cblxuICBpZiAoIWlzVmFsaWRIZXgobWVzc2FnZVRvVmVyaWZ5KSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdtZXNzYWdlIGlzIG5vdCBpbiBhIHZhbGlkIGZvcm1hdCwgbmVlZHMgdG8gYmUgaGV4YWRlY2ltYWwnKTtcbiAgfVxuXG4gIGlmICghaXNCYXNlNThBZGRyZXNzKGJhc2U1OEFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ2FkZHJlc3MgbmVlZHMgdG8gYmUgYmFzZTU4IGVuY29kZWQnKTtcbiAgfVxuXG4gIHJldHVybiB0cm9ud2ViLlRyeC52ZXJpZnlTaWduYXR1cmUobWVzc2FnZVRvVmVyaWZ5LCBiYXNlNThBZGRyZXNzLCBzaWdIZXgsIHVzZVRyb25IZWFkZXIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSBiYXNlNThcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhleEFkZHJlc3NGcm9tQmFzZTU4QWRkcmVzcyhiYXNlNTg6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIHB1bGxlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vVFJPTi1VUy90cm9ud2ViL2Jsb2IvZGNiOGVmYTM2YTVlYmI2NWM0ZGFiMzYyNmU5MDI1NmE0NTNmM2IwZC9zcmMvdXRpbHMvaGVscC5qcyNMMTdcbiAgLy8gYnV0IHRoZXkgZG9uJ3Qgc3VyZmFjZSB0aGlzIGNhbGwgaW4gaW5kZXguanNcbiAgY29uc3QgYnl0ZXMgPSB0cm9ud2ViLnV0aWxzLmNyeXB0by5kZWNvZGVCYXNlNThBZGRyZXNzKGJhc2U1OCk7XG4gIHJldHVybiBnZXRIZXhBZGRyZXNzRnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHByaXZhdGVLZXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFB1YktleUZyb21QcmlLZXkocHJpdmF0ZUtleTogVHJvbkJpbmFyeUxpa2UpOiBCeXRlQXJyYXkge1xuICByZXR1cm4gdHJvbndlYi51dGlscy5jcnlwdG8uZ2V0UHViS2V5RnJvbVByaUtleShwcml2YXRlS2V5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gcHJpdmF0ZUtleVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzc0Zyb21QcmlLZXkocHJpdmF0ZUtleTogVHJvbkJpbmFyeUxpa2UpOiBCeXRlQXJyYXkge1xuICByZXR1cm4gdHJvbndlYi51dGlscy5jcnlwdG8uZ2V0QWRkcmVzc0Zyb21QcmlLZXkocHJpdmF0ZUtleSk7XG59XG5cbi8qKlxuICogQHBhcmFtIGFkZHJlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJhc2U1OEFkZHJlc3NGcm9tQnl0ZUFycmF5KGFkZHJlc3M6IEJ5dGVBcnJheSk6IHN0cmluZyB7XG4gIHJldHVybiB0cm9ud2ViLnV0aWxzLmNyeXB0by5nZXRCYXNlNThDaGVja0FkZHJlc3MoYWRkcmVzcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIGhleFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmFzZTU4QWRkcmVzc0Zyb21IZXgoaGV4OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBhcnIgPSBnZXRCeXRlQXJyYXlGcm9tSGV4QWRkcmVzcyhoZXgpO1xuICByZXR1cm4gZ2V0QmFzZTU4QWRkcmVzc0Zyb21CeXRlQXJyYXkoYXJyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHRyYW5zYWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWduVHJhbnNhY3Rpb24ocHJpdmF0ZUtleTogc3RyaW5nIHwgQnl0ZUFycmF5LCB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25SZWNlaXB0KTogVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgcmV0dXJuIHRyb253ZWIudXRpbHMuY3J5cHRvLnNpZ25UcmFuc2FjdGlvbihwcml2YXRlS2V5LCB0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogQHBhcmFtIG1lc3NhZ2VcbiAqIEBwYXJhbSBwcml2YXRlS2V5XG4gKiBAcGFyYW0gdXNlVHJvbkhlYWRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnblN0cmluZyhtZXNzYWdlOiBzdHJpbmcsIHByaXZhdGVLZXk6IHN0cmluZyB8IEJ5dGVBcnJheSwgdXNlVHJvbkhlYWRlciA9IHRydWUpOiBzdHJpbmcge1xuICByZXR1cm4gdHJvbndlYi5Ucnguc2lnblN0cmluZyhtZXNzYWdlLCBwcml2YXRlS2V5LCB1c2VUcm9uSGVhZGVyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gcHViQnl0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJhd0FkZHJlc3NGcm9tUHViS2V5KHB1YkJ5dGVzOiBUcm9uQmluYXJ5TGlrZSk6IEJ5dGVBcnJheSB7XG4gIHJldHVybiB0cm9ud2ViLnV0aWxzLmNyeXB0by5jb21wdXRlQWRkcmVzcyhwdWJCeXRlcyk7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIGhleCBlbmNvZGVkIHRyYW5zYWN0aW9uIGluIGl0cyBwcm90b2J1ZiByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0gaGV4U3RyaW5nIHJhd19kYXRhX2hleCBmaWVsZCBmcm9tIHRyb24gdHJhbnNhY3Rpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUcmFuc2FjdGlvbihoZXhTdHJpbmc6IHN0cmluZyk6IFJhd0RhdGEge1xuICBjb25zdCByYXdUcmFuc2FjdGlvbiA9IGRlY29kZVJhd1RyYW5zYWN0aW9uKGhleFN0cmluZyk7XG5cbiAgLy8gdGhlcmUgc2hvdWxkIG5vdCBiZSBtdWx0aXBsZSBjb250cmFjdHMgaW4gdGhpcyBkYXRhXG4gIGlmIChyYXdUcmFuc2FjdGlvbi5jb250cmFjdHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ051bWJlciBvZiBjb250cmFjdHMgaXMgZ3JlYXRlciB0aGFuIDEuJyk7XG4gIH1cblxuICBsZXQgY29udHJhY3Q6IFRyYW5zZmVyQ29udHJhY3RbXSB8IEFjY291bnRQZXJtaXNzaW9uVXBkYXRlQ29udHJhY3RbXTtcbiAgbGV0IGNvbnRyYWN0VHlwZTogQ29udHJhY3RUeXBlO1xuICAvLyBlbnN1cmUgdGhlIGNvbnRyYWN0IHR5cGUgaXMgc3VwcG9ydGVkXG4gIHN3aXRjaCAocmF3VHJhbnNhY3Rpb24uY29udHJhY3RzWzBdLnBhcmFtZXRlci50eXBlX3VybCkge1xuICAgIGNhc2UgJ3R5cGUuZ29vZ2xlYXBpcy5jb20vcHJvdG9jb2wuVHJhbnNmZXJDb250cmFjdCc6XG4gICAgICBjb250cmFjdFR5cGUgPSBDb250cmFjdFR5cGUuVHJhbnNmZXI7XG4gICAgICBjb250cmFjdCA9IGV4cG9ydHMuZGVjb2RlVHJhbnNmZXJDb250cmFjdChyYXdUcmFuc2FjdGlvbi5jb250cmFjdHNbMF0ucGFyYW1ldGVyLnZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3R5cGUuZ29vZ2xlYXBpcy5jb20vcHJvdG9jb2wuQWNjb3VudFBlcm1pc3Npb25VcGRhdGVDb250cmFjdCc6XG4gICAgICBjb250cmFjdFR5cGUgPSBDb250cmFjdFR5cGUuQWNjb3VudFBlcm1pc3Npb25VcGRhdGU7XG4gICAgICBjb250cmFjdCA9IGV4cG9ydHMuZGVjb2RlQWNjb3VudFBlcm1pc3Npb25VcGRhdGVDb250cmFjdChyYXdUcmFuc2FjdGlvbi5jb250cmFjdHNbMF0ucGFyYW1ldGVyLnZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignVW5zdXBwb3J0ZWQgY29udHJhY3QgdHlwZScpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb250cmFjdFR5cGUsXG4gICAgY29udHJhY3QsXG4gICAgZXhwaXJhdGlvbjogcmF3VHJhbnNhY3Rpb24uZXhwaXJhdGlvbixcbiAgICB0aW1lc3RhbXA6IHJhd1RyYW5zYWN0aW9uLnRpbWVzdGFtcCxcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgdHJhbnNhY3Rpb24ncyByYXcgZmllbGQgZnJvbSBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBhIHByb3RvYnVmIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBwYXJhbSBoZXhTdHJpbmcgdGhpcyBpcyB0aGUgcmF3IGhleGFkZWNpbWFsIGVuY29kZWQgc3RyaW5nLiBEb2MgZm91bmQgaW4gdGhlIGZvbGxvd2luZyBsaW5rLlxuICogQGV4YW1wbGVcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9CaXRHby9iaXRnby1hY2NvdW50LWxpYi9ibG9iLzVmMjgyNTg4NzAxNzc4YTQ0MjFjNzVmYTYxZjQyNzEzZjU2ZTk1YjkvcmVzb3VyY2VzL3RyeC9wcm90b2J1Zi90cm9uLnByb3RvI0wzMTl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSYXdUcmFuc2FjdGlvbihcbiAgaGV4U3RyaW5nOiBzdHJpbmcsXG4pOiB7IGV4cGlyYXRpb246IG51bWJlcjsgdGltZXN0YW1wOiBudW1iZXI7IGNvbnRyYWN0czogQXJyYXk8YW55PiB9IHtcbiAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuZnJvbShoZXhTdHJpbmcsICdoZXgnKTtcblxuICBsZXQgcmF3O1xuICB0cnkge1xuICAgIC8vIHdlIG5lZWQgdG8gZGVjb2RlIG91ciByYXdfZGF0YV9oZXggZmllbGQgZmlyc3RcbiAgICByYXcgPSBwcm90b2NvbC5UcmFuc2FjdGlvbi5yYXcuZGVjb2RlKGJ5dGVzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3IgZGVjb2RpbmcgdGhlIGluaXRpYWwgcmF3X2RhdGFfaGV4IGZyb20gdGhlIHNlcmlhbGl6ZWQgdHguJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cGlyYXRpb246IE51bWJlcihyYXcuZXhwaXJhdGlvbiksXG4gICAgdGltZXN0YW1wOiBOdW1iZXIocmF3LnRpbWVzdGFtcCksXG4gICAgY29udHJhY3RzOiByYXcuY29udHJhY3QsXG4gIH07XG59XG5cbi8qKlxuICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHBhc3NlZCBzdHJpbmcgaXMgYSBzYWZlIGhleCBzdHJpbmcgZm9yIHRyb24ncyBwdXJwb3Nlcy5cbiAqXG4gKiBAcGFyYW0gaGV4IEEgdmFsaWQgaGV4IHN0cmluZyBtdXN0IGJlIGEgc3RyaW5nIG1hZGUgb2YgbnVtYmVycyBhbmQgY2hhcmFjdGVycyBhbmQgaGFzIGFuIGV2ZW4gbGVuZ3RoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEhleChoZXg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gL14oMHgpPyhbMC05YS1mXXsyfSkrJC9pLnRlc3QoaGV4KTtcbn1cblxuLyoqIERlc2VyaWFsaXplIHRoZSBzZWdtZW50IG9mIHRoZSB0eEhleCB3aGljaCBjb3JyZXNwb25kcyB3aXRoIHRoZSBkZXRhaWxzIG9mIHRoZSB0cmFuc2ZlclxuICpcbiAqIEBwYXJhbSB0cmFuc2ZlckhleCBpcyB0aGUgdmFsdWUgcHJvcGVydHkgb2YgdGhlIFwicGFyYW1ldGVyXCIgZmllbGQgb2YgY29udHJhY3RMaXN0WzBdXG4gKiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRyYW5zZmVyQ29udHJhY3QodHJhbnNmZXJIZXg6IHN0cmluZyk6IFRyYW5zZmVyQ29udHJhY3RbXSB7XG4gIGNvbnN0IGNvbnRyYWN0Qnl0ZXMgPSBCdWZmZXIuZnJvbSh0cmFuc2ZlckhleCwgJ2Jhc2U2NCcpO1xuICBsZXQgdHJhbnNmZXJDb250cmFjdDtcblxuICB0cnkge1xuICAgIHRyYW5zZmVyQ29udHJhY3QgPSBwcm90b2NvbC5UcmFuc2ZlckNvbnRyYWN0LmRlY29kZShjb250cmFjdEJ5dGVzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3IgZGVjb2RpbmcgdGhlIHRyYW5zZmVyIGNvbnRyYWN0IGluIHRoZSB0cmFuc2FjdGlvbi4nKTtcbiAgfVxuXG4gIGlmICghdHJhbnNmZXJDb250cmFjdC5vd25lckFkZHJlc3MpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignT3duZXIgYWRkcmVzcyBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIHRyYW5zZmVyIGNvbnRyYWN0LicpO1xuICB9XG5cbiAgaWYgKCF0cmFuc2ZlckNvbnRyYWN0LnRvQWRkcmVzcykge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdEZXN0aW5hdGlvbiBhZGRyZXNzIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgdHJhbnNmZXIgY29udHJhY3QuJyk7XG4gIH1cblxuICBpZiAoIXRyYW5zZmVyQ29udHJhY3QuaGFzT3duUHJvcGVydHkoJ2Ftb3VudCcpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ0Ftb3VudCBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIHRyYW5zZmVyIGNvbnRyYWN0LicpO1xuICB9XG5cbiAgLy8gZGVzZXJpYWxpemUgYXR0cmlidXRlc1xuICBjb25zdCBvd25lcl9hZGRyZXNzID0gZ2V0QmFzZTU4QWRkcmVzc0Zyb21CeXRlQXJyYXkoXG4gICAgZ2V0Qnl0ZUFycmF5RnJvbUhleEFkZHJlc3MoQnVmZmVyLmZyb20odHJhbnNmZXJDb250cmFjdC5vd25lckFkZHJlc3MsICdiYXNlNjQnKS50b1N0cmluZygnaGV4JykpLFxuICApO1xuICBjb25zdCB0b19hZGRyZXNzID0gZ2V0QmFzZTU4QWRkcmVzc0Zyb21CeXRlQXJyYXkoXG4gICAgZ2V0Qnl0ZUFycmF5RnJvbUhleEFkZHJlc3MoQnVmZmVyLmZyb20odHJhbnNmZXJDb250cmFjdC50b0FkZHJlc3MsICdiYXNlNjQnKS50b1N0cmluZygnaGV4JykpLFxuICApO1xuICBjb25zdCBhbW91bnQgPSB0cmFuc2ZlckNvbnRyYWN0LmFtb3VudDtcblxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHBhcmFtZXRlcjoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGFtb3VudDogTnVtYmVyKGFtb3VudCksXG4gICAgICAgICAgb3duZXJfYWRkcmVzcyxcbiAgICAgICAgICB0b19hZGRyZXNzLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICBdO1xufVxuXG4vKipcbiAqIERlc2VyaWFsaXplIHRoZSBzZWdtZW50IG9mIHRoZSB0eEhleCBjb3JyZXNwb25kaW5nIHdpdGggdGhlIGRldGFpbHMgb2YgdGhlIGNvbnRyYWN0IHdoaWNoIHVwZGF0ZXNcbiAqIGFjY291bnQgcGVybWlzc2lvblxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRcbiAqIEByZXR1cm5zIHtBY2NvdW50UGVybWlzc2lvblVwZGF0ZUNvbnRyYWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQWNjb3VudFBlcm1pc3Npb25VcGRhdGVDb250cmFjdChiYXNlNjQ6IHN0cmluZyk6IEFjY291bnRQZXJtaXNzaW9uVXBkYXRlQ29udHJhY3Qge1xuICBjb25zdCBhY2NvdW50VXBkYXRlQ29udHJhY3QgPSBwcm90b2NvbC5BY2NvdW50UGVybWlzc2lvblVwZGF0ZUNvbnRyYWN0LmRlY29kZShCdWZmZXIuZnJvbShiYXNlNjQsICdiYXNlNjQnKSkudG9KU09OKCk7XG4gIGFzc2VydChhY2NvdW50VXBkYXRlQ29udHJhY3Qub3duZXJBZGRyZXNzKTtcbiAgYXNzZXJ0KGFjY291bnRVcGRhdGVDb250cmFjdC5vd25lcik7XG4gIGFzc2VydChhY2NvdW50VXBkYXRlQ29udHJhY3QuaGFzT3duUHJvcGVydHkoJ2FjdGl2ZXMnKSk7XG5cbiAgY29uc3Qgb3duZXJBZGRyZXNzID0gZ2V0QmFzZTU4QWRkcmVzc0Zyb21CeXRlQXJyYXkoXG4gICAgZ2V0Qnl0ZUFycmF5RnJvbUhleEFkZHJlc3MoQnVmZmVyLmZyb20oYWNjb3VudFVwZGF0ZUNvbnRyYWN0Lm93bmVyQWRkcmVzcywgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdoZXgnKSksXG4gICk7XG4gIGNvbnN0IG93bmVyOiBQZXJtaXNzaW9uID0gY3JlYXRlUGVybWlzc2lvbihhY2NvdW50VXBkYXRlQ29udHJhY3Qub3duZXIpO1xuICBsZXQgd2l0bmVzczogUGVybWlzc2lvbiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgaWYgKGFjY291bnRVcGRhdGVDb250cmFjdC53aXRuZXNzKSB7XG4gICAgd2l0bmVzcyA9IGNyZWF0ZVBlcm1pc3Npb24oYWNjb3VudFVwZGF0ZUNvbnRyYWN0LndpdG5lc3MpO1xuICB9XG4gIGNvbnN0IGFjdGl2ZUxpc3QgPSBhY2NvdW50VXBkYXRlQ29udHJhY3QuYWN0aXZlcy5tYXAoYWN0aXZlID0+IGNyZWF0ZVBlcm1pc3Npb24oYWN0aXZlKSk7XG5cbiAgcmV0dXJuIHtcbiAgICBvd25lckFkZHJlc3MsXG4gICAgb3duZXIsXG4gICAgd2l0bmVzcyxcbiAgICBhY3RpdmVzOiBhY3RpdmVMaXN0LFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSByYXdcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGVybWlzc2lvbihyYXc6IHsgcGVybWlzc2lvbk5hbWU6IHN0cmluZzsgdGhyZXNob2xkOiBudW1iZXIgfSk6IFBlcm1pc3Npb24ge1xuICBsZXQgcGVybWlzc2lvblR5cGU6IFBlcm1pc3Npb25UeXBlO1xuICBjb25zdCBwZXJtaXNzaW9uID0gcmF3LnBlcm1pc3Npb25OYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICBpZiAocGVybWlzc2lvbiA9PT0gJ293bmVyJykge1xuICAgIHBlcm1pc3Npb25UeXBlID0gUGVybWlzc2lvblR5cGUuT3duZXI7XG4gIH0gZWxzZSBpZiAocGVybWlzc2lvbiA9PT0gJ3dpdG5lc3MnKSB7XG4gICAgcGVybWlzc2lvblR5cGUgPSBQZXJtaXNzaW9uVHlwZS5XaXRuZXNzO1xuICB9IGVsc2UgaWYgKHBlcm1pc3Npb24uc3Vic3RyKDAsIDYpID09PSAnYWN0aXZlJykge1xuICAgIHBlcm1pc3Npb25UeXBlID0gUGVybWlzc2lvblR5cGUuQWN0aXZlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdQZXJtaXNzaW9uIHR5cGUgbm90IHBhcnNlYWJsZS4nKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwZXJtaXNzaW9uVHlwZSwgdGhyZXNob2xkOiByYXcudGhyZXNob2xkIH07XG59XG4iXX0=