"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_1 = require("crypto");
var _ = __importStar(require("lodash"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var errors_1 = require("../baseCoin/errors");
var baseCoin_1 = require("../baseCoin");
var utils_1 = require("./utils");
var transaction_1 = require("./transaction");
var keyPair_1 = require("./keyPair");
/**
 * Tron transaction builder.
 */
var TransactionBuilder = /** @class */ (function (_super) {
    __extends(TransactionBuilder, _super);
    /**
     * Public constructor.
     *
     * @param {CoinConfig} _coinConfig Configuration object
     */
    function TransactionBuilder(_coinConfig) {
        return _super.call(this, _coinConfig) || this;
    }
    /**
     * Parse transaction takes in raw JSON directly from the node.
     *
     * @param {TransactionReceipt} rawTransaction The Tron transaction in JSON format as returned by the Tron lib or a stringifyed version of such JSON.
     * @returns {Transaction} Tron transaction
     */
    TransactionBuilder.prototype.fromImplementation = function (rawTransaction) {
        if (typeof rawTransaction === 'string') {
            var transaction = JSON.parse(rawTransaction);
            return new transaction_1.Transaction(this._coinConfig, transaction);
        }
        return new transaction_1.Transaction(this._coinConfig, rawTransaction);
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.signImplementation = function (key) {
        if (!this.transaction.inputs) {
            throw new errors_1.SigningError('Transaction has no sender');
        }
        if (!this.transaction.outputs) {
            throw new errors_1.SigningError('Transaction has no receiver');
        }
        var oldTransaction = this.transaction.toJson();
        // Store the original signatures to compare them with the new ones in a later step. Signatures
        // can be undefined if this is the first time the transaction is being signed
        var oldSignatureCount = oldTransaction.signature ? oldTransaction.signature.length : 0;
        var signedTransaction;
        try {
            var keyPair = new keyPair_1.KeyPair({ prv: key.key });
            // Since the key pair was generated using a private key, it will always have a prv attribute,
            // hence it is safe to use non-null operator
            signedTransaction = utils_1.signTransaction(keyPair.getKeys().prv, this.transaction.toJson());
        }
        catch (e) {
            throw new errors_1.SigningError('Failed to sign transaction via helper.');
        }
        // Ensure that we have more signatures than what we started with
        if (!signedTransaction.signature || oldSignatureCount >= signedTransaction.signature.length) {
            throw new errors_1.SigningError('Transaction signing did not return an additional signature.');
        }
        return new transaction_1.Transaction(this._coinConfig, signedTransaction);
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.buildImplementation = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // This is a no-op since Tron transactions are built from
                if (!this.transaction.id) {
                    throw new errors_1.BuildTransactionError('A valid transaction must have an id');
                }
                return [2 /*return*/, Promise.resolve(this.transaction)];
            });
        });
    };
    /**
     * Extend the validity of this transaction by the given amount of time
     *
     * @param {number} extensionMs The number of milliseconds to extend the validTo time
     * @returns {undefined}
     */
    TransactionBuilder.prototype.extendValidTo = function (extensionMs) {
        this.transaction.extendExpiration(extensionMs);
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateValue = function (value) {
        if (value.isLessThanOrEqualTo(0)) {
            throw new Error('Value cannot be below zero.');
        }
        // max long in Java - assumed upper limit for a TRX transaction
        if (value.isGreaterThan(new bignumber_js_1.default('9223372036854775807'))) {
            throw new Error('Value cannot be greater than handled by the javatron node.');
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateAddress = function (address) {
        // assumes a base 58 address for our addresses
        if (!utils_1.isBase58Address(address.address)) {
            throw new Error(address + ' is not a valid base58 address.');
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateKey = function (key) {
        try {
            new keyPair_1.KeyPair({ prv: key.key });
        }
        catch (err) {
            throw new Error('The provided key is not valid');
        }
    };
    /**
     * Validate the contents of a raw transaction. The validation
     * phase is to compare the raw-data-hex to the raw-data of the
     * transaction.
     *
     * The contents to be validated are
     * 1. The transaction id
     * 2. The expiration date
     * 3. The timestamp
     * 4. The contract
     *
     * @param {TransactionReceipt | string} rawTransaction The raw transaction to be validated
     */
    TransactionBuilder.prototype.validateRawTransaction = function (rawTransaction) {
        // TODO: Validation of signature
        if (!rawTransaction) {
            throw new errors_1.InvalidTransactionError('Raw transaction is empty');
        }
        var currTransaction;
        // rawTransaction can be either Stringified JSON OR
        // it can be a regular JSON object (not stringified).
        if (typeof rawTransaction === 'string') {
            try {
                currTransaction = JSON.parse(rawTransaction);
            }
            catch (e) {
                throw new errors_1.ParseTransactionError('There was error in parsing the JSON string');
            }
        }
        else if (_.isObject(rawTransaction)) {
            currTransaction = rawTransaction;
        }
        else {
            throw new errors_1.InvalidTransactionError('Transaction is not an object or stringified json');
        }
        var decodedRawDataHex = utils_1.decodeTransaction(currTransaction.raw_data_hex);
        if (!currTransaction.txID) {
            throw new errors_1.InvalidTransactionError('Transaction ID is empty');
        }
        // Validate the transaction ID from the raw data hex
        var hexBuffer = Buffer.from(currTransaction.raw_data_hex, 'hex');
        var currTxID = crypto_1.createHash('sha256')
            .update(hexBuffer)
            .digest('hex');
        if (currTransaction.txID !== currTxID) {
            throw new errors_1.InvalidTransactionError('Transaction has not have a valid id');
        }
        // Validate the expiration time from the raw-data-hex
        if (currTransaction.raw_data.expiration !== decodedRawDataHex.expiration) {
            throw new errors_1.InvalidTransactionError('Transaction has not have a valid expiration');
        }
        // Validate the timestamp from the raw-data-hex
        if (currTransaction.raw_data.timestamp !== decodedRawDataHex.timestamp) {
            throw new errors_1.InvalidTransactionError('Transaction has not have a valid timetamp');
        }
        // Transaction contract must exist
        if (!currTransaction.raw_data.contract) {
            throw new errors_1.InvalidTransactionError('Transaction contracts are empty');
        }
    };
    /** @inheritdoc */
    // Specifically, checks hex underlying transaction hashes to correct transaction ID.
    TransactionBuilder.prototype.validateTransaction = function (transaction) {
        var hexBuffer = Buffer.from(transaction.toJson().raw_data_hex, 'hex');
        var txId = crypto_1.createHash('sha256')
            .update(hexBuffer)
            .digest('hex');
        if (transaction.id !== txId) {
            throw new errors_1.InvalidTransactionError(transaction.id + ' is not a valid transaction id. Expecting: ' + txId);
        }
    };
    Object.defineProperty(TransactionBuilder.prototype, "transaction", {
        /** @inheritdoc */
        get: function () {
            return this._transaction;
        },
        /** @inheritdoc */
        set: function (transaction) {
            this._transaction = transaction;
        },
        enumerable: true,
        configurable: true
    });
    return TransactionBuilder;
}(baseCoin_1.BaseTransactionBuilder));
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvaW4vdHJ4L3RyYW5zYWN0aW9uQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxpQ0FBb0M7QUFDcEMsd0NBQTRCO0FBQzVCLDhEQUFxQztBQUVyQyw2Q0FLNEI7QUFFNUIsd0NBQXFEO0FBR3JELGlDQUE4RTtBQUM5RSw2Q0FBNEM7QUFDNUMscUNBQW9DO0FBRXBDOztHQUVHO0FBQ0g7SUFBd0Msc0NBQXNCO0lBRzVEOzs7O09BSUc7SUFDSCw0QkFBWSxXQUFpQztlQUMzQyxrQkFBTSxXQUFXLENBQUM7SUFDcEIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ08sK0NBQWtCLEdBQTVCLFVBQTZCLGNBQTJDO1FBQ3RFLElBQUksT0FBTyxjQUFjLEtBQUssUUFBUSxFQUFFO1lBQ3RDLElBQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDL0MsT0FBTyxJQUFJLHlCQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsQ0FBQztTQUN2RDtRQUNELE9BQU8sSUFBSSx5QkFBVyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVELGtCQUFrQjtJQUNSLCtDQUFrQixHQUE1QixVQUE2QixHQUFZO1FBQ3ZDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRTtZQUM1QixNQUFNLElBQUkscUJBQVksQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1NBQ3JEO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFO1lBQzdCLE1BQU0sSUFBSSxxQkFBWSxDQUFDLDZCQUE2QixDQUFDLENB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ZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUhhc2ggfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7XG4gIFNpZ25pbmdFcnJvcixcbiAgQnVpbGRUcmFuc2FjdGlvbkVycm9yLFxuICBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcixcbiAgUGFyc2VUcmFuc2FjdGlvbkVycm9yLFxufSBmcm9tICcuLi9iYXNlQ29pbi9lcnJvcnMnO1xuaW1wb3J0IHsgQmFzZUtleSB9IGZyb20gJy4uL2Jhc2VDb2luL2lmYWNlJztcbmltcG9ydCB7IEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXIgfSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblJlY2VpcHQgfSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICcuL2FkZHJlc3MnO1xuaW1wb3J0IHsgc2lnblRyYW5zYWN0aW9uLCBpc0Jhc2U1OEFkZHJlc3MsIGRlY29kZVRyYW5zYWN0aW9uIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgS2V5UGFpciB9IGZyb20gJy4va2V5UGFpcic7XG5cbi8qKlxuICogVHJvbiB0cmFuc2FjdGlvbiBidWlsZGVyLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25CdWlsZGVyIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uQnVpbGRlciB7XG4gIC8vIHRyYW5zYWN0aW9uIGJlaW5nIGJ1aWx0XG4gIHByaXZhdGUgX3RyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbjtcbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtDb2luQ29uZmlnfSBfY29pbkNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IoX2NvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+KSB7XG4gICAgc3VwZXIoX2NvaW5Db25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRyYW5zYWN0aW9uIHRha2VzIGluIHJhdyBKU09OIGRpcmVjdGx5IGZyb20gdGhlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25SZWNlaXB0fSByYXdUcmFuc2FjdGlvbiBUaGUgVHJvbiB0cmFuc2FjdGlvbiBpbiBKU09OIGZvcm1hdCBhcyByZXR1cm5lZCBieSB0aGUgVHJvbiBsaWIgb3IgYSBzdHJpbmdpZnllZCB2ZXJzaW9uIG9mIHN1Y2ggSlNPTi5cbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufSBUcm9uIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwcm90ZWN0ZWQgZnJvbUltcGxlbWVudGF0aW9uKHJhd1RyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblJlY2VpcHQgfCBzdHJpbmcpOiBUcmFuc2FjdGlvbiB7XG4gICAgaWYgKHR5cGVvZiByYXdUcmFuc2FjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gSlNPTi5wYXJzZShyYXdUcmFuc2FjdGlvbik7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHRoaXMuX2NvaW5Db25maWcsIHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbih0aGlzLl9jb2luQ29uZmlnLCByYXdUcmFuc2FjdGlvbik7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIHNpZ25JbXBsZW1lbnRhdGlvbihrZXk6IEJhc2VLZXkpOiBUcmFuc2FjdGlvbiB7XG4gICAgaWYgKCF0aGlzLnRyYW5zYWN0aW9uLmlucHV0cykge1xuICAgICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignVHJhbnNhY3Rpb24gaGFzIG5vIHNlbmRlcicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy50cmFuc2FjdGlvbi5vdXRwdXRzKSB7XG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdUcmFuc2FjdGlvbiBoYXMgbm8gcmVjZWl2ZXInKTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRUcmFuc2FjdGlvbiA9IHRoaXMudHJhbnNhY3Rpb24udG9Kc29uKCk7XG4gICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIHNpZ25hdHVyZXMgdG8gY29tcGFyZSB0aGVtIHdpdGggdGhlIG5ldyBvbmVzIGluIGEgbGF0ZXIgc3RlcC4gU2lnbmF0dXJlc1xuICAgIC8vIGNhbiBiZSB1bmRlZmluZWQgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB0aGUgdHJhbnNhY3Rpb24gaXMgYmVpbmcgc2lnbmVkXG4gICAgY29uc3Qgb2xkU2lnbmF0dXJlQ291bnQgPSBvbGRUcmFuc2FjdGlvbi5zaWduYXR1cmUgPyBvbGRUcmFuc2FjdGlvbi5zaWduYXR1cmUubGVuZ3RoIDogMDtcbiAgICBsZXQgc2lnbmVkVHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uUmVjZWlwdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qga2V5UGFpciA9IG5ldyBLZXlQYWlyKHsgcHJ2OiBrZXkua2V5IH0pO1xuICAgICAgLy8gU2luY2UgdGhlIGtleSBwYWlyIHdhcyBnZW5lcmF0ZWQgdXNpbmcgYSBwcml2YXRlIGtleSwgaXQgd2lsbCBhbHdheXMgaGF2ZSBhIHBydiBhdHRyaWJ1dGUsXG4gICAgICAvLyBoZW5jZSBpdCBpcyBzYWZlIHRvIHVzZSBub24tbnVsbCBvcGVyYXRvclxuICAgICAgc2lnbmVkVHJhbnNhY3Rpb24gPSBzaWduVHJhbnNhY3Rpb24oa2V5UGFpci5nZXRLZXlzKCkucHJ2ISwgdGhpcy50cmFuc2FjdGlvbi50b0pzb24oKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignRmFpbGVkIHRvIHNpZ24gdHJhbnNhY3Rpb24gdmlhIGhlbHBlci4nKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIG1vcmUgc2lnbmF0dXJlcyB0aGFuIHdoYXQgd2Ugc3RhcnRlZCB3aXRoXG4gICAgaWYgKCFzaWduZWRUcmFuc2FjdGlvbi5zaWduYXR1cmUgfHwgb2xkU2lnbmF0dXJlQ291bnQgPj0gc2lnbmVkVHJhbnNhY3Rpb24uc2lnbmF0dXJlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignVHJhbnNhY3Rpb24gc2lnbmluZyBkaWQgbm90IHJldHVybiBhbiBhZGRpdGlvbmFsIHNpZ25hdHVyZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHRoaXMuX2NvaW5Db25maWcsIHNpZ25lZFRyYW5zYWN0aW9uKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgYnVpbGRJbXBsZW1lbnRhdGlvbigpOiBQcm9taXNlPFRyYW5zYWN0aW9uPiB7XG4gICAgLy8gVGhpcyBpcyBhIG5vLW9wIHNpbmNlIFRyb24gdHJhbnNhY3Rpb25zIGFyZSBidWlsdCBmcm9tXG4gICAgaWYgKCF0aGlzLnRyYW5zYWN0aW9uLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdBIHZhbGlkIHRyYW5zYWN0aW9uIG11c3QgaGF2ZSBhbiBpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMudHJhbnNhY3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dGVuZCB0aGUgdmFsaWRpdHkgb2YgdGhpcyB0cmFuc2FjdGlvbiBieSB0aGUgZ2l2ZW4gYW1vdW50IG9mIHRpbWVcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGV4dGVuc2lvbk1zIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGV4dGVuZCB0aGUgdmFsaWRUbyB0aW1lXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBleHRlbmRWYWxpZFRvKGV4dGVuc2lvbk1zOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLmV4dGVuZEV4cGlyYXRpb24oZXh0ZW5zaW9uTXMpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlVmFsdWUodmFsdWU6IEJpZ051bWJlcik6IHZvaWQge1xuICAgIGlmICh2YWx1ZS5pc0xlc3NUaGFuT3JFcXVhbFRvKDApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIGNhbm5vdCBiZSBiZWxvdyB6ZXJvLicpO1xuICAgIH1cblxuICAgIC8vIG1heCBsb25nIGluIEphdmEgLSBhc3N1bWVkIHVwcGVyIGxpbWl0IGZvciBhIFRSWCB0cmFuc2FjdGlvblxuICAgIGlmICh2YWx1ZS5pc0dyZWF0ZXJUaGFuKG5ldyBCaWdOdW1iZXIoJzkyMjMzNzIwMzY4NTQ3NzU4MDcnKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiBoYW5kbGVkIGJ5IHRoZSBqYXZhdHJvbiBub2RlLicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZUFkZHJlc3MoYWRkcmVzczogQWRkcmVzcyk6IHZvaWQge1xuICAgIC8vIGFzc3VtZXMgYSBiYXNlIDU4IGFkZHJlc3MgZm9yIG91ciBhZGRyZXNzZXNcbiAgICBpZiAoIWlzQmFzZTU4QWRkcmVzcyhhZGRyZXNzLmFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYWRkcmVzcyArICcgaXMgbm90IGEgdmFsaWQgYmFzZTU4IGFkZHJlc3MuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlS2V5KGtleTogQmFzZUtleSk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBuZXcgS2V5UGFpcih7IHBydjoga2V5LmtleSB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBub3QgdmFsaWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhlIGNvbnRlbnRzIG9mIGEgcmF3IHRyYW5zYWN0aW9uLiBUaGUgdmFsaWRhdGlvblxuICAgKiBwaGFzZSBpcyB0byBjb21wYXJlIHRoZSByYXctZGF0YS1oZXggdG8gdGhlIHJhdy1kYXRhIG9mIHRoZVxuICAgKiB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogVGhlIGNvbnRlbnRzIHRvIGJlIHZhbGlkYXRlZCBhcmVcbiAgICogMS4gVGhlIHRyYW5zYWN0aW9uIGlkXG4gICAqIDIuIFRoZSBleHBpcmF0aW9uIGRhdGVcbiAgICogMy4gVGhlIHRpbWVzdGFtcFxuICAgKiA0LiBUaGUgY29udHJhY3RcbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvblJlY2VpcHQgfCBzdHJpbmd9IHJhd1RyYW5zYWN0aW9uIFRoZSByYXcgdHJhbnNhY3Rpb24gdG8gYmUgdmFsaWRhdGVkXG4gICAqL1xuICB2YWxpZGF0ZVJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblJlY2VpcHQgfCBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBUT0RPOiBWYWxpZGF0aW9uIG9mIHNpZ25hdHVyZVxuICAgIGlmICghcmF3VHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignUmF3IHRyYW5zYWN0aW9uIGlzIGVtcHR5Jyk7XG4gICAgfVxuICAgIGxldCBjdXJyVHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uUmVjZWlwdDtcbiAgICAvLyByYXdUcmFuc2FjdGlvbiBjYW4gYmUgZWl0aGVyIFN0cmluZ2lmaWVkIEpTT04gT1JcbiAgICAvLyBpdCBjYW4gYmUgYSByZWd1bGFyIEpTT04gb2JqZWN0IChub3Qgc3RyaW5naWZpZWQpLlxuICAgIGlmICh0eXBlb2YgcmF3VHJhbnNhY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjdXJyVHJhbnNhY3Rpb24gPSBKU09OLnBhcnNlKHJhd1RyYW5zYWN0aW9uKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlVHJhbnNhY3Rpb25FcnJvcignVGhlcmUgd2FzIGVycm9yIGluIHBhcnNpbmcgdGhlIEpTT04gc3RyaW5nJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHJhd1RyYW5zYWN0aW9uKSkge1xuICAgICAgY3VyclRyYW5zYWN0aW9uID0gcmF3VHJhbnNhY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gaXMgbm90IGFuIG9iamVjdCBvciBzdHJpbmdpZmllZCBqc29uJyk7XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZWRSYXdEYXRhSGV4ID0gZGVjb2RlVHJhbnNhY3Rpb24oY3VyclRyYW5zYWN0aW9uLnJhd19kYXRhX2hleCk7XG4gICAgaWYgKCFjdXJyVHJhbnNhY3Rpb24udHhJRCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBJRCBpcyBlbXB0eScpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB0aGUgdHJhbnNhY3Rpb24gSUQgZnJvbSB0aGUgcmF3IGRhdGEgaGV4XG4gICAgY29uc3QgaGV4QnVmZmVyID0gQnVmZmVyLmZyb20oY3VyclRyYW5zYWN0aW9uLnJhd19kYXRhX2hleCwgJ2hleCcpO1xuICAgIGNvbnN0IGN1cnJUeElEID0gY3JlYXRlSGFzaCgnc2hhMjU2JylcbiAgICAgIC51cGRhdGUoaGV4QnVmZmVyKVxuICAgICAgLmRpZ2VzdCgnaGV4Jyk7XG4gICAgaWYgKGN1cnJUcmFuc2FjdGlvbi50eElEICE9PSBjdXJyVHhJRCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBoYXMgbm90IGhhdmUgYSB2YWxpZCBpZCcpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB0aGUgZXhwaXJhdGlvbiB0aW1lIGZyb20gdGhlIHJhdy1kYXRhLWhleFxuICAgIGlmIChjdXJyVHJhbnNhY3Rpb24ucmF3X2RhdGEuZXhwaXJhdGlvbiAhPT0gZGVjb2RlZFJhd0RhdGFIZXguZXhwaXJhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBoYXMgbm90IGhhdmUgYSB2YWxpZCBleHBpcmF0aW9uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHRoZSB0aW1lc3RhbXAgZnJvbSB0aGUgcmF3LWRhdGEtaGV4XG4gICAgaWYgKGN1cnJUcmFuc2FjdGlvbi5yYXdfZGF0YS50aW1lc3RhbXAgIT09IGRlY29kZWRSYXdEYXRhSGV4LnRpbWVzdGFtcCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBoYXMgbm90IGhhdmUgYSB2YWxpZCB0aW1ldGFtcCcpO1xuICAgIH1cbiAgICAvLyBUcmFuc2FjdGlvbiBjb250cmFjdCBtdXN0IGV4aXN0XG4gICAgaWYgKCFjdXJyVHJhbnNhY3Rpb24ucmF3X2RhdGEuY29udHJhY3QpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gY29udHJhY3RzIGFyZSBlbXB0eScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAvLyBTcGVjaWZpY2FsbHksIGNoZWNrcyBoZXggdW5kZXJseWluZyB0cmFuc2FjdGlvbiBoYXNoZXMgdG8gY29ycmVjdCB0cmFuc2FjdGlvbiBJRC5cbiAgdmFsaWRhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24pOiB2b2lkIHtcbiAgICBjb25zdCBoZXhCdWZmZXIgPSBCdWZmZXIuZnJvbSh0cmFuc2FjdGlvbi50b0pzb24oKS5yYXdfZGF0YV9oZXgsICdoZXgnKTtcbiAgICBjb25zdCB0eElkID0gY3JlYXRlSGFzaCgnc2hhMjU2JylcbiAgICAgIC51cGRhdGUoaGV4QnVmZmVyKVxuICAgICAgLmRpZ2VzdCgnaGV4Jyk7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmlkICE9PSB0eElkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IodHJhbnNhY3Rpb24uaWQgKyAnIGlzIG5vdCBhIHZhbGlkIHRyYW5zYWN0aW9uIGlkLiBFeHBlY3Rpbmc6ICcgKyB0eElkKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGdldCB0cmFuc2FjdGlvbigpOiBUcmFuc2FjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBzZXQgdHJhbnNhY3Rpb24odHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uKSB7XG4gICAgdGhpcy5fdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgfVxufVxuIl19