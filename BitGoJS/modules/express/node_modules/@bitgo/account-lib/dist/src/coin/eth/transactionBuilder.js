"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var ethereumjs_abi_1 = __importDefault(require("ethereumjs-abi"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var utils_1 = require("ethers/utils");
var Crypto = __importStar(require("../../utils/crypto"));
var baseCoin_1 = require("../baseCoin");
var eth_1 = require("../eth");
var errors_1 = require("../baseCoin/errors");
var keyPair_1 = require("./keyPair");
var utils_2 = require("./utils");
var walletUtil_1 = require("./walletUtil");
var DEFAULT_M = 3;
/**
 * Ethereum transaction builder.
 */
var TransactionBuilder = /** @class */ (function (_super) {
    __extends(TransactionBuilder, _super);
    /**
     * Public constructor.
     *
     * @param _coinConfig
     */
    function TransactionBuilder(_coinConfig) {
        var _this = _super.call(this, _coinConfig) || this;
        _this._common = utils_2.getCommon(_this._coinConfig.network.type);
        _this._type = baseCoin_1.TransactionType.Send;
        _this._counter = 0;
        _this._value = '0';
        _this._walletOwnerAddresses = [];
        _this.transaction = new eth_1.Transaction(_this._coinConfig, _this._common);
        return _this;
    }
    /** @inheritdoc */
    TransactionBuilder.prototype.buildImplementation = function () {
        return __awaiter(this, void 0, void 0, function () {
            var transactionData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        transactionData = this.getTransactionData();
                        if (this._txSignature) {
                            Object.assign(transactionData, this._txSignature);
                        }
                        this.transaction.setTransactionType(this._type);
                        transactionData.from = this._sourceKeyPair ? this._sourceKeyPair.getAddress() : undefined;
                        this.transaction.setTransactionData(transactionData);
                        if (!(this._sourceKeyPair && this._sourceKeyPair.getKeys().prv)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.transaction.sign(this._sourceKeyPair)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, this.transaction];
                }
            });
        });
    };
    TransactionBuilder.prototype.getTransactionData = function () {
        switch (this._type) {
            case baseCoin_1.TransactionType.WalletInitialization:
                return this.buildWalletInitializationTransaction();
            case baseCoin_1.TransactionType.Send:
                return this.buildSendTransaction();
            case baseCoin_1.TransactionType.AddressInitialization:
                return this.buildAddressInitializationTransaction();
            case baseCoin_1.TransactionType.FlushTokens:
                return this.buildFlushTokensTransaction();
            case baseCoin_1.TransactionType.SingleSigSend:
                return this.buildBase('0x');
            default:
                throw new errors_1.BuildTransactionError('Unsupported transaction type');
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.fromImplementation = function (rawTransaction) {
        var tx;
        if (/^0x?[0-9a-f]{1,}$/.test(rawTransaction.toLowerCase())) {
            tx = eth_1.Transaction.fromSerialized(this._coinConfig, this._common, rawTransaction);
            this.loadBuilderInput(tx.toJson());
        }
        else {
            var txData = JSON.parse(rawTransaction);
            tx = new eth_1.Transaction(this._coinConfig, txData);
        }
        return tx;
    };
    /**
     * Load the builder data using the deserialized transaction
     *
     * @param {TxData} transactionJson the deserialized transaction json
     */
    TransactionBuilder.prototype.loadBuilderInput = function (transactionJson) {
        var decodedType = eth_1.Utils.classifyTransaction(transactionJson.data);
        this.type(decodedType);
        this.fee({ fee: transactionJson.gasPrice, gasLimit: transactionJson.gasLimit });
        this.counter(transactionJson.nonce);
        this.value(transactionJson.value);
        if (utils_2.hasSignature(transactionJson)) {
            this._txSignature = { v: transactionJson.v, r: transactionJson.r, s: transactionJson.s };
        }
        this.setTransactionTypeFields(decodedType, transactionJson);
    };
    TransactionBuilder.prototype.setTransactionTypeFields = function (decodedType, transactionJson) {
        var _this = this;
        switch (decodedType) {
            case baseCoin_1.TransactionType.WalletInitialization:
                var owners = eth_1.Utils.decodeWalletCreationData(transactionJson.data);
                owners.forEach(function (element) {
                    _this.owner(element);
                });
                break;
            case baseCoin_1.TransactionType.FlushTokens:
                if (transactionJson.to === undefined) {
                    throw new errors_1.BuildTransactionError('Undefined recipient address');
                }
                // the address of the wallet contract that we are calling "flushForwarderTokens" on
                this.contract(transactionJson.to);
                var _a = eth_1.Utils.decodeFlushTokensData(transactionJson.data), forwarderAddress = _a.forwarderAddress, tokenAddress = _a.tokenAddress;
                this.forwarderAddress(forwarderAddress);
                this.tokenAddress(tokenAddress);
                break;
            case baseCoin_1.TransactionType.Send:
                if (transactionJson.to === undefined) {
                    throw new errors_1.BuildTransactionError('Undefined recipient address');
                }
                this.contract(transactionJson.to);
                this._transfer = this.transfer(transactionJson.data);
                break;
            case baseCoin_1.TransactionType.AddressInitialization:
                if (transactionJson.to === undefined) {
                    throw new errors_1.BuildTransactionError('Undefined recipient address');
                }
                this.contract(transactionJson.to);
                break;
            case baseCoin_1.TransactionType.SingleSigSend:
                if (transactionJson.to === undefined) {
                    throw new errors_1.BuildTransactionError('Undefined recipient address');
                }
                this.contract(transactionJson.to);
                break;
            default:
                throw new errors_1.BuildTransactionError('Unsupported transaction type');
            // TODO: Add other cases of deserialization
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.signImplementation = function (key) {
        var signer = new keyPair_1.KeyPair({ prv: key.key });
        if (this._type === baseCoin_1.TransactionType.WalletInitialization && this._walletOwnerAddresses.length === 0) {
            throw new errors_1.SigningError('Cannot sign an wallet initialization transaction without owners');
        }
        if (this._sourceKeyPair) {
            throw new errors_1.SigningError('Cannot sign multiple times a non send-type transaction');
        }
        // Signing the transaction is an async operation, so save the source and leave the actual
        // signing for the build step
        this._sourceKeyPair = signer;
        return this.transaction;
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateAddress = function (address) {
        if (!utils_2.isValidEthAddress(address.address)) {
            throw new errors_1.BuildTransactionError('Invalid address ' + address.address);
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateKey = function (key) {
        if (!(Crypto.isValidXprv(key.key) || Crypto.isValidPrv(key.key))) {
            throw new errors_1.BuildTransactionError('Invalid key');
        }
    };
    /**
     * Validate the raw transaction is either a JSON or
     * a hex encoded transaction
     *
     * @param {any} rawTransaction The raw transaction to be validated
     */
    TransactionBuilder.prototype.validateRawTransaction = function (rawTransaction) {
        if (!rawTransaction) {
            throw new errors_1.InvalidTransactionError('Raw transaction is empty');
        }
        if (typeof rawTransaction === 'string') {
            if (/^0x?[0-9a-f]{1,}$/.test(rawTransaction.toLowerCase())) {
                try {
                    utils_1.RLP.decode(rawTransaction);
                }
                catch (e) {
                    throw new errors_1.ParseTransactionError('There was error in decoding the hex string');
                }
            }
            else {
                try {
                    JSON.parse(rawTransaction);
                }
                catch (e) {
                    throw new errors_1.ParseTransactionError('There was error in parsing the JSON string');
                }
            }
        }
        else {
            throw new errors_1.InvalidTransactionError('Transaction is not a hex string or stringified json');
        }
    };
    TransactionBuilder.prototype.validateBaseTransactionFields = function () {
        if (this._fee === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing fee');
        }
        if (this._common === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: network common');
        }
        if (this._counter === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing address counter');
        }
    };
    /** @inheritdoc */
    TransactionBuilder.prototype.validateTransaction = function (transaction) {
        this.validateBaseTransactionFields();
        switch (this._type) {
            case baseCoin_1.TransactionType.WalletInitialization:
                this.validateWalletInitializationFields();
                break;
            case baseCoin_1.TransactionType.Send:
                this.validateContractAddress();
                break;
            case baseCoin_1.TransactionType.AddressInitialization:
                this.validateContractAddress();
                break;
            case baseCoin_1.TransactionType.FlushTokens:
                this.validateContractAddress();
                this.validateForwarderAddress();
                this.validateTokenAddress();
                break;
            case baseCoin_1.TransactionType.SingleSigSend:
                // for single sig sends, the contract address is actually the recipient
                this.validateContractAddress();
                break;
            case baseCoin_1.TransactionType.StakingLock:
            case baseCoin_1.TransactionType.StakingUnlock:
            case baseCoin_1.TransactionType.StakingVote:
            case baseCoin_1.TransactionType.StakingUnvote:
            case baseCoin_1.TransactionType.StakingActivate:
            case baseCoin_1.TransactionType.StakingWithdraw:
                break;
            default:
                throw new errors_1.BuildTransactionError('Unsupported transaction type');
        }
    };
    /**
     * Check wallet owner addresses for wallet initialization transactions are valid or throw.
     */
    TransactionBuilder.prototype.validateWalletInitializationFields = function () {
        if (this._walletOwnerAddresses === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing wallet owners');
        }
        if (this._walletOwnerAddresses.length !== 3) {
            throw new errors_1.BuildTransactionError("Invalid transaction: wrong number of owners -- required: 3, found: " + this._walletOwnerAddresses.length);
        }
    };
    /**
     * Check if a token address for the tx was defined or throw.
     */
    TransactionBuilder.prototype.validateTokenAddress = function () {
        if (this._tokenAddress === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing token address');
        }
    };
    /**
     * Check if a forwarder address for the tx was defined or throw.
     */
    TransactionBuilder.prototype.validateForwarderAddress = function () {
        if (this._forwarderAddress === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing forwarder address');
        }
    };
    /**
     * Check if a contract address for the wallet was defined or throw.
     */
    TransactionBuilder.prototype.validateContractAddress = function () {
        if (this._contractAddress === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing contract address');
        }
    };
    TransactionBuilder.prototype.validateValue = function (value) {
        if (value.isLessThan(0)) {
            throw new errors_1.BuildTransactionError('Value cannot be below less than zero');
        }
        // TODO: validate the amount is not bigger than the max amount in each Eth family coin
    };
    //region Common builder methods
    /**
     * The type of transaction being built.
     *
     * @param {TransactionType} type
     */
    TransactionBuilder.prototype.type = function (type) {
        this._type = type;
    };
    /**
     * Set the transaction fees. Low fees may get a transaction rejected or never picked up by bakers.
     *
     * @param {Fee} fee Baker fees. May also include the maximum gas to pay
     */
    TransactionBuilder.prototype.fee = function (fee) {
        this.validateValue(new bignumber_js_1.default(fee.fee));
        if (fee.gasLimit) {
            this.validateValue(new bignumber_js_1.default(fee.gasLimit));
        }
        this._fee = fee;
    };
    /**
     * Set the transaction counter to prevent submitting repeated transactions.
     *
     * @param {number} counter The counter to use
     */
    TransactionBuilder.prototype.counter = function (counter) {
        if (counter < 0) {
            throw new errors_1.BuildTransactionError("Invalid counter: " + counter);
        }
        this._counter = counter;
    };
    /**
     * The value to send along with this transaction. 0 by default
     *
     * @param {string} value The value to send along with this transaction
     */
    TransactionBuilder.prototype.value = function (value) {
        this._value = value;
    };
    TransactionBuilder.prototype.buildBase = function (data) {
        return {
            gasLimit: this._fee.gasLimit,
            gasPrice: this._fee.fee,
            nonce: this._counter,
            data: data,
            chainId: this._common.chainId().toString(),
            value: this._value,
            to: this._contractAddress,
        };
    };
    //endregion
    //region WalletInitialization builder methods
    /**
     * Set one of the owners of the multisig wallet.
     *
     * @param {string} address An Ethereum address
     */
    TransactionBuilder.prototype.owner = function (address) {
        if (this._type !== baseCoin_1.TransactionType.WalletInitialization) {
            throw new errors_1.BuildTransactionError('Multisig wallet owner can only be set for initialization transactions');
        }
        if (this._walletOwnerAddresses.length >= DEFAULT_M) {
            throw new errors_1.BuildTransactionError('A maximum of ' + DEFAULT_M + ' owners can be set for a multisig wallet');
        }
        if (!utils_2.isValidEthAddress(address)) {
            throw new errors_1.BuildTransactionError('Invalid address: ' + address);
        }
        if (this._walletOwnerAddresses.includes(address)) {
            throw new errors_1.BuildTransactionError('Repeated owner address: ' + address);
        }
        this._walletOwnerAddresses.push(address);
    };
    /**
     * Build a transaction for a generic multisig contract.
     *
     * @returns {TxData} The Ethereum transaction data
     */
    TransactionBuilder.prototype.buildWalletInitializationTransaction = function () {
        return this.buildBase(this.getContractData(this._walletOwnerAddresses));
    };
    /**
     * Returns the smart contract encoded data
     *
     * @param {string[]} addresses - the contract signers
     * @returns {string} - the smart contract encoded data
     */
    TransactionBuilder.prototype.getContractData = function (addresses) {
        var params = [addresses];
        var resultEncodedParameters = ethereumjs_abi_1.default.rawEncode(walletUtil_1.walletSimpleConstructor, params)
            .toString('hex')
            .replace('0x', '');
        return walletUtil_1.walletSimpleByteCode + resultEncodedParameters;
    };
    //endregion
    //region Send builder methods
    TransactionBuilder.prototype.contract = function (address) {
        if (utils_2.isValidEthAddress(address))
            this._contractAddress = address;
        else
            throw new errors_1.BuildTransactionError('Invalid address: ' + address);
    };
    /**
     * Gets the transfer funds builder if exist, or creates a new one for this transaction and returns it
     *
     * @param [data] transfer data to initialize the transfer builder with, empty if none given
     * @returns {TransferBuilder} the transfer builder
     */
    TransactionBuilder.prototype.transfer = function (data) {
        if (this._type !== baseCoin_1.TransactionType.Send) {
            throw new errors_1.BuildTransactionError('Transfers can only be set for send transactions');
        }
        if (!this._transfer) {
            this._transfer = new eth_1.TransferBuilder(data);
        }
        return this._transfer;
    };
    /**
     * Returns the serialized sendMultiSig contract method data
     *
     * @returns {string} serialized sendMultiSig data
     */
    TransactionBuilder.prototype.getSendData = function () {
        if (!this._transfer) {
            throw new errors_1.BuildTransactionError('Missing transfer information');
        }
        return this._transfer.signAndBuild();
    };
    TransactionBuilder.prototype.buildSendTransaction = function () {
        var sendData = this.getSendData();
        var tx = this.buildBase(sendData);
        tx.to = this._contractAddress;
        return tx;
    };
    //endregion
    //region AddressInitialization builder methods
    /**
     * Set the contract transaction nonce to calculate the forwarder address.
     *
     * @param {number} contractCounter The counter to use
     */
    TransactionBuilder.prototype.contractCounter = function (contractCounter) {
        if (contractCounter < 0) {
            throw new errors_1.BuildTransactionError("Invalid contract counter: " + contractCounter);
        }
        this._contractCounter = contractCounter;
    };
    /**
     * Build a transaction to create a forwarder.
     *
     * @returns {TxData} The Ethereum transaction data
     */
    TransactionBuilder.prototype.buildAddressInitializationTransaction = function () {
        var addressInitData = utils_2.getAddressInitializationData();
        var tx = this.buildBase(addressInitData);
        tx.to = this._contractAddress;
        if (this._contractCounter) {
            tx.deployedAddress = utils_2.calculateForwarderAddress(this._contractAddress, this._contractCounter);
        }
        return tx;
    };
    //endregion
    //region flush methods
    /**
     * Set the forwarder address to flush
     *
     * @param {string} address The address to flush
     */
    TransactionBuilder.prototype.forwarderAddress = function (address) {
        if (!utils_2.isValidEthAddress(address)) {
            throw new errors_1.BuildTransactionError('Invalid address: ' + address);
        }
        this._forwarderAddress = address;
    };
    /**
     * Set the address of the ERC20 token contract that we are flushing tokens for
     *
     * @param {string} address the contract address of the token to flush
     */
    TransactionBuilder.prototype.tokenAddress = function (address) {
        if (!utils_2.isValidEthAddress(address)) {
            throw new errors_1.BuildTransactionError('Invalid address: ' + address);
        }
        this._tokenAddress = address;
    };
    /**
     * Build a transaction to flush tokens from a forwarder.
     *
     * @returns {TxData} The Ethereum transaction data
     */
    TransactionBuilder.prototype.buildFlushTokensTransaction = function () {
        return this.buildBase(utils_2.flushTokensData(this._forwarderAddress, this._tokenAddress));
    };
    Object.defineProperty(TransactionBuilder.prototype, "transaction", {
        //endregion
        /** @inheritdoc */
        get: function () {
            return this._transaction;
        },
        /** @inheritdoc */
        set: function (transaction) {
            this._transaction = transaction;
        },
        enumerable: true,
        configurable: true
    });
    return TransactionBuilder;
}(baseCoin_1.BaseTransactionBuilder));
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvaW4vZXRoL3RyYW5zYWN0aW9uQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxrRUFBeUM7QUFDekMsOERBQXFDO0FBQ3JDLHNDQUFtQztBQUNuQyx5REFBNkM7QUFDN0Msd0NBQXVGO0FBRXZGLDhCQUE2RDtBQUM3RCw2Q0FLNEI7QUFDNUIscUNBQW9DO0FBRXBDLGlDQU9pQjtBQUNqQiwyQ0FBNkU7QUFFN0UsSUFBTSxTQUFTLEdBQUcsQ0FBQyxDQUFDO0FBRXBCOztHQUVHO0FBQ0g7SUFBd0Msc0NBQXNCO0lBd0I1RDs7OztPQUlHO0lBQ0gsNEJBQVksV0FBaUM7UUFBN0MsWUFDRSxrQkFBTSxXQUFXLENBQUMsU0FPbkI7UUFOQyxLQUFJLENBQUMsT0FBTyxHQUFHLGlCQUFTLENBQUMsS0FBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEQsS0FBSSxDQUFDLEtBQUssR0FBRywwQkFBZSxDQUFDLElBQUksQ0FBQztRQUNsQyxLQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztRQUNsQixLQUFJLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQztRQUNsQixLQUFJLENBQUMscUJBQXFCLEdBQUcsRUFBRSxDQUFDO1FBQ2hDLEtBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxpQkFBVyxDQUFDLEtBQUksQ0FBQyxXQUFXLEVBQUUsS0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDOztJQUNyRSxDQUFDO0lBRUQsa0JBQWtCO0lBQ0YsZ0RBQW1CLEdBQW5DOzs7Ozs7d0JBQ1EsZUFBZSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO3dCQUVsRCxJQUFJLElBQUksQ0FBQyxZQUFZ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O1NBQzlGO1FBQ0QsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBQ0QsV0FBVztJQUVYLHNCQUFzQjtJQUN0Qjs7OztPQUlHO0lBQ0gsNkNBQWdCLEdBQWhCLFVBQWlCLE9BQWU7UUFDOUIsSUFBSSxDQUFDLHlCQUFpQixDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQy9CLE1BQU0sSUFBSSw4QkFBcUIsQ0FBQyxtQkFBbUIsR0FBRyxPQUFPLENBQUMsQ0FBQztTQUNoRTtRQUNELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxPQUFPLENBQUM7SUFDbkMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCx5Q0FBWSxHQUFaLFVBQWEsT0FBZTtRQUMxQixJQUFJLENBQUMseUJBQWlCLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDL0IsTUFBTSxJQUFJLDhCQUFxQixDQUFDLG1CQUFtQixHQUFHLE9BQU8sQ0FBQyxDQUFDO1NBQ2hFO1FBQ0QsSUFBSSxDQUFDLGFBQWEsR0FBRyxPQUFPLENBQUM7SUFDL0IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyx3REFBMkIsR0FBbkM7UUFDRSxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsdUJBQWUsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7SUFDckYsQ0FBQztJQUlELHNCQUFjLDJDQUFXO1FBSHpCLFdBQVc7UUFFWCxrQkFBa0I7YUFDbEI7WUFDRSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7UUFDM0IsQ0FBQztRQUVELGtCQUFrQjthQUNsQixVQUEwQixXQUF3QjtZQUNoRCxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztRQUNsQyxDQUFDOzs7T0FMQTtJQU1ILHlCQUFDO0FBQUQsQ0FBQyxBQTVnQkQsQ0FBd0MsaUNBQXNCLEdBNGdCN0Q7QUE1Z0JZLGdEQUFrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcy9kaXN0L3NyYy9iYXNlJztcclxuaW1wb3J0IEV0aGVyZXVtQ29tbW9uIGZyb20gJ2V0aGVyZXVtanMtY29tbW9uJztcclxuaW1wb3J0IEV0aGVyZXVtQWJpIGZyb20gJ2V0aGVyZXVtanMtYWJpJztcclxuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xyXG5pbXBvcnQgeyBSTFAgfSBmcm9tICdldGhlcnMvdXRpbHMnO1xyXG5pbXBvcnQgKiBhcyBDcnlwdG8gZnJvbSAnLi4vLi4vdXRpbHMvY3J5cHRvJztcclxuaW1wb3J0IHsgQmFzZVRyYW5zYWN0aW9uLCBCYXNlVHJhbnNhY3Rpb25CdWlsZGVyLCBUcmFuc2FjdGlvblR5cGUgfSBmcm9tICcuLi9iYXNlQ29pbic7XHJcbmltcG9ydCB7IEJhc2VBZGRyZXNzLCBCYXNlS2V5IH0gZnJvbSAnLi4vYmFzZUNvaW4vaWZhY2UnO1xyXG5pbXBvcnQgeyBUcmFuc2FjdGlvbiwgVHJhbnNmZXJCdWlsZGVyLCBVdGlscyB9IGZyb20gJy4uL2V0aCc7XHJcbmltcG9ydCB7XHJcbiAgQnVpbGRUcmFuc2FjdGlvbkVycm9yLFxyXG4gIEludmFsaWRUcmFuc2FjdGlvbkVycm9yLFxyXG4gIFBhcnNlVHJhbnNhY3Rpb25FcnJvcixcclxuICBTaWduaW5nRXJyb3IsXHJcbn0gZnJvbSAnLi4vYmFzZUNvaW4vZXJyb3JzJztcclxuaW1wb3J0IHsgS2V5UGFpciB9IGZyb20gJy4va2V5UGFpcic7XHJcbmltcG9ydCB7IEZlZSwgU2lnbmF0dXJlUGFydHMsIFR4RGF0YSB9IGZyb20gJy4vaWZhY2UnO1xyXG5pbXBvcnQge1xyXG4gIGNhbGN1bGF0ZUZvcndhcmRlckFkZHJlc3MsXHJcbiAgZmx1c2hUb2tlbnNEYXRhLFxyXG4gIGdldEFkZHJlc3NJbml0aWFsaXphdGlvbkRhdGEsXHJcbiAgZ2V0Q29tbW9uLFxyXG4gIGhhc1NpZ25hdHVyZSxcclxuICBpc1ZhbGlkRXRoQWRkcmVzcyxcclxufSBmcm9tICcuL3V0aWxzJztcclxuaW1wb3J0IHsgd2FsbGV0U2ltcGxlQnl0ZUNvZGUsIHdhbGxldFNpbXBsZUNvbnN0cnVjdG9yIH0gZnJvbSAnLi93YWxsZXRVdGlsJztcclxuXHJcbmNvbnN0IERFRkFVTFRfTSA9IDM7XHJcblxyXG4vKipcclxuICogRXRoZXJldW0gdHJhbnNhY3Rpb24gYnVpbGRlci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkJ1aWxkZXIgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25CdWlsZGVyIHtcclxuICBwcm90ZWN0ZWQgX3R5cGU6IFRyYW5zYWN0aW9uVHlwZTtcclxuICBwcm90ZWN0ZWQgX2NvbW1vbjogRXRoZXJldW1Db21tb247XHJcbiAgcHJpdmF0ZSBfdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uO1xyXG4gIHByaXZhdGUgX3NvdXJjZUtleVBhaXI6IEtleVBhaXI7XHJcbiAgcHJpdmF0ZSBfY291bnRlcjogbnVtYmVyO1xyXG4gIHByaXZhdGUgX2ZlZTogRmVlO1xyXG4gIHByaXZhdGUgX3ZhbHVlOiBzdHJpbmc7XHJcblxyXG4gIC8vIHRoZSBzaWduYXR1cmUgb24gdGhlIGV4dGVybmFsIEVUSCB0cmFuc2FjdGlvblxyXG4gIHByaXZhdGUgX3R4U2lnbmF0dXJlOiBTaWduYXR1cmVQYXJ0cztcclxuXHJcbiAgLy8gV2FsbGV0IGluaXRpYWxpemF0aW9uIHRyYW5zYWN0aW9uIHBhcmFtZXRlcnNcclxuICBwcml2YXRlIF93YWxsZXRPd25lckFkZHJlc3Nlczogc3RyaW5nW107XHJcblxyXG4gIC8vIGZsdXNoIHRva2VucyBwYXJhbWV0ZXJzXHJcbiAgcHJpdmF0ZSBfZm9yd2FyZGVyQWRkcmVzczogc3RyaW5nO1xyXG4gIHByaXZhdGUgX3Rva2VuQWRkcmVzczogc3RyaW5nO1xyXG5cclxuICAvLyBTZW5kIGFuZCBBZGRyZXNzSW5pdGlhbGl6YXRpb24gdHJhbnNhY3Rpb24gc3BlY2lmaWMgcGFyYW1ldGVyc1xyXG4gIHByb3RlY3RlZCBfdHJhbnNmZXI6IFRyYW5zZmVyQnVpbGRlcjtcclxuICBwcml2YXRlIF9jb250cmFjdEFkZHJlc3M6IHN0cmluZztcclxuICBwcml2YXRlIF9jb250cmFjdENvdW50ZXI6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogUHVibGljIGNvbnN0cnVjdG9yLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIF9jb2luQ29uZmlnXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoX2NvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+KSB7XHJcbiAgICBzdXBlcihfY29pbkNvbmZpZyk7XHJcbiAgICB0aGlzLl9jb21tb24gPSBnZXRDb21tb24odGhpcy5fY29pbkNvbmZpZy5uZXR3b3JrLnR5cGUpO1xyXG4gICAgdGhpcy5fdHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5TZW5kO1xyXG4gICAgdGhpcy5fY291bnRlciA9IDA7XHJcbiAgICB0aGlzLl92YWx1ZSA9ICcwJztcclxuICAgIHRoaXMuX3dhbGxldE93bmVyQWRkcmVzc2VzID0gW107XHJcbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKHRoaXMuX2NvaW5Db25maWcsIHRoaXMuX2NvbW1vbik7XHJcbiAgfVxyXG5cclxuICAvKiogQGluaGVyaXRkb2MgKi9cclxuICBwcm90ZWN0ZWQgYXN5bmMgYnVpbGRJbXBsZW1lbnRhdGlvbigpOiBQcm9taXNlPEJhc2VUcmFuc2FjdGlvbj4ge1xyXG4gICAgY29uc3QgdHJhbnNhY3Rpb25EYXRhID0gdGhpcy5nZXRUcmFuc2FjdGlvbkRhdGEoKTtcclxuXHJcbiAgICBpZiAodGhpcy5fdHhTaWduYXR1cmUpIHtcclxuICAgICAgT2JqZWN0LmFzc2lnbih0cmFuc2FjdGlvbkRhdGEsIHRoaXMuX3R4U2lnbmF0dXJlKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnRyYW5zYWN0aW9uLnNldFRyYW5zYWN0aW9uVHlwZSh0aGlzLl90eXBlKTtcclxuICAgIHRyYW5zYWN0aW9uRGF0YS5mcm9tID0gdGhpcy5fc291cmNlS2V5UGFpciA/IHRoaXMuX3NvdXJjZUtleVBhaXIuZ2V0QWRkcmVzcygpIDogdW5kZWZpbmVkO1xyXG4gICAgdGhpcy50cmFuc2FjdGlvbi5zZXRUcmFuc2FjdGlvbkRhdGEodHJhbnNhY3Rpb25EYXRhKTtcclxuXHJcbiAgICAvLyBCdWlsZCBhbmQgc2lnbiBhIG5ldyB0cmFuc2FjdGlvbiBiYXNlZCBvbiB0aGUgbGF0ZXN0IGNoYW5nZXNcclxuICAgIGlmICh0aGlzLl9zb3VyY2VLZXlQYWlyICYmIHRoaXMuX3NvdXJjZUtleVBhaXIuZ2V0S2V5cygpLnBydikge1xyXG4gICAgICBhd2FpdCB0aGlzLnRyYW5zYWN0aW9uLnNpZ24odGhpcy5fc291cmNlS2V5UGFpcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbjtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBnZXRUcmFuc2FjdGlvbkRhdGEoKTogVHhEYXRhIHtcclxuICAgIHN3aXRjaCAodGhpcy5fdHlwZSkge1xyXG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5XYWxsZXRJbml0aWFsaXphdGlvbjpcclxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZFdhbGxldEluaXRpYWxpemF0aW9uVHJhbnNhY3Rpb24oKTtcclxuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU2VuZDpcclxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZFNlbmRUcmFuc2FjdGlvbigpO1xyXG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5BZGRyZXNzSW5pdGlhbGl6YXRpb246XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRBZGRyZXNzSW5pdGlhbGl6YXRpb25UcmFuc2FjdGlvbigpO1xyXG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5GbHVzaFRva2VuczpcclxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZEZsdXNoVG9rZW5zVHJhbnNhY3Rpb24oKTtcclxuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU2luZ2xlU2lnU2VuZDpcclxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZEJhc2UoJzB4Jyk7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignVW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZScpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgcHJvdGVjdGVkIGZyb21JbXBsZW1lbnRhdGlvbihyYXdUcmFuc2FjdGlvbjogc3RyaW5nKTogVHJhbnNhY3Rpb24ge1xyXG4gICAgbGV0IHR4OiBUcmFuc2FjdGlvbjtcclxuICAgIGlmICgvXjB4P1swLTlhLWZdezEsfSQvLnRlc3QocmF3VHJhbnNhY3Rpb24udG9Mb3dlckNhc2UoKSkpIHtcclxuICAgICAgdHggPSBUcmFuc2FjdGlvbi5mcm9tU2VyaWFsaXplZCh0aGlzLl9jb2luQ29uZmlnLCB0aGlzLl9jb21tb24sIHJhd1RyYW5zYWN0aW9uKTtcclxuICAgICAgdGhpcy5sb2FkQnVpbGRlcklucHV0KHR4LnRvSnNvbigpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IHR4RGF0YSA9IEpTT04ucGFyc2UocmF3VHJhbnNhY3Rpb24pO1xyXG4gICAgICB0eCA9IG5ldyBUcmFuc2FjdGlvbih0aGlzLl9jb2luQ29uZmlnLCB0eERhdGEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHR4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTG9hZCB0aGUgYnVpbGRlciBkYXRhIHVzaW5nIHRoZSBkZXNlcmlhbGl6ZWQgdHJhbnNhY3Rpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VHhEYXRhfSB0cmFuc2FjdGlvbkpzb24gdGhlIGRlc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBqc29uXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGxvYWRCdWlsZGVySW5wdXQodHJhbnNhY3Rpb25Kc29uOiBUeERhdGEpOiB2b2lkIHtcclxuICAgIGNvbnN0IGRlY29kZWRUeXBlID0gVXRpbHMuY2xhc3NpZnlUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkpzb24uZGF0YSk7XHJcbiAgICB0aGlzLnR5cGUoZGVjb2RlZFR5cGUpO1xyXG4gICAgdGhpcy5mZWUoeyBmZWU6IHRyYW5zYWN0aW9uSnNvbi5nYXNQcmljZSwgZ2FzTGltaXQ6IHRyYW5zYWN0aW9uSnNvbi5nYXNMaW1pdCB9KTtcclxuICAgIHRoaXMuY291bnRlcih0cmFuc2FjdGlvbkpzb24ubm9uY2UpO1xyXG4gICAgdGhpcy52YWx1ZSh0cmFuc2FjdGlvbkpzb24udmFsdWUpO1xyXG4gICAgaWYgKGhhc1NpZ25hdHVyZSh0cmFuc2FjdGlvbkpzb24pKSB7XHJcbiAgICAgIHRoaXMuX3R4U2lnbmF0dXJlID0geyB2OiB0cmFuc2FjdGlvbkpzb24udiEsIHI6IHRyYW5zYWN0aW9uSnNvbi5yISwgczogdHJhbnNhY3Rpb25Kc29uLnMhIH07XHJcbiAgICB9XHJcbiAgICB0aGlzLnNldFRyYW5zYWN0aW9uVHlwZUZpZWxkcyhkZWNvZGVkVHlwZSwgdHJhbnNhY3Rpb25Kc29uKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBzZXRUcmFuc2FjdGlvblR5cGVGaWVsZHMoZGVjb2RlZFR5cGU6IFRyYW5zYWN0aW9uVHlwZSwgdHJhbnNhY3Rpb25Kc29uOiBUeERhdGEpOiB2b2lkIHtcclxuICAgIHN3aXRjaCAoZGVjb2RlZFR5cGUpIHtcclxuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuV2FsbGV0SW5pdGlhbGl6YXRpb246XHJcbiAgICAgICAgY29uc3Qgb3duZXJzID0gVXRpbHMuZGVjb2RlV2FsbGV0Q3JlYXRpb25EYXRhKHRyYW5zYWN0aW9uSnNvbi5kYXRhKTtcclxuICAgICAgICBvd25lcnMuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICAgIHRoaXMub3duZXIoZWxlbWVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkZsdXNoVG9rZW5zOlxyXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbkpzb24udG8gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignVW5kZWZpbmVkIHJlY2lwaWVudCBhZGRyZXNzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRoZSBhZGRyZXNzIG9mIHRoZSB3YWxsZXQgY29udHJhY3QgdGhhdCB3ZSBhcmUgY2FsbGluZyBcImZsdXNoRm9yd2FyZGVyVG9rZW5zXCIgb25cclxuICAgICAgICB0aGlzLmNvbnRyYWN0KHRyYW5zYWN0aW9uSnNvbi50byk7XHJcbiAgICAgICAgY29uc3QgeyBmb3J3YXJkZXJBZGRyZXNzLCB0b2tlbkFkZHJlc3MgfSA9IFV0aWxzLmRlY29kZUZsdXNoVG9rZW5zRGF0YSh0cmFuc2FjdGlvbkpzb24uZGF0YSk7XHJcbiAgICAgICAgdGhpcy5mb3J3YXJkZXJBZGRyZXNzKGZvcndhcmRlckFkZHJlc3MpO1xyXG4gICAgICAgIHRoaXMudG9rZW5BZGRyZXNzKHRva2VuQWRkcmVzcyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlNlbmQ6XHJcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uSnNvbi50byA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdVbmRlZmluZWQgcmVjaXBpZW50IGFkZHJlc3MnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb250cmFjdCh0cmFuc2FjdGlvbkpzb24udG8pO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZmVyID0gdGhpcy50cmFuc2Zlcih0cmFuc2FjdGlvbkpzb24uZGF0YSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkFkZHJlc3NJbml0aWFsaXphdGlvbjpcclxuICAgICAgICBpZiAodHJhbnNhY3Rpb25Kc29uLnRvID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ1VuZGVmaW5lZCByZWNpcGllbnQgYWRkcmVzcycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbnRyYWN0KHRyYW5zYWN0aW9uSnNvbi50byk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlNpbmdsZVNpZ1NlbmQ6XHJcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uSnNvbi50byA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdVbmRlZmluZWQgcmVjaXBpZW50IGFkZHJlc3MnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb250cmFjdCh0cmFuc2FjdGlvbkpzb24udG8pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ1Vuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGUnKTtcclxuICAgICAgLy8gVE9ETzogQWRkIG90aGVyIGNhc2VzIG9mIGRlc2VyaWFsaXphdGlvblxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgcHJvdGVjdGVkIHNpZ25JbXBsZW1lbnRhdGlvbihrZXk6IEJhc2VLZXkpOiBCYXNlVHJhbnNhY3Rpb24ge1xyXG4gICAgY29uc3Qgc2lnbmVyID0gbmV3IEtleVBhaXIoeyBwcnY6IGtleS5rZXkgfSk7XHJcbiAgICBpZiAodGhpcy5fdHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLldhbGxldEluaXRpYWxpemF0aW9uICYmIHRoaXMuX3dhbGxldE93bmVyQWRkcmVzc2VzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdDYW5ub3Qgc2lnbiBhbiB3YWxsZXQgaW5pdGlhbGl6YXRpb24gdHJhbnNhY3Rpb24gd2l0aG91dCBvd25lcnMnKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9zb3VyY2VLZXlQYWlyKSB7XHJcbiAgICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ0Nhbm5vdCBzaWduIG11bHRpcGxlIHRpbWVzIGEgbm9uIHNlbmQtdHlwZSB0cmFuc2FjdGlvbicpO1xyXG4gICAgfVxyXG4gICAgLy8gU2lnbmluZyB0aGUgdHJhbnNhY3Rpb24gaXMgYW4gYXN5bmMgb3BlcmF0aW9uLCBzbyBzYXZlIHRoZSBzb3VyY2UgYW5kIGxlYXZlIHRoZSBhY3R1YWxcclxuICAgIC8vIHNpZ25pbmcgZm9yIHRoZSBidWlsZCBzdGVwXHJcbiAgICB0aGlzLl9zb3VyY2VLZXlQYWlyID0gc2lnbmVyO1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb247XHJcbiAgfVxyXG5cclxuICAvKiogQGluaGVyaXRkb2MgKi9cclxuICB2YWxpZGF0ZUFkZHJlc3MoYWRkcmVzczogQmFzZUFkZHJlc3MpOiB2b2lkIHtcclxuICAgIGlmICghaXNWYWxpZEV0aEFkZHJlc3MoYWRkcmVzcy5hZGRyZXNzKSkge1xyXG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIGFkZHJlc3MgJyArIGFkZHJlc3MuYWRkcmVzcyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogQGluaGVyaXRkb2MgKi9cclxuICB2YWxpZGF0ZUtleShrZXk6IEJhc2VLZXkpOiB2b2lkIHtcclxuICAgIGlmICghKENyeXB0by5pc1ZhbGlkWHBydihrZXkua2V5KSB8fCBDcnlwdG8uaXNWYWxpZFBydihrZXkua2V5KSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBrZXknKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFZhbGlkYXRlIHRoZSByYXcgdHJhbnNhY3Rpb24gaXMgZWl0aGVyIGEgSlNPTiBvclxyXG4gICAqIGEgaGV4IGVuY29kZWQgdHJhbnNhY3Rpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YW55fSByYXdUcmFuc2FjdGlvbiBUaGUgcmF3IHRyYW5zYWN0aW9uIHRvIGJlIHZhbGlkYXRlZFxyXG4gICAqL1xyXG4gIHZhbGlkYXRlUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb246IGFueSk6IHZvaWQge1xyXG4gICAgaWYgKCFyYXdUcmFuc2FjdGlvbikge1xyXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ1JhdyB0cmFuc2FjdGlvbiBpcyBlbXB0eScpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiByYXdUcmFuc2FjdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgaWYgKC9eMHg/WzAtOWEtZl17MSx9JC8udGVzdChyYXdUcmFuc2FjdGlvbi50b0xvd2VyQ2FzZSgpKSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBSTFAuZGVjb2RlKHJhd1RyYW5zYWN0aW9uKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VUcmFuc2FjdGlvbkVycm9yKCdUaGVyZSB3YXMgZXJyb3IgaW4gZGVjb2RpbmcgdGhlIGhleCBzdHJpbmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIEpTT04ucGFyc2UocmF3VHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBQYXJzZVRyYW5zYWN0aW9uRXJyb3IoJ1RoZXJlIHdhcyBlcnJvciBpbiBwYXJzaW5nIHRoZSBKU09OIHN0cmluZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBpcyBub3QgYSBoZXggc3RyaW5nIG9yIHN0cmluZ2lmaWVkIGpzb24nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCB2YWxpZGF0ZUJhc2VUcmFuc2FjdGlvbkZpZWxkcygpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9mZWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiBtaXNzaW5nIGZlZScpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2NvbW1vbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb246IG5ldHdvcmsgY29tbW9uJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fY291bnRlciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb246IG1pc3NpbmcgYWRkcmVzcyBjb3VudGVyJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogQGluaGVyaXRkb2MgKi9cclxuICB2YWxpZGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uOiBCYXNlVHJhbnNhY3Rpb24pOiB2b2lkIHtcclxuICAgIHRoaXMudmFsaWRhdGVCYXNlVHJhbnNhY3Rpb25GaWVsZHMoKTtcclxuICAgIHN3aXRjaCAodGhpcy5fdHlwZSkge1xyXG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5XYWxsZXRJbml0aWFsaXphdGlvbjpcclxuICAgICAgICB0aGlzLnZhbGlkYXRlV2FsbGV0SW5pdGlhbGl6YXRpb25GaWVsZHMoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU2VuZDpcclxuICAgICAgICB0aGlzLnZhbGlkYXRlQ29udHJhY3RBZGRyZXNzKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkFkZHJlc3NJbml0aWFsaXphdGlvbjpcclxuICAgICAgICB0aGlzLnZhbGlkYXRlQ29udHJhY3RBZGRyZXNzKCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkZsdXNoVG9rZW5zOlxyXG4gICAgICAgIHRoaXMudmFsaWRhdGVDb250cmFjdEFkZHJlc3MoKTtcclxuICAgICAgICB0aGlzLnZhbGlkYXRlRm9yd2FyZGVyQWRkcmVzcygpO1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGVUb2tlbkFkZHJlc3MoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU2luZ2xlU2lnU2VuZDpcclxuICAgICAgICAvLyBmb3Igc2luZ2xlIHNpZyBzZW5kcywgdGhlIGNvbnRyYWN0IGFkZHJlc3MgaXMgYWN0dWFsbHkgdGhlIHJlY2lwaWVudFxyXG4gICAgICAgIHRoaXMudmFsaWRhdGVDb250cmFjdEFkZHJlc3MoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0xvY2s6XHJcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdVbmxvY2s6XHJcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdWb3RlOlxyXG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nVW52b3RlOlxyXG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nQWN0aXZhdGU6XHJcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdXaXRoZHJhdzpcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdVbnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayB3YWxsZXQgb3duZXIgYWRkcmVzc2VzIGZvciB3YWxsZXQgaW5pdGlhbGl6YXRpb24gdHJhbnNhY3Rpb25zIGFyZSB2YWxpZCBvciB0aHJvdy5cclxuICAgKi9cclxuICBwcml2YXRlIHZhbGlkYXRlV2FsbGV0SW5pdGlhbGl6YXRpb25GaWVsZHMoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fd2FsbGV0T3duZXJBZGRyZXNzZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiBtaXNzaW5nIHdhbGxldCBvd25lcnMnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fd2FsbGV0T3duZXJBZGRyZXNzZXMubGVuZ3RoICE9PSAzKSB7XHJcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoXHJcbiAgICAgICAgYEludmFsaWQgdHJhbnNhY3Rpb246IHdyb25nIG51bWJlciBvZiBvd25lcnMgLS0gcmVxdWlyZWQ6IDMsIGZvdW5kOiAke3RoaXMuX3dhbGxldE93bmVyQWRkcmVzc2VzLmxlbmd0aH1gLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB0b2tlbiBhZGRyZXNzIGZvciB0aGUgdHggd2FzIGRlZmluZWQgb3IgdGhyb3cuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSB2YWxpZGF0ZVRva2VuQWRkcmVzcygpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl90b2tlbkFkZHJlc3MgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiBtaXNzaW5nIHRva2VuIGFkZHJlc3MnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgZm9yd2FyZGVyIGFkZHJlc3MgZm9yIHRoZSB0eCB3YXMgZGVmaW5lZCBvciB0aHJvdy5cclxuICAgKi9cclxuICBwcml2YXRlIHZhbGlkYXRlRm9yd2FyZGVyQWRkcmVzcygpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9mb3J3YXJkZXJBZGRyZXNzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbjogbWlzc2luZyBmb3J3YXJkZXIgYWRkcmVzcycpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBjb250cmFjdCBhZGRyZXNzIGZvciB0aGUgd2FsbGV0IHdhcyBkZWZpbmVkIG9yIHRocm93LlxyXG4gICAqL1xyXG4gIHByaXZhdGUgdmFsaWRhdGVDb250cmFjdEFkZHJlc3MoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fY29udHJhY3RBZGRyZXNzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbjogbWlzc2luZyBjb250cmFjdCBhZGRyZXNzJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YWxpZGF0ZVZhbHVlKHZhbHVlOiBCaWdOdW1iZXIpOiB2b2lkIHtcclxuICAgIGlmICh2YWx1ZS5pc0xlc3NUaGFuKDApKSB7XHJcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ1ZhbHVlIGNhbm5vdCBiZSBiZWxvdyBsZXNzIHRoYW4gemVybycpO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogdmFsaWRhdGUgdGhlIGFtb3VudCBpcyBub3QgYmlnZ2VyIHRoYW4gdGhlIG1heCBhbW91bnQgaW4gZWFjaCBFdGggZmFtaWx5IGNvaW5cclxuICB9XHJcblxyXG4gIC8vcmVnaW9uIENvbW1vbiBidWlsZGVyIG1ldGhvZHNcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHR5cGUgb2YgdHJhbnNhY3Rpb24gYmVpbmcgYnVpbHQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uVHlwZX0gdHlwZVxyXG4gICAqL1xyXG4gIHR5cGUodHlwZTogVHJhbnNhY3Rpb25UeXBlKTogdm9pZCB7XHJcbiAgICB0aGlzLl90eXBlID0gdHlwZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgdHJhbnNhY3Rpb24gZmVlcy4gTG93IGZlZXMgbWF5IGdldCBhIHRyYW5zYWN0aW9uIHJlamVjdGVkIG9yIG5ldmVyIHBpY2tlZCB1cCBieSBiYWtlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0ZlZX0gZmVlIEJha2VyIGZlZXMuIE1heSBhbHNvIGluY2x1ZGUgdGhlIG1heGltdW0gZ2FzIHRvIHBheVxyXG4gICAqL1xyXG4gIGZlZShmZWU6IEZlZSk6IHZvaWQge1xyXG4gICAgdGhpcy52YWxpZGF0ZVZhbHVlKG5ldyBCaWdOdW1iZXIoZmVlLmZlZSkpO1xyXG4gICAgaWYgKGZlZS5nYXNMaW1pdCkge1xyXG4gICAgICB0aGlzLnZhbGlkYXRlVmFsdWUobmV3IEJpZ051bWJlcihmZWUuZ2FzTGltaXQpKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2ZlZSA9IGZlZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgdHJhbnNhY3Rpb24gY291bnRlciB0byBwcmV2ZW50IHN1Ym1pdHRpbmcgcmVwZWF0ZWQgdHJhbnNhY3Rpb25zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50ZXIgVGhlIGNvdW50ZXIgdG8gdXNlXHJcbiAgICovXHJcbiAgY291bnRlcihjb3VudGVyOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGlmIChjb3VudGVyIDwgMCkge1xyXG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIGNvdW50ZXI6ICR7Y291bnRlcn1gKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9jb3VudGVyID0gY291bnRlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSB2YWx1ZSB0byBzZW5kIGFsb25nIHdpdGggdGhpcyB0cmFuc2FjdGlvbi4gMCBieSBkZWZhdWx0XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHNlbmQgYWxvbmcgd2l0aCB0aGlzIHRyYW5zYWN0aW9uXHJcbiAgICovXHJcbiAgdmFsdWUodmFsdWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBidWlsZEJhc2UoZGF0YTogc3RyaW5nKTogVHhEYXRhIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGdhc0xpbWl0OiB0aGlzLl9mZWUuZ2FzTGltaXQsXHJcbiAgICAgIGdhc1ByaWNlOiB0aGlzLl9mZWUuZmVlLFxyXG4gICAgICBub25jZTogdGhpcy5fY291bnRlcixcclxuICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgY2hhaW5JZDogdGhpcy5fY29tbW9uLmNoYWluSWQoKS50b1N0cmluZygpLFxyXG4gICAgICB2YWx1ZTogdGhpcy5fdmFsdWUsXHJcbiAgICAgIHRvOiB0aGlzLl9jb250cmFjdEFkZHJlc3MsXHJcbiAgICB9O1xyXG4gIH1cclxuICAvL2VuZHJlZ2lvblxyXG5cclxuICAvL3JlZ2lvbiBXYWxsZXRJbml0aWFsaXphdGlvbiBidWlsZGVyIG1ldGhvZHNcclxuICAvKipcclxuICAgKiBTZXQgb25lIG9mIHRoZSBvd25lcnMgb2YgdGhlIG11bHRpc2lnIHdhbGxldC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIEFuIEV0aGVyZXVtIGFkZHJlc3NcclxuICAgKi9cclxuICBvd25lcihhZGRyZXNzOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl90eXBlICE9PSBUcmFuc2FjdGlvblR5cGUuV2FsbGV0SW5pdGlhbGl6YXRpb24pIHtcclxuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignTXVsdGlzaWcgd2FsbGV0IG93bmVyIGNhbiBvbmx5IGJlIHNldCBmb3IgaW5pdGlhbGl6YXRpb24gdHJhbnNhY3Rpb25zJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fd2FsbGV0T3duZXJBZGRyZXNzZXMubGVuZ3RoID49IERFRkFVTFRfTSkge1xyXG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdBIG1heGltdW0gb2YgJyArIERFRkFVTFRfTSArICcgb3duZXJzIGNhbiBiZSBzZXQgZm9yIGEgbXVsdGlzaWcgd2FsbGV0Jyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzVmFsaWRFdGhBZGRyZXNzKGFkZHJlc3MpKSB7XHJcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgYWRkcmVzczogJyArIGFkZHJlc3MpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX3dhbGxldE93bmVyQWRkcmVzc2VzLmluY2x1ZGVzKGFkZHJlc3MpKSB7XHJcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ1JlcGVhdGVkIG93bmVyIGFkZHJlc3M6ICcgKyBhZGRyZXNzKTtcclxuICAgIH1cclxuICAgIHRoaXMuX3dhbGxldE93bmVyQWRkcmVzc2VzLnB1c2goYWRkcmVzcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCdWlsZCBhIHRyYW5zYWN0aW9uIGZvciBhIGdlbmVyaWMgbXVsdGlzaWcgY29udHJhY3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7VHhEYXRhfSBUaGUgRXRoZXJldW0gdHJhbnNhY3Rpb24gZGF0YVxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBidWlsZFdhbGxldEluaXRpYWxpemF0aW9uVHJhbnNhY3Rpb24oKTogVHhEYXRhIHtcclxuICAgIHJldHVybiB0aGlzLmJ1aWxkQmFzZSh0aGlzLmdldENvbnRyYWN0RGF0YSh0aGlzLl93YWxsZXRPd25lckFkZHJlc3NlcykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgc21hcnQgY29udHJhY3QgZW5jb2RlZCBkYXRhXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhZGRyZXNzZXMgLSB0aGUgY29udHJhY3Qgc2lnbmVyc1xyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIHNtYXJ0IGNvbnRyYWN0IGVuY29kZWQgZGF0YVxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBnZXRDb250cmFjdERhdGEoYWRkcmVzc2VzOiBzdHJpbmdbXSk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBwYXJhbXMgPSBbYWRkcmVzc2VzXTtcclxuICAgIGNvbnN0IHJlc3VsdEVuY29kZWRQYXJhbWV0ZXJzID0gRXRoZXJldW1BYmkucmF3RW5jb2RlKHdhbGxldFNpbXBsZUNvbnN0cnVjdG9yLCBwYXJhbXMpXHJcbiAgICAgIC50b1N0cmluZygnaGV4JylcclxuICAgICAgLnJlcGxhY2UoJzB4JywgJycpO1xyXG4gICAgcmV0dXJuIHdhbGxldFNpbXBsZUJ5dGVDb2RlICsgcmVzdWx0RW5jb2RlZFBhcmFtZXRlcnM7XHJcbiAgfVxyXG4gIC8vZW5kcmVnaW9uXHJcblxyXG4gIC8vcmVnaW9uIFNlbmQgYnVpbGRlciBtZXRob2RzXHJcblxyXG4gIGNvbnRyYWN0KGFkZHJlc3M6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgaWYgKGlzVmFsaWRFdGhBZGRyZXNzKGFkZHJlc3MpKSB0aGlzLl9jb250cmFjdEFkZHJlc3MgPSBhZGRyZXNzO1xyXG4gICAgZWxzZSB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIGFkZHJlc3M6ICcgKyBhZGRyZXNzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHRyYW5zZmVyIGZ1bmRzIGJ1aWxkZXIgaWYgZXhpc3QsIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGZvciB0aGlzIHRyYW5zYWN0aW9uIGFuZCByZXR1cm5zIGl0XHJcbiAgICpcclxuICAgKiBAcGFyYW0gW2RhdGFdIHRyYW5zZmVyIGRhdGEgdG8gaW5pdGlhbGl6ZSB0aGUgdHJhbnNmZXIgYnVpbGRlciB3aXRoLCBlbXB0eSBpZiBub25lIGdpdmVuXHJcbiAgICogQHJldHVybnMge1RyYW5zZmVyQnVpbGRlcn0gdGhlIHRyYW5zZmVyIGJ1aWxkZXJcclxuICAgKi9cclxuICB0cmFuc2ZlcihkYXRhPzogc3RyaW5nKTogVHJhbnNmZXJCdWlsZGVyIHtcclxuICAgIGlmICh0aGlzLl90eXBlICE9PSBUcmFuc2FjdGlvblR5cGUuU2VuZCkge1xyXG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2ZlcnMgY2FuIG9ubHkgYmUgc2V0IGZvciBzZW5kIHRyYW5zYWN0aW9ucycpO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLl90cmFuc2Zlcikge1xyXG4gICAgICB0aGlzLl90cmFuc2ZlciA9IG5ldyBUcmFuc2ZlckJ1aWxkZXIoZGF0YSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNmZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzZXJpYWxpemVkIHNlbmRNdWx0aVNpZyBjb250cmFjdCBtZXRob2QgZGF0YVxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gc2VyaWFsaXplZCBzZW5kTXVsdGlTaWcgZGF0YVxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0U2VuZERhdGEoKTogc3RyaW5nIHtcclxuICAgIGlmICghdGhpcy5fdHJhbnNmZXIpIHtcclxuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignTWlzc2luZyB0cmFuc2ZlciBpbmZvcm1hdGlvbicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zZmVyLnNpZ25BbmRCdWlsZCgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBidWlsZFNlbmRUcmFuc2FjdGlvbigpOiBUeERhdGEge1xyXG4gICAgY29uc3Qgc2VuZERhdGEgPSB0aGlzLmdldFNlbmREYXRhKCk7XHJcbiAgICBjb25zdCB0eDogVHhEYXRhID0gdGhpcy5idWlsZEJhc2Uoc2VuZERhdGEpO1xyXG4gICAgdHgudG8gPSB0aGlzLl9jb250cmFjdEFkZHJlc3M7XHJcbiAgICByZXR1cm4gdHg7XHJcbiAgfVxyXG4gIC8vZW5kcmVnaW9uXHJcblxyXG4gIC8vcmVnaW9uIEFkZHJlc3NJbml0aWFsaXphdGlvbiBidWlsZGVyIG1ldGhvZHNcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBjb250cmFjdCB0cmFuc2FjdGlvbiBub25jZSB0byBjYWxjdWxhdGUgdGhlIGZvcndhcmRlciBhZGRyZXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvbnRyYWN0Q291bnRlciBUaGUgY291bnRlciB0byB1c2VcclxuICAgKi9cclxuICBjb250cmFjdENvdW50ZXIoY29udHJhY3RDb3VudGVyOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGlmIChjb250cmFjdENvdW50ZXIgPCAwKSB7XHJcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgY29udHJhY3QgY291bnRlcjogJHtjb250cmFjdENvdW50ZXJ9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fY29udHJhY3RDb3VudGVyID0gY29udHJhY3RDb3VudGVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGQgYSB0cmFuc2FjdGlvbiB0byBjcmVhdGUgYSBmb3J3YXJkZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7VHhEYXRhfSBUaGUgRXRoZXJldW0gdHJhbnNhY3Rpb24gZGF0YVxyXG4gICAqL1xyXG4gIHByaXZhdGUgYnVpbGRBZGRyZXNzSW5pdGlhbGl6YXRpb25UcmFuc2FjdGlvbigpOiBUeERhdGEge1xyXG4gICAgY29uc3QgYWRkcmVzc0luaXREYXRhID0gZ2V0QWRkcmVzc0luaXRpYWxpemF0aW9uRGF0YSgpO1xyXG4gICAgY29uc3QgdHg6IFR4RGF0YSA9IHRoaXMuYnVpbGRCYXNlKGFkZHJlc3NJbml0RGF0YSk7XHJcbiAgICB0eC50byA9IHRoaXMuX2NvbnRyYWN0QWRkcmVzcztcclxuICAgIGlmICh0aGlzLl9jb250cmFjdENvdW50ZXIpIHtcclxuICAgICAgdHguZGVwbG95ZWRBZGRyZXNzID0gY2FsY3VsYXRlRm9yd2FyZGVyQWRkcmVzcyh0aGlzLl9jb250cmFjdEFkZHJlc3MsIHRoaXMuX2NvbnRyYWN0Q291bnRlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHg7XHJcbiAgfVxyXG4gIC8vZW5kcmVnaW9uXHJcblxyXG4gIC8vcmVnaW9uIGZsdXNoIG1ldGhvZHNcclxuICAvKipcclxuICAgKiBTZXQgdGhlIGZvcndhcmRlciBhZGRyZXNzIHRvIGZsdXNoXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyBUaGUgYWRkcmVzcyB0byBmbHVzaFxyXG4gICAqL1xyXG4gIGZvcndhcmRlckFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBpZiAoIWlzVmFsaWRFdGhBZGRyZXNzKGFkZHJlc3MpKSB7XHJcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgYWRkcmVzczogJyArIGFkZHJlc3MpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fZm9yd2FyZGVyQWRkcmVzcyA9IGFkZHJlc3M7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIGFkZHJlc3Mgb2YgdGhlIEVSQzIwIHRva2VuIGNvbnRyYWN0IHRoYXQgd2UgYXJlIGZsdXNoaW5nIHRva2VucyBmb3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIHRoZSBjb250cmFjdCBhZGRyZXNzIG9mIHRoZSB0b2tlbiB0byBmbHVzaFxyXG4gICAqL1xyXG4gIHRva2VuQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGlmICghaXNWYWxpZEV0aEFkZHJlc3MoYWRkcmVzcykpIHtcclxuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBhZGRyZXNzOiAnICsgYWRkcmVzcyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl90b2tlbkFkZHJlc3MgPSBhZGRyZXNzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGQgYSB0cmFuc2FjdGlvbiB0byBmbHVzaCB0b2tlbnMgZnJvbSBhIGZvcndhcmRlci5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtUeERhdGF9IFRoZSBFdGhlcmV1bSB0cmFuc2FjdGlvbiBkYXRhXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBidWlsZEZsdXNoVG9rZW5zVHJhbnNhY3Rpb24oKTogVHhEYXRhIHtcclxuICAgIHJldHVybiB0aGlzLmJ1aWxkQmFzZShmbHVzaFRva2Vuc0RhdGEodGhpcy5fZm9yd2FyZGVyQWRkcmVzcywgdGhpcy5fdG9rZW5BZGRyZXNzKSk7XHJcbiAgfVxyXG4gIC8vZW5kcmVnaW9uXHJcblxyXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gIHByb3RlY3RlZCBnZXQgdHJhbnNhY3Rpb24oKTogVHJhbnNhY3Rpb24ge1xyXG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgcHJvdGVjdGVkIHNldCB0cmFuc2FjdGlvbih0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24pIHtcclxuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XHJcbiAgfVxyXG59XHJcbiJdfQ==