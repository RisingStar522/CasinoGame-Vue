"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var buffer_1 = require("buffer");
var assert_1 = __importDefault(require("assert"));
var ethereumjs_util_1 = require("ethereumjs-util");
var statics_1 = require("@bitgo/statics");
var ethereumjs_abi_1 = __importDefault(require("ethereumjs-abi"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var errors_1 = require("../baseCoin/errors");
var baseCoin_1 = require("../baseCoin");
var stakingUtils_1 = require("../celo/stakingUtils");
var walletUtil_1 = require("./walletUtil");
var resources_1 = require("./resources");
var types_1 = require("./types");
var commons = new Map([
    [statics_1.NetworkType.MAINNET, resources_1.mainnetCommon],
    [statics_1.NetworkType.TESTNET, resources_1.testnetCommon],
]);
/**
 * @param network
 */
function getCommon(network) {
    var common = commons.get(network);
    if (!common) {
        throw new errors_1.InvalidTransactionError('Missing network common configuration');
    }
    return common;
}
exports.getCommon = getCommon;
/**
 * Signs the transaction using the appropriate algorithm
 * and the provided common for the blockchain
 *
 * @param {TxData} transactionData the transaction data to sign
 * @param {KeyPair} keyPair the signer's keypair
 * @param {EthereumCommon} customCommon the network's custom common
 * @returns {string} the transaction signed and encoded
 */
function signInternal(transactionData, keyPair, customCommon) {
    return __awaiter(this, void 0, void 0, function () {
        var ethTx;
        return __generator(this, function (_a) {
            if (!keyPair.getKeys().prv) {
                throw new errors_1.SigningError('Missing private key');
            }
            ethTx = types_1.EthTransactionData.fromJson(transactionData, customCommon);
            ethTx.sign(keyPair);
            return [2 /*return*/, ethTx.toSerialized()];
        });
    });
}
exports.signInternal = signInternal;
/**
 * Signs the transaction using the appropriate algorithm
 *
 * @param {TxData} transactionData the transaction data to sign
 * @param {KeyPair} keyPair the signer's keypair
 * @returns {string} the transaction signed and encoded
 */
function sign(transactionData, keyPair) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, signInternal(transactionData, keyPair, resources_1.testnetCommon)];
        });
    });
}
exports.sign = sign;
/**
 * Returns the contract method encoded data
 *
 * @param {string} to destination address
 * @param {number} value Amount to tranfer
 * @param {string} data aditional method call data
 * @param {number} expireTime expiration time for the transaction in seconds
 * @param {number} sequenceId sequence id
 * @param {string} signature signature of the call
 * @returns {string} -- the contract method encoded data
 */
function sendMultiSigData(to, value, data, expireTime, sequenceId, signature) {
    var params = [to, value, ethereumjs_util_1.toBuffer(data), expireTime, sequenceId, ethereumjs_util_1.toBuffer(signature)];
    var method = ethereumjs_abi_1.default.methodID('sendMultiSig', walletUtil_1.sendMultiSigTypes);
    var args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.sendMultiSigTypes, params);
    return ethereumjs_util_1.addHexPrefix(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.sendMultiSigData = sendMultiSigData;
/**
 * Returns the contract method encoded data
 *
 * @param {string} to destination address
 * @param {number} value Amount to tranfer
 * @param {string} tokenContractAddress the address of the erc20 token contract
 * @param {number} expireTime expiration time for the transaction in seconds
 * @param {number} sequenceId sequence id
 * @param {string} signature signature of the call
 * @returns {string} -- the contract method encoded data
 */
function sendMultiSigTokenData(to, value, tokenContractAddress, expireTime, sequenceId, signature) {
    var params = [to, value, tokenContractAddress, expireTime, sequenceId, ethereumjs_util_1.toBuffer(signature)];
    var method = ethereumjs_abi_1.default.methodID('sendMultiSigToken', walletUtil_1.sendMultiSigTokenTypes);
    var args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.sendMultiSigTokenTypes, params);
    return ethereumjs_util_1.addHexPrefix(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.sendMultiSigTokenData = sendMultiSigTokenData;
/**
 * Get the data required to make a flush tokens contract call
 *
 * @param forwarderAddress The forwarder address to flush
 * @param tokenAddress The token address to flush from
 */
function flushTokensData(forwarderAddress, tokenAddress) {
    var params = [forwarderAddress, tokenAddress];
    var method = ethereumjs_abi_1.default.methodID('flushForwarderTokens', walletUtil_1.flushTokensTypes);
    var args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.flushTokensTypes, params);
    return ethereumjs_util_1.addHexPrefix(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.flushTokensData = flushTokensData;
/**
 * Returns the create forwarder method calling data
 *
 * @returns {string} - the createForwarder method encoded
 */
function getAddressInitializationData() {
    return walletUtil_1.createForwarderMethodId;
}
exports.getAddressInitializationData = getAddressInitializationData;
/**
 * Returns whether or not the string is a valid Eth address
 *
 * @param {string} address - the tx hash to validate
 * @returns {boolean} - the validation result
 */
function isValidEthAddress(address) {
    return ethereumjs_util_1.isValidAddress(address);
}
exports.isValidEthAddress = isValidEthAddress;
/**
 * Returns whether or not the string is a valid amount number
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
function isValidAmount(amount) {
    var bigNumberAmount = new bignumber_js_1.default(amount);
    return bigNumberAmount.isInteger() && bigNumberAmount.isGreaterThanOrEqualTo(0);
}
exports.isValidAmount = isValidAmount;
/**
 * Returns the smart contract encoded data
 *
 * @param {string} data The wallet creation data to decode
 * @returns {string[]} - The list of signer addresses
 */
function decodeWalletCreationData(data) {
    if (!data.startsWith(walletUtil_1.walletInitializationFirstBytes)) {
        throw new errors_1.BuildTransactionError("Invalid wallet bytecode: " + data);
    }
    var dataBuffer = buffer_1.Buffer.from(data.slice(2), 'hex');
    // the last 160 bytes contain the serialized address array
    var serializedSigners = dataBuffer.slice(-160);
    var resultEncodedParameters = ethereumjs_abi_1.default.rawDecode(walletUtil_1.walletSimpleConstructor, serializedSigners);
    if (resultEncodedParameters.length !== 1) {
        throw new errors_1.BuildTransactionError("Could not decode wallet constructor bytecode: " + resultEncodedParameters);
    }
    var addresses = resultEncodedParameters[0];
    if (addresses.length !== 3) {
        throw new errors_1.BuildTransactionError("invalid number of addresses in parsed constructor: " + addresses);
    }
    // sometimes ethereumjs-abi removes 0 padding at the start of addresses,
    // so we should pad until they are the standard 20 bytes
    var paddedAddresses = addresses.map(function (address) { return ethereumjs_util_1.stripHexPrefix(address.toString('hex')).padStart(40, '0'); });
    return paddedAddresses.map(function (address) { return ethereumjs_util_1.addHexPrefix(address); });
}
exports.decodeWalletCreationData = decodeWalletCreationData;
/**
 * Decode the given ABI-encoded transfer data and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
function decodeTransferData(data) {
    if (data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        return decodeNativeTransferData(data);
    }
    else if (data.startsWith(walletUtil_1.sendMultisigTokenMethodId)) {
        return decodeTokenTransferData(data);
    }
    else {
        throw new errors_1.BuildTransactionError("Invalid transfer bytecode: " + data);
    }
}
exports.decodeTransferData = decodeTransferData;
/**
 * Decode the given ABI-encoded transfer data for the sendMultisigToken function and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed token transfer data
 */
function decodeTokenTransferData(data) {
    if (!data.startsWith(walletUtil_1.sendMultisigTokenMethodId)) {
        throw new errors_1.BuildTransactionError("Invalid transfer bytecode: " + data);
    }
    var _a = getRawDecoded(walletUtil_1.sendMultiSigTokenTypes, getBufferedByteCode(walletUtil_1.sendMultisigTokenMethodId, data)), to = _a[0], amount = _a[1], tokenContractAddress = _a[2], expireTime = _a[3], sequenceId = _a[4], signature = _a[5];
    return {
        to: ethereumjs_util_1.addHexPrefix(to),
        amount: new bignumber_js_1.default(ethereumjs_util_1.bufferToHex(amount)).toFixed(),
        expireTime: ethereumjs_util_1.bufferToInt(expireTime),
        sequenceId: ethereumjs_util_1.bufferToInt(sequenceId),
        signature: ethereumjs_util_1.bufferToHex(signature),
        tokenContractAddress: ethereumjs_util_1.addHexPrefix(tokenContractAddress),
    };
}
exports.decodeTokenTransferData = decodeTokenTransferData;
/**
 * Decode the given ABI-encoded transfer data for the sendMultisig function and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
function decodeNativeTransferData(data) {
    if (!data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        throw new errors_1.BuildTransactionError("Invalid transfer bytecode: " + data);
    }
    var _a = getRawDecoded(walletUtil_1.sendMultiSigTypes, getBufferedByteCode(walletUtil_1.sendMultisigMethodId, data)), to = _a[0], amount = _a[1], internalData = _a[2], expireTime = _a[3], sequenceId = _a[4], signature = _a[5];
    return {
        to: ethereumjs_util_1.addHexPrefix(to),
        amount: new bignumber_js_1.default(ethereumjs_util_1.bufferToHex(amount)).toFixed(),
        expireTime: ethereumjs_util_1.bufferToInt(expireTime),
        sequenceId: ethereumjs_util_1.bufferToInt(sequenceId),
        signature: ethereumjs_util_1.bufferToHex(signature),
        data: ethereumjs_util_1.bufferToHex(internalData),
    };
}
exports.decodeNativeTransferData = decodeNativeTransferData;
/**
 * Decode the given ABI-encoded flush tokens data and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
function decodeFlushTokensData(data) {
    if (!data.startsWith(walletUtil_1.flushForwarderTokensMethodId)) {
        throw new errors_1.BuildTransactionError("Invalid transfer bytecode: " + data);
    }
    var _a = getRawDecoded(walletUtil_1.flushTokensTypes, getBufferedByteCode(walletUtil_1.flushForwarderTokensMethodId, data)), forwarderAddress = _a[0], tokenAddress = _a[1];
    return {
        forwarderAddress: ethereumjs_util_1.addHexPrefix(forwarderAddress),
        tokenAddress: ethereumjs_util_1.addHexPrefix(tokenAddress),
    };
}
exports.decodeFlushTokensData = decodeFlushTokensData;
/**
 * Classify the given transaction data based as a transaction type.
 * ETH transactions are defined by the first 8 bytes of the transaction data, also known as the method id
 *
 * @param {string} data The data to classify the transaction with
 * @returns {TransactionType} The classified transaction type
 */
function classifyTransaction(data) {
    if (data.length < 10) {
        // contract calls must have at least 4 bytes (method id) and '0x'
        // if it doesn't have enough data to be a contract call it must be a single sig send
        return baseCoin_1.TransactionType.SingleSigSend;
    }
    var transactionType = transactionTypesMap[data.slice(0, 10).toLowerCase()];
    if (transactionType === undefined) {
        throw new errors_1.BuildTransactionError("Unrecognized transaction type: " + data);
    }
    return transactionType;
}
exports.classifyTransaction = classifyTransaction;
/**
 * A transaction types map according to the starting part of the encoded data
 */
var transactionTypesMap = (_a = {},
    _a[walletUtil_1.walletInitializationFirstBytes] = baseCoin_1.TransactionType.WalletInitialization,
    _a[walletUtil_1.createForwarderMethodId] = baseCoin_1.TransactionType.AddressInitialization,
    _a[walletUtil_1.sendMultisigMethodId] = baseCoin_1.TransactionType.Send,
    _a[walletUtil_1.flushForwarderTokensMethodId] = baseCoin_1.TransactionType.FlushTokens,
    _a[walletUtil_1.sendMultisigTokenMethodId] = baseCoin_1.TransactionType.Send,
    _a[stakingUtils_1.LockMethodId] = baseCoin_1.TransactionType.StakingLock,
    _a[stakingUtils_1.VoteMethodId] = baseCoin_1.TransactionType.StakingVote,
    _a[stakingUtils_1.ActivateMethodId] = baseCoin_1.TransactionType.StakingActivate,
    _a[stakingUtils_1.UnvoteMethodId] = baseCoin_1.TransactionType.StakingUnvote,
    _a[stakingUtils_1.UnlockMethodId] = baseCoin_1.TransactionType.StakingUnlock,
    _a[stakingUtils_1.WithdrawMethodId] = baseCoin_1.TransactionType.StakingWithdraw,
    _a);
/**
 *
 * @param {number} num number to be converted to hex
 * @returns {string} the hex number
 */
function numberToHexString(num) {
    var hex = num.toString(16);
    return hex.length % 2 === 0 ? '0x' + hex : '0x0' + hex;
}
exports.numberToHexString = numberToHexString;
/**
 *
 * @param {string} hex The hex string to be converted
 * @returns {number} the resulting number
 */
function hexStringToNumber(hex) {
    return parseInt(hex.slice(2), 16);
}
exports.hexStringToNumber = hexStringToNumber;
/**
 * Generates an address of the forwarder address to be deployed
 *
 * @param {string} contractAddress the address which is creating this new address
 * @param {number} contractCounter the nonce of the contract address
 * @returns {string} the calculated forwarder contract address
 */
function calculateForwarderAddress(contractAddress, contractCounter) {
    var forwarderAddress = ethereumjs_util_1.generateAddress(contractAddress, contractCounter);
    return ethereumjs_util_1.addHexPrefix(forwarderAddress.toString('hex'));
}
exports.calculateForwarderAddress = calculateForwarderAddress;
/**
 * Convert the given signature parts to a string representation
 *
 * @param {SignatureParts} sig The signature to convert to string
 * @returns {string} String representation of the signature
 */
function toStringSig(sig) {
    return ethereumjs_util_1.bufferToHex(buffer_1.Buffer.concat([ethereumjs_util_1.setLengthLeft(sig.r, 32), ethereumjs_util_1.setLengthLeft(sig.s, 32), ethereumjs_util_1.toBuffer(sig.v)]));
}
exports.toStringSig = toStringSig;
/**
 * Return whether or not the given tx data has a signature
 *
 * @param {TxData} txData The transaction data to check for signature
 * @returns {boolean} true if the tx has a signature, else false
 */
function hasSignature(txData) {
    return (txData.v !== undefined &&
        txData.r !== undefined &&
        txData.s !== undefined &&
        txData.v.length > 0 &&
        txData.r.length > 0 &&
        txData.s.length > 0);
}
exports.hasSignature = hasSignature;
/**
 * Get the raw data decoded for some types
 *
 * @param {string[]} types ABI types definition
 * @param {Buffer} serializedArgs encoded args
 * @returns {Buffer[]} the decoded raw
 */
function getRawDecoded(types, serializedArgs) {
    return ethereumjs_abi_1.default.rawDecode(types, serializedArgs);
}
exports.getRawDecoded = getRawDecoded;
/**
 * Get the buffered bytecode from rawData using a methodId as delimiter
 *
 * @param {string} methodId the hex encoded method Id
 * @param {string} rawData the hex encoded raw data
 * @returns {Buffer} data buffered bytecode
 */
function getBufferedByteCode(methodId, rawData) {
    var splitBytecode = rawData.split(methodId);
    if (splitBytecode.length !== 2) {
        throw new errors_1.BuildTransactionError("Invalid send bytecode: " + rawData);
    }
    return buffer_1.Buffer.from(splitBytecode[1], 'hex');
}
exports.getBufferedByteCode = getBufferedByteCode;
/**
 * Get the statics coin object matching a given contract address if it exists
 *
 * @param tokenContractAddress The contract address to match against
 * @returns statics BaseCoin object for the matching token
 */
function getToken(tokenContractAddress) {
    var tokens = statics_1.coins.filter(function (coin) {
        if (coin instanceof statics_1.ContractAddressDefinedToken) {
            return coin.contractAddress.toLowerCase() === tokenContractAddress.toLowerCase();
        }
        return false;
    });
    // if length of tokens is 1, return the first, else return undefined
    // Can't directly index into tokens, or call `length`, so we use map to get an array
    var tokensArray = tokens.map(function (token) { return token; });
    if (tokensArray.length >= 1) {
        // there should never be two tokens with the same contract address, so we assert that here
        assert_1.default(tokensArray.length === 1);
        return tokensArray[0];
    }
    return undefined;
}
exports.getToken = getToken;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi9ldGgvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxpQ0FBZ0M7QUFDaEMsa0RBQTRCO0FBQzVCLG1EQVN5QjtBQUN6QiwwQ0FBZ0g7QUFDaEgsa0VBQXlDO0FBR3pDLDhEQUFxQztBQUNyQyw2Q0FBa0c7QUFDbEcsd0NBQThDO0FBQzlDLHFEQU84QjtBQUc5QiwyQ0FXc0I7QUFDdEIseUNBQTJEO0FBQzNELGlDQUE2QztBQUU3QyxJQUFNLE9BQU8sR0FBcUMsSUFBSSxHQUFHLENBQThCO0lBQ3JGLENBQUMscUJBQVcsQ0FBQyxPQUFPLEVBQUUseUJBQWEsQ0FBQztJQUNwQyxDQUFDLHFCQUFXLENBQUMsT0FBTyxFQUFFLHlCQUFhLENBQUM7Q0FDckMsQ0FBQyxDQUFDO0FBRUg7O0dBRUc7QUFDSCxTQUFnQixTQUFTLENBQUMsT0FBb0I7SUFDNUMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNwQyxJQUFJLENBQUMsTUFBTSxFQUFFO1FBQ1gsTUFBTSxJQUFJLGdDQUF1QixDQUFDLHNDQUFzQyxDQUFDLENBQUM7S0FDM0U7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBTkQsOEJBTUM7QUFFRDs7Ozs7Ozs7R0FRRztBQUNILFNBQXNCLFlBQVksQ0FDaEMsZUFBdUIsRUFDdkIsT0FBZ0IsRUFDaEIsWUFBNEI7Ozs7WUFFNUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLEVBQUU7Z0JBQzFCLE1BQU0sSUFBSSxxQkFBWSxDQUFDLHFCQUFxQixDQUFDLENBQUM7YUFDL0M7WUFDSyxLQUFLLEdBQUcsMEJBQWtCLENBQUMsUUFBUSxDQUFDLGVBQWUsRUFBRSxZQUFZLENBQUMsQ0FB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QztJQUNmLENBQUMsQ0FBQyxDQUFDO0lBRUgsb0VBQW9FO0lBQ3BFLG9GQUFvRjtJQUNwRixJQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLFVBQUEsS0FBSyxJQUFJLE9BQUEsS0FBSyxFQUFMLENBQUssQ0FBQyxDQUFDO0lBQy9DLElBQUksV0FBVyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7UUFDM0IsMEZBQTBGO1FBQzFGLGdCQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQztRQUNqQyxPQUFPLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUN2QjtJQUNELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUFqQkQsNEJBaUJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcclxuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xyXG5pbXBvcnQge1xyXG4gIGFkZEhleFByZWZpeCxcclxuICBidWZmZXJUb0hleCxcclxuICBidWZmZXJUb0ludCxcclxuICBnZW5lcmF0ZUFkZHJlc3MsXHJcbiAgaXNWYWxpZEFkZHJlc3MsXHJcbiAgc2V0TGVuZ3RoTGVmdCxcclxuICBzdHJpcEhleFByZWZpeCxcclxuICB0b0J1ZmZlcixcclxufSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xyXG5pbXBvcnQgeyBjb2lucywgQmFzZUNvaW4sIEVyYzIwQ29pbiwgQ2Vsb0NvaW4sIE5ldHdvcmtUeXBlLCBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4gfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XHJcbmltcG9ydCBFdGhlcmV1bUFiaSBmcm9tICdldGhlcmV1bWpzLWFiaSc7XHJcbmltcG9ydCBFdGhlcmV1bUNvbW1vbiBmcm9tICdldGhlcmV1bWpzLWNvbW1vbic7XHJcbmltcG9ydCAqIGFzIEJOIGZyb20gJ2JuLmpzJztcclxuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xyXG5pbXBvcnQgeyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IsIEludmFsaWRUcmFuc2FjdGlvbkVycm9yLCBTaWduaW5nRXJyb3IgfSBmcm9tICcuLi9iYXNlQ29pbi9lcnJvcnMnO1xyXG5pbXBvcnQgeyBUcmFuc2FjdGlvblR5cGUgfSBmcm9tICcuLi9iYXNlQ29pbic7XHJcbmltcG9ydCB7XHJcbiAgTG9ja01ldGhvZElkLFxyXG4gIFZvdGVNZXRob2RJZCxcclxuICBVbmxvY2tNZXRob2RJZCxcclxuICBBY3RpdmF0ZU1ldGhvZElkLFxyXG4gIFdpdGhkcmF3TWV0aG9kSWQsXHJcbiAgVW52b3RlTWV0aG9kSWQsXHJcbn0gZnJvbSAnLi4vY2Vsby9zdGFraW5nVXRpbHMnO1xyXG5pbXBvcnQgeyBGbHVzaFRva2Vuc0RhdGEsIE5hdGl2ZVRyYW5zZmVyRGF0YSwgU2lnbmF0dXJlUGFydHMsIFRva2VuVHJhbnNmZXJEYXRhLCBUcmFuc2ZlckRhdGEsIFR4RGF0YSB9IGZyb20gJy4vaWZhY2UnO1xyXG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLi9rZXlQYWlyJztcclxuaW1wb3J0IHtcclxuICBjcmVhdGVGb3J3YXJkZXJNZXRob2RJZCxcclxuICBmbHVzaEZvcndhcmRlclRva2Vuc01ldGhvZElkLFxyXG4gIGZsdXNoVG9rZW5zVHlwZXMsXHJcbiAgc2VuZE11bHRpc2lnTWV0aG9kSWQsXHJcbiAgc2VuZE11bHRpc2lnVG9rZW5NZXRob2RJZCxcclxuICBzZW5kTXVsdGlTaWdUb2tlblR5cGVzLFxyXG4gIHNlbmRNdWx0aVNpZ1R5cGVzLFxyXG4gIHdhbGxldEluaXRpYWxpemF0aW9uRmlyc3RCeXRlcyxcclxuICB3YWxsZXRTaW1wbGVCeXRlQ29kZSxcclxuICB3YWxsZXRTaW1wbGVDb25zdHJ1Y3RvcixcclxufSBmcm9tICcuL3dhbGxldFV0aWwnO1xyXG5pbXBvcnQgeyB0ZXN0bmV0Q29tbW9uLCBtYWlubmV0Q29tbW9uIH0gZnJvbSAnLi9yZXNvdXJjZXMnO1xyXG5pbXBvcnQgeyBFdGhUcmFuc2FjdGlvbkRhdGEgfSBmcm9tICcuL3R5cGVzJztcclxuXHJcbmNvbnN0IGNvbW1vbnM6IE1hcDxOZXR3b3JrVHlwZSwgRXRoZXJldW1Db21tb24+ID0gbmV3IE1hcDxOZXR3b3JrVHlwZSwgRXRoZXJldW1Db21tb24+KFtcclxuICBbTmV0d29ya1R5cGUuTUFJTk5FVCwgbWFpbm5ldENvbW1vbl0sXHJcbiAgW05ldHdvcmtUeXBlLlRFU1RORVQsIHRlc3RuZXRDb21tb25dLFxyXG5dKTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gbmV0d29ya1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbW1vbihuZXR3b3JrOiBOZXR3b3JrVHlwZSk6IEV0aGVyZXVtQ29tbW9uIHtcclxuICBjb25zdCBjb21tb24gPSBjb21tb25zLmdldChuZXR3b3JrKTtcclxuICBpZiAoIWNvbW1vbikge1xyXG4gICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdNaXNzaW5nIG5ldHdvcmsgY29tbW9uIGNvbmZpZ3VyYXRpb24nKTtcclxuICB9XHJcbiAgcmV0dXJuIGNvbW1vbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNpZ25zIHRoZSB0cmFuc2FjdGlvbiB1c2luZyB0aGUgYXBwcm9wcmlhdGUgYWxnb3JpdGhtXHJcbiAqIGFuZCB0aGUgcHJvdmlkZWQgY29tbW9uIGZvciB0aGUgYmxvY2tjaGFpblxyXG4gKlxyXG4gKiBAcGFyYW0ge1R4RGF0YX0gdHJhbnNhY3Rpb25EYXRhIHRoZSB0cmFuc2FjdGlvbiBkYXRhIHRvIHNpZ25cclxuICogQHBhcmFtIHtLZXlQYWlyfSBrZXlQYWlyIHRoZSBzaWduZXIncyBrZXlwYWlyXHJcbiAqIEBwYXJhbSB7RXRoZXJldW1Db21tb259IGN1c3RvbUNvbW1vbiB0aGUgbmV0d29yaydzIGN1c3RvbSBjb21tb25cclxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHRyYW5zYWN0aW9uIHNpZ25lZCBhbmQgZW5jb2RlZFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25JbnRlcm5hbChcclxuICB0cmFuc2FjdGlvbkRhdGE6IFR4RGF0YSxcclxuICBrZXlQYWlyOiBLZXlQYWlyLFxyXG4gIGN1c3RvbUNvbW1vbjogRXRoZXJldW1Db21tb24sXHJcbik6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgaWYgKCFrZXlQYWlyLmdldEtleXMoKS5wcnYpIHtcclxuICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZSBrZXknKTtcclxuICB9XHJcbiAgY29uc3QgZXRoVHggPSBFdGhUcmFuc2FjdGlvbkRhdGEuZnJvbUpzb24odHJhbnNhY3Rpb25EYXRhLCBjdXN0b21Db21tb24pO1xyXG4gIGV0aFR4LnNpZ24oa2V5UGFpcik7XHJcbiAgcmV0dXJuIGV0aFR4LnRvU2VyaWFsaXplZCgpO1xyXG59XHJcblxyXG4vKipcclxuICogU2lnbnMgdGhlIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBhbGdvcml0aG1cclxuICpcclxuICogQHBhcmFtIHtUeERhdGF9IHRyYW5zYWN0aW9uRGF0YSB0aGUgdHJhbnNhY3Rpb24gZGF0YSB0byBzaWduXHJcbiAqIEBwYXJhbSB7S2V5UGFpcn0ga2V5UGFpciB0aGUgc2lnbmVyJ3Mga2V5cGFpclxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdHJhbnNhY3Rpb24gc2lnbmVkIGFuZCBlbmNvZGVkXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbih0cmFuc2FjdGlvbkRhdGE6IFR4RGF0YSwga2V5UGFpcjogS2V5UGFpcik6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgcmV0dXJuIHNpZ25JbnRlcm5hbCh0cmFuc2FjdGlvbkRhdGEsIGtleVBhaXIsIHRlc3RuZXRDb21tb24pO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY29udHJhY3QgbWV0aG9kIGVuY29kZWQgZGF0YVxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdG8gZGVzdGluYXRpb24gYWRkcmVzc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgQW1vdW50IHRvIHRyYW5mZXJcclxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgYWRpdGlvbmFsIG1ldGhvZCBjYWxsIGRhdGFcclxuICogQHBhcmFtIHtudW1iZXJ9IGV4cGlyZVRpbWUgZXhwaXJhdGlvbiB0aW1lIGZvciB0aGUgdHJhbnNhY3Rpb24gaW4gc2Vjb25kc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gc2VxdWVuY2VJZCBzZXF1ZW5jZSBpZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlIHNpZ25hdHVyZSBvZiB0aGUgY2FsbFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtLSB0aGUgY29udHJhY3QgbWV0aG9kIGVuY29kZWQgZGF0YVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNlbmRNdWx0aVNpZ0RhdGEoXHJcbiAgdG86IHN0cmluZyxcclxuICB2YWx1ZTogc3RyaW5nLFxyXG4gIGRhdGE6IHN0cmluZyxcclxuICBleHBpcmVUaW1lOiBudW1iZXIsXHJcbiAgc2VxdWVuY2VJZDogbnVtYmVyLFxyXG4gIHNpZ25hdHVyZTogc3RyaW5nLFxyXG4pOiBzdHJpbmcge1xyXG4gIGNvbnN0IHBhcmFtcyA9IFt0bywgdmFsdWUsIHRvQnVmZmVyKGRhdGEpLCBleHBpcmVUaW1lLCBzZXF1ZW5jZUlkLCB0b0J1ZmZlcihzaWduYXR1cmUpXTtcclxuICBjb25zdCBtZXRob2QgPSBFdGhlcmV1bUFiaS5tZXRob2RJRCgnc2VuZE11bHRpU2lnJywgc2VuZE11bHRpU2lnVHlwZXMpO1xyXG4gIGNvbnN0IGFyZ3MgPSBFdGhlcmV1bUFiaS5yYXdFbmNvZGUoc2VuZE11bHRpU2lnVHlwZXMsIHBhcmFtcyk7XHJcbiAgcmV0dXJuIGFkZEhleFByZWZpeChCdWZmZXIuY29uY2F0KFttZXRob2QsIGFyZ3NdKS50b1N0cmluZygnaGV4JykpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY29udHJhY3QgbWV0aG9kIGVuY29kZWQgZGF0YVxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdG8gZGVzdGluYXRpb24gYWRkcmVzc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgQW1vdW50IHRvIHRyYW5mZXJcclxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuQ29udHJhY3RBZGRyZXNzIHRoZSBhZGRyZXNzIG9mIHRoZSBlcmMyMCB0b2tlbiBjb250cmFjdFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwaXJlVGltZSBleHBpcmF0aW9uIHRpbWUgZm9yIHRoZSB0cmFuc2FjdGlvbiBpbiBzZWNvbmRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZXF1ZW5jZUlkIHNlcXVlbmNlIGlkXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaWduYXR1cmUgc2lnbmF0dXJlIG9mIHRoZSBjYWxsXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0tIHRoZSBjb250cmFjdCBtZXRob2QgZW5jb2RlZCBkYXRhXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2VuZE11bHRpU2lnVG9rZW5EYXRhKFxyXG4gIHRvOiBzdHJpbmcsXHJcbiAgdmFsdWU6IHN0cmluZyxcclxuICB0b2tlbkNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxyXG4gIGV4cGlyZVRpbWU6IG51bWJlcixcclxuICBzZXF1ZW5jZUlkOiBudW1iZXIsXHJcbiAgc2lnbmF0dXJlOiBzdHJpbmcsXHJcbik6IHN0cmluZyB7XHJcbiAgY29uc3QgcGFyYW1zID0gW3RvLCB2YWx1ZSwgdG9rZW5Db250cmFjdEFkZHJlc3MsIGV4cGlyZVRpbWUsIHNlcXVlbmNlSWQsIHRvQnVmZmVyKHNpZ25hdHVyZSldO1xyXG4gIGNvbnN0IG1ldGhvZCA9IEV0aGVyZXVtQWJpLm1ldGhvZElEKCdzZW5kTXVsdGlTaWdUb2tlbicsIHNlbmRNdWx0aVNpZ1Rva2VuVHlwZXMpO1xyXG4gIGNvbnN0IGFyZ3MgPSBFdGhlcmV1bUFiaS5yYXdFbmNvZGUoc2VuZE11bHRpU2lnVG9rZW5UeXBlcywgcGFyYW1zKTtcclxuICByZXR1cm4gYWRkSGV4UHJlZml4KEJ1ZmZlci5jb25jYXQoW21ldGhvZCwgYXJnc10pLnRvU3RyaW5nKCdoZXgnKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGRhdGEgcmVxdWlyZWQgdG8gbWFrZSBhIGZsdXNoIHRva2VucyBjb250cmFjdCBjYWxsXHJcbiAqXHJcbiAqIEBwYXJhbSBmb3J3YXJkZXJBZGRyZXNzIFRoZSBmb3J3YXJkZXIgYWRkcmVzcyB0byBmbHVzaFxyXG4gKiBAcGFyYW0gdG9rZW5BZGRyZXNzIFRoZSB0b2tlbiBhZGRyZXNzIHRvIGZsdXNoIGZyb21cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmbHVzaFRva2Vuc0RhdGEoZm9yd2FyZGVyQWRkcmVzcywgdG9rZW5BZGRyZXNzKTogc3RyaW5nIHtcclxuICBjb25zdCBwYXJhbXMgPSBbZm9yd2FyZGVyQWRkcmVzcywgdG9rZW5BZGRyZXNzXTtcclxuICBjb25zdCBtZXRob2QgPSBFdGhlcmV1bUFiaS5tZXRob2RJRCgnZmx1c2hGb3J3YXJkZXJUb2tlbnMnLCBmbHVzaFRva2Vuc1R5cGVzKTtcclxuICBjb25zdCBhcmdzID0gRXRoZXJldW1BYmkucmF3RW5jb2RlKGZsdXNoVG9rZW5zVHlwZXMsIHBhcmFtcyk7XHJcbiAgcmV0dXJuIGFkZEhleFByZWZpeChCdWZmZXIuY29uY2F0KFttZXRob2QsIGFyZ3NdKS50b1N0cmluZygnaGV4JykpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY3JlYXRlIGZvcndhcmRlciBtZXRob2QgY2FsbGluZyBkYXRhXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGNyZWF0ZUZvcndhcmRlciBtZXRob2QgZW5jb2RlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFkZHJlc3NJbml0aWFsaXphdGlvbkRhdGEoKTogc3RyaW5nIHtcclxuICByZXR1cm4gY3JlYXRlRm9yd2FyZGVyTWV0aG9kSWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBFdGggYWRkcmVzc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIHRoZSB0eCBoYXNoIHRvIHZhbGlkYXRlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRFdGhBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIGFtb3VudCBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGFtb3VudCAtIHRoZSBzdHJpbmcgdG8gdmFsaWRhdGVcclxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEFtb3VudChhbW91bnQ6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IGJpZ051bWJlckFtb3VudCA9IG5ldyBCaWdOdW1iZXIoYW1vdW50KTtcclxuICByZXR1cm4gYmlnTnVtYmVyQW1vdW50LmlzSW50ZWdlcigpICYmIGJpZ051bWJlckFtb3VudC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvKDApO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgc21hcnQgY29udHJhY3QgZW5jb2RlZCBkYXRhXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIFRoZSB3YWxsZXQgY3JlYXRpb24gZGF0YSB0byBkZWNvZGVcclxuICogQHJldHVybnMge3N0cmluZ1tdfSAtIFRoZSBsaXN0IG9mIHNpZ25lciBhZGRyZXNzZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVXYWxsZXRDcmVhdGlvbkRhdGEoZGF0YTogc3RyaW5nKTogc3RyaW5nW10ge1xyXG4gIGlmICghZGF0YS5zdGFydHNXaXRoKHdhbGxldEluaXRpYWxpemF0aW9uRmlyc3RCeXRlcykpIHtcclxuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgd2FsbGV0IGJ5dGVjb2RlOiAke2RhdGF9YCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBkYXRhQnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YS5zbGljZSgyKSwgJ2hleCcpO1xyXG5cclxuICAvLyB0aGUgbGFzdCAxNjAgYnl0ZXMgY29udGFpbiB0aGUgc2VyaWFsaXplZCBhZGRyZXNzIGFycmF5XHJcbiAgY29uc3Qgc2VyaWFsaXplZFNpZ25lcnMgPSBkYXRhQnVmZmVyLnNsaWNlKC0xNjApO1xyXG5cclxuICBjb25zdCByZXN1bHRFbmNvZGVkUGFyYW1ldGVycyA9IEV0aGVyZXVtQWJpLnJhd0RlY29kZSh3YWxsZXRTaW1wbGVDb25zdHJ1Y3Rvciwgc2VyaWFsaXplZFNpZ25lcnMpO1xyXG4gIGlmIChyZXN1bHRFbmNvZGVkUGFyYW1ldGVycy5sZW5ndGggIT09IDEpIHtcclxuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYENvdWxkIG5vdCBkZWNvZGUgd2FsbGV0IGNvbnN0cnVjdG9yIGJ5dGVjb2RlOiAke3Jlc3VsdEVuY29kZWRQYXJhbWV0ZXJzfWApO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgYWRkcmVzc2VzOiBCTltdID0gcmVzdWx0RW5jb2RlZFBhcmFtZXRlcnNbMF07XHJcbiAgaWYgKGFkZHJlc3Nlcy5sZW5ndGggIT09IDMpIHtcclxuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYGludmFsaWQgbnVtYmVyIG9mIGFkZHJlc3NlcyBpbiBwYXJzZWQgY29uc3RydWN0b3I6ICR7YWRkcmVzc2VzfWApO1xyXG4gIH1cclxuXHJcbiAgLy8gc29tZXRpbWVzIGV0aGVyZXVtanMtYWJpIHJlbW92ZXMgMCBwYWRkaW5nIGF0IHRoZSBzdGFydCBvZiBhZGRyZXNzZXMsXHJcbiAgLy8gc28gd2Ugc2hvdWxkIHBhZCB1bnRpbCB0aGV5IGFyZSB0aGUgc3RhbmRhcmQgMjAgYnl0ZXNcclxuICBjb25zdCBwYWRkZWRBZGRyZXNzZXMgPSBhZGRyZXNzZXMubWFwKGFkZHJlc3MgPT4gc3RyaXBIZXhQcmVmaXgoYWRkcmVzcy50b1N0cmluZygnaGV4JykpLnBhZFN0YXJ0KDQwLCAnMCcpKTtcclxuXHJcbiAgcmV0dXJuIHBhZGRlZEFkZHJlc3Nlcy5tYXAoYWRkcmVzcyA9PiBhZGRIZXhQcmVmaXgoYWRkcmVzcykpO1xyXG59XHJcblxyXG4vKipcclxuICogRGVjb2RlIHRoZSBnaXZlbiBBQkktZW5jb2RlZCB0cmFuc2ZlciBkYXRhIGFuZCByZXR1cm4gcGFyc2VkIGZpZWxkc1xyXG4gKlxyXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvZGVcclxuICogQHJldHVybnMgcGFyc2VkIHRyYW5zZmVyIGRhdGFcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUcmFuc2ZlckRhdGEoZGF0YTogc3RyaW5nKTogVHJhbnNmZXJEYXRhIHtcclxuICBpZiAoZGF0YS5zdGFydHNXaXRoKHNlbmRNdWx0aXNpZ01ldGhvZElkKSkge1xyXG4gICAgcmV0dXJuIGRlY29kZU5hdGl2ZVRyYW5zZmVyRGF0YShkYXRhKTtcclxuICB9IGVsc2UgaWYgKGRhdGEuc3RhcnRzV2l0aChzZW5kTXVsdGlzaWdUb2tlbk1ldGhvZElkKSkge1xyXG4gICAgcmV0dXJuIGRlY29kZVRva2VuVHJhbnNmZXJEYXRhKGRhdGEpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHRyYW5zZmVyIGJ5dGVjb2RlOiAke2RhdGF9YCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRGVjb2RlIHRoZSBnaXZlbiBBQkktZW5jb2RlZCB0cmFuc2ZlciBkYXRhIGZvciB0aGUgc2VuZE11bHRpc2lnVG9rZW4gZnVuY3Rpb24gYW5kIHJldHVybiBwYXJzZWQgZmllbGRzXHJcbiAqXHJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29kZVxyXG4gKiBAcmV0dXJucyBwYXJzZWQgdG9rZW4gdHJhbnNmZXIgZGF0YVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVRva2VuVHJhbnNmZXJEYXRhKGRhdGE6IHN0cmluZyk6IFRva2VuVHJhbnNmZXJEYXRhIHtcclxuICBpZiAoIWRhdGEuc3RhcnRzV2l0aChzZW5kTXVsdGlzaWdUb2tlbk1ldGhvZElkKSkge1xyXG4gICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCB0cmFuc2ZlciBieXRlY29kZTogJHtkYXRhfWApO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgW3RvLCBhbW91bnQsIHRva2VuQ29udHJhY3RBZGRyZXNzLCBleHBpcmVUaW1lLCBzZXF1ZW5jZUlkLCBzaWduYXR1cmVdID0gZ2V0UmF3RGVjb2RlZChcclxuICAgIHNlbmRNdWx0aVNpZ1Rva2VuVHlwZXMsXHJcbiAgICBnZXRCdWZmZXJlZEJ5dGVDb2RlKHNlbmRNdWx0aXNpZ1Rva2VuTWV0aG9kSWQsIGRhdGEpLFxyXG4gICk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB0bzogYWRkSGV4UHJlZml4KHRvKSxcclxuICAgIGFtb3VudDogbmV3IEJpZ051bWJlcihidWZmZXJUb0hleChhbW91bnQpKS50b0ZpeGVkKCksXHJcbiAgICBleHBpcmVUaW1lOiBidWZmZXJUb0ludChleHBpcmVUaW1lKSxcclxuICAgIHNlcXVlbmNlSWQ6IGJ1ZmZlclRvSW50KHNlcXVlbmNlSWQpLFxyXG4gICAgc2lnbmF0dXJlOiBidWZmZXJUb0hleChzaWduYXR1cmUpLFxyXG4gICAgdG9rZW5Db250cmFjdEFkZHJlc3M6IGFkZEhleFByZWZpeCh0b2tlbkNvbnRyYWN0QWRkcmVzcyksXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERlY29kZSB0aGUgZ2l2ZW4gQUJJLWVuY29kZWQgdHJhbnNmZXIgZGF0YSBmb3IgdGhlIHNlbmRNdWx0aXNpZyBmdW5jdGlvbiBhbmQgcmV0dXJuIHBhcnNlZCBmaWVsZHNcclxuICpcclxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb2RlXHJcbiAqIEByZXR1cm5zIHBhcnNlZCB0cmFuc2ZlciBkYXRhXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTmF0aXZlVHJhbnNmZXJEYXRhKGRhdGE6IHN0cmluZyk6IE5hdGl2ZVRyYW5zZmVyRGF0YSB7XHJcbiAgaWYgKCFkYXRhLnN0YXJ0c1dpdGgoc2VuZE11bHRpc2lnTWV0aG9kSWQpKSB7XHJcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHRyYW5zZmVyIGJ5dGVjb2RlOiAke2RhdGF9YCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBbdG8sIGFtb3VudCwgaW50ZXJuYWxEYXRhLCBleHBpcmVUaW1lLCBzZXF1ZW5jZUlkLCBzaWduYXR1cmVdID0gZ2V0UmF3RGVjb2RlZChcclxuICAgIHNlbmRNdWx0aVNpZ1R5cGVzLFxyXG4gICAgZ2V0QnVmZmVyZWRCeXRlQ29kZShzZW5kTXVsdGlzaWdNZXRob2RJZCwgZGF0YSksXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHRvOiBhZGRIZXhQcmVmaXgodG8pLFxyXG4gICAgYW1vdW50OiBuZXcgQmlnTnVtYmVyKGJ1ZmZlclRvSGV4KGFtb3VudCkpLnRvRml4ZWQoKSxcclxuICAgIGV4cGlyZVRpbWU6IGJ1ZmZlclRvSW50KGV4cGlyZVRpbWUpLFxyXG4gICAgc2VxdWVuY2VJZDogYnVmZmVyVG9JbnQoc2VxdWVuY2VJZCksXHJcbiAgICBzaWduYXR1cmU6IGJ1ZmZlclRvSGV4KHNpZ25hdHVyZSksXHJcbiAgICBkYXRhOiBidWZmZXJUb0hleChpbnRlcm5hbERhdGEpLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWNvZGUgdGhlIGdpdmVuIEFCSS1lbmNvZGVkIGZsdXNoIHRva2VucyBkYXRhIGFuZCByZXR1cm4gcGFyc2VkIGZpZWxkc1xyXG4gKlxyXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvZGVcclxuICogQHJldHVybnMgcGFyc2VkIHRyYW5zZmVyIGRhdGFcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVGbHVzaFRva2Vuc0RhdGEoZGF0YTogc3RyaW5nKTogRmx1c2hUb2tlbnNEYXRhIHtcclxuICBpZiAoIWRhdGEuc3RhcnRzV2l0aChmbHVzaEZvcndhcmRlclRva2Vuc01ldGhvZElkKSkge1xyXG4gICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCB0cmFuc2ZlciBieXRlY29kZTogJHtkYXRhfWApO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgW2ZvcndhcmRlckFkZHJlc3MsIHRva2VuQWRkcmVzc10gPSBnZXRSYXdEZWNvZGVkKFxyXG4gICAgZmx1c2hUb2tlbnNUeXBlcyxcclxuICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUoZmx1c2hGb3J3YXJkZXJUb2tlbnNNZXRob2RJZCwgZGF0YSksXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGZvcndhcmRlckFkZHJlc3M6IGFkZEhleFByZWZpeChmb3J3YXJkZXJBZGRyZXNzKSxcclxuICAgIHRva2VuQWRkcmVzczogYWRkSGV4UHJlZml4KHRva2VuQWRkcmVzcyksXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENsYXNzaWZ5IHRoZSBnaXZlbiB0cmFuc2FjdGlvbiBkYXRhIGJhc2VkIGFzIGEgdHJhbnNhY3Rpb24gdHlwZS5cclxuICogRVRIIHRyYW5zYWN0aW9ucyBhcmUgZGVmaW5lZCBieSB0aGUgZmlyc3QgOCBieXRlcyBvZiB0aGUgdHJhbnNhY3Rpb24gZGF0YSwgYWxzbyBrbm93biBhcyB0aGUgbWV0aG9kIGlkXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGNsYXNzaWZ5IHRoZSB0cmFuc2FjdGlvbiB3aXRoXHJcbiAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblR5cGV9IFRoZSBjbGFzc2lmaWVkIHRyYW5zYWN0aW9uIHR5cGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGFzc2lmeVRyYW5zYWN0aW9uKGRhdGE6IHN0cmluZyk6IFRyYW5zYWN0aW9uVHlwZSB7XHJcbiAgaWYgKGRhdGEubGVuZ3RoIDwgMTApIHtcclxuICAgIC8vIGNvbnRyYWN0IGNhbGxzIG11c3QgaGF2ZSBhdCBsZWFzdCA0IGJ5dGVzIChtZXRob2QgaWQpIGFuZCAnMHgnXHJcbiAgICAvLyBpZiBpdCBkb2Vzbid0IGhhdmUgZW5vdWdoIGRhdGEgdG8gYmUgYSBjb250cmFjdCBjYWxsIGl0IG11c3QgYmUgYSBzaW5nbGUgc2lnIHNlbmRcclxuICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU2luZ2xlU2lnU2VuZDtcclxuICB9XHJcblxyXG4gIGNvbnN0IHRyYW5zYWN0aW9uVHlwZSA9IHRyYW5zYWN0aW9uVHlwZXNNYXBbZGF0YS5zbGljZSgwLCAxMCkudG9Mb3dlckNhc2UoKV07XHJcbiAgaWYgKHRyYW5zYWN0aW9uVHlwZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBVbnJlY29nbml6ZWQgdHJhbnNhY3Rpb24gdHlwZTogJHtkYXRhfWApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRyYW5zYWN0aW9uVHlwZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgdHJhbnNhY3Rpb24gdHlwZXMgbWFwIGFjY29yZGluZyB0byB0aGUgc3RhcnRpbmcgcGFydCBvZiB0aGUgZW5jb2RlZCBkYXRhXHJcbiAqL1xyXG5jb25zdCB0cmFuc2FjdGlvblR5cGVzTWFwID0ge1xyXG4gIFt3YWxsZXRJbml0aWFsaXphdGlvbkZpcnN0Qnl0ZXNdOiBUcmFuc2FjdGlvblR5cGUuV2FsbGV0SW5pdGlhbGl6YXRpb24sXHJcbiAgW2NyZWF0ZUZvcndhcmRlck1ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLkFkZHJlc3NJbml0aWFsaXphdGlvbixcclxuICBbc2VuZE11bHRpc2lnTWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuU2VuZCxcclxuICBbZmx1c2hGb3J3YXJkZXJUb2tlbnNNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5GbHVzaFRva2VucyxcclxuICBbc2VuZE11bHRpc2lnVG9rZW5NZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5TZW5kLFxyXG4gIFtMb2NrTWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0xvY2ssXHJcbiAgW1ZvdGVNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nVm90ZSxcclxuICBbQWN0aXZhdGVNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nQWN0aXZhdGUsXHJcbiAgW1Vudm90ZU1ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdVbnZvdGUsXHJcbiAgW1VubG9ja01ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdVbmxvY2ssXHJcbiAgW1dpdGhkcmF3TWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ1dpdGhkcmF3LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gbnVtYmVyIHRvIGJlIGNvbnZlcnRlZCB0byBoZXhcclxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGhleCBudW1iZXJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFN0cmluZyhudW06IG51bWJlcik6IHN0cmluZyB7XHJcbiAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcclxuICByZXR1cm4gaGV4Lmxlbmd0aCAlIDIgPT09IDAgPyAnMHgnICsgaGV4IDogJzB4MCcgKyBoZXg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaGV4IFRoZSBoZXggc3RyaW5nIHRvIGJlIGNvbnZlcnRlZFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgcmVzdWx0aW5nIG51bWJlclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGhleFN0cmluZ1RvTnVtYmVyKGhleDogc3RyaW5nKTogbnVtYmVyIHtcclxuICByZXR1cm4gcGFyc2VJbnQoaGV4LnNsaWNlKDIpLCAxNik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBvZiB0aGUgZm9yd2FyZGVyIGFkZHJlc3MgdG8gYmUgZGVwbG95ZWRcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0QWRkcmVzcyB0aGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb250cmFjdENvdW50ZXIgdGhlIG5vbmNlIG9mIHRoZSBjb250cmFjdCBhZGRyZXNzXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBjYWxjdWxhdGVkIGZvcndhcmRlciBjb250cmFjdCBhZGRyZXNzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRm9yd2FyZGVyQWRkcmVzcyhjb250cmFjdEFkZHJlc3M6IHN0cmluZywgY29udHJhY3RDb3VudGVyOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gIGNvbnN0IGZvcndhcmRlckFkZHJlc3MgPSBnZW5lcmF0ZUFkZHJlc3MoY29udHJhY3RBZGRyZXNzLCBjb250cmFjdENvdW50ZXIpO1xyXG4gIHJldHVybiBhZGRIZXhQcmVmaXgoZm9yd2FyZGVyQWRkcmVzcy50b1N0cmluZygnaGV4JykpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCB0aGUgZ2l2ZW4gc2lnbmF0dXJlIHBhcnRzIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7U2lnbmF0dXJlUGFydHN9IHNpZyBUaGUgc2lnbmF0dXJlIHRvIGNvbnZlcnQgdG8gc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2lnbmF0dXJlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmdTaWcoc2lnOiBTaWduYXR1cmVQYXJ0cyk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGJ1ZmZlclRvSGV4KEJ1ZmZlci5jb25jYXQoW3NldExlbmd0aExlZnQoc2lnLnIsIDMyKSwgc2V0TGVuZ3RoTGVmdChzaWcucywgMzIpLCB0b0J1ZmZlcihzaWcudildKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gd2hldGhlciBvciBub3QgdGhlIGdpdmVuIHR4IGRhdGEgaGFzIGEgc2lnbmF0dXJlXHJcbiAqXHJcbiAqIEBwYXJhbSB7VHhEYXRhfSB0eERhdGEgVGhlIHRyYW5zYWN0aW9uIGRhdGEgdG8gY2hlY2sgZm9yIHNpZ25hdHVyZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHggaGFzIGEgc2lnbmF0dXJlLCBlbHNlIGZhbHNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzU2lnbmF0dXJlKHR4RGF0YTogVHhEYXRhKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIChcclxuICAgIHR4RGF0YS52ICE9PSB1bmRlZmluZWQgJiZcclxuICAgIHR4RGF0YS5yICE9PSB1bmRlZmluZWQgJiZcclxuICAgIHR4RGF0YS5zICE9PSB1bmRlZmluZWQgJiZcclxuICAgIHR4RGF0YS52Lmxlbmd0aCA+IDAgJiZcclxuICAgIHR4RGF0YS5yLmxlbmd0aCA+IDAgJiZcclxuICAgIHR4RGF0YS5zLmxlbmd0aCA+IDBcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSByYXcgZGF0YSBkZWNvZGVkIGZvciBzb21lIHR5cGVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nW119IHR5cGVzIEFCSSB0eXBlcyBkZWZpbml0aW9uXHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBzZXJpYWxpemVkQXJncyBlbmNvZGVkIGFyZ3NcclxuICogQHJldHVybnMge0J1ZmZlcltdfSB0aGUgZGVjb2RlZCByYXdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRSYXdEZWNvZGVkKHR5cGVzOiBzdHJpbmdbXSwgc2VyaWFsaXplZEFyZ3M6IEJ1ZmZlcik6IEJ1ZmZlcltdIHtcclxuICByZXR1cm4gRXRoZXJldW1BYmkucmF3RGVjb2RlKHR5cGVzLCBzZXJpYWxpemVkQXJncyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGJ1ZmZlcmVkIGJ5dGVjb2RlIGZyb20gcmF3RGF0YSB1c2luZyBhIG1ldGhvZElkIGFzIGRlbGltaXRlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kSWQgdGhlIGhleCBlbmNvZGVkIG1ldGhvZCBJZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcmF3RGF0YSB0aGUgaGV4IGVuY29kZWQgcmF3IGRhdGFcclxuICogQHJldHVybnMge0J1ZmZlcn0gZGF0YSBidWZmZXJlZCBieXRlY29kZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEJ1ZmZlcmVkQnl0ZUNvZGUobWV0aG9kSWQ6IHN0cmluZywgcmF3RGF0YTogc3RyaW5nKTogQnVmZmVyIHtcclxuICBjb25zdCBzcGxpdEJ5dGVjb2RlID0gcmF3RGF0YS5zcGxpdChtZXRob2RJZCk7XHJcbiAgaWYgKHNwbGl0Qnl0ZWNvZGUubGVuZ3RoICE9PSAyKSB7XHJcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHNlbmQgYnl0ZWNvZGU6ICR7cmF3RGF0YX1gKTtcclxuICB9XHJcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNwbGl0Qnl0ZWNvZGVbMV0sICdoZXgnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgc3RhdGljcyBjb2luIG9iamVjdCBtYXRjaGluZyBhIGdpdmVuIGNvbnRyYWN0IGFkZHJlc3MgaWYgaXQgZXhpc3RzXHJcbiAqXHJcbiAqIEBwYXJhbSB0b2tlbkNvbnRyYWN0QWRkcmVzcyBUaGUgY29udHJhY3QgYWRkcmVzcyB0byBtYXRjaCBhZ2FpbnN0XHJcbiAqIEByZXR1cm5zIHN0YXRpY3MgQmFzZUNvaW4gb2JqZWN0IGZvciB0aGUgbWF0Y2hpbmcgdG9rZW5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUb2tlbih0b2tlbkNvbnRyYWN0QWRkcmVzczogc3RyaW5nKTogUmVhZG9ubHk8QmFzZUNvaW4+IHwgdW5kZWZpbmVkIHtcclxuICBjb25zdCB0b2tlbnMgPSBjb2lucy5maWx0ZXIoY29pbiA9PiB7XHJcbiAgICBpZiAoY29pbiBpbnN0YW5jZW9mIENvbnRyYWN0QWRkcmVzc0RlZmluZWRUb2tlbikge1xyXG4gICAgICByZXR1cm4gY29pbi5jb250cmFjdEFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gdG9rZW5Db250cmFjdEFkZHJlc3MudG9Mb3dlckNhc2UoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9KTtcclxuXHJcbiAgLy8gaWYgbGVuZ3RoIG9mIHRva2VucyBpcyAxLCByZXR1cm4gdGhlIGZpcnN0LCBlbHNlIHJldHVybiB1bmRlZmluZWRcclxuICAvLyBDYW4ndCBkaXJlY3RseSBpbmRleCBpbnRvIHRva2Vucywgb3IgY2FsbCBgbGVuZ3RoYCwgc28gd2UgdXNlIG1hcCB0byBnZXQgYW4gYXJyYXlcclxuICBjb25zdCB0b2tlbnNBcnJheSA9IHRva2Vucy5tYXAodG9rZW4gPT4gdG9rZW4pO1xyXG4gIGlmICh0b2tlbnNBcnJheS5sZW5ndGggPj0gMSkge1xyXG4gICAgLy8gdGhlcmUgc2hvdWxkIG5ldmVyIGJlIHR3byB0b2tlbnMgd2l0aCB0aGUgc2FtZSBjb250cmFjdCBhZGRyZXNzLCBzbyB3ZSBhc3NlcnQgdGhhdCBoZXJlXHJcbiAgICBhc3NlcnQodG9rZW5zQXJyYXkubGVuZ3RoID09PSAxKTtcclxuICAgIHJldHVybiB0b2tlbnNBcnJheVswXTtcclxuICB9XHJcbiAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG4iXX0=