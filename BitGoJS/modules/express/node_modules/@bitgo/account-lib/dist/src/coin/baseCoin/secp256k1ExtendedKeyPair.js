"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var utxo_lib_1 = require("@bitgo/utxo-lib");
var Crypto = __importStar(require("../../utils/crypto"));
var errors_1 = require("./errors");
/**
 * Base class for SECP256K1 extended keypairs.
 */
var Secp256k1ExtendedKeyPair = /** @class */ (function () {
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param {KeyPairOptions} source Either a master seed, a private key (extended or raw), or a public key
     *     (extended, compressed, or uncompressed)
     */
    function Secp256k1ExtendedKeyPair(source) {
        this.source = source;
    }
    /**
     * Build a Hierarchical Deterministic node or an ECPair from a private key.
     *
     * @param {string} prv An extended or raw private key
     */
    Secp256k1ExtendedKeyPair.prototype.recordKeysFromPrivateKey = function (prv) {
        if (Crypto.isValidXprv(prv)) {
            this.hdNode = utxo_lib_1.HDNode.fromBase58(prv);
        }
        else if (Crypto.isValidPrv(prv)) {
            // Cannot create the HD node without the chain code, so create a regular Key Chain
            this.keyPair = utxo_lib_1.ECPair.fromPrivateKeyBuffer(Buffer.from(prv, 'hex'));
        }
        else {
            throw new Error('Unsupported private key');
        }
    };
    /**
     * Build a Hierarchical Deterministic node or an ECPair from a public key.
     *
     * @param {string} pub - An extended, compressed, or uncompressed public key
     */
    Secp256k1ExtendedKeyPair.prototype.recordKeysFromPublicKey = function (pub) {
        if (Crypto.isValidXpub(pub)) {
            this.hdNode = utxo_lib_1.HDNode.fromBase58(pub);
        }
        else if (Crypto.isValidPub(pub)) {
            // Cannot create an HD node without the chain code, so create a regular Key Chain
            this.keyPair = utxo_lib_1.ECPair.fromPublicKeyBuffer(Buffer.from(pub, 'hex'));
        }
        else {
            throw new Error('Unsupported public key: ' + pub);
        }
    };
    /**
     * Get the extended public key, and the private key if one is available. This is only possible
     * when the key pair was created from a seed or extended keys.
     *
     * @returns {ExtendedKeys} The Extended keys object
     */
    Secp256k1ExtendedKeyPair.prototype.getExtendedKeys = function () {
        if (!this.hdNode) {
            throw new Error('Cannot get extended keys');
        }
        var result = {
            xpub: this.hdNode.neutered().toBase58(),
        };
        // A neutered HD node means it only contains the public key information
        if (!this.hdNode.isNeutered()) {
            result.xprv = this.hdNode.toBase58();
        }
        return result;
    };
    Secp256k1ExtendedKeyPair.prototype.getAddress = function (format) {
        throw new errors_1.NotImplementedError('getAddress not implemented');
    };
    Secp256k1ExtendedKeyPair.prototype.getKeys = function () {
        throw new errors_1.NotImplementedError('getKeys not implemented');
    };
    return Secp256k1ExtendedKeyPair;
}());
exports.Secp256k1ExtendedKeyPair = Secp256k1ExtendedKeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvaW4vYmFzZUNvaW4vc2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLDRDQUFpRDtBQUNqRCx5REFBNkM7QUFJN0MsbUNBQStDO0FBRS9DOztHQUVHO0FBQ0g7SUFNRTs7Ozs7T0FLRztJQUNILGtDQUFzQixNQUF1QjtRQUMzQyxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDJEQUF3QixHQUF4QixVQUF5QixHQUFXO1FBQ2xDLElBQUksTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUMzQixJQUFJLENBQUMsTUFBTSxHQUFHLGlCQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3RDO2FBQU0sSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ2pDLGtGQUFrRjtZQUNsRixJQUFJLENBQUMsT0FBTyxHQUFHLGlCQUFNLENBQUMsb0JBQW9CLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUNyRTthQUFNO1lBQ0wsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1NBQzVDO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCwwREFBdUIsR0FBdkIsVUFBd0IsR0FBVztRQUNqQyxJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDM0IsSUFBSSxDQUFDLE1BQU0sR0FBRyxpQkFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN0QzthQUFNLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNqQyxpRkFBaUY7WUFDakYsSUFBSSxDQUFDLE9BQU8sR0FBRyxpQkFBTSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7U0FDcEU7YUFBTTtZQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLEdBQUcsR0FBRyxDQUFDLENBQUM7U0FDbkQ7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxrREFBZSxHQUFmO1FBQ0UsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO1NBQzdDO1FBQ0QsSUFBTSxNQUFNLEdBQWlCO1lBQzNCLElBQUksRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRTtTQUN4QyxDQUFDO1FBQ0YsdUVBQXVFO1FBQ3ZFLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxFQUFFO1lBQzdCLE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztTQUN0QztRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRCw2Q0FBVSxHQUFWLFVBQVcsTUFBc0I7UUFDL0IsTUFBTSxJQUFJLDRCQUFtQixDQUFDLDRCQUE0QixDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUVELDBDQUFPLEdBQVA7UUFDRSxNQUFNLElBQUksNEJBQW1CLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBQ0gsK0JBQUM7QUFBRCxDQUFDLEFBM0VELElBMkVDO0FBM0VxQiw0REFBd0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIRE5vZGUsIEVDUGFpciB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XHJcbmltcG9ydCAqIGFzIENyeXB0byBmcm9tICcuLi8uLi91dGlscy9jcnlwdG8nO1xyXG5pbXBvcnQgeyBLZXlQYWlyT3B0aW9ucywgRXh0ZW5kZWRLZXlzIH0gZnJvbSAnLi9pZmFjZSc7XHJcbmltcG9ydCB7IEJhc2VLZXlQYWlyIH0gZnJvbSAnLi9iYXNlS2V5UGFpcic7XHJcbmltcG9ydCB7IEFkZHJlc3NGb3JtYXQgfSBmcm9tICcuL2VudW0nO1xyXG5pbXBvcnQgeyBOb3RJbXBsZW1lbnRlZEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xyXG5cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIFNFQ1AyNTZLMSBleHRlbmRlZCBrZXlwYWlycy5cclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTZWNwMjU2azFFeHRlbmRlZEtleVBhaXIgaW1wbGVtZW50cyBCYXNlS2V5UGFpciB7XHJcbiAgLy8gSW1wbGVtZW50YXRpb24gb2YgdGhlIEhEIHByb3RvY29sIChCSVAzMikuIE9ubHkgYXZhaWxhYmxlIHdoZW4gY3JlYXRpbmcgYSBLZXlQYWlyIGZyb20gYSBzZWVkLFxyXG4gIC8vIG9yIGV4dGVuZGVkIGtleXNcclxuICBwcm90ZWN0ZWQgaGROb2RlPzogSEROb2RlO1xyXG4gIHByb3RlY3RlZCBrZXlQYWlyOiBFQ1BhaXI7XHJcbiAgcHJvdGVjdGVkIHNvdXJjZT86IEtleVBhaXJPcHRpb25zO1xyXG4gIC8qKlxyXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci4gQnkgZGVmYXVsdCwgY3JlYXRlcyBhIGtleSBwYWlyIHdpdGggYSByYW5kb20gbWFzdGVyIHNlZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0tleVBhaXJPcHRpb25zfSBzb3VyY2UgRWl0aGVyIGEgbWFzdGVyIHNlZWQsIGEgcHJpdmF0ZSBrZXkgKGV4dGVuZGVkIG9yIHJhdyksIG9yIGEgcHVibGljIGtleVxyXG4gICAqICAgICAoZXh0ZW5kZWQsIGNvbXByZXNzZWQsIG9yIHVuY29tcHJlc3NlZClcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3Ioc291cmNlPzogS2V5UGFpck9wdGlvbnMpIHtcclxuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGQgYSBIaWVyYXJjaGljYWwgRGV0ZXJtaW5pc3RpYyBub2RlIG9yIGFuIEVDUGFpciBmcm9tIGEgcHJpdmF0ZSBrZXkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJ2IEFuIGV4dGVuZGVkIG9yIHJhdyBwcml2YXRlIGtleVxyXG4gICAqL1xyXG4gIHJlY29yZEtleXNGcm9tUHJpdmF0ZUtleShwcnY6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgaWYgKENyeXB0by5pc1ZhbGlkWHBydihwcnYpKSB7XHJcbiAgICAgIHRoaXMuaGROb2RlID0gSEROb2RlLmZyb21CYXNlNTgocHJ2KTtcclxuICAgIH0gZWxzZSBpZiAoQ3J5cHRvLmlzVmFsaWRQcnYocHJ2KSkge1xyXG4gICAgICAvLyBDYW5ub3QgY3JlYXRlIHRoZSBIRCBub2RlIHdpdGhvdXQgdGhlIGNoYWluIGNvZGUsIHNvIGNyZWF0ZSBhIHJlZ3VsYXIgS2V5IENoYWluXHJcbiAgICAgIHRoaXMua2V5UGFpciA9IEVDUGFpci5mcm9tUHJpdmF0ZUtleUJ1ZmZlcihCdWZmZXIuZnJvbShwcnYsICdoZXgnKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHByaXZhdGUga2V5Jyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCdWlsZCBhIEhpZXJhcmNoaWNhbCBEZXRlcm1pbmlzdGljIG5vZGUgb3IgYW4gRUNQYWlyIGZyb20gYSBwdWJsaWMga2V5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHB1YiAtIEFuIGV4dGVuZGVkLCBjb21wcmVzc2VkLCBvciB1bmNvbXByZXNzZWQgcHVibGljIGtleVxyXG4gICAqL1xyXG4gIHJlY29yZEtleXNGcm9tUHVibGljS2V5KHB1Yjogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBpZiAoQ3J5cHRvLmlzVmFsaWRYcHViKHB1YikpIHtcclxuICAgICAgdGhpcy5oZE5vZGUgPSBIRE5vZGUuZnJvbUJhc2U1OChwdWIpO1xyXG4gICAgfSBlbHNlIGlmIChDcnlwdG8uaXNWYWxpZFB1YihwdWIpKSB7XHJcbiAgICAgIC8vIENhbm5vdCBjcmVhdGUgYW4gSEQgbm9kZSB3aXRob3V0IHRoZSBjaGFpbiBjb2RlLCBzbyBjcmVhdGUgYSByZWd1bGFyIEtleSBDaGFpblxyXG4gICAgICB0aGlzLmtleVBhaXIgPSBFQ1BhaXIuZnJvbVB1YmxpY0tleUJ1ZmZlcihCdWZmZXIuZnJvbShwdWIsICdoZXgnKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHB1YmxpYyBrZXk6ICcgKyBwdWIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBleHRlbmRlZCBwdWJsaWMga2V5LCBhbmQgdGhlIHByaXZhdGUga2V5IGlmIG9uZSBpcyBhdmFpbGFibGUuIFRoaXMgaXMgb25seSBwb3NzaWJsZVxyXG4gICAqIHdoZW4gdGhlIGtleSBwYWlyIHdhcyBjcmVhdGVkIGZyb20gYSBzZWVkIG9yIGV4dGVuZGVkIGtleXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RXh0ZW5kZWRLZXlzfSBUaGUgRXh0ZW5kZWQga2V5cyBvYmplY3RcclxuICAgKi9cclxuICBnZXRFeHRlbmRlZEtleXMoKTogRXh0ZW5kZWRLZXlzIHtcclxuICAgIGlmICghdGhpcy5oZE5vZGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2V0IGV4dGVuZGVkIGtleXMnKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3VsdDogRXh0ZW5kZWRLZXlzID0ge1xyXG4gICAgICB4cHViOiB0aGlzLmhkTm9kZS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCksXHJcbiAgICB9O1xyXG4gICAgLy8gQSBuZXV0ZXJlZCBIRCBub2RlIG1lYW5zIGl0IG9ubHkgY29udGFpbnMgdGhlIHB1YmxpYyBrZXkgaW5mb3JtYXRpb25cclxuICAgIGlmICghdGhpcy5oZE5vZGUuaXNOZXV0ZXJlZCgpKSB7XHJcbiAgICAgIHJlc3VsdC54cHJ2ID0gdGhpcy5oZE5vZGUudG9CYXNlNTgoKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBnZXRBZGRyZXNzKGZvcm1hdD86IEFkZHJlc3NGb3JtYXQpOiBzdHJpbmcge1xyXG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ2dldEFkZHJlc3Mgbm90IGltcGxlbWVudGVkJyk7XHJcbiAgfVxyXG5cclxuICBnZXRLZXlzKCk6IGFueSB7XHJcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignZ2V0S2V5cyBub3QgaW1wbGVtZW50ZWQnKTtcclxuICB9XHJcbn1cclxuIl19