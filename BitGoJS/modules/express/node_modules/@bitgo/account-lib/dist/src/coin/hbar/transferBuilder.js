"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var long_1 = __importDefault(require("long"));
var sdk_1 = require("@hashgraph/sdk");
var hedera_1 = require("../../../resources/hbar/protobuf/hedera");
var errors_1 = require("../baseCoin/errors");
var transactionBuilder_1 = require("./transactionBuilder");
var utils_1 = require("./utils");
var baseCoin_1 = require("../baseCoin");
var TransferBuilder = /** @class */ (function (_super) {
    __extends(TransferBuilder, _super);
    function TransferBuilder(_coinConfig) {
        var _this = _super.call(this, _coinConfig) || this;
        _this._txBodyData = new hedera_1.proto.CryptoTransferTransactionBody();
        _this._txBody.cryptoTransfer = _this._txBodyData;
        return _this;
    }
    /** @inheritdoc */
    TransferBuilder.prototype.buildImplementation = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._txBodyData.transfers = this.buildTransferData();
                        this.transaction.setTransactionType(baseCoin_1.TransactionType.Send);
                        return [4 /*yield*/, _super.prototype.buildImplementation.call(this)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    TransferBuilder.prototype.buildTransferData = function () {
        return {
            accountAmounts: [
                { accountID: this.buildAccountData(this._source.address), amount: long_1.default.fromString(this._amount).negate() },
                { accountID: this.buildAccountData(this._toAddress), amount: long_1.default.fromString(this._amount) },
            ],
        };
    };
    TransferBuilder.prototype.buildAccountData = function (address) {
        var accountData = new sdk_1.AccountId(address);
        return new hedera_1.proto.AccountID({
            accountNum: accountData.account,
            realmNum: accountData.realm,
            shardNum: accountData.shard,
        });
    };
    /** @inheritdoc */
    TransferBuilder.prototype.initBuilder = function (tx) {
        _super.prototype.initBuilder.call(this, tx);
        this.transaction.setTransactionType(baseCoin_1.TransactionType.Send);
        var transferData = tx.txBody.cryptoTransfer;
        if (transferData && transferData.transfers && transferData.transfers.accountAmounts) {
            this.initTransfers(transferData.transfers.accountAmounts);
        }
    };
    /**
     * Initialize the transfer specific data, getting the recipient account
     * represented by the element with a positive amount on the transfer element.
     * The negative amount represents the source account so it's ignored.
     *
     * @param {proto.IAccountAmount[]} transfers array of objects which contains accountID and transferred amount
     */
    TransferBuilder.prototype.initTransfers = function (transfers) {
        var _this = this;
        transfers.forEach(function (transferData) {
            var amount = long_1.default.fromValue(transferData.amount);
            if (amount.isPositive()) {
                _this.to(utils_1.stringifyAccountId(transferData.accountID));
                _this.amount(amount.toString());
            }
        });
    };
    /** @inheritdoc */
    TransferBuilder.prototype.signImplementation = function (key) {
        if (this._multiSignerKeyPairs.length >= transactionBuilder_1.DEFAULT_M) {
            throw new errors_1.SigningError('A maximum of ' + transactionBuilder_1.DEFAULT_M + ' can sign the transaction.');
        }
        return _super.prototype.signImplementation.call(this, key);
    };
    //region Transfer fields
    /**
     * Set the destination address where the funds will be sent,
     * it may take the format `'<shard>.<realm>.<account>'` or `'<account>'`
     *
     * @param {string} address the address to transfer funds to
     * @returns {TransferBuilder} the builder with the new parameter set
     */
    TransferBuilder.prototype.to = function (address) {
        if (!utils_1.isValidAddress(address)) {
            throw new errors_1.InvalidParameterValueError('Invalid address');
        }
        this._toAddress = address;
        return this;
    };
    /**
     * Set the amount to be transferred
     *
     * @param {string} amount amount to transfer in tinyBars (there are 100,000,000 tinyBars in one Hbar)
     * @returns {TransferBuilder} the builder with the new parameter set
     */
    TransferBuilder.prototype.amount = function (amount) {
        if (!utils_1.isValidAmount(amount)) {
            throw new errors_1.InvalidParameterValueError('Invalid amount');
        }
        this._amount = amount;
        return this;
    };
    //endregion
    //region Validators
    TransferBuilder.prototype.validateMandatoryFields = function () {
        if (this._toAddress === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing to');
        }
        if (this._amount === undefined) {
            throw new errors_1.BuildTransactionError('Invalid transaction: missing amount');
        }
        _super.prototype.validateMandatoryFields.call(this);
    };
    return TransferBuilder;
}(transactionBuilder_1.TransactionBuilder));
exports.TransferBuilder = TransferBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmZXJCdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvaW4vaGJhci90cmFuc2ZlckJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSw4Q0FBd0I7QUFDeEIsc0NBQTJDO0FBQzNDLGtFQUFnRTtBQUNoRSw2Q0FBcUc7QUFFckcsMkRBQXFFO0FBRXJFLGlDQUE0RTtBQUM1RSx3Q0FBOEM7QUFFOUM7SUFBcUMsbUNBQWtCO0lBS3JELHlCQUFZLFdBQWlDO1FBQTdDLFlBQ0Usa0JBQU0sV0FBVyxDQUFDLFNBR25CO1FBRkMsS0FBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLGNBQUssQ0FBQyw2QkFBNkIsRUFBRSxDQUFDO1FBQzdELEtBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxHQUFHLEtBQUksQ0FBQyxXQUFXLENBQUM7O0lBQ2pELENBQUM7SUFFRCxrQkFBa0I7SUFDRiw2Q0FBbUIsR0FBbkM7Ozs7O3dCQUNFLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO3dCQUN0RCxJQUFJLENBQUMsV0FBVyxDQUFDLGtCQUFrQixDQUFDLDBCQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7d0JBQ25ELHFCQUFNLGlCQUFNLG1CQUFtQixXQUFFLEVBQUE7NEJBQXhDLHNCQUFPLFNBQWlDLEVBQUM7Ozs7S0FDMUM7SUFFTywyQ0FBaUIsR0FBekI7UUFDRSxPQUFPO1lBQ0wsY0FBYyxFQUFFO2dCQUNkLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLE1BQU0sRUFBRSxjQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRTtn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TSxJQUFJLDhCQUFxQixDQUFDLGlDQUFpQyxDQUFDLENBQUM7U0FDcEU7UUFDRCxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssU0FBUyxFQUFFO1lBQzlCLE1BQU0sSUFBSSw4QkFBcUIsQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO1NBQ3hFO1FBQ0QsaUJBQU0sdUJBQXVCLFdBQUUsQ0FBQztJQUNsQyxDQUFDO0lBRUgsc0JBQUM7QUFBRCxDQUFDLEFBbEhELENBQXFDLHVDQUFrQixHQWtIdEQ7QUFsSFksMENBQWUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ29pbiBhcyBDb2luQ29uZmlnIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MvZGlzdC9zcmMvYmFzZSc7XHJcbmltcG9ydCBMb25nIGZyb20gJ2xvbmcnO1xyXG5pbXBvcnQgeyBBY2NvdW50SWQgfSBmcm9tICdAaGFzaGdyYXBoL3Nkayc7XHJcbmltcG9ydCB7IHByb3RvIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2VzL2hiYXIvcHJvdG9idWYvaGVkZXJhJztcclxuaW1wb3J0IHsgQnVpbGRUcmFuc2FjdGlvbkVycm9yLCBJbnZhbGlkUGFyYW1ldGVyVmFsdWVFcnJvciwgU2lnbmluZ0Vycm9yIH0gZnJvbSAnLi4vYmFzZUNvaW4vZXJyb3JzJztcclxuaW1wb3J0IHsgQmFzZUtleSB9IGZyb20gJy4uL2Jhc2VDb2luL2lmYWNlJztcclxuaW1wb3J0IHsgVHJhbnNhY3Rpb25CdWlsZGVyLCBERUZBVUxUX00gfSBmcm9tICcuL3RyYW5zYWN0aW9uQnVpbGRlcic7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi90cmFuc2FjdGlvbic7XHJcbmltcG9ydCB7IGlzVmFsaWRBZGRyZXNzLCBpc1ZhbGlkQW1vdW50LCBzdHJpbmdpZnlBY2NvdW50SWQgfSBmcm9tICcuL3V0aWxzJztcclxuaW1wb3J0IHsgVHJhbnNhY3Rpb25UeXBlIH0gZnJvbSAnLi4vYmFzZUNvaW4nO1xyXG5cclxuZXhwb3J0IGNsYXNzIFRyYW5zZmVyQnVpbGRlciBleHRlbmRzIFRyYW5zYWN0aW9uQnVpbGRlciB7XHJcbiAgcHJpdmF0ZSBfdHhCb2R5RGF0YTogcHJvdG8uQ3J5cHRvVHJhbnNmZXJUcmFuc2FjdGlvbkJvZHk7XHJcbiAgcHJpdmF0ZSBfdG9BZGRyZXNzOiBzdHJpbmc7XHJcbiAgcHJpdmF0ZSBfYW1vdW50OiBzdHJpbmc7XHJcblxyXG4gIGNvbnN0cnVjdG9yKF9jb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xyXG4gICAgc3VwZXIoX2NvaW5Db25maWcpO1xyXG4gICAgdGhpcy5fdHhCb2R5RGF0YSA9IG5ldyBwcm90by5DcnlwdG9UcmFuc2ZlclRyYW5zYWN0aW9uQm9keSgpO1xyXG4gICAgdGhpcy5fdHhCb2R5LmNyeXB0b1RyYW5zZmVyID0gdGhpcy5fdHhCb2R5RGF0YTtcclxuICB9XHJcblxyXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gIHByb3RlY3RlZCBhc3luYyBidWlsZEltcGxlbWVudGF0aW9uKCk6IFByb21pc2U8VHJhbnNhY3Rpb24+IHtcclxuICAgIHRoaXMuX3R4Qm9keURhdGEudHJhbnNmZXJzID0gdGhpcy5idWlsZFRyYW5zZmVyRGF0YSgpO1xyXG4gICAgdGhpcy50cmFuc2FjdGlvbi5zZXRUcmFuc2FjdGlvblR5cGUoVHJhbnNhY3Rpb25UeXBlLlNlbmQpO1xyXG4gICAgcmV0dXJuIGF3YWl0IHN1cGVyLmJ1aWxkSW1wbGVtZW50YXRpb24oKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYnVpbGRUcmFuc2ZlckRhdGEoKTogcHJvdG8uSVRyYW5zZmVyTGlzdCB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBhY2NvdW50QW1vdW50czogW1xyXG4gICAgICAgIHsgYWNjb3VudElEOiB0aGlzLmJ1aWxkQWNjb3VudERhdGEodGhpcy5fc291cmNlLmFkZHJlc3MpLCBhbW91bnQ6IExvbmcuZnJvbVN0cmluZyh0aGlzLl9hbW91bnQpLm5lZ2F0ZSgpIH0sIC8vIHNlbmRlclxyXG4gICAgICAgIHsgYWNjb3VudElEOiB0aGlzLmJ1aWxkQWNjb3VudERhdGEodGhpcy5fdG9BZGRyZXNzKSwgYW1vdW50OiBMb25nLmZyb21TdHJpbmcodGhpcy5fYW1vdW50KSB9LCAvLyByZWNpcGllbnRcclxuICAgICAgXSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGJ1aWxkQWNjb3VudERhdGEoYWRkcmVzczogc3RyaW5nKTogcHJvdG8uQWNjb3VudElEIHtcclxuICAgIGNvbnN0IGFjY291bnREYXRhID0gbmV3IEFjY291bnRJZChhZGRyZXNzKTtcclxuICAgIHJldHVybiBuZXcgcHJvdG8uQWNjb3VudElEKHtcclxuICAgICAgYWNjb3VudE51bTogYWNjb3VudERhdGEuYWNjb3VudCxcclxuICAgICAgcmVhbG1OdW06IGFjY291bnREYXRhLnJlYWxtLFxyXG4gICAgICBzaGFyZE51bTogYWNjb3VudERhdGEuc2hhcmQsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gIGluaXRCdWlsZGVyKHR4OiBUcmFuc2FjdGlvbik6IHZvaWQge1xyXG4gICAgc3VwZXIuaW5pdEJ1aWxkZXIodHgpO1xyXG4gICAgdGhpcy50cmFuc2FjdGlvbi5zZXRUcmFuc2FjdGlvblR5cGUoVHJhbnNhY3Rpb25UeXBlLlNlbmQpO1xyXG4gICAgY29uc3QgdHJhbnNmZXJEYXRhID0gdHgudHhCb2R5LmNyeXB0b1RyYW5zZmVyO1xyXG4gICAgaWYgKHRyYW5zZmVyRGF0YSAmJiB0cmFuc2ZlckRhdGEudHJhbnNmZXJzICYmIHRyYW5zZmVyRGF0YS50cmFuc2ZlcnMuYWNjb3VudEFtb3VudHMpIHtcclxuICAgICAgdGhpcy5pbml0VHJhbnNmZXJzKHRyYW5zZmVyRGF0YS50cmFuc2ZlcnMuYWNjb3VudEFtb3VudHMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSB0aGUgdHJhbnNmZXIgc3BlY2lmaWMgZGF0YSwgZ2V0dGluZyB0aGUgcmVjaXBpZW50IGFjY291bnRcclxuICAgKiByZXByZXNlbnRlZCBieSB0aGUgZWxlbWVudCB3aXRoIGEgcG9zaXRpdmUgYW1vdW50IG9uIHRoZSB0cmFuc2ZlciBlbGVtZW50LlxyXG4gICAqIFRoZSBuZWdhdGl2ZSBhbW91bnQgcmVwcmVzZW50cyB0aGUgc291cmNlIGFjY291bnQgc28gaXQncyBpZ25vcmVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtwcm90by5JQWNjb3VudEFtb3VudFtdfSB0cmFuc2ZlcnMgYXJyYXkgb2Ygb2JqZWN0cyB3aGljaCBjb250YWlucyBhY2NvdW50SUQgYW5kIHRyYW5zZmVycmVkIGFtb3VudFxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBpbml0VHJhbnNmZXJzKHRyYW5zZmVyczogcHJvdG8uSUFjY291bnRBbW91bnRbXSk6IHZvaWQge1xyXG4gICAgdHJhbnNmZXJzLmZvckVhY2godHJhbnNmZXJEYXRhID0+IHtcclxuICAgICAgY29uc3QgYW1vdW50ID0gTG9uZy5mcm9tVmFsdWUodHJhbnNmZXJEYXRhLmFtb3VudCEpO1xyXG4gICAgICBpZiAoYW1vdW50LmlzUG9zaXRpdmUoKSkge1xyXG4gICAgICAgIHRoaXMudG8oc3RyaW5naWZ5QWNjb3VudElkKHRyYW5zZmVyRGF0YS5hY2NvdW50SUQhKSk7XHJcbiAgICAgICAgdGhpcy5hbW91bnQoYW1vdW50LnRvU3RyaW5nKCkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gIHByb3RlY3RlZCBzaWduSW1wbGVtZW50YXRpb24oa2V5OiBCYXNlS2V5KTogVHJhbnNhY3Rpb24ge1xyXG4gICAgaWYgKHRoaXMuX211bHRpU2lnbmVyS2V5UGFpcnMubGVuZ3RoID49IERFRkFVTFRfTSkge1xyXG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdBIG1heGltdW0gb2YgJyArIERFRkFVTFRfTSArICcgY2FuIHNpZ24gdGhlIHRyYW5zYWN0aW9uLicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1cGVyLnNpZ25JbXBsZW1lbnRhdGlvbihrZXkpO1xyXG4gIH1cclxuXHJcbiAgLy9yZWdpb24gVHJhbnNmZXIgZmllbGRzXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzIHdoZXJlIHRoZSBmdW5kcyB3aWxsIGJlIHNlbnQsXHJcbiAgICogaXQgbWF5IHRha2UgdGhlIGZvcm1hdCBgJzxzaGFyZD4uPHJlYWxtPi48YWNjb3VudD4nYCBvciBgJzxhY2NvdW50PidgXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyB0aGUgYWRkcmVzcyB0byB0cmFuc2ZlciBmdW5kcyB0b1xyXG4gICAqIEByZXR1cm5zIHtUcmFuc2ZlckJ1aWxkZXJ9IHRoZSBidWlsZGVyIHdpdGggdGhlIG5ldyBwYXJhbWV0ZXIgc2V0XHJcbiAgICovXHJcbiAgdG8oYWRkcmVzczogc3RyaW5nKTogdGhpcyB7XHJcbiAgICBpZiAoIWlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpKSB7XHJcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyYW1ldGVyVmFsdWVFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl90b0FkZHJlc3MgPSBhZGRyZXNzO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIGFtb3VudCB0byBiZSB0cmFuc2ZlcnJlZFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFtb3VudCBhbW91bnQgdG8gdHJhbnNmZXIgaW4gdGlueUJhcnMgKHRoZXJlIGFyZSAxMDAsMDAwLDAwMCB0aW55QmFycyBpbiBvbmUgSGJhcilcclxuICAgKiBAcmV0dXJucyB7VHJhbnNmZXJCdWlsZGVyfSB0aGUgYnVpbGRlciB3aXRoIHRoZSBuZXcgcGFyYW1ldGVyIHNldFxyXG4gICAqL1xyXG4gIGFtb3VudChhbW91bnQ6IHN0cmluZyk6IHRoaXMge1xyXG4gICAgaWYgKCFpc1ZhbGlkQW1vdW50KGFtb3VudCkpIHtcclxuICAgICAgdGhyb3cgbmV3IEludmFsaWRQYXJhbWV0ZXJWYWx1ZUVycm9yKCdJbnZhbGlkIGFtb3VudCcpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fYW1vdW50ID0gYW1vdW50O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvL2VuZHJlZ2lvblxyXG5cclxuICAvL3JlZ2lvbiBWYWxpZGF0b3JzXHJcbiAgdmFsaWRhdGVNYW5kYXRvcnlGaWVsZHMoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fdG9BZGRyZXNzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbjogbWlzc2luZyB0bycpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2Ftb3VudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb246IG1pc3NpbmcgYW1vdW50Jyk7XHJcbiAgICB9XHJcbiAgICBzdXBlci52YWxpZGF0ZU1hbmRhdG9yeUZpZWxkcygpO1xyXG4gIH1cclxuICAvL2VuZHJlZ2lvblxyXG59XHJcbiJdfQ==