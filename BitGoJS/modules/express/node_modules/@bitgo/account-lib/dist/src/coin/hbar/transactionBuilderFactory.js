"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("../baseCoin/errors");
var baseCoin_1 = require("../baseCoin");
var walletInitializationBuilder_1 = require("./walletInitializationBuilder");
var transferBuilder_1 = require("./transferBuilder");
var transaction_1 = require("./transaction");
var utils_1 = require("./utils");
var TransactionBuilderFactory = /** @class */ (function (_super) {
    __extends(TransactionBuilderFactory, _super);
    function TransactionBuilderFactory(_coinConfig) {
        return _super.call(this, _coinConfig) || this;
    }
    /** @inheritdoc */
    TransactionBuilderFactory.prototype.getWalletInitializationBuilder = function (tx) {
        return this.initializeBuilder(tx, new walletInitializationBuilder_1.WalletInitializationBuilder(this._coinConfig));
    };
    /** @inheritDoc */
    TransactionBuilderFactory.prototype.getTransferBuilder = function (tx) {
        return this.initializeBuilder(tx, new transferBuilder_1.TransferBuilder(this._coinConfig));
    };
    /** @inheritDoc */
    TransactionBuilderFactory.prototype.from = function (raw) {
        this.validateRawTransaction(raw);
        var tx = this.parseTransaction(raw);
        switch (tx.txBody.data) {
            case 'cryptoTransfer':
                return this.getTransferBuilder(tx);
            case 'cryptoCreateAccount':
                return this.getWalletInitializationBuilder(tx);
            default:
                throw new errors_1.InvalidTransactionError('Invalid transaction ' + tx.txBody.data);
        }
    };
    /**
     * Initialize the builder with the given transaction
     *
     * @param {Transaction | undefined} tx - the transaction used to initialize the builder
     * @param {TransactionBuilder} builder - the builder to be initialized
     * @returns {TransactionBuilder} the builder initialized
     */
    TransactionBuilderFactory.prototype.initializeBuilder = function (tx, builder) {
        if (tx) {
            builder.initBuilder(tx);
        }
        return builder;
    };
    /**
     * Returns a transaction instance from the encoded value
     *
     * @param {Uint8Array | string} rawTransaction - encoded transaction
     * @returns {Transaction} the parsed transaction instance
     */
    TransactionBuilderFactory.prototype.parseTransaction = function (rawTransaction) {
        var tx = new transaction_1.Transaction(this._coinConfig);
        var buffer;
        if (typeof rawTransaction === 'string') {
            buffer = utils_1.toUint8Array(rawTransaction);
        }
        else {
            buffer = rawTransaction;
        }
        tx.bodyBytes(buffer);
        return tx;
    };
    /**
     * Check the raw transaction has a valid format in the blockchain context, throw otherwise.
     *
     * @param {any} rawTransaction - Transaction in any format
     */
    TransactionBuilderFactory.prototype.validateRawTransaction = function (rawTransaction) {
        if (!utils_1.isValidRawTransactionFormat(rawTransaction)) {
            throw new errors_1.ParseTransactionError('Invalid raw transaction');
        }
    };
    return TransactionBuilderFactory;
}(baseCoin_1.BaseTransactionBuilderFactory));
exports.TransactionBuilderFactory = TransactionBuilderFactory;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb2luL2hiYXIvdHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFDQSw2Q0FBb0Y7QUFDcEYsd0NBQTREO0FBQzVELDZFQUE0RTtBQUM1RSxxREFBb0Q7QUFFcEQsNkNBQTRDO0FBQzVDLGlDQUFvRTtBQUVwRTtJQUErQyw2Q0FBNkI7SUFDMUUsbUNBQVksV0FBaUM7ZUFDM0Msa0JBQU0sV0FBVyxDQUFDO0lBQ3BCLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsa0VBQThCLEdBQTlCLFVBQStCLEVBQWdCO1FBQzdDLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxJQUFJLHlEQUEyQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO0lBQ3ZGLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsc0RBQWtCLEdBQWxCLFVBQW1CLEVBQWdCO1FBQ2pDLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxJQUFJLGlDQUFlLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7SUFDM0UsQ0FBQztJQUVELGtCQUFrQjtJQUNsQix3Q0FBSSxHQUFKLFVBQUssR0FBd0I7UUFDM0IsSUFBSSxDQUFDLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2pDLElBQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN0QyxRQUFRLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFO1lBQ3RCLEtBQUssZ0JBQWdCO2dCQUNuQixPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNyQyxLQUFLLHFCQUFxQjtnQkFDeEIsT0FBTyxJQUFJLENBQUMsOEJBQThCLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDakQ7Z0JBQ0UsTUFBTSxJQUFJLGdDQUF1QixDQUFDLHNCQUFzQixHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDOUU7SUFDSCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0sscURBQWlCLEdBQXpCLFVBQXdELEVBQTJCLEVBQUUsT0FBVTtRQUM3RixJQUFJLEVBQUUsRUFBRTtZQUNOLE9BQU8sQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDekI7UUFDRCxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxvREFBZ0IsR0FBeEIsVUFBeUIsY0FBbUM7UUFDMUQsSUFBTSxFQUFFLEdBQUcsSUFBSSx5QkFBVyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUM3QyxJQUFJLE1BQU0sQ0FBQztRQUNYLElBQUksT0FBTyxjQUFjLEtBQUssUUFBUSxFQUFFO1lBQ3RDLE1BQU0sR0FBRyxvQkFBWSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1NBQ3ZDO2FBQU07WUFDTCxNQUFNLEdBQUcsY0FBYyxDQUFDO1NBQ3pCO1FBQ0QsRUFBRSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNyQixPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssMERBQXNCLEdBQTlCLFVBQStCLGNBQW1CO1FBQ2hELElBQUksQ0FBQyxtQ0FBMkIsQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUNoRCxNQUFNLElBQUksOEJBQXFCLENBQUMseUJBQXlCLENBQUMsQ0FBQztTQUM1RDtJQUNILENBQUM7SUFDSCxnQ0FBQztBQUFELENBQUMsQUF2RUQsQ0FBK0Msd0NBQTZCLEdBdUUzRTtBQXZFWSw4REFBeUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ29pbiBhcyBDb2luQ29uZmlnIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MvZGlzdC9zcmMvYmFzZSc7XG5pbXBvcnQgeyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvciwgUGFyc2VUcmFuc2FjdGlvbkVycm9yIH0gZnJvbSAnLi4vYmFzZUNvaW4vZXJyb3JzJztcbmltcG9ydCB7IEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5IH0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgV2FsbGV0SW5pdGlhbGl6YXRpb25CdWlsZGVyIH0gZnJvbSAnLi93YWxsZXRJbml0aWFsaXphdGlvbkJ1aWxkZXInO1xuaW1wb3J0IHsgVHJhbnNmZXJCdWlsZGVyIH0gZnJvbSAnLi90cmFuc2ZlckJ1aWxkZXInO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25CdWlsZGVyIH0gZnJvbSAnLi90cmFuc2FjdGlvbkJ1aWxkZXInO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IGlzVmFsaWRSYXdUcmFuc2FjdGlvbkZvcm1hdCwgdG9VaW50OEFycmF5IH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5IGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uQnVpbGRlckZhY3Rvcnkge1xuICBjb25zdHJ1Y3RvcihfY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihfY29pbkNvbmZpZyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgZ2V0V2FsbGV0SW5pdGlhbGl6YXRpb25CdWlsZGVyKHR4PzogVHJhbnNhY3Rpb24pOiBXYWxsZXRJbml0aWFsaXphdGlvbkJ1aWxkZXIge1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVCdWlsZGVyKHR4LCBuZXcgV2FsbGV0SW5pdGlhbGl6YXRpb25CdWlsZGVyKHRoaXMuX2NvaW5Db25maWcpKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBnZXRUcmFuc2ZlckJ1aWxkZXIodHg/OiBUcmFuc2FjdGlvbik6IFRyYW5zZmVyQnVpbGRlciB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZUJ1aWxkZXIodHgsIG5ldyBUcmFuc2ZlckJ1aWxkZXIodGhpcy5fY29pbkNvbmZpZykpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGZyb20ocmF3OiBVaW50OEFycmF5IHwgc3RyaW5nKTogVHJhbnNhY3Rpb25CdWlsZGVyIHtcbiAgICB0aGlzLnZhbGlkYXRlUmF3VHJhbnNhY3Rpb24ocmF3KTtcbiAgICBjb25zdCB0eCA9IHRoaXMucGFyc2VUcmFuc2FjdGlvbihyYXcpO1xuICAgIHN3aXRjaCAodHgudHhCb2R5LmRhdGEpIHtcbiAgICAgIGNhc2UgJ2NyeXB0b1RyYW5zZmVyJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNmZXJCdWlsZGVyKHR4KTtcbiAgICAgIGNhc2UgJ2NyeXB0b0NyZWF0ZUFjY291bnQnOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRXYWxsZXRJbml0aWFsaXphdGlvbkJ1aWxkZXIodHgpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uICcgKyB0eC50eEJvZHkuZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGJ1aWxkZXIgd2l0aCB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbiB8IHVuZGVmaW5lZH0gdHggLSB0aGUgdHJhbnNhY3Rpb24gdXNlZCB0byBpbml0aWFsaXplIHRoZSBidWlsZGVyXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25CdWlsZGVyfSBidWlsZGVyIC0gdGhlIGJ1aWxkZXIgdG8gYmUgaW5pdGlhbGl6ZWRcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uQnVpbGRlcn0gdGhlIGJ1aWxkZXIgaW5pdGlhbGl6ZWRcbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUJ1aWxkZXI8VCBleHRlbmRzIFRyYW5zYWN0aW9uQnVpbGRlcj4odHg6IFRyYW5zYWN0aW9uIHwgdW5kZWZpbmVkLCBidWlsZGVyOiBUKTogVCB7XG4gICAgaWYgKHR4KSB7XG4gICAgICBidWlsZGVyLmluaXRCdWlsZGVyKHR4KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkZXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHRyYW5zYWN0aW9uIGluc3RhbmNlIGZyb20gdGhlIGVuY29kZWQgdmFsdWVcbiAgICpcbiAgICogQHBhcmFtIHtVaW50OEFycmF5IHwgc3RyaW5nfSByYXdUcmFuc2FjdGlvbiAtIGVuY29kZWQgdHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufSB0aGUgcGFyc2VkIHRyYW5zYWN0aW9uIGluc3RhbmNlXG4gICAqL1xuICBwcml2YXRlIHBhcnNlVHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb246IFVpbnQ4QXJyYXkgfCBzdHJpbmcpOiBUcmFuc2FjdGlvbiB7XG4gICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb24odGhpcy5fY29pbkNvbmZpZyk7XG4gICAgbGV0IGJ1ZmZlcjtcbiAgICBpZiAodHlwZW9mIHJhd1RyYW5zYWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmZmVyID0gdG9VaW50OEFycmF5KHJhd1RyYW5zYWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyID0gcmF3VHJhbnNhY3Rpb247XG4gICAgfVxuICAgIHR4LmJvZHlCeXRlcyhidWZmZXIpO1xuICAgIHJldHVybiB0eDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgcmF3IHRyYW5zYWN0aW9uIGhhcyBhIHZhbGlkIGZvcm1hdCBpbiB0aGUgYmxvY2tjaGFpbiBjb250ZXh0LCB0aHJvdyBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSByYXdUcmFuc2FjdGlvbiAtIFRyYW5zYWN0aW9uIGluIGFueSBmb3JtYXRcbiAgICovXG4gIHByaXZhdGUgdmFsaWRhdGVSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbjogYW55KSB7XG4gICAgaWYgKCFpc1ZhbGlkUmF3VHJhbnNhY3Rpb25Gb3JtYXQocmF3VHJhbnNhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHJhdyB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgfVxufVxuIl19