"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var utxo_lib_1 = require("@bitgo/utxo-lib");
var ethereumjs_util_1 = require("ethereumjs-util");
var iface_1 = require("../baseCoin/iface");
var secp256k1ExtendedKeyPair_1 = require("../baseCoin/secp256k1ExtendedKeyPair");
/**
 * Ethereum keys and address management.
 */
var KeyPair = /** @class */ (function (_super) {
    __extends(KeyPair, _super);
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param { KeyPairOptions } source Either a master seed, a private key (extended or raw), or a public key
     *     (extended, compressed, or uncompressed)
     */
    function KeyPair(source) {
        var _this = _super.call(this, source) || this;
        if (source) {
            if (iface_1.isPrivateKey(source)) {
                _super.prototype.recordKeysFromPrivateKey.call(_this, source.prv);
            }
            else if (iface_1.isPublicKey(source)) {
                _super.prototype.recordKeysFromPublicKey.call(_this, source.pub);
            }
            else {
                throw new Error('Invalid key pair options');
            }
        }
        else {
            throw new Error('Invalid key pair options');
        }
        return _this;
    }
    /**
     * Ethereum default keys format is raw private and uncompressed public key
     *
     * @returns { DefaultKeys } The keys in the protocol default key format
     */
    KeyPair.prototype.getKeys = function () {
        if (this.hdNode) {
            var _a = this.getExtendedKeys(), xpub = _a.xpub, xprv = _a.xprv;
            return {
                pub: utxo_lib_1.HDNode.fromBase58(xpub)
                    .getPublicKeyBuffer()
                    .toString('hex')
                    .toUpperCase(),
                prv: xprv
                    ? utxo_lib_1.HDNode.fromBase58(xprv)
                        .keyPair.getPrivateKeyBuffer()
                        .toString('hex')
                        .toUpperCase()
                    : undefined,
            };
        }
        else {
            return {
                pub: this.keyPair.Q.getEncoded(false)
                    .toString('hex')
                    .toUpperCase(),
                prv: this.keyPair.d
                    ? this.keyPair.d
                        .toBuffer(32)
                        .toString('hex')
                        .toUpperCase()
                    : undefined,
            };
        }
    };
    /**
     * Get an Ethereum public address
     *
     * @returns {string} The address derived from the public key
     */
    KeyPair.prototype.getAddress = function () {
        var publicKey = Buffer.from(this.getKeys().pub, 'hex'); // first two characters identify a public key
        return ethereumjs_util_1.addHexPrefix(ethereumjs_util_1.pubToAddress(publicKey, true).toString('hex'));
    };
    return KeyPair;
}(secp256k1ExtendedKeyPair_1.Secp256k1ExtendedKeyPair));
exports.KeyPair = KeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb2luL2V0aC9rZXlQYWlyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDRDQUF5QztBQUN6QyxtREFBNkQ7QUFDN0QsMkNBQTJGO0FBQzNGLGlGQUFnRjtBQUVoRjs7R0FFRztBQUNIO0lBQTZCLDJCQUF3QjtJQUNuRDs7Ozs7T0FLRztJQUNILGlCQUFZLE1BQXVCO1FBQW5DLFlBQ0Usa0JBQU0sTUFBTSxDQUFDLFNBWWQ7UUFYQyxJQUFJLE1BQU0sRUFBRTtZQUNWLElBQUksb0JBQVksQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDeEIsaUJBQU0sd0JBQXdCLGFBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQzVDO2lCQUFNLElBQUksbUJBQVcsQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDOUIsaUJBQU0sdUJBQXVCLGFBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQzNDO2lCQUFNO2dCQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQzthQUM3QztTQUNGO2FBQU07WUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUM7U0FDN0M7O0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCx5QkFBTyxHQUFQO1FBQ0UsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1QsSUFBQSwyQkFBdUMsRUFBckMsY0FBSSxFQUFFLGNBQStCLENBQUM7WUFDOUMsT0FBTztnQkFDTCxHQUFHLEVBQUUsaUJBQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDO3FCQUN6QixrQkFBa0IsRUFBRTtxQkFDcEIsUUFBUSxDQUFDLEtBQUssQ0FBQztxQkFDZixXQUFXLEVBQUU7Z0JBQ2hCLEdBQUcsRUFBRSxJQUFJO29CQUNQLENBQUMsQ0FBQyxpQkFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7eUJBQ3BCLE9BQU8sQ0FBQyxtQkFBbUIsRUFBRTt5QkFDN0IsUUFBUSxDQUFDLEtBQUssQ0FBQzt5QkFDZixXQUFXLEVBQUU7b0JBQ2xCLENBQUMsQ0FBQyxTQUFTO2FBQ2QsQ0FBQztTQUNIO2FBQU07WUFDTCxPQUFPO2dCQUNMLEdBQUcsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDO3FCQUNsQyxRQUFRLENBQUMsS0FBSyxDQUFDO3FCQUNmLFdBQVcsRUFBRTtnQkFDaEIsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFDakIsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQzt5QkFDWCxRQUFRLENBQUMsRUFBRSxDQUFDO3lCQUNaLFFBQVEsQ0FBQyxLQUFLLENBQUM7eUJBQ2YsV0FBVyxFQUFFO29CQUNsQixDQUFDLENBQUMsU0FBUzthQUNkLENBQUM7U0FDSDtJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsNEJBQVUsR0FBVjtRQUNFLElBQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLDZDQUE2QztRQUN2RyxPQUFPLDhCQUFZLENBQUMsOEJBQVksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDckUsQ0FBQztJQUNILGNBQUM7QUFBRCxDQUFDLEFBbEVELENBQTZCLG1EQUF3QixHQWtFcEQ7QUFsRVksMEJBQU8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIRE5vZGUgfSBmcm9tICdAYml0Z28vdXR4by1saWInO1xyXG5pbXBvcnQgeyBhZGRIZXhQcmVmaXgsIHB1YlRvQWRkcmVzcyB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XHJcbmltcG9ydCB7IERlZmF1bHRLZXlzLCBpc1ByaXZhdGVLZXksIGlzUHVibGljS2V5LCBLZXlQYWlyT3B0aW9ucyB9IGZyb20gJy4uL2Jhc2VDb2luL2lmYWNlJztcclxuaW1wb3J0IHsgU2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyIH0gZnJvbSAnLi4vYmFzZUNvaW4vc2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyJztcclxuXHJcbi8qKlxyXG4gKiBFdGhlcmV1bSBrZXlzIGFuZCBhZGRyZXNzIG1hbmFnZW1lbnQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgS2V5UGFpciBleHRlbmRzIFNlY3AyNTZrMUV4dGVuZGVkS2V5UGFpciB7XHJcbiAgLyoqXHJcbiAgICogUHVibGljIGNvbnN0cnVjdG9yLiBCeSBkZWZhdWx0LCBjcmVhdGVzIGEga2V5IHBhaXIgd2l0aCBhIHJhbmRvbSBtYXN0ZXIgc2VlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7IEtleVBhaXJPcHRpb25zIH0gc291cmNlIEVpdGhlciBhIG1hc3RlciBzZWVkLCBhIHByaXZhdGUga2V5IChleHRlbmRlZCBvciByYXcpLCBvciBhIHB1YmxpYyBrZXlcclxuICAgKiAgICAgKGV4dGVuZGVkLCBjb21wcmVzc2VkLCBvciB1bmNvbXByZXNzZWQpXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Ioc291cmNlPzogS2V5UGFpck9wdGlvbnMpIHtcclxuICAgIHN1cGVyKHNvdXJjZSk7XHJcbiAgICBpZiAoc291cmNlKSB7XHJcbiAgICAgIGlmIChpc1ByaXZhdGVLZXkoc291cmNlKSkge1xyXG4gICAgICAgIHN1cGVyLnJlY29yZEtleXNGcm9tUHJpdmF0ZUtleShzb3VyY2UucHJ2KTtcclxuICAgICAgfSBlbHNlIGlmIChpc1B1YmxpY0tleShzb3VyY2UpKSB7XHJcbiAgICAgICAgc3VwZXIucmVjb3JkS2V5c0Zyb21QdWJsaWNLZXkoc291cmNlLnB1Yik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSBwYWlyIG9wdGlvbnMnKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSBwYWlyIG9wdGlvbnMnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV0aGVyZXVtIGRlZmF1bHQga2V5cyBmb3JtYXQgaXMgcmF3IHByaXZhdGUgYW5kIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5XHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7IERlZmF1bHRLZXlzIH0gVGhlIGtleXMgaW4gdGhlIHByb3RvY29sIGRlZmF1bHQga2V5IGZvcm1hdFxyXG4gICAqL1xyXG4gIGdldEtleXMoKTogRGVmYXVsdEtleXMge1xyXG4gICAgaWYgKHRoaXMuaGROb2RlKSB7XHJcbiAgICAgIGNvbnN0IHsgeHB1YiwgeHBydiB9ID0gdGhpcy5nZXRFeHRlbmRlZEtleXMoKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBwdWI6IEhETm9kZS5mcm9tQmFzZTU4KHhwdWIpXHJcbiAgICAgICAgICAuZ2V0UHVibGljS2V5QnVmZmVyKClcclxuICAgICAgICAgIC50b1N0cmluZygnaGV4JylcclxuICAgICAgICAgIC50b1VwcGVyQ2FzZSgpLFxyXG4gICAgICAgIHBydjogeHBydlxyXG4gICAgICAgICAgPyBIRE5vZGUuZnJvbUJhc2U1OCh4cHJ2KVxyXG4gICAgICAgICAgICAgIC5rZXlQYWlyLmdldFByaXZhdGVLZXlCdWZmZXIoKVxyXG4gICAgICAgICAgICAgIC50b1N0cmluZygnaGV4JylcclxuICAgICAgICAgICAgICAudG9VcHBlckNhc2UoKVxyXG4gICAgICAgICAgOiB1bmRlZmluZWQsXHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHB1YjogdGhpcy5rZXlQYWlyLlEuZ2V0RW5jb2RlZChmYWxzZSlcclxuICAgICAgICAgIC50b1N0cmluZygnaGV4JylcclxuICAgICAgICAgIC50b1VwcGVyQ2FzZSgpLFxyXG4gICAgICAgIHBydjogdGhpcy5rZXlQYWlyLmRcclxuICAgICAgICAgID8gdGhpcy5rZXlQYWlyLmRcclxuICAgICAgICAgICAgICAudG9CdWZmZXIoMzIpXHJcbiAgICAgICAgICAgICAgLnRvU3RyaW5nKCdoZXgnKVxyXG4gICAgICAgICAgICAgIC50b1VwcGVyQ2FzZSgpXHJcbiAgICAgICAgICA6IHVuZGVmaW5lZCxcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbiBFdGhlcmV1bSBwdWJsaWMgYWRkcmVzc1xyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGFkZHJlc3MgZGVyaXZlZCBmcm9tIHRoZSBwdWJsaWMga2V5XHJcbiAgICovXHJcbiAgZ2V0QWRkcmVzcygpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgcHVibGljS2V5ID0gQnVmZmVyLmZyb20odGhpcy5nZXRLZXlzKCkucHViLCAnaGV4Jyk7IC8vIGZpcnN0IHR3byBjaGFyYWN0ZXJzIGlkZW50aWZ5IGEgcHVibGljIGtleVxyXG4gICAgcmV0dXJuIGFkZEhleFByZWZpeChwdWJUb0FkZHJlc3MocHVibGljS2V5LCB0cnVlKS50b1N0cmluZygnaGV4JykpO1xyXG4gIH1cclxufVxyXG4iXX0=