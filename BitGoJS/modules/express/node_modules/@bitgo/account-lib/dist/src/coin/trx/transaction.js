"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_1 = require("crypto");
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var baseCoin_1 = require("../baseCoin");
var tron_1 = require("../../../resources/trx/protobuf/tron");
var errors_1 = require("../baseCoin/errors");
var baseCoin_2 = require("../baseCoin/");
var enum_1 = require("./enum");
var utils_1 = require("./utils");
/**
 * Tron transaction model.
 */
var Transaction = /** @class */ (function (_super) {
    __extends(Transaction, _super);
    /**
     * Public constructor.
     *
     * @param coinConfig
     * @param rawTransaction
     */
    function Transaction(coinConfig, rawTransaction) {
        var _this = _super.call(this, coinConfig) || this;
        if (rawTransaction) {
            if (!rawTransaction.txID) {
                throw new errors_1.ParseTransactionError('Transaction has no id');
            }
            _this._id = rawTransaction.txID;
            _this._transaction = rawTransaction;
            _this._decodedRawDataHex = utils_1.decodeTransaction(rawTransaction.raw_data_hex);
            // Destination depends on the contract type
            _this.recordRawDataFields(_this._decodedRawDataHex);
        }
        return _this;
    }
    /**
     * Parse the transaction raw data and record the most important fields.
     *
     * @param rawData Object from a tron transaction
     */
    Transaction.prototype.recordRawDataFields = function (rawData) {
        // Contract-agnostic fields
        this._validFrom = rawData.timestamp;
        this._validTo = rawData.expiration;
        var output, input;
        // Contract-specific fields
        switch (rawData.contractType) {
            case enum_1.ContractType.Transfer:
                this._type = baseCoin_2.TransactionType.Send;
                var value = new bignumber_js_1.default(rawData.contract[0].parameter.value.amount).toFixed(0);
                output = {
                    address: rawData.contract[0].parameter.value.to_address,
                    value: value,
                };
                input = {
                    address: rawData.contract[0].parameter.value.owner_address,
                    value: value,
                };
                break;
            case enum_1.ContractType.AccountPermissionUpdate:
                this._type = baseCoin_2.TransactionType.WalletInitialization;
                output = {
                    address: rawData.contract.owner_address,
                    value: '0',
                };
                input = {
                    address: rawData.contract.owner_address,
                    value: '0',
                };
                break;
            default:
                throw new errors_1.ParseTransactionError('Unsupported contract type');
        }
        this._inputs = [input];
        this._outputs = [output];
    };
    /**
     * Recalculate and update the transaction id. This should be done after changing any transaction
     * field since the the id is a hash of the transaction body.
     */
    Transaction.prototype.updateId = function () {
        if (!this._transaction) {
            throw new errors_1.ParseTransactionError('Empty transaction');
        }
        var hexBuffer = Buffer.from(this._transaction.raw_data_hex, 'hex');
        var newTxid = crypto_1.createHash('sha256')
            .update(hexBuffer)
            .digest('hex');
        this._transaction.txID = newTxid;
        this._id = newTxid;
    };
    /**
     * Extend the expiration date by the given number of milliseconds.
     *
     * @param extensionMs The number of milliseconds to extend the expiration by
     */
    Transaction.prototype.extendExpiration = function (extensionMs) {
        if (extensionMs < 0) {
            throw new errors_1.ExtendTransactionError('Invalid extension range. Must be positive a integer');
        }
        if (!this._transaction) {
            throw new errors_1.ExtendTransactionError('Empty transaction');
        }
        if (this._transaction.signature && this._transaction.signature.length > 0) {
            throw new errors_1.ExtendTransactionError('Cannot extend a signed transaction');
        }
        var rawDataHex = this._transaction.raw_data_hex;
        var bytes = Buffer.from(rawDataHex, 'hex');
        var raw;
        try {
            raw = tron_1.protocol.Transaction.raw.decode(bytes);
            var newExpiration = new bignumber_js_1.default(raw.expiration).plus(extensionMs).toNumber();
            raw.expiration = newExpiration;
            var newRawDataHex = Buffer.from(tron_1.protocol.Transaction.raw.encode(raw).finish()).toString('hex');
            // Set the internal variables to account for the new expiration date
            this._transaction.raw_data_hex = newRawDataHex;
            this._transaction.raw_data.expiration = newExpiration;
            this._decodedRawDataHex = utils_1.decodeTransaction(newRawDataHex);
            this.recordRawDataFields(this._decodedRawDataHex);
            this.updateId();
        }
        catch (e) {
            throw new errors_1.ExtendTransactionError('There was an error decoding the initial raw_data_hex from the serialized tx.');
        }
    };
    Object.defineProperty(Transaction.prototype, "signature", {
        /**
         * Get the signatures associated with this transaction.
         */
        get: function () {
            if (!this._transaction) {
                throw new errors_1.ParseTransactionError('Empty transaction');
            }
            if (this._transaction.signature) {
                return this._transaction.signature;
            }
            return [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "validFrom", {
        /**
         * Get the time in milliseconds this transaction becomes valid and can be broadcasted to the
         * network.
         */
        get: function () {
            return this._validFrom;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "validTo", {
        /**
         * Get the expiration time in milliseconds.
         */
        get: function () {
            return this._validTo;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    Transaction.prototype.canSign = function (key) {
        // Tron transaction do not contain the owners account address so it is not possible to check the
        // private key with any but the account main address. This is not enough to fail this check, so
        // it is a no-op.
        return true;
    };
    /** @inheritdoc */
    Transaction.prototype.toJson = function () {
        if (!this._transaction) {
            throw new errors_1.ParseTransactionError('Empty transaction');
        }
        return this._transaction;
    };
    /** @inheritdoc */
    Transaction.prototype.toBroadcastFormat = function () {
        return JSON.stringify(this.toJson());
    };
    return Transaction;
}(baseCoin_1.BaseTransaction));
exports.Transaction = Transaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi90cngvdHJhbnNhY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUNBQW9DO0FBRXBDLDhEQUFxQztBQUNyQyx3Q0FBOEM7QUFDOUMsNkRBQWdFO0FBQ2hFLDZDQUFtRjtBQUNuRix5Q0FBK0M7QUFFL0MsK0JBQXNDO0FBQ3RDLGlDQUE0QztBQUc1Qzs7R0FFRztBQUNIO0lBQWlDLCtCQUFlO0lBUTlDOzs7OztPQUtHO0lBQ0gscUJBQVksVUFBZ0MsRUFBRSxjQUFtQztRQUFqRixZQUNFLGtCQUFNLFVBQVUsQ0FBQyxTQVlsQjtRQVhDLElBQUksY0FBYyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFO2dCQUN4QixNQUFNLElBQUksOEJBQXFCLENBQUMsdUJBQXVCLENBQUMsQ0FBQzthQUMxRDtZQUNELEtBQUksQ0FBQyxHQUFHLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQztZQUMvQixLQUFJLENBQUMsWUFBWSxHQUFHLGNBQWMsQ0FBQztZQUNuQyxLQUFJLENBQUMsa0JBQWtCLEdBQUcseUJBQWlCLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBRXpFLDJDQUEyQztZQUMzQyxLQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7U0FDbkQ7O0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyx5Q0FBbUIsR0FBM0IsVUFBNEIsT0FBZ0I7UUFDMUMsMkJBQTJCO1FBQzNCLElBQUksQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQztRQUNwQyxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUM7UUFFbkMsSUFBSSxNQUFNLEVBQUUsS0FBSyxDQUFDO1FBQ2xCLDJCQUEyQjtRQUMzQixRQUFRLE9BQU8sQ0FBQyxZQUFZLEVBQUU7WUFDNUIsS0FBSyxtQkFBWSxDQUFDLFFBQVE7Z0JBQ3hCLElBQUksQ0FBQyxLQUFLLEdBQUcsMEJBQWUsQ0FBQyxJQUFJLENBQUM7Z0JBQ2xDLElBQU0sS0FBSyxHQUFHLElBQUksc0JBQVMsQ0FBRSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBc0IsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDekcsTUFBTSxHQUFHO29CQUNQLE9BQU8sRUFBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBc0IsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLFVBQVU7b0JBQzdFLEtBQUssT0FBQTtpQkFDTixDQUFDO2dCQUNGLEtBQUssR0FBRztvQkFDTixPQUFPLEVBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQXNCLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxhQUFhO29CQUNoRixLQUFLLE9BQUE7aUJBQ04sQ0FBQztnQkFDRixNQUFNO1lBQ1IsS0FBSyxtQkFBWSxDQUFDLHVCQUF1QjtnQkFDdkMsSUFBSSxDQUFDLEtBQUssR0FBRywwQkFBZSxDQUFDLG9CQUFvQixDQUFDO2dCQUNsRCxNQUFNLEdBQUc7b0JBQ1AsT0FBTyxFQUFHLE9BQU8sQ0FBQyxRQUFnQixDQUFDLGFBQWE7b0JBQ2hELEtBQUssRUFBRSxHQUFHO2lCQUNYLENBQUM7Z0JBQ0YsS0FBSyxHQUFHO29CQUNOLE9BQU8sRUFBRyxPQUFPLENBQUMsUUFBZ0IsQ0FBQyxhQUFhO29CQUNoRCxLQUFLLEVBQUUsR0FBRztpQkFDWCxDQUFDO2dCQUNGLE1BQU07WUFDUjtnQkFDRSxNQUFNLElBQUksOEJBQXFCLENBQUMsMkJBQTJCLENBQUMsQ0FBQztTQUNoRTtRQUNELElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7T0FHRztJQUNLLDhCQUFRLEdBQWhCO1FBQ0UsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDdEIsTUFBTSxJQUFJLDhCQUFxQixDQUFDLG1CQUFtQixDQUFDLENBQUM7U0FDdEQ7UUFDRCxJQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3JFLElBQU0sT0FBTyxHQUFHLG1CQUFVLENBQUMsUUFBUSxDQUFDO2FBQ2pDLE1BQU0sQ0FBQyxTQUFTLENBQUM7YUFDakIsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2pCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQztRQUNqQyxJQUFJLENBQUMsR0FBRyxHQUFHLE9BQU8sQ0FBQztJQUNyQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILHNDQUFnQixHQUFoQixVQUFpQixXQUFtQjtRQUNsQyxJQUFJLFdBQVcsR0FBRyxDQUFDLEVBQUU7WUFDbkIsTUFBTSxJQUFJLCtCQUFzQixDQUFDLHFEQUFxRCxDQUFDLENBQUM7U0FDekY7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUN0QixNQUFNLElBQUksK0JBQXNCLENBQUMsbUJBQW1CLENBQUMsQ0FBQztTQUN2RDtRQUVELElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUN6RSxNQUFNLElBQUksK0JBQXNCLENBQUMsb0NBQW9DLENBQUMsQ0FBQztTQUN4RTtRQUVELElBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDO1FBQ2xELElBQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQzdDLElBQUksR0FBRyxDQUFDO1FBQ1IsSUFBSTtZQUNGLEdBQUcsR0FBRyxlQUFRLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDN0MsSUFBTSxhQUFhLEdBQUcsSUFBSSxzQkFBUyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDakYsR0FBRyxDQUFDLFVBQVUsR0FBRyxhQUFhLENBQUM7WUFDL0IsSUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFRLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDakcsb0VBQW9FO1lBQ3BFLElBQUksQ0FBQyxZQUFZLENBQUMsWUFBWSxHQUFHLGFBQWEsQ0FBQztZQUMvQyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxVQUFVLEdBQUcsYUFBYSxDQUFDO1lBQ3RELElBQUksQ0FBQyxrQkFBa0IsR0FBRyx5QkFBaUIsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUMzRCxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7WUFDbEQsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQ2pCO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixNQUFNLElBQUksK0JBQXNCLENBQUMsOEVBQThFLENBQUMsQ0FBQztTQUNsSDtJQUNILENBQUM7SUFLRCxzQkFBSSxrQ0FBUztRQUhiOztXQUVHO2FBQ0g7WUFDRSxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtnQkFDdEIsTUFBTSxJQUFJLDhCQUFxQixDQUFDLG1CQUFtQixDQUFDLENBQUM7YUFDdEQ7WUFDRCxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFO2dCQUMvQixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDO2FBQ3BDO1lBQ0QsT0FBTyxFQUFFLENBQUM7UUFDWixDQUFDOzs7T0FBQTtJQU1ELHNCQUFJLGtDQUFTO1FBSmI7OztXQUdHO2FBQ0g7WUFDRSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7UUFDekIsQ0FBQzs7O09BQUE7SUFLRCxzQkFBSSxnQ0FBTztRQUhYOztXQUVHO2FBQ0g7WUFDRSxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDdkIsQ0FBQzs7O09BQUE7SUFFRCxrQkFBa0I7SUFDbEIsNkJBQU8sR0FBUCxVQUFRLEdBQVk7UUFDbEIsZ0dBQWdHO1FBQ2hHLCtGQUErRjtRQUMvRixpQkFBaUI7UUFDakIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLDRCQUFNLEdBQU47UUFDRSxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUN0QixNQUFNLElBQUksOEJBQXFCLENBQUMsbUJBQW1CLENBQUMsQ0FBQztTQUN0RDtRQUNELE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztJQUMzQixDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLHVDQUFpQixHQUFqQjtRQUNFLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBQ0gsa0JBQUM7QUFBRCxDQUFDLEFBN0tELENBQWlDLDBCQUFlLEdBNksvQztBQTdLWSxrQ0FBVyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUhhc2ggfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IEJhc2VUcmFuc2FjdGlvbiB9IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IHByb3RvY29sIH0gZnJvbSAnLi4vLi4vLi4vcmVzb3VyY2VzL3RyeC9wcm90b2J1Zi90cm9uJztcbmltcG9ydCB7IFBhcnNlVHJhbnNhY3Rpb25FcnJvciwgRXh0ZW5kVHJhbnNhY3Rpb25FcnJvciB9IGZyb20gJy4uL2Jhc2VDb2luL2Vycm9ycyc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblR5cGUgfSBmcm9tICcuLi9iYXNlQ29pbi8nO1xuaW1wb3J0IHsgQmFzZUtleSB9IGZyb20gJy4uL2Jhc2VDb2luL2lmYWNlJztcbmltcG9ydCB7IENvbnRyYWN0VHlwZSB9IGZyb20gJy4vZW51bSc7XG5pbXBvcnQgeyBkZWNvZGVUcmFuc2FjdGlvbiB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgUmF3RGF0YSwgVHJhbnNhY3Rpb25SZWNlaXB0LCBUcmFuc2ZlckNvbnRyYWN0IH0gZnJvbSAnLi9pZmFjZSc7XG5cbi8qKlxuICogVHJvbiB0cmFuc2FjdGlvbiBtb2RlbC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uIHtcbiAgLy8gVHJvbiBzcGVjaWZpYyBmaWVsZHNcbiAgcHJvdGVjdGVkIF92YWxpZEZyb206IG51bWJlcjtcbiAgcHJvdGVjdGVkIF92YWxpZFRvOiBudW1iZXI7XG5cbiAgcHJpdmF0ZSBfZGVjb2RlZFJhd0RhdGFIZXg6IFJhd0RhdGE7XG4gIHByaXZhdGUgX3RyYW5zYWN0aW9uPzogVHJhbnNhY3Rpb25SZWNlaXB0O1xuXG4gIC8qKlxuICAgKiBQdWJsaWMgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBjb2luQ29uZmlnXG4gICAqIEBwYXJhbSByYXdUcmFuc2FjdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IoY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4sIHJhd1RyYW5zYWN0aW9uPzogVHJhbnNhY3Rpb25SZWNlaXB0KSB7XG4gICAgc3VwZXIoY29pbkNvbmZpZyk7XG4gICAgaWYgKHJhd1RyYW5zYWN0aW9uKSB7XG4gICAgICBpZiAoIXJhd1RyYW5zYWN0aW9uLnR4SUQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gaGFzIG5vIGlkJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pZCA9IHJhd1RyYW5zYWN0aW9uLnR4SUQ7XG4gICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHJhd1RyYW5zYWN0aW9uO1xuICAgICAgdGhpcy5fZGVjb2RlZFJhd0RhdGFIZXggPSBkZWNvZGVUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbi5yYXdfZGF0YV9oZXgpO1xuXG4gICAgICAvLyBEZXN0aW5hdGlvbiBkZXBlbmRzIG9uIHRoZSBjb250cmFjdCB0eXBlXG4gICAgICB0aGlzLnJlY29yZFJhd0RhdGFGaWVsZHModGhpcy5fZGVjb2RlZFJhd0RhdGFIZXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgdHJhbnNhY3Rpb24gcmF3IGRhdGEgYW5kIHJlY29yZCB0aGUgbW9zdCBpbXBvcnRhbnQgZmllbGRzLlxuICAgKlxuICAgKiBAcGFyYW0gcmF3RGF0YSBPYmplY3QgZnJvbSBhIHRyb24gdHJhbnNhY3Rpb25cbiAgICovXG4gIHByaXZhdGUgcmVjb3JkUmF3RGF0YUZpZWxkcyhyYXdEYXRhOiBSYXdEYXRhKSB7XG4gICAgLy8gQ29udHJhY3QtYWdub3N0aWMgZmllbGRzXG4gICAgdGhpcy5fdmFsaWRGcm9tID0gcmF3RGF0YS50aW1lc3RhbXA7XG4gICAgdGhpcy5fdmFsaWRUbyA9IHJhd0RhdGEuZXhwaXJhdGlvbjtcblxuICAgIGxldCBvdXRwdXQsIGlucHV0O1xuICAgIC8vIENvbnRyYWN0LXNwZWNpZmljIGZpZWxkc1xuICAgIHN3aXRjaCAocmF3RGF0YS5jb250cmFjdFR5cGUpIHtcbiAgICAgIGNhc2UgQ29udHJhY3RUeXBlLlRyYW5zZmVyOlxuICAgICAgICB0aGlzLl90eXBlID0gVHJhbnNhY3Rpb25UeXBlLlNlbmQ7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IEJpZ051bWJlcigocmF3RGF0YS5jb250cmFjdFswXSBhcyBUcmFuc2ZlckNvbnRyYWN0KS5wYXJhbWV0ZXIudmFsdWUuYW1vdW50KS50b0ZpeGVkKDApO1xuICAgICAgICBvdXRwdXQgPSB7XG4gICAgICAgICAgYWRkcmVzczogKHJhd0RhdGEuY29udHJhY3RbMF0gYXMgVHJhbnNmZXJDb250cmFjdCkucGFyYW1ldGVyLnZhbHVlLnRvX2FkZHJlc3MsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgIH07XG4gICAgICAgIGlucHV0ID0ge1xuICAgICAgICAgIGFkZHJlc3M6IChyYXdEYXRhLmNvbnRyYWN0WzBdIGFzIFRyYW5zZmVyQ29udHJhY3QpLnBhcmFtZXRlci52YWx1ZS5vd25lcl9hZGRyZXNzLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29udHJhY3RUeXBlLkFjY291bnRQZXJtaXNzaW9uVXBkYXRlOlxuICAgICAgICB0aGlzLl90eXBlID0gVHJhbnNhY3Rpb25UeXBlLldhbGxldEluaXRpYWxpemF0aW9uO1xuICAgICAgICBvdXRwdXQgPSB7XG4gICAgICAgICAgYWRkcmVzczogKHJhd0RhdGEuY29udHJhY3QgYXMgYW55KS5vd25lcl9hZGRyZXNzLFxuICAgICAgICAgIHZhbHVlOiAnMCcsXG4gICAgICAgIH07XG4gICAgICAgIGlucHV0ID0ge1xuICAgICAgICAgIGFkZHJlc3M6IChyYXdEYXRhLmNvbnRyYWN0IGFzIGFueSkub3duZXJfYWRkcmVzcyxcbiAgICAgICAgICB2YWx1ZTogJzAnLFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBQYXJzZVRyYW5zYWN0aW9uRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbnRyYWN0IHR5cGUnKTtcbiAgICB9XG4gICAgdGhpcy5faW5wdXRzID0gW2lucHV0XTtcbiAgICB0aGlzLl9vdXRwdXRzID0gW291dHB1dF07XG4gIH1cblxuICAvKipcbiAgICogUmVjYWxjdWxhdGUgYW5kIHVwZGF0ZSB0aGUgdHJhbnNhY3Rpb24gaWQuIFRoaXMgc2hvdWxkIGJlIGRvbmUgYWZ0ZXIgY2hhbmdpbmcgYW55IHRyYW5zYWN0aW9uXG4gICAqIGZpZWxkIHNpbmNlIHRoZSB0aGUgaWQgaXMgYSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBib2R5LlxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVJZCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX3RyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VUcmFuc2FjdGlvbkVycm9yKCdFbXB0eSB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBoZXhCdWZmZXIgPSBCdWZmZXIuZnJvbSh0aGlzLl90cmFuc2FjdGlvbi5yYXdfZGF0YV9oZXgsICdoZXgnKTtcbiAgICBjb25zdCBuZXdUeGlkID0gY3JlYXRlSGFzaCgnc2hhMjU2JylcbiAgICAgIC51cGRhdGUoaGV4QnVmZmVyKVxuICAgICAgLmRpZ2VzdCgnaGV4Jyk7XG4gICAgdGhpcy5fdHJhbnNhY3Rpb24udHhJRCA9IG5ld1R4aWQ7XG4gICAgdGhpcy5faWQgPSBuZXdUeGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dGVuZCB0aGUgZXhwaXJhdGlvbiBkYXRlIGJ5IHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICAgKlxuICAgKiBAcGFyYW0gZXh0ZW5zaW9uTXMgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZXh0ZW5kIHRoZSBleHBpcmF0aW9uIGJ5XG4gICAqL1xuICBleHRlbmRFeHBpcmF0aW9uKGV4dGVuc2lvbk1zOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoZXh0ZW5zaW9uTXMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXh0ZW5kVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBleHRlbnNpb24gcmFuZ2UuIE11c3QgYmUgcG9zaXRpdmUgYSBpbnRlZ2VyJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl90cmFuc2FjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEV4dGVuZFRyYW5zYWN0aW9uRXJyb3IoJ0VtcHR5IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uLnNpZ25hdHVyZSAmJiB0aGlzLl90cmFuc2FjdGlvbi5zaWduYXR1cmUubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEV4dGVuZFRyYW5zYWN0aW9uRXJyb3IoJ0Nhbm5vdCBleHRlbmQgYSBzaWduZWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCByYXdEYXRhSGV4ID0gdGhpcy5fdHJhbnNhY3Rpb24ucmF3X2RhdGFfaGV4O1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmZyb20ocmF3RGF0YUhleCwgJ2hleCcpO1xuICAgIGxldCByYXc7XG4gICAgdHJ5IHtcbiAgICAgIHJhdyA9IHByb3RvY29sLlRyYW5zYWN0aW9uLnJhdy5kZWNvZGUoYnl0ZXMpO1xuICAgICAgY29uc3QgbmV3RXhwaXJhdGlvbiA9IG5ldyBCaWdOdW1iZXIocmF3LmV4cGlyYXRpb24pLnBsdXMoZXh0ZW5zaW9uTXMpLnRvTnVtYmVyKCk7XG4gICAgICByYXcuZXhwaXJhdGlvbiA9IG5ld0V4cGlyYXRpb247XG4gICAgICBjb25zdCBuZXdSYXdEYXRhSGV4ID0gQnVmZmVyLmZyb20ocHJvdG9jb2wuVHJhbnNhY3Rpb24ucmF3LmVuY29kZShyYXcpLmZpbmlzaCgpKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAvLyBTZXQgdGhlIGludGVybmFsIHZhcmlhYmxlcyB0byBhY2NvdW50IGZvciB0aGUgbmV3IGV4cGlyYXRpb24gZGF0ZVxuICAgICAgdGhpcy5fdHJhbnNhY3Rpb24ucmF3X2RhdGFfaGV4ID0gbmV3UmF3RGF0YUhleDtcbiAgICAgIHRoaXMuX3RyYW5zYWN0aW9uLnJhd19kYXRhLmV4cGlyYXRpb24gPSBuZXdFeHBpcmF0aW9uO1xuICAgICAgdGhpcy5fZGVjb2RlZFJhd0RhdGFIZXggPSBkZWNvZGVUcmFuc2FjdGlvbihuZXdSYXdEYXRhSGV4KTtcbiAgICAgIHRoaXMucmVjb3JkUmF3RGF0YUZpZWxkcyh0aGlzLl9kZWNvZGVkUmF3RGF0YUhleCk7XG4gICAgICB0aGlzLnVwZGF0ZUlkKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEV4dGVuZFRyYW5zYWN0aW9uRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciBkZWNvZGluZyB0aGUgaW5pdGlhbCByYXdfZGF0YV9oZXggZnJvbSB0aGUgc2VyaWFsaXplZCB0eC4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaWduYXR1cmVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgZ2V0IHNpZ25hdHVyZSgpOiBzdHJpbmdbXSB7XG4gICAgaWYgKCF0aGlzLl90cmFuc2FjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlVHJhbnNhY3Rpb25FcnJvcignRW1wdHkgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uLnNpZ25hdHVyZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uLnNpZ25hdHVyZTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdGhpcyB0cmFuc2FjdGlvbiBiZWNvbWVzIHZhbGlkIGFuZCBjYW4gYmUgYnJvYWRjYXN0ZWQgdG8gdGhlXG4gICAqIG5ldHdvcmsuXG4gICAqL1xuICBnZXQgdmFsaWRGcm9tKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkRnJvbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4cGlyYXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gICAqL1xuICBnZXQgdmFsaWRUbygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl92YWxpZFRvO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGNhblNpZ24oa2V5OiBCYXNlS2V5KTogYm9vbGVhbiB7XG4gICAgLy8gVHJvbiB0cmFuc2FjdGlvbiBkbyBub3QgY29udGFpbiB0aGUgb3duZXJzIGFjY291bnQgYWRkcmVzcyBzbyBpdCBpcyBub3QgcG9zc2libGUgdG8gY2hlY2sgdGhlXG4gICAgLy8gcHJpdmF0ZSBrZXkgd2l0aCBhbnkgYnV0IHRoZSBhY2NvdW50IG1haW4gYWRkcmVzcy4gVGhpcyBpcyBub3QgZW5vdWdoIHRvIGZhaWwgdGhpcyBjaGVjaywgc29cbiAgICAvLyBpdCBpcyBhIG5vLW9wLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHRvSnNvbigpOiBUcmFuc2FjdGlvblJlY2VpcHQge1xuICAgIGlmICghdGhpcy5fdHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZVRyYW5zYWN0aW9uRXJyb3IoJ0VtcHR5IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB0b0Jyb2FkY2FzdEZvcm1hdCgpOiBhbnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSnNvbigpKTtcbiAgfVxufVxuIl19