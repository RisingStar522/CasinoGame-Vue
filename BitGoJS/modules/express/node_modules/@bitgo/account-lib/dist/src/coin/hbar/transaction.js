"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var sha384_1 = require("@stablelib/sha384");
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var nacl = __importStar(require("tweetnacl"));
var long_1 = __importDefault(require("long"));
var hedera_1 = require("../../../resources/hbar/protobuf/hedera");
var baseCoin_1 = require("../baseCoin");
var errors_1 = require("../baseCoin/errors");
var utils_1 = require("./utils");
var Transaction = /** @class */ (function (_super) {
    __extends(Transaction, _super);
    function Transaction(_coinConfig) {
        return _super.call(this, _coinConfig) || this;
    }
    /** @inheritdoc */
    Transaction.prototype.canSign = function (key) {
        return true;
    };
    Transaction.prototype.sign = function (keyPair) {
        return __awaiter(this, void 0, void 0, function () {
            var keys, secretKey, signature;
            return __generator(this, function (_a) {
                keys = keyPair.getKeys(true);
                if (!keys.prv) {
                    throw new errors_1.SigningError('Missing private key');
                }
                secretKey = utils_1.toUint8Array(keys.prv + keys.pub);
                signature = nacl.sign.detached(this._hederaTx.bodyBytes, secretKey);
                this.addSignature(utils_1.toHex(signature), keyPair);
                return [2 /*return*/];
            });
        });
    };
    /**
     * Add a signature to this transaction
     * @param signature The signature to add, in string hex format
     * @param key The key of the key that created the signature
     */
    Transaction.prototype.addSignature = function (signature, key) {
        var sigPair = new hedera_1.proto.SignaturePair();
        sigPair.pubKeyPrefix = utils_1.toUint8Array(key.getKeys(true).pub);
        sigPair.ed25519 = utils_1.toUint8Array(signature);
        var sigMap = this._hederaTx.sigMap || new hedera_1.proto.SignatureMap();
        sigMap.sigPair.push(sigPair);
        this._hederaTx.sigMap = sigMap;
        this._signatures.push(signature);
    };
    /** @inheritdoc */
    Transaction.prototype.toBroadcastFormat = function () {
        return utils_1.toHex(this.encode(this._hederaTx));
    };
    /** @inheritdoc */
    Transaction.prototype.toJson = function () {
        var _a = this.getTxIdParts(), acc = _a[0], time = _a[1];
        var result = {
            id: acc + '@' + time,
            hash: this.getTxHash(),
            data: utils_1.toHex(this._hederaTx.bodyBytes),
            fee: new bignumber_js_1.default(this._txBody.transactionFee.toString()).toNumber(),
            from: acc,
            startTime: time,
            validDuration: this._txBody.transactionValidDuration.seconds.toString(),
            node: utils_1.stringifyAccountId(this._txBody.nodeAccountID),
            memo: this._txBody.memo,
        };
        if (this._txBody.data === 'cryptoTransfer') {
            var _b = this.getTransferData(), recipient = _b[0], amount = _b[1];
            result.amount = amount;
            result.to = recipient;
        }
        return result;
    };
    /**
     * Get the recipient account and the amount
     * transferred on this transaction
     *
     * @returns {[string, string]} first element is the recipient, second element is the amount
     */
    Transaction.prototype.getTransferData = function () {
        var transferData;
        this._txBody.cryptoTransfer.transfers.accountAmounts.forEach(function (transfer) {
            var amount = long_1.default.fromValue(transfer.amount);
            if (amount.isPositive()) {
                transferData = [utils_1.stringifyAccountId(transfer.accountID), amount.toString()];
            }
        });
        return transferData;
    };
    Object.defineProperty(Transaction.prototype, "txBody", {
        //region getters & setters
        get: function () {
            return this._txBody;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "hederaTx", {
        get: function () {
            return this._hederaTx;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets this transaction body components
     *
     * @param {proto.Transaction} tx body transaction
     */
    Transaction.prototype.body = function (tx) {
        this._txBody = hedera_1.proto.TransactionBody.decode(tx.bodyBytes);
        this._hederaTx = tx;
        // this.loadPreviousSignatures();
        this.loadInputsAndOutputs();
    };
    /**
     * Set the transaction type
     *
     * @param {TransactionType} transactionType The transaction type to be set
     */
    Transaction.prototype.setTransactionType = function (transactionType) {
        this._type = transactionType;
    };
    /**
     * Decode previous signatures from the inner hedera transaction
     * and save them into the base transaction signature list.
     */
    Transaction.prototype.loadPreviousSignatures = function () {
        var _this = this;
        if (this._hederaTx.sigMap && this._hederaTx.sigMap.sigPair) {
            var sigPairs = this._hederaTx.sigMap.sigPair;
            sigPairs.forEach(function (sigPair) {
                var signature = sigPair.ed25519;
                if (signature) {
                    _this._signatures.push(utils_1.toHex(signature));
                }
            });
        }
    };
    /**
     * Load the input and output data on this transaction using the transaction json
     * if there are outputs. For transactions without outputs (e.g. wallet initializations),
     * this function will not do anything
     */
    Transaction.prototype.loadInputsAndOutputs = function () {
        var txJson = this.toJson();
        if (txJson.to && txJson.amount) {
            this._outputs = [{
                    address: txJson.to,
                    value: txJson.amount,
                    coin: this._coinConfig.name,
                }];
            this._inputs = [{
                    address: txJson.from,
                    value: txJson.amount,
                    coin: this._coinConfig.name,
                }];
        }
    };
    /**
     * Sets this transaction body components
     *
     * @param {Uint8Array} bytes encoded body transaction
     */
    Transaction.prototype.bodyBytes = function (bytes) {
        this.body(hedera_1.proto.Transaction.decode(bytes));
    };
    //endregion
    //region helpers
    /**
     * Returns this hedera transaction id components in a readable format
     *
     * @returns {[string, string]} - transaction id parts [<account id>, <startTime in seconds>]
     */
    Transaction.prototype.getTxIdParts = function () {
        if (this._txBody &&
            this._txBody.transactionID &&
            this._txBody.transactionID.accountID &&
            this._txBody.transactionID.transactionValidStart) {
            return [
                utils_1.stringifyAccountId(this._txBody.transactionID.accountID),
                utils_1.stringifyTxTime(this._txBody.transactionID.transactionValidStart),
            ];
        }
        throw new Error('Missing transaction id information');
    };
    /**
     * Returns this transaction hash
     *
     * @returns {string} - The transaction hash
     */
    Transaction.prototype.getTxHash = function () {
        if (!this._txBody.nodeAccountID) {
            throw new Error('Missing transaction node id');
        }
        return this.getHashOf(this._hederaTx);
    };
    /**
     * Encode an object using the given encoder class
     *
     * @param obj - the object to be encoded, it must be an proto namespace object
     * @param encoder - Object encoder
     * @returns {Uint8Array} - encoded object byte array
     */
    Transaction.prototype.encode = function (obj, encoder) {
        if (encoder) {
            return encoder.encode(obj).finish();
        }
        return this.encode(obj, hedera_1.proto[obj.constructor.name]);
    };
    /**
     * Returns an sha-384 hash
     *
     * @param {Uint8Array} bytes - bytes to be hashed
     * @returns {string} - the resulting hash string
     */
    Transaction.prototype.sha = function (bytes) {
        return utils_1.toHex(sha384_1.hash(bytes));
    };
    /**
     * Returns a hash of the given proto object.
     *
     * @param obj - The object to be hashed, it must be an proto namespace object
     * @returns {string} - the resulting hash string
     */
    Transaction.prototype.getHashOf = function (obj) {
        return this.sha(this.encode(obj));
    };
    return Transaction;
}(baseCoin_1.BaseTransaction));
exports.Transaction = Transaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi9oYmFyL3RyYW5zYWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLDRDQUF5QztBQUN6Qyw4REFBcUM7QUFFckMsOENBQWtDO0FBQ2xDLDhDQUF3QjtBQUN4QixrRUFBZ0U7QUFDaEUsd0NBQStEO0FBRS9ELDZDQUFrRDtBQUVsRCxpQ0FBbUY7QUFHbkY7SUFBaUMsK0JBQWU7SUFLOUMscUJBQVksV0FBaUM7ZUFDM0Msa0JBQU0sV0FBVyxDQUFDO0lBQ3BCLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsNkJBQU8sR0FBUCxVQUFRLEdBQVk7UUFDbEIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUssMEJBQUksR0FBVixVQUFXLE9BQWdCOzs7O2dCQUNuQixJQUFJLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUU7b0JBQ2IsTUFBTSxJQUFJLHFCQUFZLENBQUMscUJBQXFCLENBQUMsQ0FBQztpQkFDL0M7Z0JBQ0ssU0FBUyxHQUFHLG9CQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQzlDLFNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztnQkFDMUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFLLENBQUMsU0FBUyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7Ozs7S0FDOUM7SUFFRDs7OztPQUlHO0lBQ0gsa0NBQVksR0FBWixVQUFhLFNBQWlCLEVBQUUsR0FBWTtRQUMxQyxJ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TyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ssNEJBQU0sR0FBZCxVQUFvRCxHQUFNLEVBQUUsT0FBb0M7UUFDOUYsSUFBSSxPQUFPLEVBQUU7WUFDWCxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7U0FDckM7UUFDRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLGNBQUssQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gseUJBQUcsR0FBSCxVQUFJLEtBQWlCO1FBQ25CLE9BQU8sYUFBSyxDQUFDLGFBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQzVCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLCtCQUFTLEdBQWpCLFVBQXFCLEdBQU07UUFDekIsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUgsa0JBQUM7QUFBRCxDQUFDLEFBeE9ELENBQWlDLDBCQUFlLEdBd08vQztBQXhPWSxrQ0FBVyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcy9kaXN0L3NyYy9iYXNlJztcbmltcG9ydCB7IGhhc2ggfSBmcm9tICdAc3RhYmxlbGliL3NoYTM4NCc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBXcml0ZXIgfSBmcm9tICdwcm90b2J1ZmpzJztcbmltcG9ydCAqIGFzIG5hY2wgZnJvbSAndHdlZXRuYWNsJztcbmltcG9ydCBMb25nIGZyb20gJ2xvbmcnO1xuaW1wb3J0IHsgcHJvdG8gfSBmcm9tICcuLi8uLi8uLi9yZXNvdXJjZXMvaGJhci9wcm90b2J1Zi9oZWRlcmEnO1xuaW1wb3J0IHsgQmFzZVRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvblR5cGUgfSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBCYXNlS2V5IH0gZnJvbSAnLi4vYmFzZUNvaW4vaWZhY2UnO1xuaW1wb3J0IHsgU2lnbmluZ0Vycm9yIH0gZnJvbSAnLi4vYmFzZUNvaW4vZXJyb3JzJztcbmltcG9ydCB7IFR4RGF0YSB9IGZyb20gJy4vaWZhY2VzJztcbmltcG9ydCB7IHN0cmluZ2lmeUFjY291bnRJZCwgc3RyaW5naWZ5VHhUaW1lLCB0b0hleCwgdG9VaW50OEFycmF5IH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLi8nO1xuXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb24gZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb24ge1xuICBwcml2YXRlIF9oZWRlcmFUeDogcHJvdG8uVHJhbnNhY3Rpb247XG4gIHByaXZhdGUgX3R4Qm9keTogcHJvdG8uVHJhbnNhY3Rpb25Cb2R5O1xuICBwcm90ZWN0ZWQgX3R5cGU6IFRyYW5zYWN0aW9uVHlwZTtcblxuICBjb25zdHJ1Y3RvcihfY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihfY29pbkNvbmZpZyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgY2FuU2lnbihrZXk6IEJhc2VLZXkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGFzeW5jIHNpZ24oa2V5UGFpcjogS2V5UGFpcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGtleXMgPSBrZXlQYWlyLmdldEtleXModHJ1ZSk7XG4gICAgaWYgKCFrZXlzLnBydikge1xuICAgICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignTWlzc2luZyBwcml2YXRlIGtleScpO1xuICAgIH1cbiAgICBjb25zdCBzZWNyZXRLZXkgPSB0b1VpbnQ4QXJyYXkoa2V5cy5wcnYgKyBrZXlzLnB1Yik7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gbmFjbC5zaWduLmRldGFjaGVkKHRoaXMuX2hlZGVyYVR4LmJvZHlCeXRlcywgc2VjcmV0S2V5KTtcbiAgICB0aGlzLmFkZFNpZ25hdHVyZSh0b0hleChzaWduYXR1cmUpLCBrZXlQYWlyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBzaWduYXR1cmUgdG8gdGhpcyB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gc2lnbmF0dXJlIFRoZSBzaWduYXR1cmUgdG8gYWRkLCBpbiBzdHJpbmcgaGV4IGZvcm1hdFxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGtleSB0aGF0IGNyZWF0ZWQgdGhlIHNpZ25hdHVyZVxuICAgKi9cbiAgYWRkU2lnbmF0dXJlKHNpZ25hdHVyZTogc3RyaW5nLCBrZXk6IEtleVBhaXIpOiB2b2lkIHtcbiAgICBjb25zdCBzaWdQYWlyID0gbmV3IHByb3RvLlNpZ25hdHVyZVBhaXIoKTtcbiAgICBzaWdQYWlyLnB1YktleVByZWZpeCA9IHRvVWludDhBcnJheShrZXkuZ2V0S2V5cyh0cnVlKS5wdWIpO1xuICAgIHNpZ1BhaXIuZWQyNTUxOSA9IHRvVWludDhBcnJheShzaWduYXR1cmUpO1xuXG4gICAgY29uc3Qgc2lnTWFwID0gdGhpcy5faGVkZXJhVHguc2lnTWFwIHx8IG5ldyBwcm90by5TaWduYXR1cmVNYXAoKTtcbiAgICBzaWdNYXAuc2lnUGFpciEucHVzaChzaWdQYWlyKTtcbiAgICB0aGlzLl9oZWRlcmFUeC5zaWdNYXAgPSBzaWdNYXA7XG4gICAgdGhpcy5fc2lnbmF0dXJlcy5wdXNoKHNpZ25hdHVyZSk7XG4gIH1cblxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB0b0Jyb2FkY2FzdEZvcm1hdCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0b0hleCh0aGlzLmVuY29kZSh0aGlzLl9oZWRlcmFUeCkpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHRvSnNvbigpOiBUeERhdGEge1xuICAgIGNvbnN0IFthY2MsIHRpbWVdID0gdGhpcy5nZXRUeElkUGFydHMoKTtcbiAgICBjb25zdCByZXN1bHQ6IFR4RGF0YSA9IHtcbiAgICAgIGlkOiBhY2MgKyAnQCcgKyB0aW1lLFxuICAgICAgaGFzaDogdGhpcy5nZXRUeEhhc2goKSwgLy8gVE9ETzogVXBkYXRlIG9uY2UgaGVkZXJhLXNkayByZWxlYXNlIHRoaXMgZnVuY3Rpb25hbGl0eSBCR0EtMjg0XG4gICAgICBkYXRhOiB0b0hleCh0aGlzLl9oZWRlcmFUeC5ib2R5Qnl0ZXMpLFxuICAgICAgZmVlOiBuZXcgQmlnTnVtYmVyKHRoaXMuX3R4Qm9keS50cmFuc2FjdGlvbkZlZSEudG9TdHJpbmcoKSkudG9OdW1iZXIoKSxcbiAgICAgIGZyb206IGFjYyxcbiAgICAgIHN0YXJ0VGltZTogdGltZSxcbiAgICAgIHZhbGlkRHVyYXRpb246IHRoaXMuX3R4Qm9keS50cmFuc2FjdGlvblZhbGlkRHVyYXRpb24hLnNlY29uZHMhLnRvU3RyaW5nKCksXG4gICAgICBub2RlOiBzdHJpbmdpZnlBY2NvdW50SWQodGhpcy5fdHhCb2R5Lm5vZGVBY2NvdW50SUQhKSxcbiAgICAgIG1lbW86IHRoaXMuX3R4Qm9keS5tZW1vLFxuICAgIH07XG5cbiAgICBpZiAodGhpcy5fdHhCb2R5LmRhdGEgPT09ICdjcnlwdG9UcmFuc2ZlcicpIHtcbiAgICAgIGNvbnN0IFtyZWNpcGllbnQsIGFtb3VudF0gPSB0aGlzLmdldFRyYW5zZmVyRGF0YSgpO1xuICAgICAgcmVzdWx0LmFtb3VudCA9IGFtb3VudDtcbiAgICAgIHJlc3VsdC50byA9IHJlY2lwaWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlY2lwaWVudCBhY2NvdW50IGFuZCB0aGUgYW1vdW50XG4gICAqIHRyYW5zZmVycmVkIG9uIHRoaXMgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge1tzdHJpbmcsIHN0cmluZ119IGZpcnN0IGVsZW1lbnQgaXMgdGhlIHJlY2lwaWVudCwgc2Vjb25kIGVsZW1lbnQgaXMgdGhlIGFtb3VudFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRUcmFuc2ZlckRhdGEoKTogW3N0cmluZywgc3RyaW5nXSB7XG4gICAgbGV0IHRyYW5zZmVyRGF0YTtcbiAgICB0aGlzLl90eEJvZHkuY3J5cHRvVHJhbnNmZXIhLnRyYW5zZmVycyEuYWNjb3VudEFtb3VudHMhLmZvckVhY2godHJhbnNmZXIgPT4ge1xuICAgICAgY29uc3QgYW1vdW50ID0gTG9uZy5mcm9tVmFsdWUodHJhbnNmZXIuYW1vdW50ISk7XG4gICAgICBpZiAoYW1vdW50LmlzUG9zaXRpdmUoKSkge1xuICAgICAgICB0cmFuc2ZlckRhdGEgPSBbc3RyaW5naWZ5QWNjb3VudElkKHRyYW5zZmVyLmFjY291bnRJRCEpLCBhbW91bnQudG9TdHJpbmcoKV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJhbnNmZXJEYXRhO1xuICB9XG5cbiAgLy9yZWdpb24gZ2V0dGVycyAmIHNldHRlcnNcbiAgZ2V0IHR4Qm9keSgpOiBwcm90by5UcmFuc2FjdGlvbkJvZHkge1xuICAgIHJldHVybiB0aGlzLl90eEJvZHk7XG4gIH1cblxuICBnZXQgaGVkZXJhVHgoKTogcHJvdG8uVHJhbnNhY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLl9oZWRlcmFUeDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgdHJhbnNhY3Rpb24gYm9keSBjb21wb25lbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7cHJvdG8uVHJhbnNhY3Rpb259IHR4IGJvZHkgdHJhbnNhY3Rpb25cbiAgICovXG4gIGJvZHkodHg6IHByb3RvLlRyYW5zYWN0aW9uKSB7XG4gICAgdGhpcy5fdHhCb2R5ID0gcHJvdG8uVHJhbnNhY3Rpb25Cb2R5LmRlY29kZSh0eC5ib2R5Qnl0ZXMpO1xuICAgIHRoaXMuX2hlZGVyYVR4ID0gdHg7XG4gICAgLy8gdGhpcy5sb2FkUHJldmlvdXNTaWduYXR1cmVzKCk7XG4gICAgdGhpcy5sb2FkSW5wdXRzQW5kT3V0cHV0cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdHJhbnNhY3Rpb24gdHlwZVxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uVHlwZX0gdHJhbnNhY3Rpb25UeXBlIFRoZSB0cmFuc2FjdGlvbiB0eXBlIHRvIGJlIHNldFxuICAgKi9cbiAgc2V0VHJhbnNhY3Rpb25UeXBlKHRyYW5zYWN0aW9uVHlwZTogVHJhbnNhY3Rpb25UeXBlKTogdm9pZCB7XG4gICAgdGhpcy5fdHlwZSA9IHRyYW5zYWN0aW9uVHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgcHJldmlvdXMgc2lnbmF0dXJlcyBmcm9tIHRoZSBpbm5lciBoZWRlcmEgdHJhbnNhY3Rpb25cbiAgICogYW5kIHNhdmUgdGhlbSBpbnRvIHRoZSBiYXNlIHRyYW5zYWN0aW9uIHNpZ25hdHVyZSBsaXN0LlxuICAgKi9cbiAgbG9hZFByZXZpb3VzU2lnbmF0dXJlcygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5faGVkZXJhVHguc2lnTWFwICYmIHRoaXMuX2hlZGVyYVR4LnNpZ01hcC5zaWdQYWlyKSB7XG4gICAgICBjb25zdCBzaWdQYWlycyA9IHRoaXMuX2hlZGVyYVR4LnNpZ01hcC5zaWdQYWlyO1xuICAgICAgc2lnUGFpcnMuZm9yRWFjaChzaWdQYWlyID0+IHtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnUGFpci5lZDI1NTE5O1xuICAgICAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgICAgdGhpcy5fc2lnbmF0dXJlcy5wdXNoKHRvSGV4KHNpZ25hdHVyZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9hZCB0aGUgaW5wdXQgYW5kIG91dHB1dCBkYXRhIG9uIHRoaXMgdHJhbnNhY3Rpb24gdXNpbmcgdGhlIHRyYW5zYWN0aW9uIGpzb25cbiAgICogaWYgdGhlcmUgYXJlIG91dHB1dHMuIEZvciB0cmFuc2FjdGlvbnMgd2l0aG91dCBvdXRwdXRzIChlLmcuIHdhbGxldCBpbml0aWFsaXphdGlvbnMpLFxuICAgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgbm90IGRvIGFueXRoaW5nXG4gICAqL1xuICBsb2FkSW5wdXRzQW5kT3V0cHV0cygpOiB2b2lkIHtcbiAgICBjb25zdCB0eEpzb24gPSB0aGlzLnRvSnNvbigpO1xuICAgIGlmICh0eEpzb24udG8gJiYgdHhKc29uLmFtb3VudCkge1xuICAgICAgdGhpcy5fb3V0cHV0cyA9IFt7XG4gICAgICAgIGFkZHJlc3M6IHR4SnNvbi50byxcbiAgICAgICAgdmFsdWU6IHR4SnNvbi5hbW91bnQsXG4gICAgICAgIGNvaW46IHRoaXMuX2NvaW5Db25maWcubmFtZSxcbiAgICAgIH1dO1xuXG4gICAgICB0aGlzLl9pbnB1dHMgPSBbe1xuICAgICAgICBhZGRyZXNzOiB0eEpzb24uZnJvbSxcbiAgICAgICAgdmFsdWU6IHR4SnNvbi5hbW91bnQsXG4gICAgICAgIGNvaW46IHRoaXMuX2NvaW5Db25maWcubmFtZSxcbiAgICAgIH1dO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgdHJhbnNhY3Rpb24gYm9keSBjb21wb25lbnRzXG4gICAqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXMgZW5jb2RlZCBib2R5IHRyYW5zYWN0aW9uXG4gICAqL1xuICBib2R5Qnl0ZXMoYnl0ZXM6IFVpbnQ4QXJyYXkpIHtcbiAgICB0aGlzLmJvZHkocHJvdG8uVHJhbnNhY3Rpb24uZGVjb2RlKGJ5dGVzKSk7XG4gIH1cbiAgLy9lbmRyZWdpb25cblxuICAvL3JlZ2lvbiBoZWxwZXJzXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgaGVkZXJhIHRyYW5zYWN0aW9uIGlkIGNvbXBvbmVudHMgaW4gYSByZWFkYWJsZSBmb3JtYXRcbiAgICpcbiAgICogQHJldHVybnMge1tzdHJpbmcsIHN0cmluZ119IC0gdHJhbnNhY3Rpb24gaWQgcGFydHMgWzxhY2NvdW50IGlkPiwgPHN0YXJ0VGltZSBpbiBzZWNvbmRzPl1cbiAgICovXG4gIGdldFR4SWRQYXJ0cygpOiBbc3RyaW5nLCBzdHJpbmddIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLl90eEJvZHkgJiZcbiAgICAgIHRoaXMuX3R4Qm9keS50cmFuc2FjdGlvbklEICYmXG4gICAgICB0aGlzLl90eEJvZHkudHJhbnNhY3Rpb25JRC5hY2NvdW50SUQgJiZcbiAgICAgIHRoaXMuX3R4Qm9keS50cmFuc2FjdGlvbklELnRyYW5zYWN0aW9uVmFsaWRTdGFydFxuICAgICkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc3RyaW5naWZ5QWNjb3VudElkKHRoaXMuX3R4Qm9keS50cmFuc2FjdGlvbklELmFjY291bnRJRCksXG4gICAgICAgIHN0cmluZ2lmeVR4VGltZSh0aGlzLl90eEJvZHkudHJhbnNhY3Rpb25JRC50cmFuc2FjdGlvblZhbGlkU3RhcnQpLFxuICAgICAgXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHRyYW5zYWN0aW9uIGlkIGluZm9ybWF0aW9uJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGlzIHRyYW5zYWN0aW9uIGhhc2hcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgdHJhbnNhY3Rpb24gaGFzaFxuICAgKi9cbiAgZ2V0VHhIYXNoKCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLl90eEJvZHkubm9kZUFjY291bnRJRCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHRyYW5zYWN0aW9uIG5vZGUgaWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0SGFzaE9mKHRoaXMuX2hlZGVyYVR4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgYW4gb2JqZWN0IHVzaW5nIHRoZSBnaXZlbiBlbmNvZGVyIGNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSBvYmogLSB0aGUgb2JqZWN0IHRvIGJlIGVuY29kZWQsIGl0IG11c3QgYmUgYW4gcHJvdG8gbmFtZXNwYWNlIG9iamVjdFxuICAgKiBAcGFyYW0gZW5jb2RlciAtIE9iamVjdCBlbmNvZGVyXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSAtIGVuY29kZWQgb2JqZWN0IGJ5dGUgYXJyYXlcbiAgICovXG4gIHByaXZhdGUgZW5jb2RlPFQgZXh0ZW5kcyB7IGNvbnN0cnVjdG9yOiBGdW5jdGlvbiB9PihvYmo6IFQsIGVuY29kZXI/OiB7IGVuY29kZShhcmc6IFQpOiBXcml0ZXIgfSk6IFVpbnQ4QXJyYXkge1xuICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGUob2JqKS5maW5pc2goKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlKG9iaiwgcHJvdG9bb2JqLmNvbnN0cnVjdG9yLm5hbWVdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIHNoYS0zODQgaGFzaFxuICAgKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzIC0gYnl0ZXMgdG8gYmUgaGFzaGVkXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIHJlc3VsdGluZyBoYXNoIHN0cmluZ1xuICAgKi9cbiAgc2hhKGJ5dGVzOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgICByZXR1cm4gdG9IZXgoaGFzaChieXRlcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBoYXNoIG9mIHRoZSBnaXZlbiBwcm90byBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSBvYmogLSBUaGUgb2JqZWN0IHRvIGJlIGhhc2hlZCwgaXQgbXVzdCBiZSBhbiBwcm90byBuYW1lc3BhY2Ugb2JqZWN0XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIHJlc3VsdGluZyBoYXNoIHN0cmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBnZXRIYXNoT2Y8VD4ob2JqOiBUKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zaGEodGhpcy5lbmNvZGUob2JqKSk7XG4gIH1cbiAgLy9lbmRyZWdpb25cbn1cbiJdfQ==