"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var baseCoin_1 = require("../baseCoin");
var errors_1 = require("../baseCoin/errors");
var types_1 = require("./types");
var utils_1 = require("./utils");
var UNSUPPORTED_COIN_NAME = 'unsupported';
var Transaction = /** @class */ (function (_super) {
    __extends(Transaction, _super);
    /**
     * Public constructor.
     *
     * @param {Readonly<CoinConfig>} coinConfig
     * @param common the network commons
     * @param {TxData} txData The object transaction data or encoded transaction data
     */
    function Transaction(coinConfig, common, txData) {
        var _this = _super.call(this, coinConfig) || this;
        _this._common = common;
        if (txData) {
            _this.setTransactionData(txData);
        }
        return _this;
    }
    /**
     * return a new Transaction initialized with the serialized tx string
     *
     * @param coinConfig The coin configuration object
     * @param common network commons
     * @param serializedTx The serialized tx string with which to initialize the transaction
     * @returns a new transaction object
     */
    Transaction.fromSerialized = function (coinConfig, common, serializedTx) {
        return new Transaction(coinConfig, common, types_1.EthTransactionData.fromSerialized(serializedTx, common).toJson());
    };
    /**
     * Set the transaction data
     *
     * @param {TxData} txData The transaction data to set
     */
    Transaction.prototype.setTransactionData = function (txData) {
        this._transactionData = types_1.EthTransactionData.fromJson(txData, this._common);
        this.updateFields();
    };
    /**
     * Update the internal fields based on the currently set transaction data, if there is any
     */
    Transaction.prototype.updateFields = function () {
        if (!this._transactionData) {
            return;
        }
        var txData = this._transactionData.toJson();
        if (txData.id) {
            this._id = txData.id;
        }
        this._type = utils_1.classifyTransaction(txData.data);
        // reset arrays to empty to ensure that they are only set with one set of fresh values
        this._inputs = [];
        this._outputs = [];
        this._signatures = [];
        if (utils_1.hasSignature(txData)) {
            this._signatures.push(utils_1.toStringSig({ v: txData.v, r: txData.r, s: txData.s }));
        }
        // only send transactions have inputs / outputs / signatures to parse
        if (this._type === baseCoin_1.TransactionType.Send) {
            var _a = utils_1.decodeTransferData(txData.data), to = _a.to, amount = _a.amount, tokenContractAddress = _a.tokenContractAddress, signature = _a.signature;
            var coinName = void 0;
            if (tokenContractAddress) {
                var token = utils_1.getToken(tokenContractAddress);
                coinName = token ? token.name : UNSUPPORTED_COIN_NAME;
            }
            else {
                coinName = this._coinConfig.name;
            }
            this.outputs.push({
                address: to,
                value: amount,
                coin: coinName,
            });
            this.inputs.push({
                address: txData.to,
                value: amount,
                coin: coinName,
            });
            this._signatures.push(signature);
        }
    };
    /**
     * Set the transaction type
     *
     * @param {TransactionType} transactionType The transaction type to be set
     */
    Transaction.prototype.setTransactionType = function (transactionType) {
        this._type = transactionType;
    };
    /** @inheritdoc */
    Transaction.prototype.canSign = function (key) {
        // TODO: implement this validation for the ethereum network
        return true;
    };
    /**
     * Sign the transaction with the provided key. It does not check if the signer is allowed to sign
     * it or not.
     *
     * @param {KeyPair} keyPair The key to sign the transaction with
     */
    Transaction.prototype.sign = function (keyPair) {
        return __awaiter(this, void 0, void 0, function () {
            var txData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._transactionData) {
                            throw new errors_1.InvalidTransactionError('No transaction data to sign');
                        }
                        if (!keyPair.getKeys().prv) {
                            throw new errors_1.SigningError('Missing private key');
                        }
                        return [4 /*yield*/, this._transactionData.sign(keyPair)];
                    case 1:
                        _a.sent();
                        txData = this._transactionData.toJson();
                        this._signatures.push(utils_1.toStringSig({ v: txData.v, r: txData.r, s: txData.s }));
                        return [2 /*return*/];
                }
            });
        });
    };
    /** @inheritdoc */
    Transaction.prototype.toBroadcastFormat = function () {
        if (this._transactionData) {
            return this._transactionData.toSerialized();
        }
        throw new errors_1.InvalidTransactionError('No transaction data to format');
    };
    /** @inheritdoc */
    Transaction.prototype.toJson = function () {
        if (this._transactionData) {
            return this._transactionData.toJson();
        }
        throw new errors_1.InvalidTransactionError('Empty transaction');
    };
    return Transaction;
}(baseCoin_1.BaseTransaction));
exports.Transaction = Transaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29pbi9ldGgvdHJhbnNhY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLQSx3Q0FBK0Q7QUFFL0QsNkNBQTJFO0FBRzNFLGlDQUE2QztBQUM3QyxpQ0FBdUc7QUFFdkcsSUFBTSxxQkFBcUIsR0FBRyxhQUFhLENBQUM7QUFFNUM7SUFBaUMsK0JBQWU7SUEwQjlDOzs7Ozs7T0FNRztJQUNILHFCQUFZLFVBQWdDLEVBQUUsTUFBc0IsRUFBRSxNQUFlO1FBQXJGLFlBQ0Usa0JBQU0sVUFBVSxDQUFDLFNBS2xCO1FBSkMsS0FBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7UUFDdEIsSUFBSSxNQUFNLEVBQUU7WUFDVixLQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDakM7O0lBQ0gsQ0FBQztJQTdCRDs7Ozs7OztPQU9HO0lBQ1csMEJBQWMsR0FBNUIsVUFDRSxVQUFnQyxFQUNoQyxNQUFzQixFQUN0QixZQUFvQjtRQUVwQixPQUFPLElBQUksV0FBVyxDQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsMEJBQWtCLENBQUMsY0FBYyxDQUFDLFlBQVksRUFBRSxNQUFNLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO0lBQy9HLENBQUM7SUFpQkQ7Ozs7T0FJRztJQUNILHdDQUFrQixHQUFsQixVQUFtQixNQUFjO1FBQy9CLElBQUksQ0FBQyxnQkFBZ0IsR0FBRywwQkFBa0IsQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMxRSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVEOztPQUVHO0lBQ08sa0NBQVksR0FBdEI7UUFDRSxJQUFJLENBQUMsSUFBSSxDQUFD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QUMsSUFBSSxDQUFDLG1CQUFXLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUUsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUUsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQzs7Ozs7S0FDbEY7SUFFRCxrQkFBa0I7SUFDbEIsdUNBQWlCLEdBQWpCO1FBQ0UsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7WUFDekIsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxFQUFFLENBQUM7U0FDN0M7UUFDRCxNQUFNLElBQUksZ0NBQXVCLENBQUMsK0JBQStCLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLDRCQUFNLEdBQU47UUFDRSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUN6QixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUN2QztRQUNELE1BQU0sSUFBSSxnQ0FBdUIsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFDSCxrQkFBQztBQUFELENBQUMsQUFySkQsQ0FBaUMsMEJBQWUsR0FxSi9DO0FBckpZLGtDQUFXIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEV0aGVyZXVtIHRyYW5zYWN0aW9uIG1vZGVsLiBUaGlzIGlzIHRoZSBiYXNlIG1vZGVsIGZvciBhbGwgZXRoZXJldW0gYmFzZWQgY29pbnMgKENlbG8sIEVUQywgUlNLLCBFVEgpXHJcbiAqL1xyXG5pbXBvcnQgeyBCYXNlQ29pbiBhcyBDb2luQ29uZmlnIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xyXG5pbXBvcnQgRXRoZXJldW1Db21tb24gZnJvbSAnZXRoZXJldW1qcy1jb21tb24nO1xyXG5pbXBvcnQgeyBCYXNlVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJy4uL2Jhc2VDb2luJztcclxuaW1wb3J0IHsgQmFzZUtleSwgRW50cnkgfSBmcm9tICcuLi9iYXNlQ29pbi9pZmFjZSc7XHJcbmltcG9ydCB7IEludmFsaWRUcmFuc2FjdGlvbkVycm9yLCBTaWduaW5nRXJyb3IgfSBmcm9tICcuLi9iYXNlQ29pbi9lcnJvcnMnO1xyXG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLi9rZXlQYWlyJztcclxuaW1wb3J0IHsgRXRoTGlrZVRyYW5zYWN0aW9uRGF0YSwgVHhEYXRhIH0gZnJvbSAnLi9pZmFjZSc7XHJcbmltcG9ydCB7IEV0aFRyYW5zYWN0aW9uRGF0YSB9IGZyb20gJy4vdHlwZXMnO1xyXG5pbXBvcnQgeyBjbGFzc2lmeVRyYW5zYWN0aW9uLCBkZWNvZGVUcmFuc2ZlckRhdGEsIGdldFRva2VuLCBoYXNTaWduYXR1cmUsIHRvU3RyaW5nU2lnIH0gZnJvbSAnLi91dGlscyc7XHJcblxyXG5jb25zdCBVTlNVUFBPUlRFRF9DT0lOX05BTUUgPSAndW5zdXBwb3J0ZWQnO1xyXG5cclxuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uIHtcclxuICBwcm90ZWN0ZWQgX2lkOiBzdHJpbmc7IC8vIFRoZSB0cmFuc2FjdGlvbiBpZCBhcyBzZWVuIGluIHRoZSBibG9ja2NoYWluXHJcbiAgcHJvdGVjdGVkIF9pbnB1dHM6IEVudHJ5W107XHJcbiAgcHJvdGVjdGVkIF9vdXRwdXRzOiBFbnRyeVtdO1xyXG4gIHByb3RlY3RlZCBfc2lnbmF0dXJlczogc3RyaW5nW107XHJcbiAgcHJvdGVjdGVkIF90eXBlOiBUcmFuc2FjdGlvblR5cGU7XHJcbiAgcHJvdGVjdGVkIF9jb21tb246IEV0aGVyZXVtQ29tbW9uO1xyXG5cclxuICBwcm90ZWN0ZWQgX3RyYW5zYWN0aW9uRGF0YT86IEV0aExpa2VUcmFuc2FjdGlvbkRhdGE7XHJcblxyXG4gIC8qKlxyXG4gICAqIHJldHVybiBhIG5ldyBUcmFuc2FjdGlvbiBpbml0aWFsaXplZCB3aXRoIHRoZSBzZXJpYWxpemVkIHR4IHN0cmluZ1xyXG4gICAqXHJcbiAgICogQHBhcmFtIGNvaW5Db25maWcgVGhlIGNvaW4gY29uZmlndXJhdGlvbiBvYmplY3RcclxuICAgKiBAcGFyYW0gY29tbW9uIG5ldHdvcmsgY29tbW9uc1xyXG4gICAqIEBwYXJhbSBzZXJpYWxpemVkVHggVGhlIHNlcmlhbGl6ZWQgdHggc3RyaW5nIHdpdGggd2hpY2ggdG8gaW5pdGlhbGl6ZSB0aGUgdHJhbnNhY3Rpb25cclxuICAgKiBAcmV0dXJucyBhIG5ldyB0cmFuc2FjdGlvbiBvYmplY3RcclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIGZyb21TZXJpYWxpemVkKFxyXG4gICAgY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4sXHJcbiAgICBjb21tb246IEV0aGVyZXVtQ29tbW9uLFxyXG4gICAgc2VyaWFsaXplZFR4OiBzdHJpbmcsXHJcbiAgKTogVHJhbnNhY3Rpb24ge1xyXG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbihjb2luQ29uZmlnLCBjb21tb24sIEV0aFRyYW5zYWN0aW9uRGF0YS5mcm9tU2VyaWFsaXplZChzZXJpYWxpemVkVHgsIGNvbW1vbikudG9Kc29uKCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHVibGljIGNvbnN0cnVjdG9yLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWFkb25seTxDb2luQ29uZmlnPn0gY29pbkNvbmZpZ1xyXG4gICAqIEBwYXJhbSBjb21tb24gdGhlIG5ldHdvcmsgY29tbW9uc1xyXG4gICAqIEBwYXJhbSB7VHhEYXRhfSB0eERhdGEgVGhlIG9iamVjdCB0cmFuc2FjdGlvbiBkYXRhIG9yIGVuY29kZWQgdHJhbnNhY3Rpb24gZGF0YVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+LCBjb21tb246IEV0aGVyZXVtQ29tbW9uLCB0eERhdGE/OiBUeERhdGEpIHtcclxuICAgIHN1cGVyKGNvaW5Db25maWcpO1xyXG4gICAgdGhpcy5fY29tbW9uID0gY29tbW9uO1xyXG4gICAgaWYgKHR4RGF0YSkge1xyXG4gICAgICB0aGlzLnNldFRyYW5zYWN0aW9uRGF0YSh0eERhdGEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSB0cmFuc2FjdGlvbiBkYXRhXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1R4RGF0YX0gdHhEYXRhIFRoZSB0cmFuc2FjdGlvbiBkYXRhIHRvIHNldFxyXG4gICAqL1xyXG4gIHNldFRyYW5zYWN0aW9uRGF0YSh0eERhdGE6IFR4RGF0YSk6IHZvaWQge1xyXG4gICAgdGhpcy5fdHJhbnNhY3Rpb25EYXRhID0gRXRoVHJhbnNhY3Rpb25EYXRhLmZyb21Kc29uKHR4RGF0YSwgdGhpcy5fY29tbW9uKTtcclxuICAgIHRoaXMudXBkYXRlRmllbGRzKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGludGVybmFsIGZpZWxkcyBiYXNlZCBvbiB0aGUgY3VycmVudGx5IHNldCB0cmFuc2FjdGlvbiBkYXRhLCBpZiB0aGVyZSBpcyBhbnlcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgdXBkYXRlRmllbGRzKCk6IHZvaWQge1xyXG4gICAgaWYgKCF0aGlzLl90cmFuc2FjdGlvbkRhdGEpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHR4RGF0YSA9IHRoaXMuX3RyYW5zYWN0aW9uRGF0YS50b0pzb24oKTtcclxuICAgIGlmICh0eERhdGEuaWQpIHtcclxuICAgICAgdGhpcy5faWQgPSB0eERhdGEuaWQ7XHJcbiAgICB9XHJcbiAgICB0aGlzLl90eXBlID0gY2xhc3NpZnlUcmFuc2FjdGlvbih0eERhdGEuZGF0YSk7XHJcblxyXG4gICAgLy8gcmVzZXQgYXJyYXlzIHRvIGVtcHR5IHRvIGVuc3VyZSB0aGF0IHRoZXkgYXJlIG9ubHkgc2V0IHdpdGggb25lIHNldCBvZiBmcmVzaCB2YWx1ZXNcclxuICAgIHRoaXMuX2lucHV0cyA9IFtdO1xyXG4gICAgdGhpcy5fb3V0cHV0cyA9IFtdO1xyXG4gICAgdGhpcy5fc2lnbmF0dXJlcyA9IFtdO1xyXG5cclxuICAgIGlmIChoYXNTaWduYXR1cmUodHhEYXRhKSkge1xyXG4gICAgICB0aGlzLl9zaWduYXR1cmVzLnB1c2godG9TdHJpbmdTaWcoeyB2OiB0eERhdGEudiEsIHI6IHR4RGF0YS5yISwgczogdHhEYXRhLnMhIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBvbmx5IHNlbmQgdHJhbnNhY3Rpb25zIGhhdmUgaW5wdXRzIC8gb3V0cHV0cyAvIHNpZ25hdHVyZXMgdG8gcGFyc2VcclxuICAgIGlmICh0aGlzLl90eXBlID09PSBUcmFuc2FjdGlvblR5cGUuU2VuZCkge1xyXG4gICAgICBjb25zdCB7IHRvLCBhbW91bnQsIHRva2VuQ29udHJhY3RBZGRyZXNzLCBzaWduYXR1cmUgfSA9IGRlY29kZVRyYW5zZmVyRGF0YSh0eERhdGEuZGF0YSk7XHJcbiAgICAgIGxldCBjb2luTmFtZTogc3RyaW5nO1xyXG4gICAgICBpZiAodG9rZW5Db250cmFjdEFkZHJlc3MpIHtcclxuICAgICAgICBjb25zdCB0b2tlbiA9IGdldFRva2VuKHRva2VuQ29udHJhY3RBZGRyZXNzKTtcclxuICAgICAgICBjb2luTmFtZSA9IHRva2VuID8gdG9rZW4ubmFtZSA6IFVOU1VQUE9SVEVEX0NPSU5fTkFNRTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb2luTmFtZSA9IHRoaXMuX2NvaW5Db25maWcubmFtZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5vdXRwdXRzLnB1c2goe1xyXG4gICAgICAgIGFkZHJlc3M6IHRvLFxyXG4gICAgICAgIHZhbHVlOiBhbW91bnQsXHJcbiAgICAgICAgY29pbjogY29pbk5hbWUsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5pbnB1dHMucHVzaCh7XHJcbiAgICAgICAgYWRkcmVzczogdHhEYXRhLnRvISwgLy8gdGhlIHNlbmRpbmcgd2FsbGV0IGNvbnRyYWN0IGlzIHRoZSByZWNpcGllbnQgb2YgdGhlIG91dGVyIHRyYW5zYWN0aW9uXHJcbiAgICAgICAgdmFsdWU6IGFtb3VudCxcclxuICAgICAgICBjb2luOiBjb2luTmFtZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLl9zaWduYXR1cmVzLnB1c2goc2lnbmF0dXJlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgdHJhbnNhY3Rpb24gdHlwZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvblR5cGV9IHRyYW5zYWN0aW9uVHlwZSBUaGUgdHJhbnNhY3Rpb24gdHlwZSB0byBiZSBzZXRcclxuICAgKi9cclxuICBzZXRUcmFuc2FjdGlvblR5cGUodHJhbnNhY3Rpb25UeXBlOiBUcmFuc2FjdGlvblR5cGUpOiB2b2lkIHtcclxuICAgIHRoaXMuX3R5cGUgPSB0cmFuc2FjdGlvblR5cGU7XHJcbiAgfVxyXG5cclxuICAvKiogQGluaGVyaXRkb2MgKi9cclxuICBjYW5TaWduKGtleTogQmFzZUtleSk6IGJvb2xlYW4ge1xyXG4gICAgLy8gVE9ETzogaW1wbGVtZW50IHRoaXMgdmFsaWRhdGlvbiBmb3IgdGhlIGV0aGVyZXVtIG5ldHdvcmtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2lnbiB0aGUgdHJhbnNhY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQga2V5LiBJdCBkb2VzIG5vdCBjaGVjayBpZiB0aGUgc2lnbmVyIGlzIGFsbG93ZWQgdG8gc2lnblxyXG4gICAqIGl0IG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7S2V5UGFpcn0ga2V5UGFpciBUaGUga2V5IHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uIHdpdGhcclxuICAgKi9cclxuICBhc3luYyBzaWduKGtleVBhaXI6IEtleVBhaXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGlmICghdGhpcy5fdHJhbnNhY3Rpb25EYXRhKSB7XHJcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignTm8gdHJhbnNhY3Rpb24gZGF0YSB0byBzaWduJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWtleVBhaXIuZ2V0S2V5cygpLnBydikge1xyXG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdNaXNzaW5nIHByaXZhdGUga2V5Jyk7XHJcbiAgICB9XHJcbiAgICBhd2FpdCB0aGlzLl90cmFuc2FjdGlvbkRhdGEuc2lnbihrZXlQYWlyKTtcclxuICAgIGNvbnN0IHR4RGF0YSA9IHRoaXMuX3RyYW5zYWN0aW9uRGF0YS50b0pzb24oKTtcclxuICAgIHRoaXMuX3NpZ25hdHVyZXMucHVzaCh0b1N0cmluZ1NpZyh7IHY6IHR4RGF0YS52ISwgcjogdHhEYXRhLnIhLCBzOiB0eERhdGEucyEgfSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBpbmhlcml0ZG9jICovXHJcbiAgdG9Ccm9hZGNhc3RGb3JtYXQoKTogc3RyaW5nIHtcclxuICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbkRhdGEpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uRGF0YS50b1NlcmlhbGl6ZWQoKTtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignTm8gdHJhbnNhY3Rpb24gZGF0YSB0byBmb3JtYXQnKTtcclxuICB9XHJcblxyXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gIHRvSnNvbigpOiBUeERhdGEge1xyXG4gICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9uRGF0YSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25EYXRhLnRvSnNvbigpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdFbXB0eSB0cmFuc2FjdGlvbicpO1xyXG4gIH1cclxufVxyXG4iXX0=