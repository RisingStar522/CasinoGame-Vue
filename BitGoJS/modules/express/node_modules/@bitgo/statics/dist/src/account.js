"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hederaCoin = exports.tstellarToken = exports.stellarToken = exports.tceloToken = exports.celoToken = exports.erc20CompatibleAccountCoin = exports.terc20 = exports.erc20 = exports.account = exports.HederaCoin = exports.StellarCoin = exports.CeloCoin = exports.Erc20CompatibleAccountCoin = exports.Erc20Coin = exports.ContractAddressDefinedToken = exports.AccountCoinToken = exports.AccountCoin = void 0;
var base_1 = require("./base");
var errors_1 = require("./errors");
var networks_1 = require("./networks");
/**
 * Account based coins, such as Ethereum, Stellar, or XRP.
 *
 * These types of coins maintain an "account balance" for each address on the network,
 * as opposed to the unspent transaction output model which maintains a record of all
 * "pieces" of coin which belong to an address.
 */
var AccountCoin = /** @class */ (function (_super) {
    __extends(AccountCoin, _super);
    function AccountCoin(options) {
        var _this = _super.call(this, __assign(__assign({}, options), { kind: base_1.CoinKind.CRYPTO })) || this;
        _this.network = options.network;
        return _this;
    }
    AccountCoin.prototype.requiredFeatures = function () {
        return new Set([base_1.CoinFeature.ACCOUNT_MODEL]);
    };
    AccountCoin.prototype.disallowedFeatures = function () {
        return new Set([base_1.CoinFeature.UNSPENT_MODEL]);
    };
    AccountCoin.DEFAULT_FEATURES = [
        base_1.CoinFeature.ACCOUNT_MODEL,
        base_1.CoinFeature.REQUIRES_BIG_NUMBER,
        base_1.CoinFeature.VALUELESS_TRANSFER,
        base_1.CoinFeature.TRANSACTION_DATA,
    ];
    return AccountCoin;
}(base_1.BaseCoin));
exports.AccountCoin = AccountCoin;
var AccountCoinToken = /** @class */ (function (_super) {
    __extends(AccountCoinToken, _super);
    function AccountCoinToken(options) {
        return _super.call(this, __assign({}, options)) || this;
    }
    return AccountCoinToken;
}(AccountCoin));
exports.AccountCoinToken = AccountCoinToken;
/**
 * Some blockchains support tokens which are defined by an address at which they have a smart contract deployed.
 * Examples are ERC20 tokens, and the equivalent on other chains.
 */
var ContractAddressDefinedToken = /** @class */ (function (_super) {
    __extends(ContractAddressDefinedToken, _super);
    function ContractAddressDefinedToken(options) {
        var _this = _super.call(this, __assign({}, options)) || this;
        // valid ERC 20 contract addresses are "0x" followed by 40 lowercase hex characters
        if (!options.contractAddress.match(/^0x[a-f0-9]{40}$/)) {
            throw new errors_1.InvalidContractAddressError(options.name, options.contractAddress);
        }
        _this.contractAddress = options.contractAddress;
        return _this;
    }
    return ContractAddressDefinedToken;
}(AccountCoinToken));
exports.ContractAddressDefinedToken = ContractAddressDefinedToken;
/**
 * ERC 20 is a token standard for the Ethereum blockchain. They are similar to other account coins, but have a
 * contract address property which identifies the smart contract which defines the token.
 */
var Erc20Coin = /** @class */ (function (_super) {
    __extends(Erc20Coin, _super);
    function Erc20Coin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Erc20Coin;
}(ContractAddressDefinedToken));
exports.Erc20Coin = Erc20Coin;
/**
 * Some blockchains have native coins which also support the ERC20 interface such as CELO.
 */
var Erc20CompatibleAccountCoin = /** @class */ (function (_super) {
    __extends(Erc20CompatibleAccountCoin, _super);
    function Erc20CompatibleAccountCoin(options) {
        return _super.call(this, __assign(__assign({}, options), { 
            // These coins should not be classified as tokens as they are not children of other coins
            isToken: false })) || this;
    }
    return Erc20CompatibleAccountCoin;
}(ContractAddressDefinedToken));
exports.Erc20CompatibleAccountCoin = Erc20CompatibleAccountCoin;
/**
 * The CELO blockchain supports tokens of the ERC20 standard similar to ETH ERC20 tokens.
 */
var CeloCoin = /** @class */ (function (_super) {
    __extends(CeloCoin, _super);
    function CeloCoin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CeloCoin;
}(ContractAddressDefinedToken));
exports.CeloCoin = CeloCoin;
/**
 * The Stellar network supports tokens (non-native assets)
 * XLM is also known as the native asset.
 * Stellar tokens work similar to XLM, but the token name is determined by the chain,
 * the token code and the issuer account in the form: (t)xlm:<token>-<issuer>
 */
var StellarCoin = /** @class */ (function (_super) {
    __extends(StellarCoin, _super);
    function StellarCoin(options) {
        var _this = _super.call(this, __assign({}, options)) || this;
        var domainPattern = /^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z0-9][a-z0-9-]{0,61}[a-z0-9]$/;
        if (options.domain !== '' && !options.domain.match(domainPattern)) {
            throw new errors_1.InvalidDomainError(options.name, options.domain);
        }
        _this.domain = options.domain;
        return _this;
    }
    return StellarCoin;
}(AccountCoinToken));
exports.StellarCoin = StellarCoin;
/**
 * The Hedera coin needs a client set with the node account Id.
 * It's an account based coin that needs the node account ID
 * where the transaction will be sent.
 */
var HederaCoin = /** @class */ (function (_super) {
    __extends(HederaCoin, _super);
    function HederaCoin(options) {
        var _this = _super.call(this, __assign({}, options)) || this;
        _this.nodeAccountId = options.nodeAccountId;
        return _this;
    }
    return HederaCoin;
}(AccountCoinToken));
exports.HederaCoin = HederaCoin;
/**
 * Factory function for account coin instances.
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function account(name, fullName, network, decimalPlaces, asset, features, primaryKeyCurve, prefix, suffix, isToken) {
    if (features === void 0) { features = AccountCoin.DEFAULT_FEATURES; }
    if (primaryKeyCurve === void 0) { primaryKeyCurve = base_1.KeyCurve.Secp256k1; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.toUpperCase(); }
    if (isToken === void 0) { isToken = false; }
    return Object.freeze(new AccountCoin({
        name: name,
        fullName: fullName,
        network: network,
        prefix: prefix,
        suffix: suffix,
        features: features,
        decimalPlaces: decimalPlaces,
        isToken: isToken,
        asset: asset,
        primaryKeyCurve: primaryKeyCurve,
    }));
}
exports.account = account;
/**
 * Factory function for erc20 token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Ethereum main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function erc20(name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network, primaryKeyCurve) {
    if (features === void 0) { features = AccountCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.main.ethereum; }
    if (primaryKeyCurve === void 0) { primaryKeyCurve = base_1.KeyCurve.Secp256k1; }
    return Object.freeze(new Erc20Coin({
        name: name,
        fullName: fullName,
        network: network,
        contractAddress: contractAddress,
        prefix: prefix,
        suffix: suffix,
        features: features,
        decimalPlaces: decimalPlaces,
        asset: asset,
        isToken: true,
        primaryKeyCurve: primaryKeyCurve,
    }));
}
exports.erc20 = erc20;
/**
 * Factory function for testnet erc20 token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the Kovan test network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function terc20(name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network) {
    if (features === void 0) { features = AccountCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.test.kovan; }
    return erc20(name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network);
}
exports.terc20 = terc20;
/**
 * Factory function for ERC20-compatible account coin instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function erc20CompatibleAccountCoin(name, fullName, network, decimalPlaces, contractAddress, asset, features, prefix, suffix, primaryKeyCurve) {
    if (features === void 0) { features = AccountCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.toUpperCase(); }
    if (primaryKeyCurve === void 0) { primaryKeyCurve = base_1.KeyCurve.Secp256k1; }
    return Object.freeze(new Erc20CompatibleAccountCoin({
        name: name,
        fullName: fullName,
        network: network,
        contractAddress: contractAddress,
        prefix: prefix,
        suffix: suffix,
        features: features,
        decimalPlaces: decimalPlaces,
        asset: asset,
        isToken: false,
        primaryKeyCurve: primaryKeyCurve,
    }));
}
exports.erc20CompatibleAccountCoin = erc20CompatibleAccountCoin;
/**
 * Factory function for celo token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to CELO main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function celoToken(name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network, primaryKeyCurve) {
    if (features === void 0) { features = AccountCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.main.celo; }
    if (primaryKeyCurve === void 0) { primaryKeyCurve = base_1.KeyCurve.Secp256k1; }
    return Object.freeze(new CeloCoin({
        name: name,
        fullName: fullName,
        network: network,
        contractAddress: contractAddress,
        prefix: prefix,
        suffix: suffix,
        features: features,
        decimalPlaces: decimalPlaces,
        asset: asset,
        isToken: true,
        primaryKeyCurve: primaryKeyCurve,
    }));
}
exports.celoToken = celoToken;
/**
 * Factory function for testnet celo token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet CELO network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function tceloToken(name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network) {
    if (features === void 0) { features = AccountCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.test.celo; }
    return celoToken(name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network);
}
exports.tceloToken = tceloToken;
/**
 * Factory function for Stellar token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param domain Domain of the token issuer (used to access token information from the issuer's stellar.toml file)
 * See https://www.stellar.org/developers/guides/concepts/stellar-toml.html
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Stellar mainnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function stellarToken(name, fullName, decimalPlaces, asset, domain, features, prefix, suffix, network, primaryKeyCurve) {
    if (domain === void 0) { domain = ''; }
    if (features === void 0) { features = AccountCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.main.stellar; }
    if (primaryKeyCurve === void 0) { primaryKeyCurve = base_1.KeyCurve.Ed25519; }
    return Object.freeze(new StellarCoin({
        name: name,
        fullName: fullName,
        decimalPlaces: decimalPlaces,
        asset: asset,
        domain: domain,
        features: features,
        prefix: prefix,
        suffix: suffix,
        network: network,
        isToken: true,
        primaryKeyCurve: primaryKeyCurve,
    }));
}
exports.stellarToken = stellarToken;
/**
 * Factory function for testnet Stellar token instances.
 *
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param domain Domain of the token issuer (used to access token information from the issuer's stellar.toml file)
 * See https://www.stellar.org/developers/guides/concepts/stellar-toml.html
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Stellar testnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function tstellarToken(name, fullName, decimalPlaces, asset, domain, features, prefix, suffix, network) {
    if (domain === void 0) { domain = ''; }
    if (features === void 0) { features = AccountCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.test.stellar; }
    return stellarToken(name, fullName, decimalPlaces, asset, domain, features, prefix, suffix, network);
}
exports.tstellarToken = tstellarToken;
/**
 * Factory function for Hedera coin instances
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param nodeAccountId node account Id from which the transaction will be sent
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Hedera mainnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function hederaCoin(name, fullName, network, decimalPlaces, asset, nodeAccountId, features, prefix, suffix, primaryKeyCurve) {
    if (nodeAccountId === void 0) { nodeAccountId = '0.0.3'; }
    if (features === void 0) { features = AccountCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.toUpperCase(); }
    if (primaryKeyCurve === void 0) { primaryKeyCurve = base_1.KeyCurve.Ed25519; }
    return Object.freeze(new HederaCoin({
        name: name,
        fullName: fullName,
        decimalPlaces: decimalPlaces,
        asset: asset,
        nodeAccountId: nodeAccountId,
        features: features,
        prefix: prefix,
        suffix: suffix,
        network: network,
        isToken: false,
        primaryKeyCurve: primaryKeyCurve,
    }));
}
exports.hederaCoin = hederaCoin;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3VudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hY2NvdW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLCtCQUFvRjtBQUNwRixtQ0FBMkU7QUFDM0UsdUNBQXNEO0FBZXREOzs7Ozs7R0FNRztBQUNIO0lBQWlDLCtCQUFRO0lBVXZDLHFCQUFZLE9BQWtDO1FBQTlDLFlBQ0Usd0NBQ0ssT0FBTyxLQUNWLElBQUksRUFBRSxlQUFRLENBQUMsTUFBTSxJQUNyQixTQUdIO1FBREMsS0FBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDOztJQUNqQyxDQUFDO0lBRVMsc0NBQWdCLEdBQTFCO1FBQ0UsT0FBTyxJQUFJLEdBQUcsQ0FBYyxDQUFDLGtCQUFXLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRVMsd0NBQWtCLEdBQTVCO1FBQ0UsT0FBTyxJQUFJLEdBQUcsQ0FBYyxDQUFDLGtCQUFXLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBeEJzQiw0QkFBZ0IsR0FBRztRQUN4QyxrQkFBVyxDQUFDLGFBQWE7UUFDekIsa0JBQVcsQ0FBQyxtQkFBbUI7UUFDL0Isa0JBQVcsQ0FBQyxrQkFBa0I7UUFDOUIsa0JBQVcsQ0FBQyxnQkFBZ0I7S0FDN0IsQ0FBQztJQW9CSixrQkFBQztDQUFBLEFBMUJELENBQWlDLGVBQVEsR0EwQnhDO0FBMUJZLGtDQUFXO0FBNEN4QjtJQUFzQyxvQ0FBVztJQUMvQywwQkFBWSxPQUFrQztlQUM1QywrQkFDSyxPQUFPLEVBQ1Y7SUFDSixDQUFDO0lBQ0gsdUJBQUM7QUFBRCxDQUFDLEFBTkQsQ0FBc0MsV0FBVyxHQU1oRDtBQU5ZLDRDQUFnQjtBQVE3Qjs7O0dBR0c7QUFDSDtJQUFpRCwrQ0FBZ0I7SUFHL0QscUNBQVksT0FBZ0M7UUFBNUMsWUFDRSwrQkFDSyxPQUFPLEVBQ1Ys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QkFBQSxFQUFBLFVBQTBCLG1CQUFRLENBQUMsSUFBSSxDQUFDLE9BQU87SUFFL0MsT0FBTyxZQUFZLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztBQUN2RyxDQUFDO0FBWkQsc0NBWUM7QUFFRDs7Ozs7Ozs7Ozs7OztHQWFHO0FBQ0gsU0FBZ0IsVUFBVSxDQUN4QixJQUFZLEVBQ1osUUFBZ0IsRUFDaEIsT0FBdUIsRUFDdkIsYUFBcUIsRUFDckIsS0FBc0IsRUFDdEIsYUFBK0IsRUFDL0IsUUFBc0QsRUFDdEQsTUFBbUIsRUFDbkIsTUFBbUMsRUFDbkMsZUFBNEM7SUFKNUMsOEJBQUEsRUFBQSx1QkFBK0I7SUFDL0IseUJBQUEsRUFBQSxXQUEwQixXQUFXLENBQUMsZ0JBQWdCO0lBQ3RELHVCQUFBLEVBQUEsV0FBbUI7SUFDbkIsdUJBQUEsRUFBQSxTQUFpQixJQUFJLENBQUMsV0FBVyxFQUFFO0lBQ25DLGdDQUFBLEVBQUEsa0JBQTRCLGVBQVEsQ0FBQyxPQUFPO0lBRTVDLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FDbEIsSUFBSSxVQUFVLENBQUM7UUFDYixJQUFJLE1BQUE7UUFDSixRQUFRLFVBQUE7UUFDUixhQUFhLGVBQUE7UUFDYixLQUFLLE9BQUE7UUFDTCxhQUFhLGVBQUE7UUFDYixRQUFRLFVBQUE7UUFDUixNQUFNLFFBQUE7UUFDTixNQUFNLFFBQUE7UUFDTixPQUFPLFNBQUE7UUFDUCxPQUFPLEVBQUUsS0FBSztRQUNkLGVBQWUsaUJBQUE7S0FDaEIsQ0FBQyxDQUNILENBQUM7QUFDSixDQUFDO0FBM0JELGdDQTJCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDb2luLCBDb2luRmVhdHVyZSwgQ29pbktpbmQsIEtleUN1cnZlLCBVbmRlcmx5aW5nQXNzZXQgfSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgSW52YWxpZENvbnRyYWN0QWRkcmVzc0Vycm9yLCBJbnZhbGlkRG9tYWluRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBBY2NvdW50TmV0d29yaywgTmV0d29ya3MgfSBmcm9tICcuL25ldHdvcmtzJztcblxuZXhwb3J0IGludGVyZmFjZSBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zIHtcbiAgZnVsbE5hbWU6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yaztcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldDtcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW107XG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcjtcbiAgaXNUb2tlbjogYm9vbGVhbjtcbiAgcHJlZml4Pzogc3RyaW5nO1xuICBzdWZmaXg/OiBzdHJpbmc7XG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmU7XG59XG5cbi8qKlxuICogQWNjb3VudCBiYXNlZCBjb2lucywgc3VjaCBhcyBFdGhlcmV1bSwgU3RlbGxhciwgb3IgWFJQLlxuICpcbiAqIFRoZXNlIHR5cGVzIG9mIGNvaW5zIG1haW50YWluIGFuIFwiYWNjb3VudCBiYWxhbmNlXCIgZm9yIGVhY2ggYWRkcmVzcyBvbiB0aGUgbmV0d29yayxcbiAqIGFzIG9wcG9zZWQgdG8gdGhlIHVuc3BlbnQgdHJhbnNhY3Rpb24gb3V0cHV0IG1vZGVsIHdoaWNoIG1haW50YWlucyBhIHJlY29yZCBvZiBhbGxcbiAqIFwicGllY2VzXCIgb2YgY29pbiB3aGljaCBiZWxvbmcgdG8gYW4gYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFjY291bnRDb2luIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfRkVBVFVSRVMgPSBbXG4gICAgQ29pbkZlYXR1cmUuQUNDT1VOVF9NT0RFTCxcbiAgICBDb2luRmVhdHVyZS5SRVFVSVJFU19CSUdfTlVNQkVSLFxuICAgIENvaW5GZWF0dXJlLlZBTFVFTEVTU19UUkFOU0ZFUixcbiAgICBDb2luRmVhdHVyZS5UUkFOU0FDVElPTl9EQVRBLFxuICBdO1xuXG4gIHB1YmxpYyByZWFkb25seSBuZXR3b3JrOiBBY2NvdW50TmV0d29yaztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGtpbmQ6IENvaW5LaW5kLkNSWVBUTyxcbiAgICB9KTtcblxuICAgIHRoaXMubmV0d29yayA9IG9wdGlvbnMubmV0d29yaztcbiAgfVxuXG4gIHByb3RlY3RlZCByZXF1aXJlZEZlYXR1cmVzKCk6IFNldDxDb2luRmVhdHVyZT4ge1xuICAgIHJldHVybiBuZXcgU2V0PENvaW5GZWF0dXJlPihbQ29pbkZlYXR1cmUuQUNDT1VOVF9NT0RFTF0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGRpc2FsbG93ZWRGZWF0dXJlcygpOiBTZXQ8Q29pbkZlYXR1cmU+IHtcbiAgICByZXR1cm4gbmV3IFNldDxDb2luRmVhdHVyZT4oW0NvaW5GZWF0dXJlLlVOU1BFTlRfTU9ERUxdKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVyYzIwQ29uc3RydWN0b3JPcHRpb25zIGV4dGVuZHMgQWNjb3VudENvbnN0cnVjdG9yT3B0aW9ucyB7XG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0ZWxsYXJDb2luQ29uc3RydWN0b3JPcHRpb25zIGV4dGVuZHMgQWNjb3VudENvbnN0cnVjdG9yT3B0aW9ucyB7XG4gIGRvbWFpbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhlZGVyYUNvaW5Db25zdHJ1Y3Rvck9wdGlvbnMgZXh0ZW5kcyBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zIHtcbiAgbm9kZUFjY291bnRJZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRyYWN0QWRkcmVzcyBleHRlbmRzIFN0cmluZyB7XG4gIF9fY29udHJhY3RhZGRyZXNzX3BoYW50b21fXzogbmV2ZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBBY2NvdW50Q29pblRva2VuIGV4dGVuZHMgQWNjb3VudENvaW4ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFNvbWUgYmxvY2tjaGFpbnMgc3VwcG9ydCB0b2tlbnMgd2hpY2ggYXJlIGRlZmluZWQgYnkgYW4gYWRkcmVzcyBhdCB3aGljaCB0aGV5IGhhdmUgYSBzbWFydCBjb250cmFjdCBkZXBsb3llZC5cbiAqIEV4YW1wbGVzIGFyZSBFUkMyMCB0b2tlbnMsIGFuZCB0aGUgZXF1aXZhbGVudCBvbiBvdGhlciBjaGFpbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4gZXh0ZW5kcyBBY2NvdW50Q29pblRva2VuIHtcbiAgcHVibGljIGNvbnRyYWN0QWRkcmVzczogQ29udHJhY3RBZGRyZXNzO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEVyYzIwQ29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIC8vIHZhbGlkIEVSQyAyMCBjb250cmFjdCBhZGRyZXNzZXMgYXJlIFwiMHhcIiBmb2xsb3dlZCBieSA0MCBsb3dlcmNhc2UgaGV4IGNoYXJhY3RlcnNcbiAgICBpZiAoIW9wdGlvbnMuY29udHJhY3RBZGRyZXNzLm1hdGNoKC9eMHhbYS1mMC05XXs0MH0kLykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQ29udHJhY3RBZGRyZXNzRXJyb3Iob3B0aW9ucy5uYW1lLCBvcHRpb25zLmNvbnRyYWN0QWRkcmVzcyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cmFjdEFkZHJlc3MgPSAob3B0aW9ucy5jb250cmFjdEFkZHJlc3MgYXMgdW5rbm93bikgYXMgQ29udHJhY3RBZGRyZXNzO1xuICB9XG59XG5cbi8qKlxuICogRVJDIDIwIGlzIGEgdG9rZW4gc3RhbmRhcmQgZm9yIHRoZSBFdGhlcmV1bSBibG9ja2NoYWluLiBUaGV5IGFyZSBzaW1pbGFyIHRvIG90aGVyIGFjY291bnQgY29pbnMsIGJ1dCBoYXZlIGFcbiAqIGNvbnRyYWN0IGFkZHJlc3MgcHJvcGVydHkgd2hpY2ggaWRlbnRpZmllcyB0aGUgc21hcnQgY29udHJhY3Qgd2hpY2ggZGVmaW5lcyB0aGUgdG9rZW4uXG4gKi9cbmV4cG9ydCBjbGFzcyBFcmMyMENvaW4gZXh0ZW5kcyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4ge31cblxuLyoqXG4gKiBTb21lIGJsb2NrY2hhaW5zIGhhdmUgbmF0aXZlIGNvaW5zIHdoaWNoIGFsc28gc3VwcG9ydCB0aGUgRVJDMjAgaW50ZXJmYWNlIHN1Y2ggYXMgQ0VMTy5cbiAqL1xuZXhwb3J0IGNsYXNzIEVyYzIwQ29tcGF0aWJsZUFjY291bnRDb2luIGV4dGVuZHMgQ29udHJhY3RBZGRyZXNzRGVmaW5lZFRva2VuIHtcbiAgY29uc3RydWN0b3Iob3B0aW9uczogRXJjMjBDb25zdHJ1Y3Rvck9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgLy8gVGhlc2UgY29pbnMgc2hvdWxkIG5vdCBiZSBjbGFzc2lmaWVkIGFzIHRva2VucyBhcyB0aGV5IGFyZSBub3QgY2hpbGRyZW4gb2Ygb3RoZXIgY29pbnNcbiAgICAgIGlzVG9rZW46IGZhbHNlLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogVGhlIENFTE8gYmxvY2tjaGFpbiBzdXBwb3J0cyB0b2tlbnMgb2YgdGhlIEVSQzIwIHN0YW5kYXJkIHNpbWlsYXIgdG8gRVRIIEVSQzIwIHRva2Vucy5cbiAqL1xuZXhwb3J0IGNsYXNzIENlbG9Db2luIGV4dGVuZHMgQ29udHJhY3RBZGRyZXNzRGVmaW5lZFRva2VuIHt9XG5cbi8qKlxuICogVGhlIFN0ZWxsYXIgbmV0d29yayBzdXBwb3J0cyB0b2tlbnMgKG5vbi1uYXRpdmUgYXNzZXRzKVxuICogWExNIGlzIGFsc28ga25vd24gYXMgdGhlIG5hdGl2ZSBhc3NldC5cbiAqIFN0ZWxsYXIgdG9rZW5zIHdvcmsgc2ltaWxhciB0byBYTE0sIGJ1dCB0aGUgdG9rZW4gbmFtZSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBjaGFpbixcbiAqIHRoZSB0b2tlbiBjb2RlIGFuZCB0aGUgaXNzdWVyIGFjY291bnQgaW4gdGhlIGZvcm06ICh0KXhsbTo8dG9rZW4+LTxpc3N1ZXI+XG4gKi9cbmV4cG9ydCBjbGFzcyBTdGVsbGFyQ29pbiBleHRlbmRzIEFjY291bnRDb2luVG9rZW4ge1xuICBwdWJsaWMgZG9tYWluOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogU3RlbGxhckNvaW5Db25zdHJ1Y3Rvck9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuXG4gICAgY29uc3QgZG9tYWluUGF0dGVybiA9IC9eKD86W2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/XFwuKStbYS16MC05XVthLXowLTktXXswLDYxfVthLXowLTldJC87XG4gICAgaWYgKG9wdGlvbnMuZG9tYWluICE9PSAnJyAmJiAhb3B0aW9ucy5kb21haW4ubWF0Y2goZG9tYWluUGF0dGVybikpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRG9tYWluRXJyb3Iob3B0aW9ucy5uYW1lLCBvcHRpb25zLmRvbWFpbik7XG4gICAgfVxuXG4gICAgdGhpcy5kb21haW4gPSBvcHRpb25zLmRvbWFpbiBhcyBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgSGVkZXJhIGNvaW4gbmVlZHMgYSBjbGllbnQgc2V0IHdpdGggdGhlIG5vZGUgYWNjb3VudCBJZC5cbiAqIEl0J3MgYW4gYWNjb3VudCBiYXNlZCBjb2luIHRoYXQgbmVlZHMgdGhlIG5vZGUgYWNjb3VudCBJRFxuICogd2hlcmUgdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgc2VudC5cbiAqL1xuZXhwb3J0IGNsYXNzIEhlZGVyYUNvaW4gZXh0ZW5kcyBBY2NvdW50Q29pblRva2VuIHtcbiAgcHVibGljIG5vZGVBY2NvdW50SWQ6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBIZWRlcmFDb2luQ29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIHRoaXMubm9kZUFjY291bnRJZCA9IG9wdGlvbnMubm9kZUFjY291bnRJZDtcbiAgfVxufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGFjY291bnQgY29pbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gYWNjb3VudChcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azEsXG4gIHByZWZpeDogc3RyaW5nID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBpc1Rva2VuOiBib29sZWFuID0gZmFsc2Vcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgQWNjb3VudENvaW4oe1xuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGVyYzIwIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIEV0aGVyZXVtIG1haW4gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcmMyMChcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeDogc3RyaW5nID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLm1haW4uZXRoZXJldW0sXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgRXJjMjBDb2luKHtcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IGVyYzIwIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIHRoZSBLb3ZhbiB0ZXN0IG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXJjMjAoXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXg6IHN0cmluZyA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0LmtvdmFuXG4pIHtcbiAgcmV0dXJuIGVyYzIwKG5hbWUsIGZ1bGxOYW1lLCBkZWNpbWFsUGxhY2VzLCBjb250cmFjdEFkZHJlc3MsIGFzc2V0LCBmZWF0dXJlcywgcHJlZml4LCBzdWZmaXgsIG5ldHdvcmspO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIEVSQzIwLWNvbXBhdGlibGUgYWNjb3VudCBjb2luIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVyYzIwQ29tcGF0aWJsZUFjY291bnRDb2luKFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeDogc3RyaW5nID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEVyYzIwQ29tcGF0aWJsZUFjY291bnRDb2luKHtcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIGlzVG9rZW46IGZhbHNlLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgY2VsbyB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byBDRUxPIG1haW4gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjZWxvVG9rZW4oXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXg6IHN0cmluZyA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmNlbG8sXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgQ2Vsb0NvaW4oe1xuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgY2VsbyB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byB0aGUgdGVzdG5ldCBDRUxPIG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0Y2Vsb1Rva2VuKFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4OiBzdHJpbmcgPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrID0gTmV0d29ya3MudGVzdC5jZWxvXG4pIHtcbiAgcmV0dXJuIGNlbG9Ub2tlbihuYW1lLCBmdWxsTmFtZSwgZGVjaW1hbFBsYWNlcywgY29udHJhY3RBZGRyZXNzLCBhc3NldCwgZmVhdHVyZXMsIHByZWZpeCwgc3VmZml4LCBuZXR3b3JrKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBTdGVsbGFyIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBkb21haW4gRG9tYWluIG9mIHRoZSB0b2tlbiBpc3N1ZXIgKHVzZWQgdG8gYWNjZXNzIHRva2VuIGluZm9ybWF0aW9uIGZyb20gdGhlIGlzc3VlcidzIHN0ZWxsYXIudG9tbCBmaWxlKVxuICogU2VlIGh0dHBzOi8vd3d3LnN0ZWxsYXIub3JnL2RldmVsb3BlcnMvZ3VpZGVzL2NvbmNlcHRzL3N0ZWxsYXItdG9tbC5odG1sXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIFN0ZWxsYXIgbWFpbm5ldC5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGVsbGFyVG9rZW4oXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBkb21haW46IHN0cmluZyA9ICcnLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeDogc3RyaW5nID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLm1haW4uc3RlbGxhcixcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLkVkMjU1MTlcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgU3RlbGxhckNvaW4oe1xuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgZG9tYWluLFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBuZXR3b3JrLFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgU3RlbGxhciB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gZG9tYWluIERvbWFpbiBvZiB0aGUgdG9rZW4gaXNzdWVyICh1c2VkIHRvIGFjY2VzcyB0b2tlbiBpbmZvcm1hdGlvbiBmcm9tIHRoZSBpc3N1ZXIncyBzdGVsbGFyLnRvbWwgZmlsZSlcbiAqIFNlZSBodHRwczovL3d3dy5zdGVsbGFyLm9yZy9kZXZlbG9wZXJzL2d1aWRlcy9jb25jZXB0cy9zdGVsbGFyLXRvbWwuaHRtbFxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byBTdGVsbGFyIHRlc3RuZXQuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0c3RlbGxhclRva2VuKFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZG9tYWluOiBzdHJpbmcgPSAnJyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXg6IHN0cmluZyA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0LnN0ZWxsYXJcbikge1xuICByZXR1cm4gc3RlbGxhclRva2VuKG5hbWUsIGZ1bGxOYW1lLCBkZWNpbWFsUGxhY2VzLCBhc3NldCwgZG9tYWluLCBmZWF0dXJlcywgcHJlZml4LCBzdWZmaXgsIG5ldHdvcmspO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIEhlZGVyYSBjb2luIGluc3RhbmNlc1xuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gbm9kZUFjY291bnRJZCBub2RlIGFjY291bnQgSWQgZnJvbSB3aGljaCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBiZSBzZW50XG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIEhlZGVyYSBtYWlubmV0LlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhlZGVyYUNvaW4oXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmssXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgbm9kZUFjY291bnRJZDogc3RyaW5nID0gJzAuMC4zJyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXg6IHN0cmluZyA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLkVkMjU1MTlcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgSGVkZXJhQ29pbih7XG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgYXNzZXQsXG4gICAgICBub2RlQWNjb3VudElkLFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBuZXR3b3JrLFxuICAgICAgaXNUb2tlbjogZmFsc2UsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgfSlcbiAgKTtcbn1cbiJdfQ==