"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tofcerc20 = exports.ofcerc20 = exports.tofc = exports.ofc = exports.OfcCoin = void 0;
var base_1 = require("./base");
var networks_1 = require("./networks");
/**
 * OFC (off chain) coins. These are virtual coins used to represent off chain assets on the BitGo platform.
 */
var OfcCoin = /** @class */ (function (_super) {
    __extends(OfcCoin, _super);
    function OfcCoin(options) {
        var _this = this;
        var addressCoin = options.addressCoin, baseOptions = __rest(options, ["addressCoin"]);
        _this = _super.call(this, baseOptions) || this;
        _this.addressCoin = addressCoin;
        return _this;
    }
    OfcCoin.prototype.requiredFeatures = function () {
        return new Set([base_1.CoinFeature.ACCOUNT_MODEL, base_1.CoinFeature.REQUIRES_BIG_NUMBER]);
    };
    OfcCoin.prototype.disallowedFeatures = function () {
        return new Set([
            base_1.CoinFeature.UNSPENT_MODEL,
            base_1.CoinFeature.CHILD_PAYS_FOR_PARENT,
            base_1.CoinFeature.NATIVE_SEGWIT,
            base_1.CoinFeature.PAYGO,
            base_1.CoinFeature.WRAPPED_SEGWIT,
            base_1.CoinFeature.SUPPORTS_TOKENS,
        ]);
    };
    OfcCoin.DEFAULT_FEATURES = [base_1.CoinFeature.ACCOUNT_MODEL, base_1.CoinFeature.REQUIRES_BIG_NUMBER];
    return OfcCoin;
}(base_1.BaseCoin));
exports.OfcCoin = OfcCoin;
/**
 * Factory function for ofc coin instances.
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofc(name, fullName, decimalPlaces, asset, kind, features, prefix, suffix, network, isToken, 
/** OFC tokens use SECP256K1 under the hood even if the chain doesn't **/
primaryKeyCurve) {
    if (kind === void 0) { kind = base_1.CoinKind.CRYPTO; }
    if (features === void 0) { features = OfcCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.replace(/^ofc/, '').toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.main.ofc; }
    if (isToken === void 0) { isToken = true; }
    if (primaryKeyCurve === void 0) { primaryKeyCurve = base_1.KeyCurve.Secp256k1; }
    return Object.freeze(new OfcCoin({
        name: name,
        fullName: fullName,
        network: network,
        prefix: prefix,
        suffix: suffix,
        features: features,
        decimalPlaces: decimalPlaces,
        isToken: isToken,
        asset: asset,
        kind: kind,
        primaryKeyCurve: primaryKeyCurve,
    }));
}
exports.ofc = ofc;
/**
 * Factory function for testnet ofc coin instances.
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofc(name, fullName, decimalPlaces, asset, kind, features, prefix, suffix, network, isToken, primaryKeyCurve) {
    if (kind === void 0) { kind = base_1.CoinKind.CRYPTO; }
    if (features === void 0) { features = OfcCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.replace(/^ofc/, '').toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.test.ofc; }
    if (isToken === void 0) { isToken = true; }
    if (primaryKeyCurve === void 0) { primaryKeyCurve = base_1.KeyCurve.Secp256k1; }
    return Object.freeze(new OfcCoin({
        name: name,
        fullName: fullName,
        network: network,
        prefix: prefix,
        suffix: suffix,
        features: features,
        decimalPlaces: decimalPlaces,
        isToken: isToken,
        asset: asset,
        kind: kind,
        primaryKeyCurve: primaryKeyCurve,
    }));
}
exports.tofc = tofc;
/**
 * Factory function for ofc erc20 coin instances.
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcerc20(name, fullName, decimalPlaces, asset, kind, features, prefix, suffix, network, isToken, addressCoin, primaryKeyCurve) {
    if (kind === void 0) { kind = base_1.CoinKind.CRYPTO; }
    if (features === void 0) { features = OfcCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.replace(/^ofc/, '').toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.main.ofc; }
    if (isToken === void 0) { isToken = true; }
    if (addressCoin === void 0) { addressCoin = 'eth'; }
    if (primaryKeyCurve === void 0) { primaryKeyCurve = base_1.KeyCurve.Secp256k1; }
    return Object.freeze(new OfcCoin({
        name: name,
        fullName: fullName,
        network: network,
        prefix: prefix,
        suffix: suffix,
        features: features,
        decimalPlaces: decimalPlaces,
        isToken: isToken,
        asset: asset,
        kind: kind,
        addressCoin: addressCoin,
        primaryKeyCurve: primaryKeyCurve,
    }));
}
exports.ofcerc20 = ofcerc20;
/**
 * Factory function for testnet ofc erc20 coin instances.
 *
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcerc20(name, fullName, decimalPlaces, asset, kind, features, prefix, suffix, network, isToken, addressCoin, primaryKeyCurve) {
    if (kind === void 0) { kind = base_1.CoinKind.CRYPTO; }
    if (features === void 0) { features = OfcCoin.DEFAULT_FEATURES; }
    if (prefix === void 0) { prefix = ''; }
    if (suffix === void 0) { suffix = name.replace(/^ofc/, '').toUpperCase(); }
    if (network === void 0) { network = networks_1.Networks.test.ofc; }
    if (isToken === void 0) { isToken = true; }
    if (addressCoin === void 0) { addressCoin = 'teth'; }
    if (primaryKeyCurve === void 0) { primaryKeyCurve = base_1.KeyCurve.Secp256k1; }
    return Object.freeze(new OfcCoin({
        name: name,
        fullName: fullName,
        network: network,
        prefix: prefix,
        suffix: suffix,
        features: features,
        decimalPlaces: decimalPlaces,
        isToken: isToken,
        asset: asset,
        kind: kind,
        addressCoin: addressCoin,
        primaryKeyCurve: primaryKeyCurve,
    }));
}
exports.tofcerc20 = tofcerc20;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2ZjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL29mYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQkFBb0Y7QUFDcEYsdUNBQStEO0FBaUIvRDs7R0FFRztBQUNIO0lBQTZCLDJCQUFRO0lBTW5DLGlCQUFZLE9BQThCO1FBQTFDLGlCQUlDO1FBSFMsSUFBQSxXQUFXLEdBQXFCLE9BQU8sWUFBNUIsRUFBSyxXQUFXLFVBQUssT0FBTyxFQUF6QyxlQUErQixDQUFGLENBQWE7UUFDaEQsUUFBQSxrQkFBTSxXQUFXLENBQUMsU0FBQztRQUNuQixLQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQzs7SUFDakMsQ0FBQztJQUVTLGtDQUFnQixHQUExQjtRQUNFLE9BQU8sSUFBSSxHQUFHLENBQWMsQ0FBQyxrQkFBVyxDQUFDLGFBQWEsRUFBRSxrQkFBVyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQztJQUM1RixDQUFDO0lBRVMsb0NBQWtCLEdBQTVCO1FBQ0UsT0FBTyxJQUFJLEdBQUcsQ0FBYztZQUMxQixrQkFBVyxDQUFDLGFBQWE7WUFDekIsa0JBQVcsQ0FBQyxxQkFBcUI7WUFDakMsa0JBQVcsQ0FBQyxhQUFhO1lBQ3pCLGtCQUFXLENBQUMsS0FBSztZQUNqQixrQkFBVyxDQUFDLGNBQWM7WUFDMUIsa0JBQVcsQ0FBQyxlQUFlO1NBQzVCLENBQUMsQ0FBQztJQUNMLENBQUM7SUF4QnNCLHdCQUFnQixHQUFHLENBQUMsa0JBQVcsQ0FBQyxhQUFhLEVBQUUsa0JBQVcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0lBeUJ6RyxjQUFDO0NBQUEsQUExQkQsQ0FBNkIsZUFBUSxHQTBCcEM7QUExQlksMEJBQU87QUE0QnBCOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBQ0gsU0FBZ0IsR0FBRyxDQUNqQixJQUFZLEVBQ1osUUFBZ0IsRUFDaEIsYUFBcUIsRUFDckIsS0FBc0IsRUFDdEIs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QU8sU0FBQTtRQUNQLE1BQU0sUUFBQTtRQUNOLE1BQU0sUUFBQTtRQUNOLFFBQVEsVUFBQTtRQUNSLGFBQWEsZUFBQTtRQUNiLE9BQU8sU0FBQTtRQUNQLEtBQUssT0FBQTtRQUNMLElBQUksTUFBQTtRQUNKLFdBQVcsYUFBQTtRQUNYLGVBQWUsaUJBQUE7S0FDaEIsQ0FBQyxDQUNILENBQUM7QUFDSixDQUFDO0FBOUJELDhCQThCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDb2luLCBDb2luRmVhdHVyZSwgQ29pbktpbmQsIEtleUN1cnZlLCBVbmRlcmx5aW5nQXNzZXQgfSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgQmFzZU5ldHdvcmssIE5ldHdvcmtzLCBPZmNOZXR3b3JrIH0gZnJvbSAnLi9uZXR3b3Jrcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT2ZjQ29uc3RydWN0b3JPcHRpb25zIHtcbiAgZnVsbE5hbWU6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBuZXR3b3JrOiBCYXNlTmV0d29yaztcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldDtcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW107XG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcjtcbiAgaXNUb2tlbjogYm9vbGVhbjtcbiAga2luZDogQ29pbktpbmQ7XG4gIHByZWZpeD86IHN0cmluZztcbiAgc3VmZml4Pzogc3RyaW5nO1xuICBhZGRyZXNzQ29pbj86IHN0cmluZztcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZTtcbn1cblxuLyoqXG4gKiBPRkMgKG9mZiBjaGFpbikgY29pbnMuIFRoZXNlIGFyZSB2aXJ0dWFsIGNvaW5zIHVzZWQgdG8gcmVwcmVzZW50IG9mZiBjaGFpbiBhc3NldHMgb24gdGhlIEJpdEdvIHBsYXRmb3JtLlxuICovXG5leHBvcnQgY2xhc3MgT2ZjQ29pbiBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBERUZBVUxUX0ZFQVRVUkVTID0gW0NvaW5GZWF0dXJlLkFDQ09VTlRfTU9ERUwsIENvaW5GZWF0dXJlLlJFUVVJUkVTX0JJR19OVU1CRVJdO1xuXG4gIC8vIElmIHNldCwgdGhpcyBjb2luIGlzIHRoZSBuYXRpdmUgYWRkcmVzcyBmb3JtYXQgZm9yIHRoaXMgdG9rZW4uXG4gIHB1YmxpYyByZWFkb25seSBhZGRyZXNzQ29pbj86IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBPZmNDb25zdHJ1Y3Rvck9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFkZHJlc3NDb2luLCAuLi5iYXNlT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICBzdXBlcihiYXNlT3B0aW9ucyk7XG4gICAgdGhpcy5hZGRyZXNzQ29pbiA9IGFkZHJlc3NDb2luO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlcXVpcmVkRmVhdHVyZXMoKTogU2V0PENvaW5GZWF0dXJlPiB7XG4gICAgcmV0dXJuIG5ldyBTZXQ8Q29pbkZlYXR1cmU+KFtDb2luRmVhdHVyZS5BQ0NPVU5UX01PREVMLCBDb2luRmVhdHVyZS5SRVFVSVJFU19CSUdfTlVNQkVSXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZGlzYWxsb3dlZEZlYXR1cmVzKCk6IFNldDxDb2luRmVhdHVyZT4ge1xuICAgIHJldHVybiBuZXcgU2V0PENvaW5GZWF0dXJlPihbXG4gICAgICBDb2luRmVhdHVyZS5VTlNQRU5UX01PREVMLFxuICAgICAgQ29pbkZlYXR1cmUuQ0hJTERfUEFZU19GT1JfUEFSRU5ULFxuICAgICAgQ29pbkZlYXR1cmUuTkFUSVZFX1NFR1dJVCxcbiAgICAgIENvaW5GZWF0dXJlLlBBWUdPLFxuICAgICAgQ29pbkZlYXR1cmUuV1JBUFBFRF9TRUdXSVQsXG4gICAgICBDb2luRmVhdHVyZS5TVVBQT1JUU19UT0tFTlMsXG4gICAgXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBvZmMgY29pbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gb2ZjKFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXg6IHN0cmluZyA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUucmVwbGFjZSgvXm9mYy8sICcnKS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MubWFpbi5vZmMsXG4gIGlzVG9rZW46IGJvb2xlYW4gPSB0cnVlLFxuICAvKiogT0ZDIHRva2VucyB1c2UgU0VDUDI1NksxIHVuZGVyIHRoZSBob29kIGV2ZW4gaWYgdGhlIGNoYWluIGRvZXNuJ3QgKiovXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgb2ZjIGNvaW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIGNvaW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIGNvaW4gc3VmZml4LiBEZWZhdWx0cyB0byBjb2luIG5hbWUuXG4gKiBAcGFyYW0gaXNUb2tlbj8gV2hldGhlciBvciBub3QgdGhpcyBhY2NvdW50IGNvaW4gaXMgYSB0b2tlbiBvZiBhbm90aGVyIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBPZmNDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvZmMoXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeDogc3RyaW5nID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS5yZXBsYWNlKC9eb2ZjLywgJycpLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IE9mY05ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0Lm9mYyxcbiAgaXNUb2tlbjogYm9vbGVhbiA9IHRydWUsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIG9mYyBlcmMyMCBjb2luIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZmNlcmMyMChcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4OiBzdHJpbmcgPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLm1haW4ub2ZjLFxuICBpc1Rva2VuOiBib29sZWFuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW46IHN0cmluZyA9ICdldGgnLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICB9KVxuICApO1xufVxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IG9mYyBlcmMyMCBjb2luIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b2ZjZXJjMjAoXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeDogc3RyaW5nID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS5yZXBsYWNlKC9eb2ZjLywgJycpLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IE9mY05ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0Lm9mYyxcbiAgaXNUb2tlbjogYm9vbGVhbiA9IHRydWUsXG4gIGFkZHJlc3NDb2luOiBzdHJpbmcgPSAndGV0aCcsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIGFkZHJlc3NDb2luLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgIH0pXG4gICk7XG59XG4iXX0=