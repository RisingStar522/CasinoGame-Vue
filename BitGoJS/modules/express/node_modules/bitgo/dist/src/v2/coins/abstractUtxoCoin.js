"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var unspents_1 = require("@bitgo/unspents");
var codes_1 = require("@bitgo/unspents/dist/codes");
var bitcoin = require("@bitgo/utxo-lib");
var bitcoinMessage = require("bitcoinjs-message");
var Bluebird = require("bluebird");
var crypto_1 = require("crypto");
var debugLib = require("debug");
var _ = require("lodash");
var request = require("superagent");
var bitcoin_1 = require("../../bitcoin");
var config = require("../../config");
var errors = require("../../errors");
var baseCoin_1 = require("../baseCoin");
var parseOutput_1 = require("../internal/parseOutput");
var keychains_1 = require("../keychains");
var promise_utils_1 = require("../promise-utils");
var recovery_1 = require("../recovery");
var debug = debugLib('bitgo:v2:utxo');
var co = Bluebird.coroutine;
var AbstractUtxoCoin = /** @class */ (function (_super) {
    __extends(AbstractUtxoCoin, _super);
    function AbstractUtxoCoin(bitgo, network) {
        var _this = _super.call(this, bitgo) || this;
        if (!_.isObject(network)) {
            throw new Error('network must be an object');
        }
        _this._network = network;
        return _this;
    }
    Object.defineProperty(AbstractUtxoCoin.prototype, "network", {
        get: function () {
            return this._network;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractUtxoCoin, "validAddressTypes", {
        get: function () {
            var validAddressTypes = [];
            // best way I could find to loop over enum values
            // https://github.com/Microsoft/TypeScript/issues/17198#issuecomment-423836658
            // this is a typescript rough corner for sure
            var unspentTypeKeys = Object.keys(codes_1.UnspentType);
            var unspentTypes = unspentTypeKeys
                .map(function (k) { return codes_1.UnspentType[k]; })
                .map(function (v) { return v; });
            for (var _i = 0, unspentTypes_1 = unspentTypes; _i < unspentTypes_1.length; _i++) {
                var addressType = unspentTypes_1[_i];
                try {
                    unspents_1.Codes.forType(addressType);
                    validAddressTypes.push(addressType);
                }
                catch (e) {
                    // Do nothing. Codes.forType will throw if the address type has no chain codes, meaning it is invalid on the
                    // BitGo platform and should not be added to the validAddressTypes array.
                }
            }
            return validAddressTypes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    AbstractUtxoCoin.prototype.getBaseFactor = function () {
        return 1e8;
    };
    /**
     * Get an instance of the library which can be used to perform low-level operations for this coin
     */
    AbstractUtxoCoin.prototype.getCoinLibrary = function () {
        return bitcoin;
    };
    /**
     * Helper to get the version number for an address
     */
    AbstractUtxoCoin.prototype.getAddressVersion = function (address) {
        // try decoding as base58 first
        try {
            var version = this.getCoinLibrary().address.fromBase58Check(address).version;
            return version;
        }
        catch (e) {
            // if that fails, and we aren't supporting p2wsh, then we are done and did not find a version
            if (!this.supportsP2wsh()) {
                return;
            }
        }
        // otherwise, try decoding as bech32
        try {
            var _a = this.getCoinLibrary().address.fromBech32(address), version = _a.version, prefix = _a.prefix;
            if (_.isString(this.network.bech32) && prefix === this.network.bech32) {
                return version;
            }
        }
        catch (e) {
            // ignore errors, just fall through and return undefined
        }
    };
    /**
     * Helper to get the bech32 prefix for an address
     */
    AbstractUtxoCoin.prototype.getAddressPrefix = function (address) {
        // otherwise, try decoding as bech32
        try {
            var prefix = this.getCoinLibrary().address.fromBech32(address).prefix;
            return prefix;
        }
        catch (e) {
            // ignore errors, just fall through and return undefined
        }
    };
    /**
     * Check if an address is valid
     * @param address
     * @param forceAltScriptSupport
     */
    AbstractUtxoCoin.prototype.isValidAddress = function (address, forceAltScriptSupport) {
        if (forceAltScriptSupport === void 0) { forceAltScriptSupport = false; }
        var validVersions = [
            this.network.pubKeyHash,
            this.network.scriptHash,
        ];
        if (this.altScriptHash && (forceAltScriptSupport || this.supportAltScriptDestination)) {
            validVersions.push(this.altScriptHash);
        }
        var addressVersion = this.getAddressVersion(address);
        // the address version needs to be among the valid ones
        var addressVersionValid = _.isNumber(addressVersion) && validVersions.includes(addressVersion);
        var addressPrefix = this.getAddressPrefix(address);
        if (!this.supportsP2wsh() || _.isUndefined(addressPrefix)) {
            return addressVersionValid;
        }
        // address has a potential bech32 prefix, validate that
        return _.isString(this.network.bech32) && this.network.bech32 === addressPrefix;
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    AbstractUtxoCoin.prototype.isValidPub = function (pub) {
        try {
            bitcoin.HDNode.fromBase58(pub);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Get the latest block height
     * @param reqId
     * @param callback
     */
    AbstractUtxoCoin.prototype.getLatestBlockHeight = function (reqId, callback) {
        var self = this;
        return co(function () {
            var chainhead;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (reqId) {
                            this.bitgo._reqId = reqId;
                        }
                        return [4 /*yield*/, self.bitgo.get(self.url('/public/block/latest')).result()];
                    case 1:
                        chainhead = _a.sent();
                        return [2 /*return*/, chainhead.height];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Run custom coin logic after a transaction prebuild has been received from BitGo
     * @param prebuild
     * @param callback
     */
    AbstractUtxoCoin.prototype.postProcessPrebuild = function (prebuild, callback) {
        var self = this;
        return co(function () {
            var transaction, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (_.isUndefined(prebuild.txHex)) {
                            throw new Error('missing required txPrebuild property txHex');
                        }
                        transaction = bitcoin.Transaction.fromHex(prebuild.txHex, self.network);
                        if (!_.isUndefined(prebuild.blockHeight)) return [3 /*break*/, 2];
                        _a = prebuild;
                        return [4 /*yield*/, self.getLatestBlockHeight()];
                    case 1:
                        _a.blockHeight = (_b.sent());
                        _b.label = 2;
                    case 2:
                        // Lock transaction to the next block to discourage fee sniping
                        // See: https://github.com/bitcoin/bitcoin/blob/fb0ac482eee761ec17ed2c11df11e054347a026d/src/wallet/wallet.cpp#L2133
                        transaction.locktime = prebuild.blockHeight;
                        return [2 /*return*/, _.extend({}, prebuild, { txHex: transaction.toHex() })];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Find outputs that are within expected outputs but not within actual outputs, including duplicates
     * @param expectedOutputs
     * @param actualOutputs
     * @returns {Array}
     */
    AbstractUtxoCoin.findMissingOutputs = function (expectedOutputs, actualOutputs) {
        var keyFunc = function (_a) {
            var address = _a.address, amount = _a.amount;
            return address + ":" + Number(amount);
        };
        var groupedOutputs = _.groupBy(expectedOutputs, keyFunc);
        actualOutputs.forEach(function (output) {
            var group = groupedOutputs[keyFunc(output)];
            if (group) {
                group.pop();
            }
        });
        return _.flatten(_.values(groupedOutputs));
    };
    /**
     * Determine an address' type based on its witness and redeem script presence
     * @param addressDetails
     */
    AbstractUtxoCoin.inferAddressType = function (addressDetails) {
        if (_.isObject(addressDetails.coinSpecific)) {
            if (_.isString(addressDetails.coinSpecific.redeemScript) && _.isString(addressDetails.coinSpecific.witnessScript)) {
                return unspents_1.Codes.UnspentTypeTcomb('p2shP2wsh');
            }
            else if (_.isString(addressDetails.coinSpecific.redeemScript)) {
                return unspents_1.Codes.UnspentTypeTcomb('p2sh');
            }
            else if (_.isString(addressDetails.coinSpecific.witnessScript)) {
                return unspents_1.Codes.UnspentTypeTcomb('p2wsh');
            }
        }
        return null;
    };
    /**
     * Extract and fill transaction details such as internal/change spend, external spend (explicit vs. implicit), etc.
     * @param params
     * @param callback
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.parseTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            function fetchKeychains(wallet) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        return [2 /*return*/, promise_utils_1.promiseProps({
                                user: self.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.USER], reqId: reqId }),
                                backup: self.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.BACKUP], reqId: reqId }),
                                bitgo: self.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.BITGO], reqId: reqId }),
                            })];
                    });
                });
            }
            var txParams, txPrebuild, wallet, _a, verification, reqId, disableNetworking, keychains, keychainArray, keySignatures, explanation, allOutputs, expectedOutputs, missingOutputs, customChange, _b, customChangeWalletId, customChangeKeySignatures, customChangeWallet, customChangeKeys, customChangeKeychains, allOutputDetails, needsCustomChangeKeySignatureVerification, changeOutputs, implicitOutputs, explicitOutputs, explicitExternalOutputs, explicitExternalSpendAmount, implicitExternalOutputs, implicitExternalSpendAmount, result;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        txParams = params.txParams, txPrebuild = params.txPrebuild, wallet = params.wallet, _a = params.verification, verification = _a === void 0 ? {} : _a, reqId = params.reqId;
                        if (!_.isUndefined(verification.disableNetworking) && !_.isBoolean(verification.disableNetworking)) {
                            throw new Error('verification.disableNetworking must be a boolean');
                        }
                        disableNetworking = verification.disableNetworking;
                        keychains = verification.keychains;
                        if (!!keychains) return [3 /*break*/, 2];
                        if (disableNetworking) {
                            throw new Error('cannot fetch keychains without networking');
                        }
                        return [4 /*yield*/, fetchKeychains(wallet)];
                    case 1:
                        keychains = _c.sent();
                        _c.label = 2;
                    case 2:
                        if (!keychains || !keychains.user || !keychains.backup || !keychains.bitgo) {
                            throw new Error('keychains are required, but could not be fetched');
                        }
                        keychainArray = [keychains.user, keychains.backup, keychains.bitgo];
                        keySignatures = _.get(wallet, '_wallet.keySignatures');
                        if (_.isUndefined(txPrebuild.txHex)) {
                            throw new Error('missing required txPrebuild property txHex');
                        }
                        return [4 /*yield*/, self.explainTransaction({
                                txHex: txPrebuild.txHex,
                                txInfo: txPrebuild.txInfo,
                            })];
                    case 3:
                        explanation = _c.sent();
                        allOutputs = explanation.outputs.concat(explanation.changeOutputs);
                        expectedOutputs = _.get(txParams, 'recipients', []);
                        missingOutputs = AbstractUtxoCoin.findMissingOutputs(expectedOutputs, allOutputs);
                        _b = (wallet.coinSpecific() || {}).customChangeWalletId, customChangeWalletId = _b === void 0 ? undefined : _b;
                        if (!customChangeWalletId) return [3 /*break*/, 6];
                        customChangeKeySignatures = _.get(wallet, '_wallet.customChangeKeySignatures', {});
                        return [4 /*yield*/, self.wallets().get({ id: customChangeWalletId })];
                    case 4:
                        customChangeWallet = _c.sent();
                        return [4 /*yield*/, fetchKeychains(customChangeWallet)];
                    case 5:
                        customChangeKeys = _c.sent();
                        if (!customChangeKeys) {
                            throw new Error('failed to fetch keychains for custom change wallet');
                        }
                        customChangeKeychains = [customChangeKeys.user, customChangeKeys.backup, customChangeKeys.bitgo];
                        if (customChangeKeychains && customChangeWallet) {
                            customChange = {
                                keys: customChangeKeychains,
                                signatures: [customChangeKeySignatures.user, customChangeKeySignatures.backup, customChangeKeySignatures.bitgo],
                            };
                        }
                        _c.label = 6;
                    case 6: return [4 /*yield*/, Bluebird.map(allOutputs, function (currentOutput) {
                            return parseOutput_1.parseOutput({
                                currentOutput: currentOutput,
                                coin: self,
                                txPrebuild: txPrebuild,
                                verification: verification,
                                keychainArray: keychainArray,
                                wallet: wallet,
                                txParams: txParams,
                                customChange: customChange,
                                reqId: reqId,
                            });
                        })];
                    case 7:
                        allOutputDetails = _c.sent();
                        needsCustomChangeKeySignatureVerification = allOutputDetails.some(function (output) { return output.needsCustomChangeKeySignatureVerification; });
                        changeOutputs = _.filter(allOutputDetails, { external: false });
                        implicitOutputs = AbstractUtxoCoin.findMissingOutputs(allOutputDetails, expectedOutputs);
                        explicitOutputs = AbstractUtxoCoin.findMissingOutputs(allOutputDetails, implicitOutputs);
                        explicitExternalOutputs = _.filter(explicitOutputs, { external: true });
                        explicitExternalSpendAmount = _.sumBy(explicitExternalOutputs, 'amount');
                        implicitExternalOutputs = _.filter(implicitOutputs, { external: true });
                        implicitExternalSpendAmount = _.sumBy(implicitExternalOutputs, 'amount');
                        result = {
                            keychains: keychains,
                            keySignatures: keySignatures,
                            outputs: allOutputDetails,
                            missingOutputs: missingOutputs,
                            explicitExternalOutputs: explicitExternalOutputs,
                            implicitExternalOutputs: implicitExternalOutputs,
                            changeOutputs: changeOutputs,
                            explicitExternalSpendAmount: explicitExternalSpendAmount,
                            implicitExternalSpendAmount: implicitExternalSpendAmount,
                            needsCustomChangeKeySignatureVerification: needsCustomChangeKeySignatureVerification,
                            customChange: customChange,
                        };
                        return [2 /*return*/, result];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Decrypt the wallet's user private key and verify that the claimed public key matches
     * @param {VerifyUserPublicKeyOptions} params
     * @return {boolean}
     * @protected
     */
    AbstractUtxoCoin.prototype.verifyUserPublicKey = function (params) {
        var userKeychain = params.userKeychain, txParams = params.txParams, disableNetworking = params.disableNetworking;
        if (!userKeychain) {
            throw new Error('user keychain is required');
        }
        var userPub = userKeychain.pub;
        // decrypt the user private key so we can verify that the claimed public key is a match
        var userPrv = userKeychain.prv;
        if (_.isEmpty(userPrv)) {
            var encryptedPrv = userKeychain.encryptedPrv;
            if (!_.isEmpty(encryptedPrv)) {
                // if the decryption fails, it will throw an error
                userPrv = this.bitgo.decrypt({
                    input: encryptedPrv,
                    password: txParams.walletPassphrase,
                });
            }
        }
        if (_.isEmpty(userPrv)) {
            var errorMessage = 'user private key unavailable for verification';
            if (disableNetworking) {
                console.log(errorMessage);
                return false;
            }
            else {
                throw new Error(errorMessage);
            }
        }
        else {
            var userPrivateKey = bitcoin.HDNode.fromBase58(userPrv);
            if (userPrivateKey.toBase58() === userPrivateKey.neutered().toBase58()) {
                throw new Error('user private key is only public');
            }
            if (userPrivateKey.neutered().toBase58() !== userPub) {
                throw new Error('user private key does not match public key');
            }
        }
        return true;
    };
    /**
     * Verify signatures produced by the user key over the backup and bitgo keys.
     *
     * If set, these signatures ensure that the wallet keys cannot be changed after the wallet has been created.
     * @param {VerifyKeySignaturesOptions} params
     * @return {{backup: boolean, bitgo: boolean}}
     */
    AbstractUtxoCoin.prototype.verifyKeySignature = function (params) {
        // first, let's verify the integrity of the user key, whose public key is used for subsequent verifications
        var userKeychain = params.userKeychain, keychainToVerify = params.keychainToVerify, keySignature = params.keySignature;
        if (!userKeychain) {
            throw new Error('user keychain is required');
        }
        if (!keychainToVerify) {
            throw new Error('keychain to verify is required');
        }
        if (!keySignature) {
            throw new Error('key signature is required');
        }
        // verify the signature against the user public key
        var signingAddress = bitcoin.HDNode.fromBase58(userKeychain.pub).keyPair.getAddress();
        // BG-5703: use BTC mainnet prefix for all key signature operations
        // (this means do not pass a prefix parameter, and let it use the default prefix instead)
        try {
            return bitcoinMessage.verify(keychainToVerify.pub, signingAddress, Buffer.from(keySignature, 'hex'));
        }
        catch (e) {
            debug('error thrown from bitcoinmessage while verifying key signature', e);
            return false;
        }
    };
    /**
     * Verify signatures against the user private key over the change wallet extended keys
     * @param {ParsedTransaction} tx
     * @param {Keychain} userKeychain
     * @return {boolean}
     * @protected
     */
    AbstractUtxoCoin.prototype.verifyCustomChangeKeySignatures = function (tx, userKeychain) {
        if (!tx.customChange) {
            throw new Error('parsed transaction is missing required custom change verification data');
        }
        if (!Array.isArray(tx.customChange.keys) || !Array.isArray(tx.customChange.signatures)) {
            throw new Error('customChange property is missing keys or signatures');
        }
        for (var _i = 0, _a = [keychains_1.KeyIndices.USER, keychains_1.KeyIndices.BACKUP, keychains_1.KeyIndices.BITGO]; _i < _a.length; _i++) {
            var keyIndex = _a[_i];
            var keychainToVerify = tx.customChange.keys[keyIndex];
            var keySignature = tx.customChange.signatures[keyIndex];
            if (!keychainToVerify) {
                throw new Error("missing required custom change " + keychains_1.KeyIndices[keyIndex].toLowerCase() + " keychain public key");
            }
            if (!keySignature) {
                throw new Error("missing required custom change " + keychains_1.KeyIndices[keyIndex].toLowerCase() + " keychain signature");
            }
            if (!this.verifyKeySignature({ userKeychain: userKeychain, keychainToVerify: keychainToVerify, keySignature: keySignature })) {
                debug('failed to verify custom change %s key signature!', keychains_1.KeyIndices[keyIndex].toLowerCase());
                return false;
            }
        }
        return true;
    };
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param params
     * @param params.txParams params object passed to send
     * @param params.txPrebuild prebuild object returned by server
     * @param params.txPrebuild.txHex prebuilt transaction's txHex form
     * @param params.wallet Wallet object to obtain keys to verify against
     * @param params.verification Object specifying some verification parameters
     * @param params.verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param params.verification.keychains Pass keychains manually rather than fetching them by id
     * @param params.verification.addresses Address details to pass in for out-of-band verification
     * @param callback
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.verifyTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txParams, txPrebuild, wallet, _a, verification, reqId, disableNetworking, parsedTransaction, keychains, userPublicKeyVerified, keySignatures, verify, isBackupKeySignatureValid, isBitgoKeySignatureValid, customChangeKeySignaturesVerified, missingOutputs, intendedExternalSpend, payAsYouGoLimit, nonChangeAmount, allOutputs, transaction, transactionCache, inputs, inputAmount, outputAmount, fee;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        txParams = params.txParams, txPrebuild = params.txPrebuild, wallet = params.wallet, _a = params.verification, verification = _a === void 0 ? {} : _a, reqId = params.reqId;
                        disableNetworking = !!verification.disableNetworking;
                        return [4 /*yield*/, self.parseTransaction({ txParams: txParams, txPrebuild: txPrebuild, wallet: wallet, verification: verification, reqId: reqId })];
                    case 1:
                        parsedTransaction = _b.sent();
                        keychains = parsedTransaction.keychains;
                        userPublicKeyVerified = false;
                        try {
                            // verify the user public key matches the private key - this will throw if there is no match
                            userPublicKeyVerified = self.verifyUserPublicKey({ userKeychain: keychains.user, disableNetworking: disableNetworking, txParams: txParams });
                        }
                        catch (e) {
                            debug('failed to verify user public key!', e);
                        }
                        keySignatures = parsedTransaction.keySignatures;
                        if (!_.isEmpty(keySignatures)) {
                            verify = function (key, pub) { return self.verifyKeySignature({ userKeychain: keychains.user, keychainToVerify: key, keySignature: pub }); };
                            isBackupKeySignatureValid = verify(keychains.backup, keySignatures.backupPub);
                            isBitgoKeySignatureValid = verify(keychains.bitgo, keySignatures.bitgoPub);
                            if (!isBackupKeySignatureValid || !isBitgoKeySignatureValid) {
                                throw new Error('secondary public key signatures invalid');
                            }
                            debug('successfully verified backup and bitgo key signatures');
                        }
                        else if (!disableNetworking) {
                            // these keys were obtained online and their signatures were not verified
                            // this could be dangerous
                            console.log('unsigned keys obtained online are being used for address verification');
                        }
                        if (parsedTransaction.needsCustomChangeKeySignatureVerification) {
                            if (!keychains.user || !userPublicKeyVerified) {
                                throw new Error('transaction requires verification of user public key, but it was unable to be verified');
                            }
                            customChangeKeySignaturesVerified = self.verifyCustomChangeKeySignatures(parsedTransaction, keychains.user);
                            if (!customChangeKeySignaturesVerified) {
                                throw new Error('transaction requires verification of custom change key signatures, but they were unable to be verified');
                            }
                            debug('successfully verified user public key and custom change key signatures');
                        }
                        missingOutputs = parsedTransaction.missingOutputs;
                        if (missingOutputs.length !== 0) {
                            // there are some outputs in the recipients list that have not made it into the actual transaction
                            throw new Error('expected outputs missing in transaction prebuild');
                        }
                        intendedExternalSpend = parsedTransaction.explicitExternalSpendAmount;
                        payAsYouGoLimit = intendedExternalSpend * 0.015;
                        nonChangeAmount = parsedTransaction.implicitExternalSpendAmount;
                        debug('Intended spend is %s, Non-change amount is %s, paygo limit is %s', intendedExternalSpend, nonChangeAmount, payAsYouGoLimit);
                        // the additional external outputs can only be BitGo's pay-as-you-go fee, but we cannot verify the wallet address
                        if (nonChangeAmount > payAsYouGoLimit) {
                            // there are some addresses that are outside the scope of intended recipients that are not change addresses
                            throw new Error('prebuild attempts to spend to unintended external recipients');
                        }
                        allOutputs = parsedTransaction.outputs;
                        transaction = bitcoin.Transaction.fromHex(txPrebuild.txHex, self.network);
                        transactionCache = {};
                        return [4 /*yield*/, Bluebird.map(transaction.ins, co(function (currentInput) {
                                var transactionId, txHex, localTx, currentOutput, address, _a, _b, transactionDetails;
                                return __generator(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            transactionId = Buffer.from(currentInput.hash).reverse().toString('hex');
                                            txHex = _.get(txPrebuild, "txInfo.txHexes." + transactionId);
                                            if (!txHex) return [3 /*break*/, 1];
                                            localTx = bitcoin.Transaction.fromHex(txHex, self.network);
                                            if (localTx.getId() !== transactionId) {
                                                throw new Error('input transaction hex does not match id');
                                            }
                                            currentOutput = localTx.outs[currentInput.index];
                                            address = bitcoin.address.fromOutputScript(currentOutput.script, self.network);
                                            return [2 /*return*/, {
                                                    address: address,
                                                    value: currentOutput.value,
                                                }];
                                        case 1:
                                            if (!!transactionCache[transactionId]) return [3 /*break*/, 3];
                                            if (disableNetworking) {
                                                throw new Error('attempting to retrieve transaction details externally with networking disabled');
                                            }
                                            if (reqId) {
                                                self.bitgo.setRequestTracer(reqId);
                                            }
                                            _a = transactionCache;
                                            _b = transactionId;
                                            return [4 /*yield*/, self.bitgo.get(self.url("/public/tx/" + transactionId)).result()];
                                        case 2:
                                            _a[_b] = _c.sent();
                                            _c.label = 3;
                                        case 3:
                                            transactionDetails = transactionCache[transactionId];
                                            return [2 /*return*/, transactionDetails.outputs[currentInput.index]];
                                    }
                                });
                            }).bind(this))];
                    case 2:
                        inputs = _b.sent();
                        inputAmount = _.sumBy(inputs, 'value');
                        outputAmount = _.sumBy(allOutputs, 'amount');
                        fee = inputAmount - outputAmount;
                        if (fee < 0) {
                            throw new Error("attempting to spend " + outputAmount + " satoshis, which exceeds the input amount (" + inputAmount + " satoshis) by " + -fee);
                        }
                        return [2 /*return*/, true];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Make sure an address is valid and throw an error if it's not.
     * @param params.address The address string on the network
     * @param params.addressType
     * @param params.keychains Keychain objects with xpubs
     * @param params.coinSpecific Coin-specific details for the address such as a witness script
     * @param params.chain Derivation chain
     * @param params.index Derivation index
     * @throws {InvalidAddressError}
     * @throws {InvalidAddressDerivationPropertyError}
     * @throws {UnexpectedAddressError}
     */
    AbstractUtxoCoin.prototype.verifyAddress = function (params) {
        var address = params.address, addressType = params.addressType, keychains = params.keychains, coinSpecific = params.coinSpecific, chain = params.chain, index = params.index;
        if (!this.isValidAddress(address)) {
            throw new errors.InvalidAddressError("invalid address: " + address);
        }
        if ((_.isUndefined(chain) && _.isUndefined(index)) || (!(_.isFinite(chain) && _.isFinite(index)))) {
            throw new errors.InvalidAddressDerivationPropertyError("address validation failure: invalid chain (" + chain + ") or index (" + index + ")");
        }
        if (!_.isObject(coinSpecific)) {
            throw new errors.InvalidAddressVerificationObjectPropertyError('address validation failure: coinSpecific field must be an object');
        }
        if (!keychains) {
            throw new Error('missing required param keychains');
        }
        var expectedAddress = this.generateAddress({
            addressType: addressType,
            keychains: keychains,
            threshold: 2,
            chain: chain,
            index: index,
        });
        if (expectedAddress.address !== address) {
            throw new errors.UnexpectedAddressError("address validation failure: expected " + expectedAddress.address + " but got " + address);
        }
        return true;
    };
    /**
     * Indicates whether coin supports a block target
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.supportsBlockTarget = function () {
        return true;
    };
    /**
     * Indicates whether a coin supports wrapped segwit outputs
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.supportsP2shP2wsh = function () {
        return false;
    };
    /**
     * Indicates whether a coin supports native segwit outputs
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.supportsP2wsh = function () {
        return false;
    };
    /**
     * TODO(BG-11487): Remove addressType, segwit, and bech32 params in SDKv6
     * Generate an address for a wallet based on a set of configurations
     * @param params.addressType {string}   Deprecated
     * @param params.keychains   {[object]} Array of objects with xpubs
     * @param params.threshold   {number}   Minimum number of signatures
     * @param params.chain       {number}   Derivation chain (see https://github.com/BitGo/unspents/blob/master/src/codes.ts for
     *                                                 the corresponding address type of a given chain code)
     * @param params.index       {number}   Derivation index
     * @param params.segwit      {boolean}  Deprecated
     * @param params.bech32      {boolean}  Deprecated
     * @returns {{chain: number, index: number, coin: number, coinSpecific: {outputScript, redeemScript}}}
     */
    AbstractUtxoCoin.prototype.generateAddress = function (params) {
        var keychains = params.keychains, threshold = params.threshold, chain = params.chain, index = params.index, _a = params.segwit, segwit = _a === void 0 ? false : _a, _b = params.bech32, bech32 = _b === void 0 ? false : _b;
        var derivationChain = 0;
        if (_.isNumber(chain) && _.isInteger(chain) && chain > 0) {
            derivationChain = chain;
        }
        function convertFlagsToAddressType() {
            if (_.isBoolean(segwit) && segwit) {
                return unspents_1.Codes.UnspentTypeTcomb('p2shP2wsh');
            }
            else if (_.isBoolean(bech32) && bech32) {
                return unspents_1.Codes.UnspentTypeTcomb('p2wsh');
            }
            else {
                return unspents_1.Codes.UnspentTypeTcomb('p2sh');
            }
        }
        var addressType = params.addressType || convertFlagsToAddressType();
        switch (addressType) {
            case unspents_1.Codes.UnspentTypeTcomb('p2sh'):
                if (!unspents_1.Codes.isP2sh(derivationChain)) {
                    throw new errors.AddressTypeChainMismatchError(addressType, derivationChain);
                }
                break;
            case unspents_1.Codes.UnspentTypeTcomb('p2shP2wsh'):
                if (!this.supportsP2shP2wsh()) {
                    throw new errors.P2shP2wshUnsupportedError();
                }
                if (!unspents_1.Codes.isP2shP2wsh(derivationChain)) {
                    throw new errors.AddressTypeChainMismatchError(addressType, derivationChain);
                }
                break;
            case unspents_1.Codes.UnspentTypeTcomb('p2wsh'):
                if (!this.supportsP2wsh()) {
                    throw new errors.P2wshUnsupportedError();
                }
                if (!unspents_1.Codes.isP2wsh(derivationChain)) {
                    throw new errors.AddressTypeChainMismatchError(addressType, derivationChain);
                }
                break;
            default:
                throw new errors.UnsupportedAddressTypeError();
        }
        var signatureThreshold = 2;
        if (_.isInteger(threshold)) {
            signatureThreshold = threshold;
            if (signatureThreshold <= 0) {
                throw new Error('threshold has to be positive');
            }
            if (signatureThreshold > keychains.length) {
                throw new Error('threshold cannot exceed number of keys');
            }
        }
        var derivationIndex = 0;
        if (_.isInteger(index) && index > 0) {
            derivationIndex = index;
        }
        var path = 'm/0/0/' + derivationChain + '/' + derivationIndex;
        var hdNodes = keychains.map(function (_a) {
            var pub = _a.pub;
            return bitcoin.HDNode.fromBase58(pub);
        });
        var derivedKeys = hdNodes.map(function (hdNode) { return bitcoin_1.hdPath(hdNode).deriveKey(path).getPublicKeyBuffer(); });
        var _c = this.createMultiSigAddress(addressType, signatureThreshold, derivedKeys), outputScript = _c.outputScript, redeemScript = _c.redeemScript, witnessScript = _c.witnessScript, address = _c.address;
        return {
            address: address,
            chain: derivationChain,
            index: derivationIndex,
            coin: this.getChain(),
            coinSpecific: {
                outputScript: outputScript.toString('hex'),
                redeemScript: redeemScript && redeemScript.toString('hex'),
                witnessScript: witnessScript && witnessScript.toString('hex'),
            },
            addressType: addressType,
        };
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * @param params.txPrebuild transaction prebuild from bitgo server
     * @param params.prv private key to be used for signing
     * @param params.isLastSignature True if `TransactionBuilder.build()` should be called and not `TransactionBuilder.buildIncomplete()`
     * @param callback
     * @returns {Bluebird<SignedTransaction>}
     */
    AbstractUtxoCoin.prototype.signTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txPrebuild, userPrv, transaction, isLastSignature, keychain, keychainHdPath, txb, getSignatureContext, signatureIssues, index, signatureContext, privKey, sigHashType, witnessScript, witnessScriptHash, prevOutScript, subscript, isP2shP2wsh, witnessScript, index, signatureContext, isValidSignature, failedIndices, error;
            return __generator(this, function (_a) {
                txPrebuild = params.txPrebuild;
                userPrv = params.prv;
                if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
                    if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                        throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
                    }
                    throw new Error('missing txPrebuild parameter');
                }
                transaction = bitcoin.Transaction.fromHex(txPrebuild.txHex, self.network);
                if (transaction.ins.length !== txPrebuild.txInfo.unspents.length) {
                    throw new Error('length of unspents array should equal to the number of transaction inputs');
                }
                isLastSignature = false;
                if (_.isBoolean(params.isLastSignature)) {
                    // if build is called instead of buildIncomplete, no signature placeholders are left in the sig script
                    isLastSignature = params.isLastSignature;
                }
                if (_.isUndefined(userPrv) || !_.isString(userPrv)) {
                    if (!_.isUndefined(userPrv)) {
                        throw new Error("prv must be a string, got type " + typeof userPrv);
                    }
                    throw new Error('missing prv parameter to sign transaction');
                }
                keychain = bitcoin.HDNode.fromBase58(userPrv);
                keychainHdPath = bitcoin_1.hdPath(keychain);
                txb = bitcoin.TransactionBuilder.fromTransaction(transaction, self.network);
                self.prepareTransactionBuilder(txb);
                getSignatureContext = function (txPrebuild, index) {
                    var currentUnspent = txPrebuild.txInfo.unspents[index];
                    return {
                        inputIndex: index,
                        unspent: currentUnspent,
                        path: 'm/0/0/' + currentUnspent.chain + '/' + currentUnspent.index,
                        isP2wsh: !currentUnspent.redeemScript,
                        isBitGoTaintedUnspent: self.isBitGoTaintedUnspent(currentUnspent),
                        error: undefined,
                    };
                };
                signatureIssues = [];
                // Sign inputs
                for (index = 0; index < transaction.ins.length; ++index) {
                    debug('Signing input %d of %d', index + 1, transaction.ins.length);
                    signatureContext = getSignatureContext(txPrebuild, index);
                    if (signatureContext.isBitGoTaintedUnspent) {
                        debug('Skipping input %d of %d (unspent from replay protection address which is platform signed only)', index + 1, transaction.ins.length);
                        continue;
                    }
                    privKey = keychainHdPath.deriveKey(signatureContext.path);
                    privKey.network = self.network;
                    debug('Input details: %O', signatureContext);
                    sigHashType = self.defaultSigHashType;
                    try {
                        if (signatureContext.isP2wsh) {
                            debug('Signing p2wsh input');
                            witnessScript = Buffer.from(signatureContext.unspent.witnessScript, 'hex');
                            witnessScriptHash = bitcoin.crypto.sha256(witnessScript);
                            prevOutScript = bitcoin.script.witnessScriptHash.output.encode(witnessScriptHash);
                            txb.sign(index, privKey, prevOutScript, sigHashType, signatureContext.unspent.value, witnessScript);
                        }
                        else {
                            subscript = Buffer.from(signatureContext.unspent.redeemScript, 'hex');
                            isP2shP2wsh = !!signatureContext.unspent.witnessScript;
                            if (isP2shP2wsh) {
                                debug('Signing p2shP2wsh input');
                                witnessScript = Buffer.from(signatureContext.unspent.witnessScript, 'hex');
                                txb.sign(index, privKey, subscript, sigHashType, signatureContext.unspent.value, witnessScript);
                            }
                            else {
                                debug('Signing p2sh input');
                                txb.sign(index, privKey, subscript, sigHashType, signatureContext.unspent.value);
                            }
                        }
                    }
                    catch (e) {
                        debug('Failed to sign input:', e);
                        signatureContext.error = e;
                        signatureIssues.push(signatureContext);
                        continue;
                    }
                    debug('Successfully signed input %d of %d', index + 1, transaction.ins.length);
                }
                if (isLastSignature) {
                    transaction = txb.build();
                }
                else {
                    transaction = txb.buildIncomplete();
                }
                // Verify input signatures
                for (index = 0; index < transaction.ins.length; ++index) {
                    debug('Verifying input signature %d of %d', index + 1, transaction.ins.length);
                    signatureContext = getSignatureContext(txPrebuild, index);
                    if (signatureContext.isBitGoTaintedUnspent) {
                        debug('Skipping input signature %d of %d (unspent from replay protection address which is platform signed only)', index + 1, transaction.ins.length);
                        continue;
                    }
                    if (signatureContext.isP2wsh) {
                        transaction.setInputScript(index, Buffer.alloc(0));
                    }
                    isValidSignature = self.verifySignature(transaction, index, signatureContext.unspent.value);
                    if (!isValidSignature) {
                        debug('Invalid signature');
                        signatureContext.error = new Error('invalid signature');
                        signatureIssues.push(signatureContext);
                    }
                }
                if (signatureIssues.length > 0) {
                    failedIndices = signatureIssues.map(function (currentIssue) { return currentIssue.inputIndex; });
                    error = new Error("Failed to sign inputs at indices " + failedIndices.join(', '));
                    error.code = 'input_signature_failure';
                    error.signingErrors = signatureIssues;
                    throw error;
                }
                return [2 /*return*/, {
                        txHex: transaction.toBuffer().toString('hex'),
                    }];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Always false for coins other than BCH and TBCH.
     * @param unspent
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.isBitGoTaintedUnspent = function (unspent) {
        return false;
    };
    /**
     * Modify the transaction builder to comply with the specific coin's requirements such as version and branch id
     * @param txBuilder
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.prepareTransactionBuilder = function (txBuilder) {
        return txBuilder;
    };
    Object.defineProperty(AbstractUtxoCoin.prototype, "defaultSigHashType", {
        /**
         * Get the default sighash type to be used when signing transactions
         * @returns {number}
         */
        get: function () {
            return bitcoin.Transaction.SIGHASH_ALL;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Parse a transaction's signature script to obtain public keys, signatures, the sig script, and other properties
     * @param transaction
     * @param inputIndex
     * @returns { isSegwitInput: boolean, inputClassification: string, signatures: [Buffer], publicKeys: [Buffer], pubScript: Buffer }
     */
    AbstractUtxoCoin.prototype.parseSignatureScript = function (transaction, inputIndex) {
        var currentInput = transaction.ins[inputIndex];
        var isSegwitInput = currentInput.witness.length > 0;
        var isNativeSegwitInput = currentInput.script.length === 0;
        var decompiledSigScript, inputClassification;
        if (isSegwitInput) {
            // The decompiledSigScript is the script containing the signatures, public keys, and the script that was committed
            // to (pubScript). If this is a segwit input the decompiledSigScript is in the witness, regardless of whether it
            // is native or not. The inputClassification is determined based on whether or not the input is native to give an
            // accurate classification. Note that p2shP2wsh inputs will be classified as p2sh and not p2wsh.
            decompiledSigScript = currentInput.witness;
            if (isNativeSegwitInput) {
                inputClassification = bitcoin.script.classifyWitness(bitcoin.script.compile(decompiledSigScript), true);
            }
            else {
                inputClassification = bitcoin.script.classifyInput(currentInput.script, true);
            }
        }
        else {
            inputClassification = bitcoin.script.classifyInput(currentInput.script, true);
            decompiledSigScript = bitcoin.script.decompile(currentInput.script);
        }
        if (inputClassification === bitcoin.script.types.P2PKH) {
            var signature = decompiledSigScript[0], publicKey = decompiledSigScript[1];
            var publicKeys = [publicKey];
            var signatures = [signature];
            var pubScript = bitcoin.script.pubKeyHash.output.encode(bitcoin.crypto.hash160(publicKey));
            return { isSegwitInput: isSegwitInput, inputClassification: inputClassification, signatures: signatures, publicKeys: publicKeys, pubScript: pubScript };
        }
        else if (inputClassification === bitcoin.script.types.P2SH
            || inputClassification === bitcoin.script.types.P2WSH) {
            // Note the assumption here that if we have a p2sh or p2wsh input it will be multisig (appropriate because the
            // BitGo platform only supports multisig within these types of inputs). Signatures are all but the last entry in
            // the decompiledSigScript. The redeemScript/witnessScript (depending on which type of input this is) is the last
            // entry in the decompiledSigScript (denoted here as the pubScript). The public keys are the second through
            // antepenultimate entries in the decompiledPubScript. See below for a visual representation of the typical 2-of-3
            // multisig setup:
            //
            // decompiledSigScript = 0 <sig1> <sig2> <pubScript>
            // decompiledPubScript = 2 <pub1> <pub2> <pub3> 3 OP_CHECKMULTISIG
            var signatures = decompiledSigScript.slice(0, -1);
            var pubScript = _.last(decompiledSigScript);
            var decompiledPubScript = bitcoin.script.decompile(pubScript);
            var publicKeys = decompiledPubScript.slice(1, -2);
            // Op codes 81 through 96 represent numbers 1 through 16 (see https://en.bitcoin.it/wiki/Script#Opcodes), which is
            // why we subtract by 80 to get the number of signatures (n) and the number of public keys (m) in an n-of-m setup.
            var len = decompiledPubScript.length;
            var nSignatures = decompiledPubScript[0] - 80;
            var nPubKeys = decompiledPubScript[len - 2] - 80;
            // Due to a bug in the implementation of multisignature in the bitcoin protocol, a 0 is added to the signature
            // script, so we add 1 when asserting the number of signatures matches the number of signatures expected by the
            // pub script. Also, note that we consider a signature script with the the same number of signatures as public
            // keys (+1 as noted above) valid because we use placeholder signatures when parsing a half-signed signature
            // script.
            if (signatures.length !== nSignatures + 1 && signatures.length !== nPubKeys + 1) {
                throw new Error("expected " + nSignatures + " or " + nPubKeys + " signatures, got " + (signatures.length - 1));
            }
            if (publicKeys.length !== nPubKeys) {
                throw new Error("expected " + nPubKeys + " public keys, got " + publicKeys.length);
            }
            var lastOpCode = decompiledPubScript[len - 1];
            if (lastOpCode !== bitcoin.opcodes.OP_CHECKMULTISIG) {
                throw new Error("expected opcode #" + bitcoin.opcodes.OP_CHECKMULTISIG + ", got opcode #" + lastOpCode);
            }
            return { isSegwitInput: isSegwitInput, inputClassification: inputClassification, signatures: signatures, publicKeys: publicKeys, pubScript: pubScript };
        }
        else {
            return { isSegwitInput: isSegwitInput, inputClassification: inputClassification };
        }
    };
    /**
     * Calculate the hash to verify the signature against
     * @param transaction Transaction object
     * @param inputIndex
     * @param pubScript
     * @param amount The previous output's amount
     * @param hashType
     * @param isSegwitInput
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.calculateSignatureHash = function (transaction, inputIndex, pubScript, amount, hashType, isSegwitInput) {
        if (isSegwitInput) {
            return transaction.hashForWitnessV0(inputIndex, pubScript, amount, hashType);
        }
        else {
            return transaction.hashForSignature(inputIndex, pubScript, hashType);
        }
    };
    /**
     * Verify the signature on a (half-signed) transaction
     * @param transaction bitcoinjs-lib tx object
     * @param inputIndex The input whererfore to check the signature
     * @param amount For segwit and BCH, the input amount needs to be known for signature verification
     * @param verificationSettings
     * @param verificationSettings.signatureIndex The index of the signature to verify (only iterates over non-empty signatures)
     * @param verificationSettings.publicKey The hex of the public key to verify (will verify all signatures)
     * @returns {boolean}
     */
    AbstractUtxoCoin.prototype.verifySignature = function (transaction, inputIndex, amount, verificationSettings) {
        if (verificationSettings === void 0) { verificationSettings = {}; }
        var _a = this.parseSignatureScript(transaction, inputIndex), signatures = _a.signatures, publicKeys = _a.publicKeys, isSegwitInput = _a.isSegwitInput, inputClassification = _a.inputClassification, pubScript = _a.pubScript;
        if (![bitcoin.script.types.P2WSH, bitcoin.script.types.P2SH, bitcoin.script.types.P2PKH].includes(inputClassification)) {
            return false;
        }
        if (!publicKeys || publicKeys.length === 0) {
            return false;
        }
        if (isSegwitInput && !amount) {
            return false;
        }
        // get the first non-empty signature and verify it against all public keys
        var nonEmptySignatures = _.filter(signatures, function (s) { return !_.isEmpty(s); });
        /*
        We either want to verify all signature/pubkey combinations, or do an explicit combination
    
        If a signature index is specified, only that signature is checked. It's verified against all public keys.
        If a single public key is found to be valid, the function returns true.
    
        If a public key is specified, we iterate over all signatures. If a single one matches the public key, the function
        returns true.
    
        If neither is specified, all signatures are checked against all public keys. Each signature must have its own distinct
        public key that it matches for the function to return true.
         */
        var signaturesToCheck = nonEmptySignatures;
        if (!_.isUndefined(verificationSettings.signatureIndex)) {
            signaturesToCheck = [nonEmptySignatures[verificationSettings.signatureIndex]];
        }
        var publicKeyHex = verificationSettings.publicKey;
        var matchedPublicKeyIndices = {};
        var areAllSignaturesValid = true;
        // go over all signatures
        for (var _i = 0, signaturesToCheck_1 = signaturesToCheck; _i < signaturesToCheck_1.length; _i++) {
            var signatureBuffer = signaturesToCheck_1[_i];
            var isSignatureValid = false;
            var hasSignatureBuffer = Buffer.isBuffer(signatureBuffer) && signatureBuffer.length > 0;
            if (hasSignatureBuffer && Buffer.isBuffer(pubScript) && pubScript.length > 0) {
                // slice the last byte from the signature hash input because it's the hash type
                var signature = bitcoin.ECSignature.fromDER(signatureBuffer.slice(0, -1));
                var hashType = _.last(signatureBuffer);
                if (!hashType) {
                    // missing hashType byte - signature cannot be validated
                    return false;
                }
                var signatureHash = this.calculateSignatureHash(transaction, inputIndex, pubScript, amount, hashType, isSegwitInput);
                for (var publicKeyIndex = 0; publicKeyIndex < publicKeys.length; publicKeyIndex++) {
                    var publicKeyBuffer = publicKeys[publicKeyIndex];
                    if (!_.isUndefined(publicKeyHex) && publicKeyBuffer.toString('hex') !== publicKeyHex) {
                        // we are only looking to verify one specific public key's signature (publicKeyHex)
                        // this particular public key is not the one whose signature we're trying to verify
                        continue;
                    }
                    if (matchedPublicKeyIndices[publicKeyIndex]) {
                        continue;
                    }
                    var publicKey = bitcoin.ECPair.fromPublicKeyBuffer(publicKeyBuffer);
                    if (publicKey.verify(signatureHash, signature)) {
                        isSignatureValid = true;
                        matchedPublicKeyIndices[publicKeyIndex] = true;
                        break;
                    }
                }
            }
            if (!_.isUndefined(publicKeyHex) && isSignatureValid) {
                // We were trying to see if any of the signatures was valid for the given public key. Evidently yes.
                return true;
            }
            if (!isSignatureValid && _.isUndefined(publicKeyHex)) {
                return false;
            }
            areAllSignaturesValid = isSignatureValid && areAllSignaturesValid;
        }
        return areAllSignaturesValid;
    };
    /**
     * Decompose a raw transaction into useful information, such as the total amounts,
     * change amounts, and transaction outputs.
     * @param params
     * @param callback
     */
    AbstractUtxoCoin.prototype.explainTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txHex, transaction, id, changeAddresses, spendAmount, changeAmount, txInfo, explanation, unspentValues, inputSignatures;
            return __generator(this, function (_a) {
                txHex = _.get(params, 'txHex');
                if (!txHex || !_.isString(txHex) || !txHex.match(/^([a-f0-9]{2})+$/i)) {
                    throw new Error('invalid transaction hex, must be a valid hex string');
                }
                try {
                    transaction = bitcoin.Transaction.fromHex(txHex, self.network);
                }
                catch (e) {
                    throw new Error('failed to parse transaction hex');
                }
                id = transaction.getId();
                changeAddresses = [];
                spendAmount = 0;
                changeAmount = 0;
                txInfo = _.get(params, 'txInfo');
                if (txInfo && txInfo.changeAddresses) {
                    changeAddresses = txInfo.changeAddresses;
                }
                explanation = {
                    displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs'],
                    id: id,
                    outputs: [],
                    changeOutputs: [],
                };
                transaction.outs.forEach(function (currentOutput) {
                    var currentAddress = self.getCoinLibrary().address.fromOutputScript(currentOutput.script, self.network);
                    var currentAmount = currentOutput.value;
                    if (changeAddresses.indexOf(currentAddress) !== -1) {
                        // this is change
                        changeAmount += currentAmount;
                        explanation.changeOutputs.push({
                            address: currentAddress,
                            amount: currentAmount,
                        });
                        return;
                    }
                    spendAmount += currentAmount;
                    explanation.outputs.push({
                        address: currentAddress,
                        amount: currentAmount,
                    });
                });
                explanation.outputAmount = spendAmount;
                explanation.changeAmount = changeAmount;
                // add fee info if available
                if (params.feeInfo) {
                    explanation.displayOrder.push('fee');
                    explanation.fee = params.feeInfo;
                }
                if (_.isInteger(transaction.locktime) && transaction.locktime > 0) {
                    explanation.locktime = transaction.locktime;
                    explanation.displayOrder.push('locktime');
                }
                unspentValues = {};
                inputSignatures = transaction.ins.map(function (input, idx) {
                    var hasSigScript = !_.isEmpty(input.script);
                    var hasWitnessScript = !_.isEmpty(input.witness);
                    if (!hasSigScript && !hasWitnessScript) {
                        // no sig script or witness data for this input
                        debug('no signature script or witness script data for input %s', idx);
                        return 0;
                    }
                    var parsedSigScript;
                    try {
                        parsedSigScript = self.parseSignatureScript(transaction, idx);
                    }
                    catch (e) {
                        return false;
                    }
                    if (hasWitnessScript) {
                        if (!txInfo || !txInfo.unspents) {
                            // segwit txs require input values, cannot validate signatures
                            debug('unable to retrieve input amounts from unspents - cannot validate segwit input signatures');
                            return 0;
                        }
                        // lazily populate unspent values
                        if (_.isEmpty(unspentValues)) {
                            txInfo.unspents.forEach(function (unspent) {
                                unspentValues[unspent.id] = unspent.value;
                            });
                        }
                    }
                    var nonEmptySignatures = parsedSigScript.signatures.filter(function (sig) { return !_.isEmpty(sig); });
                    var validSignatures = nonEmptySignatures.map(function (sig, sigIndex) {
                        if (_.isEmpty(sig)) {
                            return false;
                        }
                        var parentTxId = Buffer.from(input.hash).reverse().toString('hex');
                        var inputId = parentTxId + ":" + input.index;
                        var amount = unspentValues[inputId];
                        try {
                            return self.verifySignature(transaction, idx, amount, { signatureIndex: sigIndex });
                        }
                        catch (e) {
                            return false;
                        }
                    });
                    return validSignatures.reduce(function (validCount, isValid) { return isValid ? validCount + 1 : validCount; }, 0);
                });
                explanation.inputSignatures = inputSignatures;
                explanation.signatures = _.max(inputSignatures);
                return [2 /*return*/, explanation];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Create a multisig address of a given type from a list of keychains and a signing threshold
     * @param addressType
     * @param signatureThreshold
     * @param keys
     */
    AbstractUtxoCoin.prototype.createMultiSigAddress = function (addressType, signatureThreshold, keys) {
        function createWitnessProgram(inputScript) {
            var witnessScriptHash = bitcoin.crypto.sha256(inputScript);
            return bitcoin.script.witnessScriptHash.output.encode(witnessScriptHash);
        }
        var multiSigScript = bitcoin.script.multisig.output.encode(signatureThreshold, keys);
        var outputScript, redeemScript, witnessScript;
        switch (addressType) {
            case unspents_1.Codes.UnspentTypeTcomb('p2sh'):
                var multisigScriptHash = bitcoin.crypto.hash160(multiSigScript);
                outputScript = bitcoin.script.scriptHash.output.encode(multisigScriptHash);
                redeemScript = multiSigScript;
                break;
            case unspents_1.Codes.UnspentTypeTcomb('p2shP2wsh'):
                var witnessProgram = createWitnessProgram(multiSigScript);
                var witnessProgramHash = bitcoin.crypto.hash160(witnessProgram);
                outputScript = bitcoin.script.scriptHash.output.encode(witnessProgramHash);
                redeemScript = witnessProgram;
                witnessScript = multiSigScript;
                break;
            case unspents_1.Codes.UnspentTypeTcomb('p2wsh'):
                outputScript = createWitnessProgram(multiSigScript);
                witnessScript = multiSigScript;
                break;
            default:
                throw new Error("unexpected addressType " + addressType);
        }
        return {
            outputScript: outputScript,
            redeemScript: redeemScript,
            witnessScript: witnessScript,
            address: bitcoin.address.fromOutputScript(outputScript, this.network),
        };
    };
    /**
     * @param scriptHashScript
     * @deprecated
     */
    // TODO(BG-11638): remove in next SDK major version release
    AbstractUtxoCoin.prototype.calculateRecoveryAddress = function (scriptHashScript) {
        return this.getCoinLibrary().address.fromOutputScript(scriptHashScript, this.network);
    };
    /**
     * Get a static fee rate which is used in recovery situations
     * @deprecated
     */
    AbstractUtxoCoin.prototype.getRecoveryFeePerBytes = function () {
        return Bluebird.resolve(100);
    };
    /**
     * Get a url which can be used for determining recovery fee rates
     */
    AbstractUtxoCoin.prototype.getRecoveryFeeRecommendationApiBaseUrl = function () {
        return Bluebird.reject(new Error('AbtractUtxoCoin method not implemented'));
    };
    /**
     * Get the current market price from a third party to be used for recovery
     */
    AbstractUtxoCoin.prototype.getRecoveryMarketPrice = function () {
        var self = this;
        return co(function getRecoveryMarketPrice() {
            var familyNamesToCoinGeckoIds, coinGeckoId, coinGeckoUrl, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        familyNamesToCoinGeckoIds = new Map()
                            .set('BTC', 'bitcoin')
                            .set('LTC', 'litecoin')
                            .set('BCH', 'bitcoin-cash')
                            .set('ZEC', 'zcash')
                            .set('DASH', 'dash')
                            .set('BSV', 'bitcoin-sv');
                        coinGeckoId = familyNamesToCoinGeckoIds.get(self.getFamily().toUpperCase());
                        if (!coinGeckoId) {
                            throw new Error("There is no CoinGecko id for family name " + self.getFamily().toUpperCase() + ".");
                        }
                        coinGeckoUrl = config.coinGeckoBaseUrl + ("simple/price?ids=" + coinGeckoId + "&vs_currencies=USD");
                        return [4 /*yield*/, request.get(coinGeckoUrl).retry(2).result()];
                    case 1:
                        response = _a.sent();
                        // An example of response
                        // {
                        //   "ethereum": {
                        //     "usd": 220.64
                        //   }
                        // }
                        if (!response) {
                            throw new Error('Unable to reach Coin Gecko API for price data');
                        }
                        if (!response[coinGeckoId]['usd'] || typeof response[coinGeckoId]['usd'] !== 'number') {
                            throw new Error('Unexpected response from Coin Gecko API for price data');
                        }
                        return [2 /*return*/, response[coinGeckoId]['usd']];
                }
            });
        }).call(this);
    };
    /**
     * Helper function for recover()
     * This transforms the txInfo from recover into the format that offline-signing-tool expects
     * @param txInfo
     * @param txHex
     * @returns {{txHex: *, txInfo: {unspents: *}, feeInfo: {}, coin: void}}
     */
    AbstractUtxoCoin.prototype.formatForOfflineVault = function (txInfo, txHex) {
        var response = {
            txHex: txHex,
            txInfo: {
                unspents: txInfo.inputs,
            },
            feeInfo: {},
            coin: this.getChain(),
        };
        _.map(response.txInfo.unspents, function (unspent) {
            var pathArray = unspent.chainPath.split('/');
            // Note this code works because we assume our chainPath is m/0/0/chain/index - this will be incorrect for custom derivation schemes
            unspent.index = pathArray[4];
            unspent.chain = pathArray[3];
        });
        return response;
    };
    /**
     * Derive child keys at specific index, from provided parent keys
     * @param {bitcoin.HDNode[]} keyArray
     * @param {number} index
     * @returns {bitcoin.HDNode[]}
     */
    AbstractUtxoCoin.prototype.deriveKeys = function (keyArray, index) {
        return keyArray.map(function (k) { return k.derive(index); });
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - userKey: [encrypted] xprv, or xpub
     * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
     * - walletPassphrase: necessary if one of the xprvs is encrypted
     * - bitgoKey: xpub
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * - scan: the amount of consecutive addresses without unspents to scan through before stopping
     * - ignoreAddressTypes: (optional) array of AddressTypes to ignore, these are strings defined in Codes.UnspentTypeTcomb
     *        for example: ['p2shP2wsh', 'p2wsh'] will prevent code from checking for wrapped-segwit and native-segwit chains on the public block explorers
     * @param callback
     */
    AbstractUtxoCoin.prototype.recover = function (params, callback) {
        var self = this;
        return co(function recover() {
            // ============================HELPER FUNCTIONS============================
            function queryBlockchainUnspentsPath(keyArray, basePath, addressesById) {
                return co(function () {
                    var MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS, numSequentialAddressesWithoutTxs, gatherUnspents, walletUnspents;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS = params.scan || 20;
                                numSequentialAddressesWithoutTxs = 0;
                                gatherUnspents = co(function coGatherUnspents(addrIndex) {
                                    var derivedKeys, chain, keys, address, addrInfo, addressUnspents;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                derivedKeys = self.deriveKeys(keyArray, addrIndex);
                                                chain = Number(basePath.split('/').pop());
                                                keys = derivedKeys.map(function (k) { return k.getPublicKeyBuffer(); });
                                                address = self.createMultiSigAddress(unspents_1.Codes.typeForCode(chain), 2, keys);
                                                return [4 /*yield*/, self.getAddressInfoFromExplorer(address.address, params.apiKey)];
                                            case 1:
                                                addrInfo = _a.sent();
                                                if (!(addrInfo.txCount === 0)) return [3 /*break*/, 2];
                                                numSequentialAddressesWithoutTxs++;
                                                return [3 /*break*/, 4];
                                            case 2:
                                                numSequentialAddressesWithoutTxs = 0;
                                                if (!(addrInfo.totalBalance > 0)) return [3 /*break*/, 4];
                                                console.log("Found an address with balance: " + address.address + " with balance " + addrInfo.totalBalance);
                                                // This address has a balance.
                                                address.chainPath = basePath + '/' + addrIndex;
                                                address.userKey = derivedKeys[0];
                                                address.backupKey = derivedKeys[1];
                                                addressesById[address.address] = address;
                                                return [4 /*yield*/, self.getUnspentInfoFromExplorer(address.address, params.apiKey)];
                                            case 3:
                                                addressUnspents = _a.sent();
                                                addressUnspents.forEach(function addAddressToUnspent(unspent) {
                                                    unspent.address = address.address;
                                                    walletUnspents.push(unspent);
                                                });
                                                _a.label = 4;
                                            case 4:
                                                if (numSequentialAddressesWithoutTxs >= MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS) {
                                                    // stop searching for addresses with unspents in them, we've found ${MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS} in a row with none
                                                    // we are done
                                                    return [2 /*return*/];
                                                }
                                                return [2 /*return*/, gatherUnspents(addrIndex + 1)];
                                        }
                                    });
                                });
                                walletUnspents = [];
                                // This will populate walletAddresses
                                return [4 /*yield*/, gatherUnspents(0)];
                            case 1:
                                // This will populate walletAddresses
                                _a.sent();
                                if (walletUnspents.length === 0) {
                                    // Couldn't find any addresses with funds
                                    return [2 /*return*/, []];
                                }
                                return [2 /*return*/, walletUnspents];
                        }
                    });
                }).call(this);
            }
            var isKrsRecovery, isUnsignedSweep, krsProvider, keys, userKey, backupKey, bitgoKey, derivedUserKey, baseKeyPath, twoKeys, queries, addressesById, queryResponses, unspents, totalInputAmount, transactionBuilder, txInfo, feePerByte, outputSize, approximateSize, approximateFee, recoveryAmount, krsFee, err_1, krsFeeAddress, txHex, signedTx, _a, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        // ============================LOGIC============================
                        if (_.isUndefined(params.userKey)) {
                            throw new Error('missing userKey');
                        }
                        if (_.isUndefined(params.backupKey)) {
                            throw new Error('missing backupKey');
                        }
                        if (_.isUndefined(params.recoveryDestination) || !self.isValidAddress(params.recoveryDestination)) {
                            throw new Error('invalid recoveryDestination');
                        }
                        if (!_.isUndefined(params.scan) && (!_.isInteger(params.scan) || params.scan < 0)) {
                            throw new Error('scan must be a positive integer');
                        }
                        isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
                        isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
                        krsProvider = config.krsProviders[params.krsProvider];
                        if (isKrsRecovery && _.isUndefined(krsProvider)) {
                            throw new Error('unknown key recovery service provider');
                        }
                        if (isKrsRecovery && !(krsProvider.supportedCoins.includes(self.getFamily()))) {
                            throw new Error('specified key recovery service does not support recoveries for this coin');
                        }
                        return [4 /*yield*/, self.initiateRecovery(params)];
                    case 1:
                        keys = _b.sent();
                        userKey = keys[0], backupKey = keys[1], bitgoKey = keys[2];
                        if (params.userKeyPath) {
                            derivedUserKey = bitcoin_1.deriveKeyByPath(userKey, params.userKeyPath);
                            twoKeys = self.deriveKeys(self.deriveKeys([backupKey, bitgoKey], 0), 0);
                            baseKeyPath = [derivedUserKey].concat(twoKeys);
                        }
                        else {
                            baseKeyPath = self.deriveKeys(self.deriveKeys(keys, 0), 0);
                        }
                        queries = [];
                        addressesById = {};
                        _.forEach(Object.keys(unspents_1.Codes.UnspentTypeTcomb.meta.map), function (addressType) {
                            // If we aren't ignoring the address type, we derive the public key and construct the query for the external and
                            // internal indices
                            if (!_.includes(params.ignoreAddressTypes, addressType)) {
                                if (addressType === unspents_1.Codes.UnspentTypeTcomb('p2shP2wsh') && !self.supportsP2shP2wsh()) {
                                    // P2shP2wsh is not supported. Skip.
                                    return;
                                }
                                if (addressType === unspents_1.Codes.UnspentTypeTcomb('p2wsh') && !self.supportsP2wsh()) {
                                    // P2wsh is not supported. Skip.
                                    return;
                                }
                                var codes = void 0;
                                try {
                                    codes = unspents_1.Codes.forType(unspents_1.Codes.UnspentTypeTcomb(addressType));
                                }
                                catch (e) {
                                    // The unspent type is not supported by bitgo so attempting to get its chain codes throws. Catch that error
                                    // and continue.
                                    return;
                                }
                                var externalChainCode = codes.external;
                                var internalChainCode = codes.internal;
                                var externalKey = self.deriveKeys(baseKeyPath, externalChainCode);
                                var internalKey = self.deriveKeys(baseKeyPath, internalChainCode);
                                queries.push(queryBlockchainUnspentsPath(externalKey, '/0/0/' + externalChainCode, addressesById));
                                queries.push(queryBlockchainUnspentsPath(internalKey, '/0/0/' + internalChainCode, addressesById));
                            }
                        });
                        return [4 /*yield*/, Promise.all(queries)];
                    case 2:
                        queryResponses = _b.sent();
                        unspents = _.flatten(queryResponses);
                        totalInputAmount = _.sumBy(unspents, 'amount');
                        if (totalInputAmount <= 0) {
                            throw new errors.ErrorNoInputToRecover();
                        }
                        transactionBuilder = new bitcoin.TransactionBuilder(self.network);
                        self.prepareTransactionBuilder(transactionBuilder);
                        txInfo = {};
                        return [4 /*yield*/, self.getRecoveryFeePerBytes()];
                    case 3:
                        feePerByte = _b.sent();
                        outputSize = (isKrsRecovery ? 2 : 1) * unspents_1.VirtualSizes.txP2wshOutputSize;
                        approximateSize = unspents_1.VirtualSizes.txSegOverheadVSize + outputSize + (unspents_1.VirtualSizes.txP2shInputSize * unspents.length);
                        approximateFee = approximateSize * feePerByte;
                        // Construct a transaction
                        txInfo.inputs = unspents.map(function addInputForUnspent(unspent) {
                            var address = addressesById[unspent.address];
                            transactionBuilder.addInput(unspent.txid, unspent.n, 0xffffffff, address.outputScript);
                            return {
                                chainPath: address.chainPath,
                                redeemScript: address.redeemScript && address.redeemScript.toString('hex'),
                                witnessScript: address.witnessScript && address.witnessScript.toString('hex'),
                                value: unspent.amount,
                            };
                        });
                        recoveryAmount = totalInputAmount - approximateFee;
                        if (!isKrsRecovery) return [3 /*break*/, 7];
                        _b.label = 4;
                    case 4:
                        _b.trys.push([4, 6, , 7]);
                        return [4 /*yield*/, self.calculateFeeAmount({ provider: params.krsProvider, amount: recoveryAmount })];
                    case 5:
                        krsFee = _b.sent();
                        recoveryAmount -= krsFee;
                        return [3 /*break*/, 7];
                    case 6:
                        err_1 = _b.sent();
                        // Don't let this error block the recovery -
                        console.dir(err_1);
                        return [3 /*break*/, 7];
                    case 7:
                        if (recoveryAmount < 0) {
                            throw new Error("this wallet's balance is too low to pay the fees specified by the KRS provider. \n          Existing balance on wallet: " + totalInputAmount + ". Estimated network fee for the recovery transaction\n          : " + approximateFee + ", KRS fee to pay: " + krsFee + ". After deducting fees, your total recoverable balance\n          is " + recoveryAmount);
                        }
                        transactionBuilder.addOutput(params.recoveryDestination, recoveryAmount);
                        if (isKrsRecovery && krsFee > 0) {
                            krsFeeAddress = krsProvider.feeAddresses[self.getChain()];
                            if (!krsFeeAddress) {
                                throw new Error('this KRS provider has not configured their fee structure yet - recovery cannot be completed');
                            }
                            transactionBuilder.addOutput(krsFeeAddress, krsFee);
                        }
                        if (!isUnsignedSweep) return [3 /*break*/, 8];
                        txHex = transactionBuilder.buildIncomplete().toBuffer().toString('hex');
                        return [2 /*return*/, self.formatForOfflineVault(txInfo, txHex)];
                    case 8:
                        signedTx = self.signRecoveryTransaction(transactionBuilder, unspents, addressesById, !isKrsRecovery);
                        txInfo.transactionHex = signedTx.build().toBuffer().toString('hex');
                        _b.label = 9;
                    case 9:
                        _b.trys.push([9, 11, , 12]);
                        _a = txInfo;
                        return [4 /*yield*/, self.verifyRecoveryTransaction(txInfo)];
                    case 10:
                        _a.tx = _b.sent();
                        return [3 /*break*/, 12];
                    case 11:
                        e_1 = _b.sent();
                        // some coins don't have a reliable third party verification endpoint, or sometimes the third party endpoint
                        // could be unavailable due to service outage, so we continue without verification for those coins, but we will
                        // let users know that they should verify their own
                        // this message should be piped to WRW and displayed on the UI
                        if (e_1 instanceof errors.MethodNotImplementedError || e_1 instanceof errors.BlockExplorerUnavailable) {
                            console.log('Please verify your transaction by decoding the tx hex using a third-party api of your choice');
                        }
                        else {
                            throw e_1;
                        }
                        return [3 /*break*/, 12];
                    case 12:
                        if (isKrsRecovery) {
                            txInfo.coin = self.getChain();
                            txInfo.backupKey = params.backupKey;
                            txInfo.recoveryAmount = recoveryAmount;
                        }
                        return [2 /*return*/, txInfo];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Apply signatures to a funds recovery transaction using user + backup key
     * @param txb {Object} a transaction builder object (with inputs and outputs)
     * @param unspents {Array} the unspents to use in the transaction
     * @param addresses {Array} the address and redeem script info for the unspents
     * @param cosign {Boolean} whether to cosign this transaction with the user's backup key (false if KRS recovery)
     * @returns the transaction builder originally passed in as the first argument
     */
    AbstractUtxoCoin.prototype.signRecoveryTransaction = function (txb, unspents, addresses, cosign) {
        var _this = this;
        var signatureIssues = [];
        unspents.forEach(function (unspent, i) {
            var address = addresses[unspent.address];
            var backupPrivateKey = address.backupKey.keyPair;
            var userPrivateKey = address.userKey.keyPair;
            // force-override networks
            backupPrivateKey.network = _this.network;
            userPrivateKey.network = _this.network;
            var currentSignatureIssue = {
                inputIndex: i,
                unspent: unspent,
                error: null,
            };
            if (cosign) {
                try {
                    txb.sign(i, backupPrivateKey, address.redeemScript, _this.defaultSigHashType, unspent.amount, address.witnessScript);
                }
                catch (e) {
                    currentSignatureIssue.error = e;
                    signatureIssues.push(currentSignatureIssue);
                }
            }
            try {
                txb.sign(i, userPrivateKey, address.redeemScript, _this.defaultSigHashType, unspent.amount, address.witnessScript);
            }
            catch (e) {
                currentSignatureIssue.error = e;
                signatureIssues.push(currentSignatureIssue);
            }
        });
        if (signatureIssues.length > 0) {
            var failedIndices = signatureIssues.map(function (currentIssue) { return currentIssue.inputIndex; });
            var error = new Error("Failed to sign inputs at indices " + failedIndices.join(', '));
            error.code = 'input_signature_failure';
            error.signingErrors = signatureIssues;
            throw error;
        }
        return txb;
    };
    /**
     * Calculates the amount (in base units) to pay a KRS provider when building a recovery transaction
     * @param params
     * @param params.provider {String} the KRS provider that holds the backup key
     * @param params.amount {Number} amount (in base units) to be recovered
     * @param callback
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.calculateFeeAmount = function (params, callback) {
        var self = this;
        return co(function calculateFeeAmount() {
            var krsProvider, feeAmountUsd, currentPrice;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        krsProvider = config.krsProviders[params.provider];
                        if (krsProvider === undefined) {
                            throw new Error("no fee structure specified for provider " + params.provider);
                        }
                        if (!(krsProvider.feeType === 'flatUsd')) return [3 /*break*/, 2];
                        feeAmountUsd = krsProvider.feeAmount;
                        return [4 /*yield*/, self.getRecoveryMarketPrice()];
                    case 1:
                        currentPrice = _a.sent();
                        return [2 /*return*/, Math.round(feeAmountUsd / currentPrice * self.getBaseFactor())];
                    case 2: 
                    // we can add more fee structures here as needed for different providers, such as percentage of recovery amount
                    throw new Error('Fee structure not implemented');
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Recover BTC that was sent to the wrong chain
     * @param params
     * @param params.txid The txid of the faulty transaction
     * @param params.recoveryAddress address to send recovered funds to
     * @param params.wallet the wallet that received the funds
     * @param params.recoveryCoin the coin type of the wallet that received the funds
     * @param params.signed return a half-signed transaction (default=true)
     * @param params.walletPassphrase the wallet passphrase
     * @param params.xprv the unencrypted xprv (used instead of wallet passphrase)
     * @param callback
     * @returns {*}
     */
    AbstractUtxoCoin.prototype.recoverFromWrongChain = function (params, callback) {
        var self = this;
        return co(function recoverFromWrongChain() {
            var txid, recoveryAddress, wallet, walletPassphrase, xprv, recoveryCoin, signed, sourceCoinFamily, recoveryCoinFamily, supportedRecoveryCoins, recoveryTool;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txid = params.txid, recoveryAddress = params.recoveryAddress, wallet = params.wallet, walletPassphrase = params.walletPassphrase, xprv = params.xprv;
                        recoveryCoin = params.coin || params.recoveryCoin;
                        if (!recoveryCoin) {
                            throw new Error('missing required object recoveryCoin');
                        }
                        signed = params.signed !== false;
                        sourceCoinFamily = self.getFamily();
                        recoveryCoinFamily = recoveryCoin.getFamily();
                        supportedRecoveryCoins = config.supportedCrossChainRecoveries[sourceCoinFamily];
                        if (_.isUndefined(supportedRecoveryCoins) || !supportedRecoveryCoins.includes(recoveryCoinFamily)) {
                            throw new Error("Recovery of " + sourceCoinFamily + " balances from " + recoveryCoinFamily + " wallets is not supported.");
                        }
                        recoveryTool = new recovery_1.CrossChainRecoveryTool({
                            bitgo: self.bitgo,
                            sourceCoin: self,
                            recoveryCoin: recoveryCoin,
                            logging: false,
                        });
                        return [4 /*yield*/, recoveryTool.buildTransaction({
                                wallet: wallet,
                                faultyTxId: txid,
                                recoveryAddress: recoveryAddress,
                            })];
                    case 1:
                        _a.sent();
                        if (!signed) return [3 /*break*/, 3];
                        return [4 /*yield*/, recoveryTool.signTransaction({ passphrase: walletPassphrase, prv: xprv })];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, recoveryTool.export()];
                    case 3: return [4 /*yield*/, recoveryTool.buildUnsigned()];
                    case 4: return [2 /*return*/, _a.sent()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Generate secp256k1 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    AbstractUtxoCoin.prototype.generateKeyPair = function (seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto_1.randomBytes(512 / 8);
        }
        var extendedKey = bitcoin.HDNode.fromSeedBuffer(seed);
        var xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58(),
        };
    };
    AbstractUtxoCoin.prototype.getExtraPrebuildParams = function (buildParams, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    AbstractUtxoCoin.prototype.preCreateBitGo = function (params) { };
    AbstractUtxoCoin.prototype.presignTransaction = function (params, callback) {
        return Bluebird.resolve(params).asCallback(callback);
    };
    AbstractUtxoCoin.prototype.supplementGenerateWallet = function (walletParams, keychains) {
        return Bluebird.resolve(walletParams);
    };
    AbstractUtxoCoin.prototype.transactionDataAllowed = function () {
        return false;
    };
    AbstractUtxoCoin.prototype.valuelessTransferAllowed = function () {
        return false;
    };
    AbstractUtxoCoin.prototype.verifyRecoveryTransaction = function (txInfo) {
        return Bluebird.reject(new errors.MethodNotImplementedError());
    };
    AbstractUtxoCoin.prototype.signMessage = function (key, message, callback) {
        return co(function cosignMessage() {
            var privateKey, privateKeyBuffer, isCompressed, prefix;
            return __generator(this, function (_a) {
                privateKey = bitcoin.HDNode.fromBase58(key.prv).getKey();
                privateKeyBuffer = privateKey.d.toBuffer(32);
                isCompressed = privateKey.compressed;
                prefix = bitcoin.networks.bitcoin.messagePrefix;
                return [2 /*return*/, bitcoinMessage.sign(message, privateKeyBuffer, isCompressed, prefix)];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    return AbstractUtxoCoin;
}(baseCoin_1.BaseCoin));
exports.AbstractUtxoCoin = AbstractUtxoCoin;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJzdHJhY3RVdHhvQ29pbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy92Mi9jb2lucy9hYnN0cmFjdFV0eG9Db2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNENBQXNEO0FBQ3RELG9EQUF5RDtBQUN6RCx5Q0FBMkM7QUFDM0Msa0RBQW9EO0FBQ3BELG1DQUFxQztBQUNyQyxpQ0FBcUM7QUFDckMsZ0NBQWtDO0FBQ2xDLDBCQUE0QjtBQUM1QixvQ0FBc0M7QUFFdEMseUNBQXdEO0FBRXhELHFDQUF1QztBQUN2QyxxQ0FBdUM7QUFFdkMsd0NBZ0JxQjtBQUNyQix1REFBMkU7QUFFM0UsMENBQW9EO0FBQ3BELGtEQUFnRDtBQUNoRCx3Q0FBcUQ7QUFLckQsSUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQ3hDLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUErTTlCO0lBQStDLG9DQUFRO0lBS3JELDBCQUFzQixLQUFZLEVBQUUsT0FBb0I7UUFBeEQsWUFDRSxrQkFBTSxLQUFLLENBQUMsU0FLYjtRQUpDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3hCLE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLENBQUMsQ0FBQztTQUM5QztRQUNELEtBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDOztJQUMxQixDQUFDO0lBRUQsc0JBQUkscUNBQU87YUFBWDtZQUNFLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUN2QixDQUFDOzs7T0FBQTtJQUVELHNCQUFXLHFDQUFpQjthQUE1QjtZQUNFLElBQU0saUJBQWlCLEdBQWtCLEVBQUUsQ0FBQztZQUM1QyxpREFBaUQ7WUFDakQsOEVBQThFO1lBQzlFLDZDQUE2QztZQUM3QyxJQUFNLGVBQWUsR0FBYSxNQUFNLENBQUMsSUFBSSxDQUFDLG1CQUFXLENBQUMsQ0FBQztZQUMzRCxJQUFNLFlBQVksR0FBa0IsZUFBZTtpQkFDaEQsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsbUJBQVcsQ0FBQyxDQUFRLENBQUMsRUFBckIsQ0FBcUIsQ0FBQztpQkFDL0IsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsQ0FBZ0IsRUFBaEIsQ0FBZ0IsQ0FBQyxDQUFDO1lBQzlCLEtBQTBCLFVBQVksRUFBWiw2QkFBWSxFQUFaLDBCQUFZLEVBQVosSUFBWSxFQUFFO2dCQUFuQyxJQUFNLFdBQVcscUJBQUE7Z0JBQ3BCLElBQUk7b0JBQ0YsZ0JBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7b0JBQzNCLGlCQUFpQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztpQkFDckM7Z0JBQUMsT0FBTyxDQUFDLEVBQUU7b0JBQ1YsNEdBQTRHO29CQUM1Ryx5RUFBeUU7aUJBQzFFO2FBQ0Y7WUFDRCxPQUFPLGlCQUFpQixDQUFDO1FBQzNCLENBQUM7OztPQUFBO0lBRUQ7OztPQUdHO0lBQ0gsd0NBQWEsR0FBYjtRQUNFLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVEOztPQUVHO0lBQ0gseUNBQWMsR0FBZDtRQUNFLE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRDs7T0FFRztJQUNPLDRDQUFpQixHQUEzQixVQUE0QixPQUFlO1FBQ3pDLCtCQUErQjtRQUMvQixJQUFJO1lBQ00sSUFBQSx3RUFBTyxDQUE0RDtZQUMzRSxPQUFPLE9BQU8sQ0FBQztTQUNoQjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsNkZBQTZGO1lBQzdGLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLEVBQUU7Z0JBQ3pCLE9BQU87YUFDUjtTQUNGO1FBRUQsb0NBQW9DO1FBQ3BDLElBQUk7WUFDSSxJQUFBLHNEQUF1RSxFQUFyRSxvQkFBTyxFQUFFLGtCQUE0RCxDQUFDO1lBQzlFLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLE1BQU0sS0FBSyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRTtnQkFDckUsT0FBTyxPQUFPLENBQUM7YUFDaEI7U0FDRjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1Ysd0RBQXdEO1NBQ3pEO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ08sMkNBQWdCLEdBQTFCLFVBQTJCLE9BQWU7UUFDeEMsb0NBQW9DO1FBQ3BDLElBQUk7WUFDTSxJQUFBLGlFQUFNLENBQXVEO1lBQ3JFLE9BQU8sTUFBTSxDQUFDO1NBQ2Y7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLHdEQUF3RDtTQUN6RDtJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gseUNBQWMsR0FBZCxVQUFlLE9BQWUsRUFBRSxxQkFBNkI7UUFBN0Isc0NBQUEsRUFBQSw2QkFBNkI7UUFDM0QsSUFBTSxhQUFhLEdBQUc7WUFDcEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVO1lBQ3ZCLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVTtTQUN4QixDQUFDO1FBQ0YsSUFBSSxJQUFJLENBQUMsYUFBYSxJQUFJLENBQUMscUJBQXFCLElBQUksSUFBSSxDQUFDLDJCQUEyQixDQUFDLEVBQUU7WUFDckYsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDeEM7UUFFRCxJQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFdkQsdURBQXVEO1FBQ3ZELElBQU0sbUJBQW1CLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsSUFBSSxhQUFhLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ2pHLElBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUVyRCxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLEVBQUU7WUFDekQsT0FBTyxtQkFBbUIsQ0FBQztTQUM1QjtRQUVELHVEQUF1RDtRQUN2RCxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sS0FBSyxhQUFhLENBQUM7SUFDbEYsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gscUNBQVUsR0FBVixVQUFXLEdBQVc7UUFDcEIsSUFBSTtZQUNGLE9BQU8sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQy9CLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILCtDQUFvQixHQUFwQixVQUFxQixLQUFxQixFQUFFLFFBQStCO1FBQ3pFLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBUzs7Ozs7d0JBQ2hCLElBQUksS0FBSyxFQUFFOzRCQUNULElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQzt5QkFDM0I7d0JBQ2lCLHFCQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFBOzt3QkFBM0UsU0FBUyxHQUFHLFNBQStEO3dCQUNqRixzQkFBTyxTQUFTLENBQUMsTUFBTSxFQUFDOzs7U0FDekIsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCw4Q0FBbUIsR0FBbkIsVUFBb0IsUUFBNkIsRUFBRSxRQUE0QztRQUM3RixJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQXNCOzs7Ozt3QkFDN0IsSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTs0QkFDakMsTUFBTSxJQUFJLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO3lCQUMvRDt3QkFDSyxXQUFXLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7NkJBQzFFLENBQUMsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxFQUFuQyx3QkFBbUM7d0JBQ3JDLEtBQUEsUUFBUSxDQUFBO3dCQUFnQixxQkFBTSxJQUFJLENBQUMsb0JBQW9CLEVBQUUsRUFBQTs7d0JBQXpELEdBQVMsV0FBVyxHQUFHLENBQUMsU0FBaUMsQ0FBVyxDQUFDOzs7d0JBRXZFLCtEQUErRDt3QkFDL0Qsb0hBQW9IO3dCQUNwSCxXQUFXLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUM7d0JBQzVDLHNCQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLFFBQVEsRUFBRSxFQUFFLEtBQUssRUFBRSxXQUFXLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxFQUFDOzs7U0FDL0QsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ2MsbUNBQWtCLEdBQW5DLFVBQW9DLGVBQXlCLEVBQUUsYUFBdUI7UUFDcEYsSUFBTSxPQUFPLEdBQUcsVUFBQyxFQUEyQjtnQkFBekIsb0JBQU8sRUFBRSxrQkFBTTtZQUF1QixPQUFHLE9BQU8sU0FBSSxNQUFNLENBQUMsTUFBTSxDQUFHO1FBQTlCLENBQThCLENBQUM7UUFDeEYsSUFBTSxjQUFjLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFFM0QsYUFBYSxDQUFDLE9BQU8sQ0FBQyxVQUFDLE1BQU07WUFDM0IsSUFBTSxLQUFLLEdBQUcsY0FBYyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQzlDLElBQUksS0FBSyxFQUFFO2dCQUNULEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQzthQUNiO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFSCxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRDs7O09BR0c7SUFDSSxpQ0FBZ0IsR0FBdkIsVUFBd0IsY0FBcUQ7UUFDM0UsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsRUFBRTtZQUMzQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLEVBQUU7Z0JBQ2pILE9BQU8sZ0JBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUM1QztpQkFBTSxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsRUFBRTtnQkFDL0QsT0FBTyxnQkFBSyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ3ZDO2lCQUFNLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxFQUFFO2dCQUNoRSxPQUFPLGdCQUFLLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDeEM7U0FDRjtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsMkNBQWdCLEdBQWhCLFVBQWlCLE1BQStCLEVBQUUsUUFBMEM7UUFDMUYsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFvQjtZQWMzQixTQUFlLGNBQWMsQ0FBQyxNQUFjOzs7d0JBQzFDLHNCQUFPLDRCQUFZLENBQUM7Z0NBQ2xCLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxzQkFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssT0FBQSxFQUFFLENBQUM7Z0NBQzNFLE1BQU0sRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxzQkFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssT0FBQSxFQUFFLENBQUM7Z0NBQy9FLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxzQkFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssT0FBQSxFQUFFLENBQUM7NkJBQzlFLENBQUMsRUFBQzs7O2FBQ0o7Ozs7O3dCQWxCQyxRQUFRLEdBS04sTUFBTSxTQUxBLEVBQ1IsVUFBVSxHQUlSLE1BQU0sV0FKRSxFQUNWLE1BQU0sR0FHSixNQUFNLE9BSEYsRUFDTixLQUVFLE1BQU0sYUFGUyxFQUFqQixZQUFZLG1CQUFHLEVBQUUsS0FBQSxFQUNqQixLQUFLLEdBQ0gsTUFBTSxNQURILENBQ0k7d0JBRVgsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFOzRCQUNsRyxNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQUM7eUJBQ3JFO3dCQUNLLGlCQUFpQixHQUFHLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQzt3QkFXckQsU0FBUyxHQUFpRCxZQUFZLENBQUMsU0FBUyxDQUFDOzZCQUNqRixDQUFDLFNBQVMsRUFBVix3QkFBVTt3QkFDWixJQUFJLGlCQUFpQixFQUFFOzRCQUNyQixNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7eUJBQzlEO3dCQUNXLHFCQUFNLGNBQWMsQ0FBQyxNQUFNLENBQUMsRUFBQTs7d0JBQXhDLFNBQVMsR0FBRyxTQUE0QixDQUFDOzs7d0JBRzNDLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUU7NEJBQzFFLE1BQU0sSUFBSSxLQUFLLENBQUMsa0RBQWtELENBQUMsQ0FBQzt5QkFDckU7d0JBRUssYUFBYSxHQUFtQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7d0JBRXBHLGFBQWEsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO3dCQUU3RCxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFOzRCQUNuQyxNQUFNLElBQUksS0FBSyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7eUJBQy9EO3dCQUUyQyxxQkFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUM7Z0NBQ3hFLEtBQUssRUFBRSxVQUFVLENBQUMsS0FBSztnQ0FDdkIsTUFBTSxFQUFFLFVBQVUsQ0FBQyxNQUFNOzZCQUMxQixDQUFDLEVBQUE7O3dCQUhJLFdBQVcsR0FBMkIsU0FHMUM7d0JBRUksVUFBVSxHQUFPLFdBQVcsQ0FBQyxPQUFPLFFBQUssV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDO3dCQUdwRSxlQUFlLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsWUFBWSxFQUFFLEVBQTRCLENBQUMsQ0FBQzt3QkFDOUUsY0FBYyxHQUFHLGdCQUFnQixDQUFDLGtCQUFrQixDQUFDLGVBQWUsRUFBRSxVQUFVLENBQUMsQ0FBQzt3QkFJaEYsS0FBcUMsQ0FBQSxNQUFNLENBQUMsWUFBWSxFQUFFLElBQUksRUFBRSxDQUFBLHFCQUFoQyxFQUFoQyxvQkFBb0IsbUJBQUcsU0FBUyxLQUFBLENBQWlDOzZCQUNyRSxvQkFBb0IsRUFBcEIsd0JBQW9CO3dCQUdoQix5QkFBeUIsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxtQ0FBbUMsRUFBRSxFQUFFLENBQUMsQ0FBQzt3QkFDdEQscUJBQU0sSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxvQkFBb0IsRUFBRSxDQUFDLEVBQUE7O3dCQUFuRixrQkFBa0IsR0FBVyxTQUFzRDt3QkFDaEUscUJBQU0sY0FBYyxDQUFDLGtCQUFrQixDQUFDLEVBQUE7O3dCQUEzRCxnQkFBZ0IsR0FBRyxTQUF3Qzt3QkFFakUsSUFBSSxDQUFDLGdCQUFnQixFQUFFOzRCQUNyQixNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7eUJBQ3ZFO3dCQUNLLHFCQUFxQixHQUFtQyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7d0JBRXZJLElBQUkscUJBQXFCLElBQUksa0JBQWtCLEVBQUU7NEJBQy9DLFlBQVksR0FBRztnQ0FDYixJQUFJLEVBQUUscUJBQXFCO2dDQUMzQixVQUFVLEVBQUUsQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLEVBQUUseUJBQXlCLENBQUMsTUFBTSxFQUFFLHlCQUF5QixDQUFDLEtBQUssQ0FBQzs2QkFDaEgsQ0FBQzt5QkFDSDs7NEJBT2dDLHFCQUFNLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLFVBQUMsYUFBYTs0QkFDOUUsT0FBTyx5QkFBVyxDQUFDO2dDQUNqQixhQUFhLGVBQUE7Z0NBQ2IsSUFBSSxFQUFFLElBQUk7Z0NBQ1YsVUFBVSxZQUFBO2dDQUNWLFlBQVksY0FBQTtnQ0FDWixhQUFhLGVBQUE7Z0NBQ2IsTUFBTSxRQUFBO2dDQUNOLFFBQVEsVUFBQTtnQ0FDUixZQUFZLGNBQUE7Z0NBQ1osS0FBSyxPQUFBOzZCQUNOLENBQUMsQ0FBQzt3QkFDTCxDQUFDLENBQUMsRUFBQTs7d0JBWkksZ0JBQWdCLEdBQWEsU0FZakM7d0JBRUkseUNBQXlDLEdBQUcsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFVBQUMsTUFBTSxJQUFLLE9BQUEsTUFBTSxDQUFDLHlDQUF5QyxFQUFoRCxDQUFnRCxDQUFDLENBQUM7d0JBRWhJLGFBQWEsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUFFLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7d0JBR2hFLGVBQWUsR0FBRyxnQkFBZ0IsQ0FBQyxrQkFBa0IsQ0FBQyxnQkFBZ0IsRUFBRSxlQUFlLENBQUMsQ0FBQzt3QkFFekYsZUFBZSxHQUFHLGdCQUFnQixDQUFDLGtCQUFrQixDQUFDLGdCQUFnQixFQUFFLGVBQWUsQ0FBQyxDQUFDO3dCQUd6Rix1QkFBdUIsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLGVBQWUsRUFBRSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO3dCQUd4RSwyQkFBMkIsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLHVCQUF1QixFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQWF6RSx1QkFBdUIsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLGVBQWUsRUFBRSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO3dCQUN4RSwyQkFBMkIsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLHVCQUF1QixFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUV6RSxNQUFNLEdBQXNCOzRCQUNoQyxTQUFTLFdBQUE7NEJBQ1QsYUFBYSxlQUFBOzRCQUNiLE9BQU8sRUFBRSxnQkFBZ0I7NEJBQ3pCLGNBQWMsZ0JBQUE7NEJBQ2QsdUJBQXVCLHlCQUFBOzRCQUN2Qix1QkFBdUIseUJBQUE7NEJBQ3ZCLGFBQWEsZUFBQTs0QkFDYiwyQkFBMkIsNkJBQUE7NEJBQzNCLDJCQUEyQiw2QkFBQTs0QkFDM0IseUNBQXlDLDJDQUFBOzRCQUN6QyxZQUFZLGNBQUE7eUJBQ2IsQ0FBQzt3QkFDRixzQkFBTyxNQUFNLEVBQUM7OztTQUNmLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNPLDhDQUFtQixHQUE3QixVQUE4QixNQUFrQztRQUN0RCxJQUFBLGtDQUFZLEVBQUUsMEJBQVEsRUFBRSw0Q0FBaUIsQ0FBWTtRQUM3RCxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ2pCLE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLENBQUMsQ0FBQztTQUM5QztRQUVELElBQU0sT0FBTyxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUM7UUFFakMsdUZBQXVGO1FBQ3ZGLElBQUksT0FBTyxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUM7UUFDL0IsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3RCLElBQU0sWUFBWSxHQUFHLFlBQVksQ0FBQyxZQUFZLENBQUM7WUFDL0MsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEVBQUU7Z0JBQzVCLGtEQUFrRDtnQkFDbEQsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDO29CQUMzQixLQUFLLEVBQUUsWUFBWTtvQkFDbkIsUUFBUSxFQUFFLFFBQVEsQ0FBQyxnQkFBZ0I7aUJBQ3BDLENBQUMsQ0FBQzthQUNKO1NBQ0Y7UUFFRCxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDdEIsSUFBTSxZQUFZLEdBQUcsK0NBQStDLENBQUM7WUFDckUsSUFBSSxpQkFBaUIsRUFBRTtnQkFDckIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQztnQkFDMUIsT0FBTyxLQUFLLENBQUM7YUFDZDtpQkFBTTtnQkFDTCxNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO2FBQy9CO1NBQ0Y7YUFBTTtZQUNMLElBQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzFELElBQUksY0FBYyxDQUFDLFFBQVEsRUFBRSxLQUFLLGNBQWMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUUsRUFBRTtnQkFDdEUsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO2FBQ3BEO1lBQ0QsSUFBSSxjQUFjLENBQUMsUUFBUSxFQUFFLENBQUMsUUFBUSxFQUFFLEtBQUssT0FBTyxFQUFFO2dCQUNwRCxNQUFNLElBQUksS0FBSyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7YUFDL0Q7U0FDRjtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNPLDZDQUFrQixHQUE1QixVQUE2QixNQUFrQztRQUM3RCwyR0FBMkc7UUFDbkcsSUFBQSxrQ0FBWSxFQUFFLDBDQUFnQixFQUFFLGtDQUFZLENBQVk7UUFDaEUsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNqQixNQUFNLElBQUksS0FBSyxDQUFDLDJCQUEyQixDQUFDLENBQUM7U0FDOUM7UUFFRCxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7WUFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO1NBQ25EO1FBRUQsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNqQixNQUFNLElBQUksS0FBSyxDQUFDLDJCQUEyQixDQUFDLENBQUM7U0FDOUM7UUFFRCxtREFBbUQ7UUFDbkQsSUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUV4RixtRUFBbUU7UUFDbkUseUZBQXlGO1FBQ3pGLElBQUk7WUFDRixPQUFPLGNBQWMsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxFQUFFLGNBQWMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQ3RHO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixLQUFLLENBQUMsZ0VBQWdFLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDM0UsT0FBTyxLQUFLLENBQUM7U0FDZDtJQUNILENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDTywwREFBK0IsR0FBekMsVUFBMEMsRUFBcUIsRUFBRSxZQUFzQjtRQUNyRixJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksRUFBRTtZQUNwQixNQUFNLElBQUksS0FBSyxDQUFDLHdFQUF3RSxDQUFDLENBQUM7U0FDM0Y7UUFFRCxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ3RGLE1BQU0sSUFBSSxLQUFLLENBQUMscURBQXFELENBQUMsQ0FBQztTQUN4RTtRQUVELEtBQXVCLFVBQXNELEVBQXRELE1BQUMsc0JBQVUsQ0FBQyxJQUFJLEVBQUUsc0JBQVUsQ0FBQyxNQUFNLEVBQUUsc0JBQVUsQ0FBQyxLQUFLLENBQUMsRUFBdEQsY0FBc0QsRUFBdEQsSUFBc0QsRUFBRTtZQUExRSxJQUFNLFFBQVEsU0FBQTtZQUNqQixJQUFNLGdCQUFnQixHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3hELElBQU0sWUFBWSxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzFELElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtnQkFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBa0Msc0JBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxXQUFXLEVBQUUseUJBQXNCLENBQUMsQ0FBQzthQUM3RztZQUNELElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQ2pCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0NBQWtDLHNCQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsV0FBVyxFQUFFLHdCQUFxQixDQUFDLENBQUM7YUFDNUc7WUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEVBQUUsWUFBWSxjQUFBLEVBQUUsZ0JBQWdCLGtCQUFBLEVBQUUsWUFBWSxjQUFBLEVBQUUsQ0FBQyxFQUFFO2dCQUM5RSxLQUFLLENBQUMsa0RBQWtELEVBQUUsc0JBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO2dCQUM5RixPQUFPLEtBQUssQ0FBQzthQUNkO1NBQ0Y7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7T0FjRztJQUNILDRDQUFpQixHQUFqQixVQUFrQixNQUFnQyxFQUFFLFFBQWdDO1FBQ2xGLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBVTs7Ozs7d0JBQ1QsUUFBUSxHQUFtRCxNQUFNLFNBQXpELEVBQUUsVUFBVSxHQUF1QyxNQUFNLFdBQTdDLEVBQUUsTUFBTSxHQUErQixNQUFNLE9BQXJDLEVBQUUsS0FBNkIsTUFBTSxhQUFsQixFQUFqQixZQUFZLG1CQUFHLEVBQUUsS0FBQSxFQUFFLEtBQUssR0FBSyxNQUFNLE1BQVgsQ0FBWTt3QkFDcEUsaUJBQWlCLEdBQUcsQ0FBQyxDQUFDLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQzt3QkFDZCxxQkFBTSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxRQUFRLFVBQUEsRUFBRSxVQUFVLFlBQUEsRUFBRSxNQUFNLFFBQUEsRUFBRSxZQUFZLGNBQUEsRUFBRSxLQUFLLE9BQUEsRUFBRSxDQUFDLEVBQUE7O3dCQUF6SCxpQkFBaUIsR0FBc0IsU0FBa0Y7d0JBRXpILFNBQVMsR0FBRyxpQkFBaUIsQ0FBQyxTQUFTLENBQUM7d0JBRzFDLHFCQUFxQixHQUFHLEtBQUssQ0FBQzt3QkFDbEMsSUFBSTs0QkFDRiw0RkFBNEY7NEJBQzVGLHFCQUFxQixHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFLFlBQVksRUFBRSxTQUFTLENBQUMsSUFBSSxFQUFFLGlCQUFpQixtQkFBQSxFQUFFLFFBQVEsVUFBQSxFQUFFLENBQUMsQ0FBQzt5QkFDakg7d0JBQUMsT0FBTyxDQUFDLEVBQUU7NEJBQ1YsS0FBSyxDQUFDLG1DQUFtQyxFQUFFLENBQUMsQ0FBQyxDQUFDO3lCQUMvQzt3QkFHSyxhQUFhLEdBQUcsaUJBQWlCLENBQUMsYUFBYSxDQUFDO3dCQUN0RCxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsRUFBRTs0QkFDdkIsTUFBTSxHQUFHLFVBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSyxPQUFBLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLFlBQVksRUFBRSxTQUFTLENBQUMsSUFBSSxFQUFFLGdCQUFnQixFQUFFLEdBQUcsRUFBRSxZQUFZLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBbkcsQ0FBbUcsQ0FBQzs0QkFDM0gseUJBQXlCLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDOzRCQUM5RSx3QkFBd0IsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7NEJBQ2pGLElBQUksQ0FBQyx5QkFBeUIsSUFBSSxDQUFDLHdCQUF3QixFQUFFO2dDQUMzRCxNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7NkJBQzVEOzRCQUNELEtBQUssQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO3lCQUNoRTs2QkFBTSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7NEJBQzdCLHlFQUF5RTs0QkFDekUsMEJBQTBCOzRCQUMxQixPQUFPLENBQUMsR0FBRyxDQUFDLHVFQUF1RSxDQUFDLENBQUM7eUJBQ3RGO3dCQUVELElBQUksaUJBQWlCLENBQUMseUNBQXlDLEVBQUU7NEJBQy9ELElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUU7Z0NBQzdDLE1BQU0sSUFBSSxLQUFLLENBQUMsd0ZBQXdGLENBQUMsQ0FBQzs2QkFDM0c7NEJBQ0ssaUNBQWlDLEdBQUcsSUFBSSxDQUFDLCtCQUErQixDQUFDLGlCQUFpQixFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQzs0QkFDbEgsSUFBSSxDQUFDLGlDQUFpQyxFQUFFO2dDQUN0QyxNQUFNLElBQUksS0FBSyxDQUFDLHdHQUF3RyxDQUFDLENBQUM7NkJBQzNIOzRCQUNELEtBQUssQ0FBQyx3RUFBd0UsQ0FBQyxDQUFDO3lCQUNqRjt3QkFFSyxjQUFjLEdBQUcsaUJBQWlCLENBQUMsY0FBYyxDQUFDO3dCQUN4RCxJQUFJLGNBQWMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFOzRCQUMvQixrR0FBa0c7NEJBQ2xHLE1BQU0sSUFBSSxLQUFLLENBQUMsa0RBQWtELENBQUMsQ0FBQzt5QkFDckU7d0JBRUsscUJBQXFCLEdBQUcsaUJBQWlCLENBQUMsMkJBQTJCLENBQUM7d0JBR3RFLGVBQWUsR0FBRyxxQkFBcUIsR0FBRyxLQUFLLENBQUM7d0JBWWhELGVBQWUsR0FBRyxpQkFBaUIsQ0FBQywyQkFBMkIsQ0FBQzt3QkFFdEUsS0FBSyxDQUFDLGtFQUFrRSxFQUFFLHFCQUFxQixFQUFFLGVBQWUsRUFBRSxlQUFlLENBQUMsQ0FBQzt3QkFFbkksaUhBQWlIO3dCQUNqSCxJQUFJLGVBQWUsR0FBRyxlQUFlLEVBQUU7NEJBQ3JDLDJHQUEyRzs0QkFDM0csTUFBTSxJQUFJLEtBQUssQ0FBQyw4REFBOEQsQ0FBQyxDQUFDO3lCQUNqRjt3QkFFSyxVQUFVLEdBQUcsaUJBQWlCLENBQUMsT0FBTyxDQUFDO3dCQUN2QyxXQUFXLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7d0JBQzFFLGdCQUFnQixHQUFHLEVBQUUsQ0FBQzt3QkFDYixxQkFBTSxRQUFRLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLFVBQVcsWUFBWTs7Ozs7NENBQ3JFLGFBQWEsR0FBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQWEsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7NENBQ3JGLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxvQkFBa0IsYUFBZSxDQUFDLENBQUM7aURBQy9ELEtBQUssRUFBTCx3QkFBSzs0Q0FDRCxPQUFPLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQzs0Q0FDakUsSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFLEtBQUssYUFBYSxFQUFFO2dEQUNyQyxNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7NkNBQzVEOzRDQUNLLGFBQWEsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQzs0Q0FDakQsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7NENBQ3JGLHNCQUFPO29EQUNMLE9BQU8sU0FBQTtvREFDUCxLQUFLLEVBQUUsYUFBYSxDQUFDLEtBQUs7aURBQzNCLEVBQUM7O2lEQUNPLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLEVBQWhDLHdCQUFnQzs0Q0FDekMsSUFBSSxpQkFBaUIsRUFBRTtnREFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyxnRkFBZ0YsQ0FBQyxDQUFDOzZDQUNuRzs0Q0FDRCxJQUFJLEtBQUssRUFBRTtnREFDVCxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDOzZDQUNwQzs0Q0FDRCxLQUFBLGdCQUFnQixDQUFBOzRDQUFDLEtBQUEsYUFBYSxDQUFBOzRDQUFJLHFCQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsZ0JBQWMsYUFBZSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBQTs7NENBQXhHLE1BQStCLEdBQUcsU0FBc0UsQ0FBQzs7OzRDQUVyRyxrQkFBa0IsR0FBRyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsQ0FBQzs0Q0FDM0Qsc0JBQU8sa0JBQWtCLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsRUFBQzs7OzZCQUN2RCxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUE7O3dCQXpCUixNQUFNLEdBQUcsU0F5QkQ7d0JBRVIsV0FBVyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO3dCQUN2QyxZQUFZLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7d0JBQzdDLEdBQUcsR0FBRyxXQUFXLEdBQUcsWUFBWSxDQUFDO3dCQUV2QyxJQUFJLEdBQUcsR0FBRyxDQUFDLEVBQUU7NEJBQ1gsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBdUIsWUFBWSxtREFBOEMsV0FBVyxzQkFBaUIsQ0FBQyxHQUFLLENBQUMsQ0FBQzt5QkFDdEk7d0JBRUQsc0JBQU8sSUFBSSxFQUFDOzs7U0FDYixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSCx3Q0FBYSxHQUFiLFVBQWMsTUFBNEI7UUFDaEMsSUFBQSx3QkFBTyxFQUFFLGdDQUFXLEVBQUUsNEJBQVMsRUFBRSxrQ0FBWSxFQUFFLG9CQUFLLEVBQUUsb0JBQUssQ0FBWTtRQUUvRSxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUNqQyxNQUFNLElBQUksTUFBTSxDQUFDLG1CQUFtQixDQUFDLHNCQUFvQixPQUFTLENBQUMsQ0FBQztTQUNyRTtRQUVELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ2pHLE1BQU0sSUFBSSxNQUFNLENBQUMscUNBQXFDLENBQUMsZ0RBQThDLEtBQUssb0JBQWUsS0FBSyxNQUFHLENBQUMsQ0FBQztTQUNwSTtRQUVELElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxFQUFFO1lBQzdCLE1BQU0sSUFBSSxNQUFNLENBQUMsNkNBQTZDLENBQUMsa0VBQWtFLENBQUMsQ0FBQztTQUNwSTtRQUVELElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDZCxNQUFNLElBQUksS0FBSyxDQUFDLGtDQUFrQyxDQUFDLENBQUM7U0FDckQ7UUFFRCxJQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO1lBQzNDLFdBQVcsYUFBQTtZQUNYLFNBQVMsV0FBQTtZQUNULFNBQVMsRUFBRSxDQUFDO1lBQ1osS0FBSyxPQUFBO1lBQ0wsS0FBSyxPQUFBO1NBQ04sQ0FBQyxDQUFDO1FBRUgsSUFBSSxlQUFlLENBQUMsT0FBTyxLQUFLLE9BQU8sRUFBRTtZQUN2QyxNQUFNLElBQUksTUFBTSxDQUFDLHNCQUFzQixDQUFDLDBDQUF3QyxlQUFlLENBQUMsT0FBTyxpQkFBWSxPQUFTLENBQUMsQ0FBQztTQUMvSDtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7T0FHRztJQUNILDhDQUFtQixHQUFuQjtRQUNFLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7T0FHRztJQUNILDRDQUFpQixHQUFqQjtRQUNFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOzs7T0FHRztJQUNILHdDQUFhLEdBQWI7UUFDRSxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7O09BWUc7SUFDSCwwQ0FBZSxHQUFmLFVBQWdCLE1BQThCO1FBQ3BDLElBQUEsNEJBQVMsRUFBRSw0QkFBUyxFQUFFLG9CQUFLLEVBQUUsb0JBQUssRUFBRSxrQkFBYyxFQUFkLG1DQUFjLEVBQUUsa0JBQWMsRUFBZCxtQ0FBYyxDQUFZO1FBQ3RGLElBQUksZUFBZSxHQUFHLENBQUMsQ0FBQztRQUN4QixJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFO1lBQ3hELGVBQWUsR0FBRyxLQUFLLENBQUM7U0FDekI7UUFFRCxTQUFTLHlCQUF5QjtZQUNoQyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksTUFBTSxFQUFFO2dCQUNqQyxPQUFPLGdCQUFLLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDNUM7aUJBQU0sSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLE1BQU0sRUFBRTtnQkFDeEMsT0FBTyxnQkFBSyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQ3hDO2lCQUFNO2dCQUNMLE9BQU8sZ0JBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUN2QztRQUNILENBQUM7UUFFRCxJQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsV0FBVyxJQUFJLHlCQUF5QixFQUFFLENBQUM7UUFFdEUsUUFBUSxXQUFXLEVBQUU7WUFDbkIsS0FBSyxnQkFBSyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQztnQkFDakMsSUFBSSxDQUFDLGdCQUFLLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxFQUFFO29CQUNsQyxNQUFNLElBQUksTUFBTSxDQUFDLDZCQUE2QixDQUFDLFdBQVcsRUFBRSxlQUFlLENBQUMsQ0FBQztpQkFDOUU7Z0JBQ0QsTUFBTTtZQUNSLEtBQUssZ0JBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUM7Z0JBQ3RDLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsRUFBRTtvQkFDN0IsTUFBTSxJQUFJLE1BQU0sQ0FBQyx5QkFBeUIsRUFBRSxDQUFDO2lCQUM5QztnQkFFRCxJQUFJLENBQUMsZ0JBQUssQ0FBQyxXQUFXLENBQUMsZUFBZSxDQUFDLEVBQUU7b0JBQ3ZDLE1BQU0sSUFBSSxNQUFNLENBQUMsNkJBQTZCLENBQUMsV0FBVyxFQUFFLGVBQWUsQ0FBQyxDQUFDO2lCQUM5RTtnQkFDRCxNQUFNO1lBQ1IsS0FBSyxnQkFBSyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQztnQkFDbEMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRTtvQkFDekIsTUFBTSxJQUFJLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO2lCQUMxQztnQkFFRCxJQUFJLENBQUMsZ0JBQUssQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLEVBQUU7b0JBQ25DLE1BQU0sSUFBSSxNQUFNLENBQUMsNkJBQTZCLENBQUMsV0FBVyxFQUFFLGVBQWUsQ0FBQyxDQUFDO2lCQUM5RTtnQkFDRCxNQUFNO1lBQ1I7Z0JBQ0UsTUFBTSxJQUFJLE1BQU0sQ0FBQywyQkFBMkIsRUFBRSxDQUFDO1NBQ2xEO1FBRUQsSUFBSSxrQkFBa0IsR0FBRyxDQUFDLENBQUM7UUFDM0IsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQzFCLGtCQUFrQixHQUFHLFNBQVMsQ0FBQztZQUMvQixJQUFJLGtCQUFrQixJQUFJLENBQUMsRUFBRTtnQkFDM0IsTUFBTSxJQUFJLEtBQUssQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO2FBQ2pEO1lBQ0QsSUFBSSxrQkFBa0IsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFO2dCQUN6QyxNQUFNLElBQUksS0FBSyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7YUFDM0Q7U0FDRjtRQUVELElBQUksZUFBZSxHQUFHLENBQUMsQ0FBQztRQUN4QixJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRTtZQUNuQyxlQUFlLEdBQUcsS0FBSyxDQUFDO1NBQ3pCO1FBRUQsSUFBTSxJQUFJLEdBQUcsUUFBUSxHQUFHLGVBQWUsR0FBRyxHQUFHLEdBQUcsZUFBZSxDQUFDO1FBQ2hFLElBQU0sT0FBTyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsVUFBQyxFQUFPO2dCQUFMLFlBQUc7WUFBTyxPQUFBLE9BQU8sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQztRQUE5QixDQUE4QixDQUFDLENBQUM7UUFDM0UsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFBLE1BQU0sSUFBSSxPQUFBLGdCQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLGtCQUFrQixFQUFFLEVBQW5ELENBQW1ELENBQUMsQ0FBQztRQUV6RixJQUFBLDZFQUNvRSxFQURsRSw4QkFBWSxFQUFFLDhCQUFZLEVBQUUsZ0NBQWEsRUFBRSxvQkFDdUIsQ0FBQztRQUUzRSxPQUFPO1lBQ0wsT0FBTyxTQUFBO1lBQ1AsS0FBSyxFQUFFLGVBQWU7WUFDdEIsS0FBSyxFQUFFLGVBQWU7WUFDdEIsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDckIsWUFBWSxFQUFFO2dCQUNaLFlBQVksRUFBRSxZQUFZLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQztnQkFDMUMsWUFBWSxFQUFFLFlBQVksSUFBSSxZQUFZLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQztnQkFDMUQsYUFBYSxFQUFFLGFBQWEsSUFBSSxhQUFhLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQzthQUM5RDtZQUNELFdBQVcsYUFBQTtTQUNaLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSCwwQ0FBZSxHQUFmLFVBQWdCLE1BQThCLEVBQUUsUUFBMEM7UUFDeEYsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFvQjs7O2dCQUNyQixVQUFVLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQztnQkFDL0IsT0FBTyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUM7Z0JBRTNCLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUU7b0JBQ3hELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTt3QkFDekQsTUFBTSxJQUFJLEtBQUssQ0FBQyw0Q0FBMEMsT0FBTyxVQUFZLENBQUMsQ0FBQztxQkFDaEY7b0JBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO2lCQUNqRDtnQkFDRyxXQUFXLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBRTlFLElBQUksV0FBVyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEtBQUssVUFBVSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFO29CQUNoRSxNQUFNLElBQUksS0FBSyxDQUFDLDJFQUEyRSxDQUFDLENBQUM7aUJBQzlGO2dCQUVHLGVBQWUsR0FBRyxLQUFLLENBQUM7Z0JBQzVCLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLEVBQUU7b0JBQ3ZDLHNHQUFzRztvQkFDdEcsZUFBZSxHQUFHLE1BQU0sQ0FBQyxlQUFlLENBQUM7aUJBQzFDO2dCQUVELElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7b0JBQ2xELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxFQUFFO3dCQUMzQixNQUFNLElBQUksS0FBSyxDQUFDLG9DQUFrQyxPQUFPLE9BQVMsQ0FBQyxDQUFDO3FCQUNyRTtvQkFDRCxNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7aUJBQzlEO2dCQUVLLFFBQVEsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDOUMsY0FBYyxHQUFHLGdCQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQ2xDLEdBQUcsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsZUFBZSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ2xGLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFFOUIsbUJBQW1CLEdBQUcsVUFBQyxVQUErQixFQUFFLEtBQWE7b0JBQ3pFLElBQU0sY0FBYyxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUN6RCxPQUFPO3dCQUNMLFVBQVUsRUFBRSxLQUFLO3dCQUNqQixPQUFPLEVBQUUsY0FBYzt3QkFDdkIsSUFBSSxFQUFFLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxjQUFjLENBQUMsS0FBSzt3QkFDbEUsT0FBTyxFQUFFLENBQUMsY0FBYyxDQUFDLFlBQVk7d0JBQ3JDLHFCQUFxQixFQUFFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxjQUFjLENBQUM7d0JBQ2pFLEtBQUssRUFBRSxTQUE4QjtxQkFDdEMsQ0FBQztnQkFDSixDQUFDLENBQUM7Z0JBRUksZUFBZSxHQUE2QyxFQUFFLENBQUM7Z0JBQ3JFLGNBQWM7Z0JBQ2QsS0FBUyxLQUFLLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxFQUFFLEtBQUssRUFBRTtvQkFDM0QsS0FBSyxDQUFDLHdCQUF3QixFQUFFLEtBQUssR0FBRyxDQUFDLEVBQUUsV0FBVyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDN0QsZ0JBQWdCLEdBQUcsbUJBQW1CLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO29CQUNoRSxJQUFJLGdCQUFnQixDQUFDLHFCQUFxQixFQUFFO3dCQUMxQyxLQUFLLENBQ0gsZ0dBQWdHLEVBQ2hHLEtBQUssR0FBRyxDQUFDLEVBQUUsV0FBVyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQ2xDLENBQUM7d0JBQ0YsU0FBUztxQkFDVjtvQkFDSyxPQUFPLEdBQUcsY0FBYyxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDaEUsT0FBTyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO29CQUUvQixLQUFLLENBQUMsbUJBQW1CLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztvQkFFdkMsV0FBVyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztvQkFDNUMsSUFBSTt3QkFDRixJQUFJLGdCQUFnQixDQUFDLE9BQU8sRUFBRTs0QkFDNUIsS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUM7NEJBQ3ZCLGFBQWEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUUsS0FBSyxDQUFDLENBQUM7NEJBQzNFLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDOzRCQUN6RCxhQUFhLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUM7NEJBQ3hGLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsYUFBYSxDQUFDLENBQUM7eUJBQ3JHOzZCQUFNOzRCQUNDLFNBQVMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsS0FBSyxDQUFDLENBQUM7NEJBQ3RFLFdBQVcsR0FBRyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQzs0QkFDN0QsSUFBSSxXQUFXLEVBQUU7Z0NBQ2YsS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7Z0NBQzNCLGFBQWEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0NBQ2pGLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsYUFBYSxDQUFDLENBQUM7NkJBQ2pHO2lDQUFNO2dDQUNMLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO2dDQUM1QixHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7NkJBQ2xGO3lCQUNGO3FCQUVGO29CQUFDLE9BQU8sQ0FBQyxFQUFFO3dCQUNWLEtBQUssQ0FBQyx1QkFBdUIsRUFBRSxDQUFDLENBQUMsQ0FBQzt3QkFDbEMsZ0JBQWdCLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQzt3QkFDM0IsZUFBZSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO3dCQUN2QyxTQUFTO3FCQUNWO29CQUNELEtBQUssQ0FBQyxvQ0FBb0MsRUFBRSxLQUFLLEdBQUcsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7aUJBQ2hGO2dCQUVELElBQUksZUFBZSxFQUFFO29CQUNuQixXQUFXLEdBQUcsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDO2lCQUMzQjtxQkFBTTtvQkFDTCxXQUFXLEdBQUcsR0FBRyxDQUFDLGVBQWUsRUFBRSxDQUFDO2lCQUNyQztnQkFFRCwwQkFBMEI7Z0JBQzFCLEtBQVMsS0FBSyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsRUFBRSxLQUFLLEVBQUU7b0JBQzNELEtBQUssQ0FBQyxvQ0FBb0MsRUFBRSxLQUFLLEdBQUcsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7b0JBQ3pFLGdCQUFnQixHQUFHLG1CQUFtQixDQUFDLFVBQVUsRUFBRSxLQUFLLENBQUMsQ0FBQztvQkFDaEUsSUFBSSxnQkFBZ0IsQ0FBQyxxQkFBcUIsRUFBRTt3QkFDMUMsS0FBSyxDQUNILDBHQUEwRyxFQUMxRyxLQUFLLEdBQUcsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUNsQyxDQUFDO3dCQUNGLFNBQVM7cUJBQ1Y7b0JBRUQsSUFBSSxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUU7d0JBQzVCLFdBQVcsQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztxQkFDcEQ7b0JBRUssZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDbEcsSUFBSSxDQUFDLGdCQUFnQixFQUFFO3dCQUNyQixLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQzt3QkFDM0IsZ0JBQWdCLENBQUMsS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7d0JBQ3hELGVBQWUsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztxQkFDeEM7aUJBQ0Y7Z0JBRUQsSUFBSSxlQUFlLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDeEIsYUFBYSxHQUFHLGVBQWUsQ0FBQyxHQUFHLENBQUMsVUFBQSxZQUFZLElBQUksT0FBQSxZQUFZLENBQUMsVUFBVSxFQUF2QixDQUF1QixDQUFDLENBQUM7b0JBQzdFLEtBQUssR0FBUSxJQUFJLEtBQUssQ0FBQyxzQ0FBb0MsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUcsQ0FBQyxDQUFDO29CQUM3RixLQUFLLENBQUMsSUFBSSxHQUFHLHlCQUF5QixDQUFDO29CQUN2QyxLQUFLLENBQUMsYUFBYSxHQUFHLGVBQWUsQ0FBQztvQkFDdEMsTUFBTSxLQUFLLENBQUM7aUJBQ2I7Z0JBRUQsc0JBQU87d0JBQ0wsS0FBSyxFQUFFLFdBQVcsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO3FCQUM5QyxFQUFDOztTQUNILENBQUM7YUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ1YsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsZ0RBQXFCLEdBQXJCLFVBQXNCLE9BQWdCO1FBQ3BDLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxvREFBeUIsR0FBekIsVUFBMEIsU0FBYztRQUN0QyxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBTUQsc0JBQUksZ0RBQWtCO1FBSnRCOzs7V0FHRzthQUNIO1lBQ0UsT0FBTyxPQUFPLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQztRQUN6QyxDQUFDOzs7T0FBQTtJQUVEOzs7OztPQUtHO0lBQ0gsK0NBQW9CLEdBQXBCLFVBQXFCLFdBQWdCLEVBQUUsVUFBa0I7UUFDdkQsSUFBTSxZQUFZLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNqRCxJQUFNLGFBQWEsR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFDdEQsSUFBTSxtQkFBbUIsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7UUFDN0QsSUFBSSxtQkFBbUIsRUFBRSxtQkFBbUIsQ0FBQztRQUM3QyxJQUFJLGFBQWEsRUFBRTtZQUNqQixrSEFBa0g7WUFDbEgsZ0hBQWdIO1lBQ2hILGlIQUFpSDtZQUNqSCxnR0FBZ0c7WUFDaEcsbUJBQW1CLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQztZQUMzQyxJQUFJLG1CQUFtQixFQUFFO2dCQUN2QixtQkFBbUIsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO2FBQ3pHO2lCQUFNO2dCQUNMLG1CQUFtQixHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDL0U7U0FDRjthQUFNO1lBQ0wsbUJBQW1CLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztZQUM5RSxtQkFBbUIsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDckU7UUFFRCxJQUFJLG1CQUFtQixLQUFLLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRTtZQUMvQyxJQUFBLGtDQUFTLEVBQUUsa0NBQVMsQ0FBd0I7WUFDbkQsSUFBTSxVQUFVLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUMvQixJQUFNLFVBQVUsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQy9CLElBQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztZQUU3RixPQUFPLEVBQUUsYUFBYSxlQUFBLEVBQUUsbUJBQW1CLHFCQUFBLEVBQUUsVUFBVSxZQUFBLEVBQUUsVUFBVSxZQUFBLEVBQUUsU0FBUyxXQUFBLEVBQUUsQ0FBQztTQUNsRjthQUFNLElBQUksbUJBQW1CLEtBQUssT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSTtlQUNyRCxtQkFBbUIsS0FBSyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUU7WUFDekQsOEdBQThHO1lBQzlHLGdIQUFnSDtZQUNoSCxpSEFBaUg7WUFDakgsMkdBQTJHO1lBQzNHLGtIQUFrSDtZQUNsSCxrQkFBa0I7WUFDbEIsRUFBRTtZQUNGLG9EQUFvRDtZQUNwRCxrRUFBa0U7WUFDbEUsSUFBTSxVQUFVLEdBQUcsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3BELElBQU0sU0FBUyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQVMsbUJBQW1CLENBQUMsQ0FBQztZQUN0RCxJQUFNLG1CQUFtQixHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ2hFLElBQU0sVUFBVSxHQUFHLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUVwRCxrSEFBa0g7WUFDbEgsa0hBQWtIO1lBQ2xILElBQU0sR0FBRyxHQUFHLG1CQUFtQixDQUFDLE1BQU0sQ0FBQztZQUN2QyxJQUFNLFdBQVcsR0FBRyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDaEQsSUFBTSxRQUFRLEdBQUcsbUJBQW1CLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUVuRCw4R0FBOEc7WUFDOUcsK0dBQStHO1lBQy9HLDhHQUE4RztZQUM5Ryw0R0FBNEc7WUFDNUcsVUFBVTtZQUNWLElBQUksVUFBVSxDQUFDLE1BQU0sS0FBSyxXQUFXLEdBQUcsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxNQUFNLEtBQUssUUFBUSxHQUFHLENBQUMsRUFBRTtnQkFDL0UsTUFBTSxJQUFJLEtBQUssQ0FBQyxjQUFZLFdBQVcsWUFBTyxRQUFRLDBCQUFvQixVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBRSxDQUFDLENBQUM7YUFDcEc7WUFFRCxJQUFJLFVBQVUsQ0FBQyxNQUFNLEtBQUssUUFBUSxFQUFFO2dCQUNsQyxNQUFNLElBQUksS0FBSyxDQUFDLGNBQVksUUFBUSwwQkFBcUIsVUFBVSxDQUFDLE1BQVEsQ0FBQyxDQUFDO2FBQy9FO1lBRUQsSUFBTSxVQUFVLEdBQUcsbUJBQW1CLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ2hELElBQUksVUFBVSxLQUFLLE9BQU8sQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEVBQUU7Z0JBQ25ELE1BQU0sSUFBSSxLQUFLLENBQUMsc0JBQW9CLE9BQU8sQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLHNCQUFpQixVQUFZLENBQUMsQ0FBQzthQUNwRztZQUVELE9BQU8sRUFBRSxhQUFhLGVBQUEsRUFBRSxtQkFBbUIscUJBQUEsRUFBRSxVQUFVLFlBQUEsRUFBRSxVQUFVLFlBQUEsRUFBRSxTQUFTLFdBQUEsRUFBRSxDQUFDO1NBQ2xGO2FBQU07WUFDTCxPQUFPLEVBQUUsYUFBYSxlQUFBLEVBQUUsbUJBQW1CLHFCQUFBLEVBQUUsQ0FBQztTQUMvQztJQUNILENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSCxpREFBc0IsR0FBdEIsVUFBdUIsV0FBZ0IsRUFBRSxVQUFrQixFQUFFLFNBQWlCLEVBQUUsTUFBYyxFQUFFLFFBQWdCLEVBQUUsYUFBc0I7UUFDdEksSUFBSSxhQUFhLEVBQUU7WUFDakIsT0FBTyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDOUU7YUFBTTtZQUNMLE9BQU8sV0FBVyxDQUFDLGdCQUFnQixDQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDdEU7SUFDSCxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0gsMENBQWUsR0FBZixVQUFnQixXQUFnQixFQUFFLFVBQWtCLEVBQUUsTUFBYyxFQUFFLG9CQUdoRTtRQUhnRSxxQ0FBQSxFQUFBLHlCQUdoRTtRQUNFLElBQUEsdURBQ2dELEVBRDlDLDBCQUFVLEVBQUUsMEJBQVUsRUFBRSxnQ0FBYSxFQUFFLDRDQUFtQixFQUFFLHdCQUNkLENBQUM7UUFFdkQsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQUMsRUFBRTtZQUN0SCxPQUFPLEtBQUssQ0FBQztTQUNkO1FBRUQsSUFBSSxDQUFDLFVBQVUsSUFBSSxVQUFVLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMxQyxPQUFPLEtBQUssQ0FBQztTQUNkO1FBRUQsSUFBSSxhQUFhLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDNUIsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUVELDBFQUEwRTtRQUMxRSxJQUFNLGtCQUFrQixHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLFVBQUEsQ0FBQyxJQUFJLE9BQUEsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFiLENBQWEsQ0FBQyxDQUFDO1FBRXBFOzs7Ozs7Ozs7OztXQVdHO1FBQ0gsSUFBSSxpQkFBaUIsR0FBRyxrQkFBa0IsQ0FBQztRQUMzQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxvQkFBb0IsQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUN2RCxpQkFBaUIsR0FBRyxDQUFDLGtCQUFrQixDQUFDLG9CQUFvQixDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7U0FDL0U7UUFFRCxJQUFNLFlBQVksR0FBRyxvQkFBb0IsQ0FBQyxTQUFTLENBQUM7UUFDcEQsSUFBTSx1QkFBdUIsR0FBRyxFQUFFLENBQUM7UUFDbkMsSUFBSSxxQkFBcUIsR0FBRyxJQUFJLENBQUM7UUFFakMseUJBQXlCO1FBQ3pCLEtBQThCLFVBQWlCLEVBQWpCLHVDQUFpQixFQUFqQiwrQkFBaUIsRUFBakIsSUFBaUIsRUFBRTtZQUE1QyxJQUFNLGVBQWUsMEJBQUE7WUFFeEIsSUFBSSxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7WUFFN0IsSUFBTSxrQkFBa0IsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxJQUFJLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1lBQzFGLElBQUksa0JBQWtCLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDNUUsK0VBQStFO2dCQUMvRSxJQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzVFLElBQU0sUUFBUSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7Z0JBQ3pDLElBQUksQ0FBQyxRQUFRLEVBQUU7b0JBQ2Isd0RBQXdEO29CQUN4RCxPQUFPLEtBQUssQ0FBQztpQkFDZDtnQkFDRCxJQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsc0JBQXNCLENBQUMsV0FBVyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxhQUFhLENBQUMsQ0FBQztnQkFFdkgsS0FBSyxJQUFJLGNBQWMsR0FBRyxDQUFDLEVBQUUsY0FBYyxHQUFHLFVBQVUsQ0FBQyxNQUFNLEVBQUUsY0FBYyxFQUFFLEVBQUU7b0JBQ2pGLElBQU0sZUFBZSxHQUFHLFVBQVUsQ0FBQyxjQUFjLENBQUMsQ0FBQztvQkFDbkQsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLElBQUksZUFBZSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxZQUFZLEVBQUU7d0JBQ3BGLG1GQUFtRjt3QkFDbkYsbUZBQW1GO3dCQUNuRixTQUFTO3FCQUNWO29CQUVELElBQUksdUJBQXVCLENBQUMsY0FBYyxDQUFDLEVBQUU7d0JBQzNDLFNBQVM7cUJBQ1Y7b0JBRUQsSUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxlQUFlLENBQUMsQ0FBQztvQkFDdEUsSUFBSSxTQUFTLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxTQUFTLENBQUMsRUFBRTt3QkFDOUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO3dCQUN4Qix1QkFBdUIsQ0FBQyxjQUFjLENBQUMsR0FBRyxJQUFJLENBQUM7d0JBQy9DLE1BQU07cUJBQ1A7aUJBQ0Y7YUFDRjtZQUVELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxJQUFJLGdCQUFnQixFQUFFO2dCQUNwRCxvR0FBb0c7Z0JBQ3BHLE9BQU8sSUFBSSxDQUFDO2FBQ2I7WUFFRCxJQUFJLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsRUFBRTtnQkFDcEQsT0FBTyxLQUFLLENBQUM7YUFDZDtZQUVELHFCQUFxQixHQUFHLGdCQUFnQixJQUFJLHFCQUFxQixDQUFDO1NBQ25FO1FBRUQsT0FBTyxxQkFBcUIsQ0FBQztJQUMvQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCw2Q0FBa0IsR0FBbEIsVUFBbUIsTUFBaUMsRUFBRSxRQUErQztRQUNuRyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQXlCOzs7Z0JBQzFCLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFDckMsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLEVBQUU7b0JBQ3JFLE1BQU0sSUFBSSxLQUFLLENBQUMscURBQXFELENBQUMsQ0FBQztpQkFDeEU7Z0JBR0QsSUFBSTtvQkFDRixXQUFXLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztpQkFDaEU7Z0JBQUMsT0FBTyxDQUFDLEVBQUU7b0JBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO2lCQUNwRDtnQkFFSyxFQUFFLEdBQUcsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUMzQixlQUFlLEdBQWEsRUFBRSxDQUFDO2dCQUMvQixXQUFXLEdBQUcsQ0FBQyxDQUFDO2dCQUNoQixZQUFZLEdBQUcsQ0FBQyxDQUFDO2dCQUNmLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFDdkMsSUFBSSxNQUFNLElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRTtvQkFDcEMsZUFBZSxHQUFHLE1BQU0sQ0FBQyxlQUFlLENBQUM7aUJBQzFDO2dCQUNLLFdBQVcsR0FBUTtvQkFDdkIsWUFBWSxFQUFFLENBQUMsSUFBSSxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsU0FBUyxFQUFFLGVBQWUsQ0FBQztvQkFDaEYsRUFBRSxFQUFFLEVBQUU7b0JBQ04sT0FBTyxFQUFFLEVBQUU7b0JBQ1gsYUFBYSxFQUFFLEVBQUU7aUJBQ2xCLENBQUM7Z0JBRUYsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBQyxhQUFhO29CQUNyQyxJQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUMxRyxJQUFNLGFBQWEsR0FBRyxhQUFhLENBQUMsS0FBSyxDQUFDO29CQUUxQyxJQUFJLGVBQWUsQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7d0JBQ2xELGlCQUFpQjt3QkFDakIsWUFBWSxJQUFJLGFBQWEsQ0FBQzt3QkFDOUIsV0FBVyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUM7NEJBQzdCLE9BQU8sRUFBRSxjQUFjOzRCQUN2QixNQUFNLEVBQUUsYUFBYTt5QkFDdEIsQ0FBQyxDQUFDO3dCQUNILE9BQU87cUJBQ1I7b0JBRUQsV0FBVyxJQUFJLGFBQWEsQ0FBQztvQkFDN0IsV0FBVyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7d0JBQ3ZCLE9BQU8sRUFBRSxjQUFjO3dCQUN2QixNQUFNLEVBQUUsYUFBYTtxQkFDdEIsQ0FBQyxDQUFDO2dCQUNMLENBQUMsQ0FBQyxDQUFDO2dCQUNILFdBQVcsQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO2dCQUN2QyxXQUFXLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztnQkFFeEMsNEJBQTRCO2dCQUM1QixJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUU7b0JBQ2xCLFdBQVcsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNyQyxXQUFXLENBQUMsR0FBRyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUM7aUJBQ2xDO2dCQUVELElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLElBQUksV0FBVyxDQUFDLFFBQVEsR0FBRyxDQUFDLEVBQUU7b0JBQ2pFLFdBQVcsQ0FBQyxRQUFRLEdBQUcsV0FBVyxDQUFDLFFBQVEsQ0FBQztvQkFDNUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7aUJBQzNDO2dCQUVLLGFBQWEsR0FBRyxFQUFFLENBQUM7Z0JBR25CLGVBQWUsR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxVQUFDLEtBQUssRUFBRSxHQUFHO29CQUNyRCxJQUFNLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUM5QyxJQUFNLGdCQUFnQixHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBRW5ELElBQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTt3QkFDdEMsK0NBQStDO3dCQUMvQyxLQUFLLENBQUMseURBQXlELEVBQUUsR0FBRyxDQUFDLENBQUM7d0JBQ3RFLE9BQU8sQ0FBQyxDQUFDO3FCQUNWO29CQUVELElBQUksZUFBZSxDQUFDO29CQUNwQixJQUFJO3dCQUNGLGVBQWUsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFDO3FCQUMvRDtvQkFBQyxPQUFPLENBQUMsRUFBRTt3QkFDVixPQUFPLEtBQUssQ0FBQztxQkFDZDtvQkFFRCxJQUFJLGdCQUFnQixFQUFFO3dCQUNwQixJQUFJLENBQUMsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRTs0QkFDL0IsOERBQThEOzRCQUM5RCxLQUFLLENBQUMsMEZBQTBGLENBQUMsQ0FBQzs0QkFDbEcsT0FBTyxDQUFDLENBQUM7eUJBQ1Y7d0JBRUQsaUNBQWlDO3dCQUNqQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEVBQUU7NEJBQzVCLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFVBQUMsT0FBTztnQ0FDOUIsYUFBYSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDOzRCQUM1QyxDQUFDLENBQUMsQ0FBQzt5QkFDSjtxQkFDRjtvQkFFRCxJQUFNLGtCQUFrQixHQUFHLGVBQWUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFVBQUMsR0FBRyxJQUFLLE9BQUEsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFmLENBQWUsQ0FBQyxDQUFDO29CQUN2RixJQUFNLGVBQWUsR0FBRyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsVUFBQyxHQUFHLEVBQUUsUUFBUTt3QkFDM0QsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFOzRCQUNsQixPQUFPLEtBQUssQ0FBQzt5QkFDZDt3QkFFRCxJQUFNLFVBQVUsR0FBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQWEsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7d0JBQ2pGLElBQU0sT0FBTyxHQUFNLFVBQVUsU0FBSSxLQUFLLENBQUMsS0FBTyxDQUFDO3dCQUMvQyxJQUFNLE1BQU0sR0FBRyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7d0JBRXRDLElBQUk7NEJBQ0YsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7eUJBQ3JGO3dCQUFDLE9BQU8sQ0FBQyxFQUFFOzRCQUNWLE9BQU8sS0FBSyxDQUFDO3lCQUNkO29CQUNILENBQUMsQ0FBQyxDQUFDO29CQUVILE9BQU8sZUFBZSxDQUFDLE1BQU0sQ0FBQyxVQUFDLFVBQVUsRUFBRSxPQUFPLElBQUssT0FBQSxPQUFPLENBQUMsQ0FBQyxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsRUFBckMsQ0FBcUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDbkcsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsV0FBVyxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7Z0JBQzlDLFdBQVcsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQztnQkFDaEQsc0JBQU8sV0FBVyxFQUFDOztTQUNwQixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxnREFBcUIsR0FBckIsVUFBc0IsV0FBbUIsRUFBRSxrQkFBMEIsRUFBRSxJQUFjO1FBQ25GLFNBQVMsb0JBQW9CLENBQUMsV0FBVztZQUN2QyxJQUFNLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQzdELE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFDM0UsQ0FBQztRQUVELElBQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDdkYsSUFBSSxZQUFZLEVBQUUsWUFBWSxFQUFFLGFBQWEsQ0FBQztRQUM5QyxRQUFRLFdBQVcsRUFBRTtZQUNuQixLQUFLLGdCQUFLLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDO2dCQUNqQyxJQUFNLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDO2dCQUNsRSxZQUFZLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2dCQUMzRSxZQUFZLEdBQUcsY0FBYyxDQUFDO2dCQUM5QixNQUFNO1lBQ1IsS0FBSyxnQkFBSyxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQztnQkFDdEMsSUFBTSxjQUFjLEdBQUcsb0JBQW9CLENBQUMsY0FBYyxDQUFDLENBQUM7Z0JBQzVELElBQU0sa0JBQWtCLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUM7Z0JBQ2xFLFlBQVksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQUM7Z0JBQzNFLFlBQVksR0FBRyxjQUFjLENBQUM7Z0JBQzlCLGFBQWEsR0FBRyxjQUFjLENBQUM7Z0JBQy9CLE1BQU07WUFDUixLQUFLLGdCQUFLLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDO2dCQUNsQyxZQUFZLEdBQUcsb0JBQW9CLENBQUMsY0FBYyxDQUFDLENBQUM7Z0JBQ3BELGFBQWEsR0FBRyxjQUFjLENBQUM7Z0JBQy9CLE1BQU07WUFDUjtnQkFDRSxNQUFNLElBQUksS0FBSyxDQUFDLDRCQUEwQixXQUFhLENBQUMsQ0FBQztTQUM1RDtRQUVELE9BQU87WUFDTCxZQUFZLGNBQUE7WUFDWixZQUFZLGNBQUE7WUFDWixhQUFhLGVBQUE7WUFDYixPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQztTQUN0RSxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7T0FHRztJQUNILDJEQUEyRDtJQUMzRCxtREFBd0IsR0FBeEIsVUFBeUIsZ0JBQXdCO1FBQy9DLE9BQU8sSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDeEYsQ0FBQztJQUVEOzs7T0FHRztJQUNILGlEQUFzQixHQUF0QjtRQUNFLE9BQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRUQ7O09BRUc7SUFDSCxpRUFBc0MsR0FBdEM7UUFDRSxPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsd0NBQXdDLENBQUMsQ0FBQyxDQUFDO0lBQzlFLENBQUM7SUFFRDs7T0FFRztJQUNILGlEQUFzQixHQUF0QjtRQUNFLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBUyxTQUFVLHNCQUFzQjs7Ozs7d0JBQzFDLHlCQUF5QixHQUFHLElBQUksR0FBRyxFQUFFOzZCQUN4QyxHQUFHLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQzs2QkFDckIsR0FBRyxDQUFDLEtBQUssRUFBRSxVQUFVLENBQUM7NkJBQ3RCLEdBQUcsQ0FBQyxLQUFLLEVBQUUsY0FBYyxDQUFDOzZCQUMxQixHQUFHLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQzs2QkFDbkIsR0FBRyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7NkJBQ25CLEdBQUcsQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUM7d0JBQ3RCLFdBQVcsR0FBRyx5QkFBeUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7d0JBQ2xGLElBQUksQ0FBQyxXQUFXLEVBQUU7NEJBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsOENBQTRDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxXQUFXLEVBQUUsTUFBRyxDQUFDLENBQUM7eUJBQ2hHO3dCQUNLLFlBQVksR0FBRyxNQUFNLENBQUMsZ0JBQWdCLElBQUcsc0JBQW9CLFdBQVcsdUJBQW9CLENBQUEsQ0FBQzt3QkFDbEYscUJBQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUE7O3dCQUE1RCxRQUFRLEdBQUcsU0FBaUQ7d0JBRWxFLHlCQUF5Qjt3QkFDekIsSUFBSTt3QkFDSixrQkFBa0I7d0JBQ2xCLG9CQUFvQjt3QkFDcEIsTUFBTTt3QkFDTixJQUFJO3dCQUNKLElBQUksQ0FBQyxRQUFRLEVBQUU7NEJBQ2IsTUFBTSxJQUFJLEtBQUssQ0FBQywrQ0FBK0MsQ0FBQyxDQUFDO3lCQUNsRTt3QkFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLE9BQU8sUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLFFBQVEsRUFBRTs0QkFDckYsTUFBTSxJQUFJLEtBQUssQ0FBQyx3REFBd0QsQ0FBQyxDQUFDO3lCQUMzRTt3QkFFRCxzQkFBTyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUM7OztTQUNyQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxnREFBcUIsR0FBckIsVUFBc0IsTUFBMEIsRUFBRSxLQUFhO1FBQzdELElBQU0sUUFBUSxHQUFnQztZQUM1QyxLQUFLLE9BQUE7WUFDTCxNQUFNLEVBQUU7Z0JBQ04sUUFBUSxFQUFFLE1BQU0sQ0FBQyxNQUFNO2FBQ3hCO1lBQ0QsT0FBTyxFQUFFLEVBQUU7WUFDWCxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRTtTQUN0QixDQUFDO1FBQ0YsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxVQUFTLE9BQU87WUFDOUMsSUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDL0MsbUlBQW1JO1lBQ25JLE9BQU8sQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzdCLE9BQU8sQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQy9CLENBQUMsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztJQUtEOzs7OztPQUtHO0lBQ0gscUNBQVUsR0FBVixVQUFXLFFBQTBCLEVBQUUsS0FBYTtRQUNsRCxPQUFPLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBQyxDQUFDLElBQUssT0FBQSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFmLENBQWUsQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0gsa0NBQU8sR0FBUCxVQUFRLE1BQXFCLEVBQUUsUUFBNEI7UUFDekQsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFDLFNBQVUsT0FBTztZQUN6QiwyRUFBMkU7WUFDM0UsU0FBUywyQkFBMkIsQ0FBQyxRQUEwQixFQUFFLFFBQWdCLEVBQUUsYUFBYTtnQkFDOUYsT0FBTyxFQUFFLENBQUM7Ozs7O2dDQUNGLG9DQUFvQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDO2dDQUMzRCxnQ0FBZ0MsR0FBRyxDQUFDLENBQUM7Z0NBR25DLGNBQWMsR0FBRyxFQUFFLENBQUMsU0FBVSxnQkFBZ0IsQ0FBQyxTQUFTOzs7OztnREFDdEQsV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO2dEQUVuRCxLQUFLLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztnREFDMUMsSUFBSSxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsa0JBQWtCLEVBQUUsRUFBdEIsQ0FBc0IsQ0FBQyxDQUFDO2dEQUNwRCxPQUFPLEdBQVEsSUFBSSxDQUFDLHFCQUFxQixDQUFDLGdCQUFLLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztnREFFckQscUJBQU0sSUFBSSxDQUFDLDBCQUEwQixDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFBOztnREFBN0YsUUFBUSxHQUFnQixTQUFxRTtxREFFL0YsQ0FBQSxRQUFRLENBQUMsT0FBTyxLQUFLLENBQUMsQ0FBQSxFQUF0Qix3QkFBc0I7Z0RBQ3hCLGdDQUFnQyxFQUFFLENBQUM7OztnREFFbkMsZ0NBQWdDLEdBQUcsQ0FBQyxDQUFDO3FEQUVqQyxDQUFBLFFBQVEsQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFBLEVBQXpCLHdCQUF5QjtnREFDM0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQ0FBa0MsT0FBTyxDQUFDLE9BQU8sc0JBQWlCLFFBQVEsQ0FBQyxZQUFjLENBQUMsQ0FBQTtnREFDdEcsOEJBQThCO2dEQUM5QixPQUFPLENBQUMsU0FBUyxHQUFHLFFBQVEsR0FBRyxHQUFHLEdBQUcsU0FBUyxDQUFDO2dEQUMvQyxPQUFPLENBQUMsT0FBTyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztnREFDakMsT0FBTyxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0RBQ25DLGFBQWEsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDO2dEQUdGLHFCQUFNLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBQTs7Z0RBQXRHLGVBQWUsR0FBa0IsU0FBcUU7Z0RBRTVHLGVBQWUsQ0FBQyxPQUFPLENBQUMsU0FBUyxtQkFBbUIsQ0FBQyxPQUFPO29EQUMxRCxPQUFPLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7b0RBQ2xDLGNBQWMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7Z0RBQy9CLENBQUMsQ0FBQyxDQUFDOzs7Z0RBSVAsSUFBSSxnQ0FBZ0MsSUFBSSxvQ0FBb0MsRUFBRTtvREFDNUUsNkhBQTZIO29EQUM3SCxjQUFjO29EQUNkLHNCQUFPO2lEQUNSO2dEQUVELHNCQUFPLGNBQWMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLEVBQUM7OztpQ0FDdEMsQ0FBQyxDQUFDO2dDQUVHLGNBQWMsR0FBa0IsRUFBRSxDQUFDO2dDQUN6QyxxQ0FBcUM7Z0NBQ3JDLHFCQUFNLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBQTs7Z0NBRHZCLHFDQUFxQztnQ0FDckMsU0FBdUIsQ0FBQztnQ0FFeEIsSUFBSSxjQUFjLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtvQ0FDL0IseUNBQXlDO29DQUN6QyxzQkFBTyxFQUFFLEVBQUM7aUNBQ1g7Z0NBRUQsc0JBQU8sY0FBYyxFQUFDOzs7aUJBQ3ZCLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDaEIsQ0FBQzs7Ozs7d0JBRUQsZ0VBQWdFO3dCQUNoRSxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFOzRCQUNqQyxNQUFNLElBQUksS0FBSyxDQUFDLGlCQUFpQixDQUFDLENBQUM7eUJBQ3BDO3dCQUVELElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUU7NEJBQ25DLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQzt5QkFDdEM7d0JBRUQsSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsRUFBRTs0QkFDakcsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO3lCQUNoRDt3QkFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEVBQUU7NEJBQ2pGLE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQzt5QkFDcEQ7d0JBRUssYUFBYSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7d0JBQzFGLGVBQWUsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDM0YsV0FBVyxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO3dCQUU1RCxJQUFJLGFBQWEsSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxFQUFFOzRCQUMvQyxNQUFNLElBQUksS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7eUJBQzFEO3dCQUVELElBQUksYUFBYSxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxFQUFFOzRCQUM3RSxNQUFNLElBQUksS0FBSyxDQUFDLDBFQUEwRSxDQUFDLENBQUM7eUJBQzdGO3dCQUdZLHFCQUFNLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsRUFBQTs7d0JBQTFDLElBQUksR0FBRyxTQUFtQzt3QkFFekMsT0FBTyxHQUF5QixJQUFJLEdBQTdCLEVBQUUsU0FBUyxHQUFjLElBQUksR0FBbEIsRUFBRSxRQUFRLEdBQUksSUFBSSxHQUFSLENBQVM7d0JBRzVDLElBQUksTUFBTSxDQUFDLFdBQVcsRUFBRTs0QkFDdEIsY0FBYyxHQUFHLHlCQUFlLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQzs0QkFDeEQsT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFNBQVMsRUFBRSxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzs0QkFDOUUsV0FBVyxJQUFJLGNBQWMsU0FBSyxPQUFPLENBQUMsQ0FBQzt5QkFDNUM7NkJBQU07NEJBQ0wsV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7eUJBQzVEO3dCQUVLLE9BQU8sR0FBVSxFQUFFLENBQUM7d0JBQ3BCLGFBQWEsR0FBRyxFQUFFLENBQUM7d0JBRXpCLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxnQkFBSyxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxVQUFTLFdBQVc7NEJBQzFFLGdIQUFnSDs0QkFDaEgsbUJBQW1COzRCQUNuQixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsa0JBQWtCLEVBQUUsV0FBVyxDQUFDLEVBQUU7Z0NBQ3ZELElBQUksV0FBVyxLQUFLLGdCQUFLLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsRUFBRTtvQ0FDcEYsb0NBQW9DO29DQUNwQyxPQUFPO2lDQUNSO2dDQUVELElBQUksV0FBVyxLQUFLLGdCQUFLLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLEVBQUU7b0NBQzVFLGdDQUFnQztvQ0FDaEMsT0FBTztpQ0FDUjtnQ0FFRCxJQUFJLEtBQUssU0FBQSxDQUFDO2dDQUNWLElBQUk7b0NBQ0YsS0FBSyxHQUFHLGdCQUFLLENBQUMsT0FBTyxDQUFDLGdCQUFLLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFRLENBQUMsQ0FBQztpQ0FDbkU7Z0NBQUMsT0FBTyxDQUFDLEVBQUU7b0NBQ1YsMkdBQTJHO29DQUMzRyxnQkFBZ0I7b0NBQ2hCLE9BQU87aUNBQ1I7Z0NBQ0QsSUFBTSxpQkFBaUIsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDO2dDQUN6QyxJQUFNLGlCQUFpQixHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUM7Z0NBQ3pDLElBQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLGlCQUFpQixDQUFDLENBQUM7Z0NBQ3BFLElBQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLGlCQUFpQixDQUFDLENBQUM7Z0NBQ3BFLE9BQU8sQ0FBQyxJQUFJLENBQUMsMkJBQTJCLENBQUMsV0FBVyxFQUFFLE9BQU8sR0FBRyxpQkFBaUIsRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFDO2dDQUNuRyxPQUFPLENBQUMsSUFBSSxDQUFDLDJCQUEyQixDQUFDLFdBQVcsRUFBRSxPQUFPLEdBQUcsaUJBQWlCLEVBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQzs2QkFDcEc7d0JBQ0gsQ0FBQyxDQUFDLENBQUM7d0JBR29CLHFCQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUE7O3dCQUEzQyxjQUFjLEdBQUcsU0FBMEI7d0JBQzNDLFFBQVEsR0FBVSxDQUFDLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDO3dCQUM1QyxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFDckQsSUFBSSxnQkFBZ0IsSUFBSSxDQUFDLEVBQUU7NEJBQ3pCLE1BQU0sSUFBSSxNQUFNLENBQUMscUJBQXFCLEVBQUUsQ0FBQzt5QkFDMUM7d0JBR0ssa0JBQWtCLEdBQUcsSUFBSSxPQUFPLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO3dCQUN4RSxJQUFJLENBQUMseUJBQXlCLENBQUMsa0JBQWtCLENBQUMsQ0FBQzt3QkFDN0MsTUFBTSxHQUFRLEVBQUUsQ0FBQzt3QkFFSixxQkFBTSxJQUFJLENBQUMsc0JBQXNCLEVBQUUsRUFBQTs7d0JBQWhELFVBQVUsR0FBRyxTQUFtQzt3QkFLaEQsVUFBVSxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLHVCQUFZLENBQUMsaUJBQWlCLENBQUM7d0JBQ3RFLGVBQWUsR0FDbkIsdUJBQVksQ0FBQyxrQkFBa0IsR0FBRyxVQUFVLEdBQUcsQ0FBQyx1QkFBWSxDQUFDLGVBQWUsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7d0JBQzVGLGNBQWMsR0FBRyxlQUFlLEdBQUcsVUFBVSxDQUFDO3dCQUVwRCwwQkFBMEI7d0JBQzFCLE1BQU0sQ0FBQyxNQUFNLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxTQUFTLGtCQUFrQixDQUFDLE9BQU87NEJBQzlELElBQU0sT0FBTyxHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7NEJBRS9DLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQzs0QkFFdkYsT0FBTztnQ0FDTCxTQUFTLEVBQUUsT0FBTyxDQUFDLFNBQVM7Z0NBQzVCLFlBQVksRUFBRSxPQUFPLENBQUMsWUFBWSxJQUFJLE9BQU8sQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQztnQ0FDMUUsYUFBYSxFQUFFLE9BQU8sQ0FBQyxhQUFhLElBQUksT0FBTyxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO2dDQUM3RSxLQUFLLEVBQUUsT0FBTyxDQUFDLE1BQU07NkJBQ3RCLENBQUM7d0JBQ0osQ0FBQyxDQUFDLENBQUM7d0JBRUMsY0FBYyxHQUFHLGdCQUFnQixHQUFHLGNBQWMsQ0FBQzs2QkFFbkQsYUFBYSxFQUFiLHdCQUFhOzs7O3dCQUVKLHFCQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLFFBQVEsRUFBRSxNQUFNLENBQUMsV0FBVyxFQUFFLE1BQU0sRUFBRSxjQUFjLEVBQUUsQ0FBQyxFQUFBOzt3QkFBaEcsTUFBTSxHQUFHLFNBQXVGLENBQUM7d0JBQ2pHLGNBQWMsSUFBSSxNQUFNLENBQUM7Ozs7d0JBRXpCLDRDQUE0Qzt3QkFDNUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFHLENBQUMsQ0FBQzs7O3dCQUlyQixJQUFJLGNBQWMsR0FBRyxDQUFDLEVBQUU7NEJBQ3RCLE1BQU0sSUFBSSxLQUFLLENBQUMsNkhBQ2dCLGdCQUFnQiwwRUFDMUMsY0FBYywwQkFBcUIsTUFBTSw2RUFDeEMsY0FBZ0IsQ0FBQyxDQUFDO3lCQUMxQjt3QkFFRCxrQkFBa0IsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLG1CQUFtQixFQUFFLGNBQWMsQ0FBQyxDQUFDO3dCQUV6RSxJQUFJLGFBQWEsSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFOzRCQUN6QixhQUFhLEdBQUcsV0FBVyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQzs0QkFFaEUsSUFBSSxDQUFDLGFBQWEsRUFBRTtnQ0FDbEIsTUFBTSxJQUFJLEtBQUssQ0FBQyw2RkFBNkYsQ0FBQyxDQUFDOzZCQUNoSDs0QkFFRCxrQkFBa0IsQ0FBQyxTQUFTLENBQUMsYUFBYSxFQUFFLE1BQU0sQ0FBQyxDQUFDO3lCQUNyRDs2QkFFRyxlQUFlLEVBQWYsd0JBQWU7d0JBQ1gsS0FBSyxHQUFHLGtCQUFrQixDQUFDLGVBQWUsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQzt3QkFDOUUsc0JBQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsRUFBQzs7d0JBRTNDLFFBQVEsR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQUMsa0JBQWtCLEVBQUUsUUFBUSxFQUFFLGFBQWEsRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDO3dCQUMzRyxNQUFNLENBQUMsY0FBYyxHQUFHLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7Ozs7d0JBRWxFLEtBQUEsTUFBTSxDQUFBO3dCQUFNLHFCQUFNLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxNQUFNLENBQUMsRUFBQTs7d0JBQXhELEdBQU8sRUFBRSxHQUFHLFNBQTRDLENBQUM7Ozs7d0JBRXpELDRHQUE0Rzt3QkFDNUcsK0dBQStHO3dCQUMvRyxtREFBbUQ7d0JBQ25ELDhEQUE4RDt3QkFDOUQsSUFBSSxHQUFDLFlBQVksTUFBTSxDQUFDLHlCQUF5QixJQUFJLEdBQUMsWUFBWSxNQUFNLENBQUMsd0JBQXdCLEVBQUU7NEJBQ2pHLE9BQU8sQ0FBQyxHQUFHLENBQUMsOEZBQThGLENBQUMsQ0FBQzt5QkFDN0c7NkJBQU07NEJBQ0wsTUFBTSxHQUFDLENBQUM7eUJBQ1Q7Ozt3QkFJTCxJQUFJLGFBQWEsRUFBRTs0QkFDakIsTUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7NEJBQzlCLE1BQU0sQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQzs0QkFDcEMsTUFBTSxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7eUJBQ3hDO3dCQUVELHNCQUFPLE1BQU0sRUFBQzs7O1NBQ2YsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxrREFBdUIsR0FBdkIsVUFBd0IsR0FBUSxFQUFFLFFBQWtCLEVBQUUsU0FBYyxFQUFFLE1BQWU7UUFBckYsaUJBZ0RDO1FBekNDLElBQU0sZUFBZSxHQUFxQixFQUFFLENBQUM7UUFDN0MsUUFBUSxDQUFDLE9BQU8sQ0FBQyxVQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzFCLElBQU0sT0FBTyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDM0MsSUFBTSxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQztZQUNuRCxJQUFNLGNBQWMsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQztZQUMvQywwQkFBMEI7WUFDMUIsZ0JBQWdCLENBQUMsT0FBTyxHQUFHLEtBQUksQ0FBQyxPQUFPLENBQUM7WUFDeEMsY0FBYyxDQUFDLE9BQU8sR0FBRyxLQUFJLENBQUMsT0FBTyxDQUFDO1lBRXRDLElBQU0scUJBQXFCLEdBQW1CO2dCQUM1QyxVQUFVLEVBQUUsQ0FBQztnQkFDYixPQUFPLEVBQUUsT0FBTztnQkFDaEIsS0FBSyxFQUFFLElBQUk7YUFDWixDQUFDO1lBRUYsSUFBSSxNQUFNLEVBQUU7Z0JBQ1YsSUFBSTtvQkFDRixHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxnQkFBZ0IsRUFBRSxPQUFPLENBQUMsWUFBWSxFQUFFLEtBQUksQ0FBQyxrQkFBa0IsRUFBRSxPQUFPLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztpQkFDckg7Z0JBQUMsT0FBTyxDQUFDLEVBQUU7b0JBQ1YscUJBQXFCLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztvQkFDaEMsZUFBZSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO2lCQUM3QzthQUNGO1lBRUQsSUFBSTtnQkFDRixHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxjQUFjLEVBQUUsT0FBTyxDQUFDLFlBQVksRUFBRSxLQUFJLENBQUMsa0JBQWtCLEVBQUUsT0FBTyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7YUFDbkg7WUFBQyxPQUFPLENBQUMsRUFBRTtnQkFDVixxQkFBcUIsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO2dCQUNoQyxlQUFlLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUM7YUFDN0M7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksZUFBZSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDOUIsSUFBTSxhQUFhLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxVQUFBLFlBQVksSUFBSSxPQUFBLFlBQVksQ0FBQyxVQUFVLEVBQXZCLENBQXVCLENBQUMsQ0FBQztZQUNuRixJQUFNLEtBQUssR0FBUSxJQUFJLEtBQUssQ0FBQyxzQ0FBb0MsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUcsQ0FBQyxDQUFDO1lBQzdGLEtBQUssQ0FBQyxJQUFJLEdBQUcseUJBQXlCLENBQUM7WUFDdkMsS0FBSyxDQUFDLGFBQWEsR0FBRyxlQUFlLENBQUM7WUFDdEMsTUFBTSxLQUFLLENBQUM7U0FDYjtRQUVELE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCw2Q0FBa0IsR0FBbEIsVUFBbUIsTUFBNkMsRUFBRSxRQUErQjtRQUMvRixJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQVMsU0FBVSxrQkFBa0I7Ozs7O3dCQUN0QyxXQUFXLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7d0JBRXpELElBQUksV0FBVyxLQUFLLFNBQVMsRUFBRTs0QkFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBMkMsTUFBTSxDQUFDLFFBQVUsQ0FBQyxDQUFDO3lCQUMvRTs2QkFFRyxDQUFBLFdBQVcsQ0FBQyxPQUFPLEtBQUssU0FBUyxDQUFBLEVBQWpDLHdCQUFpQzt3QkFDN0IsWUFBWSxHQUFHLFdBQVcsQ0FBQyxTQUFTLENBQUM7d0JBQ3RCLHFCQUFNLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxFQUFBOzt3QkFBbEQsWUFBWSxHQUFHLFNBQW1DO3dCQUV4RCxzQkFBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksR0FBRyxZQUFZLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLEVBQUM7O29CQUV0RSwrR0FBK0c7b0JBQy9HLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLENBQUMsQ0FBQzs7O1NBRXBELENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7O09BWUc7SUFDSCxnREFBcUIsR0FBckIsVUFBc0IsTUFBb0MsRUFBRSxRQUE0QjtRQUN0RixJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQUMsU0FBVSxxQkFBcUI7Ozs7O3dCQUVyQyxJQUFJLEdBS0YsTUFBTSxLQUxKLEVBQ0osZUFBZSxHQUliLE1BQU0sZ0JBSk8sRUFDZixNQUFNLEdBR0osTUFBTSxPQUhGLEVBQ04sZ0JBQWdCLEdBRWQsTUFBTSxpQkFGUSxFQUNoQixJQUFJLEdBQ0YsTUFBTSxLQURKLENBQ0s7d0JBR0wsWUFBWSxHQUFHLE1BQU0sQ0FBQyxJQUFJLElBQUksTUFBTSxDQUFDLFlBQVksQ0FBQzt3QkFDeEQsSUFBSSxDQUFDLFlBQVksRUFBRTs0QkFDakIsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO3lCQUN6RDt3QkFFSyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sS0FBSyxLQUFLLENBQUM7d0JBRWpDLGdCQUFnQixHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQzt3QkFDcEMsa0JBQWtCLEdBQUcsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDO3dCQUM5QyxzQkFBc0IsR0FBRyxNQUFNLENBQUMsNkJBQTZCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzt3QkFFdEYsSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsa0JBQWtCLENBQUMsRUFBRTs0QkFDakcsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQkFBZSxnQkFBZ0IsdUJBQWtCLGtCQUFrQiwrQkFBNEIsQ0FBQyxDQUFDO3lCQUNsSDt3QkFFSyxZQUFZLEdBQUcsSUFBSSxpQ0FBc0IsQ0FBQzs0QkFDOUMsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLOzRCQUNqQixVQUFVLEVBQUUsSUFBSTs0QkFDaEIsWUFBWSxFQUFFLFlBQVk7NEJBQzFCLE9BQU8sRUFBRSxLQUFLO3lCQUNmLENBQUMsQ0FBQzt3QkFFSCxxQkFBTSxZQUFZLENBQUMsZ0JBQWdCLENBQUM7Z0NBQ2xDLE1BQU0sRUFBRSxNQUFNO2dDQUNkLFVBQVUsRUFBRSxJQUFJO2dDQUNoQixlQUFlLEVBQUUsZUFBZTs2QkFDakMsQ0FBQyxFQUFBOzt3QkFKRixTQUlFLENBQUM7NkJBRUMsTUFBTSxFQUFOLHdCQUFNO3dCQUNSLHFCQUFNLFlBQVksQ0FBQyxlQUFlLENBQUMsRUFBRSxVQUFVLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUE7O3dCQUEvRSxTQUErRSxDQUFDO3dCQUNoRixzQkFBTyxZQUFZLENBQUMsTUFBTSxFQUFFLEVBQUM7NEJBRXRCLHFCQUFNLFlBQVksQ0FBQyxhQUFhLEVBQUUsRUFBQTs0QkFBekMsc0JBQU8sU0FBa0MsRUFBQzs7O1NBRTdDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILDBDQUFlLEdBQWYsVUFBZ0IsSUFBWTtRQUMxQixJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1QsMEVBQTBFO1lBQzFFLDBFQUEwRTtZQUMxRSxrRUFBa0U7WUFDbEUsSUFBSSxHQUFHLG9CQUFXLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQzdCO1FBQ0QsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEQsSUFBTSxJQUFJLEdBQUcsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQy9DLE9BQU87WUFDTCxHQUFHLEVBQUUsSUFBSTtZQUNULEdBQUcsRUFBRSxXQUFXLENBQUMsUUFBUSxFQUFFO1NBQzVCLENBQUM7SUFDSixDQUFDO0lBRUQsaURBQXNCLEdBQXRCLFVBQXVCLFdBQXVDLEVBQUUsUUFBNEI7UUFDMUYsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQseUNBQWMsR0FBZCxVQUFlLE1BQTZCLElBQVMsQ0FBQztJQUV0RCw2Q0FBa0IsR0FBbEIsVUFBbUIsTUFBaUMsRUFBRSxRQUF5QztRQUM3RixPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRCxtREFBd0IsR0FBeEIsVUFBeUIsWUFBNkMsRUFBRSxTQUEyQjtRQUNqRyxPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVELGlEQUFzQixHQUF0QjtRQUNFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVELG1EQUF3QixHQUF4QjtRQUNFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVELG9EQUF5QixHQUF6QixVQUEwQixNQUF3QztRQUNoRSxPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxNQUFNLENBQUMseUJBQXlCLEVBQUUsQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFFRCxzQ0FBVyxHQUFYLFVBQVksR0FBb0IsRUFBRSxPQUF3QixFQUFFLFFBQStCO1FBQ3pGLE9BQU8sRUFBRSxDQUFTLFNBQVUsYUFBYTs7O2dCQUNqQyxVQUFVLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUN6RCxnQkFBZ0IsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDN0MsWUFBWSxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUM7Z0JBQ3JDLE1BQU0sR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUM7Z0JBQ3RELHNCQUFPLGNBQWMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFlBQVksRUFBRSxNQUFNLENBQUMsRUFBQzs7U0FDN0UsQ0FBQzthQUNDLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDVixVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUNILHVCQUFDO0FBQUQsQ0FBQyxBQWoyREQsQ0FBK0MsbUJBQVEsR0FpMkR0RDtBQWoyRHFCLDRDQUFnQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvZGVzLCBWaXJ0dWFsU2l6ZXMgfSBmcm9tICdAYml0Z28vdW5zcGVudHMnO1xuaW1wb3J0IHsgVW5zcGVudFR5cGUgfSBmcm9tICdAYml0Z28vdW5zcGVudHMvZGlzdC9jb2Rlcyc7XG5pbXBvcnQgKiBhcyBiaXRjb2luIGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgKiBhcyBiaXRjb2luTWVzc2FnZSBmcm9tICdiaXRjb2luanMtbWVzc2FnZSc7XG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgKiBhcyBkZWJ1Z0xpYiBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyByZXF1ZXN0IGZyb20gJ3N1cGVyYWdlbnQnO1xuXG5pbXBvcnQgeyBkZXJpdmVLZXlCeVBhdGgsIGhkUGF0aCB9IGZyb20gJy4uLy4uL2JpdGNvaW4nO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi8uLi9iaXRnbyc7XG5pbXBvcnQgKiBhcyBjb25maWcgZnJvbSAnLi4vLi4vY29uZmlnJztcbmltcG9ydCAqIGFzIGVycm9ycyBmcm9tICcuLi8uLi9lcnJvcnMnO1xuXG5pbXBvcnQge1xuICBBZGRyZXNzQ29pblNwZWNpZmljLFxuICBCYXNlQ29pbixcbiAgRXh0cmFQcmVidWlsZFBhcmFtc09wdGlvbnMsXG4gIEtleWNoYWluc1RyaXBsZXQsXG4gIFByZWNyZWF0ZUJpdEdvT3B0aW9ucyxcbiAgUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgU2lnbmVkVHJhbnNhY3Rpb24sXG4gIFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMsXG4gIFRyYW5zYWN0aW9uUGFyYW1zIGFzIEJhc2VUcmFuc2FjdGlvblBhcmFtcyxcbiAgVHJhbnNhY3Rpb25QcmVidWlsZCBhcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgVHJhbnNhY3Rpb25SZWNpcGllbnQsXG4gIFZlcmlmaWNhdGlvbk9wdGlvbnMsXG4gIFZlcmlmeUFkZHJlc3NPcHRpb25zIGFzIEJhc2VWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5UmVjb3ZlcnlUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbn0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgQ3VzdG9tQ2hhbmdlT3B0aW9ucywgcGFyc2VPdXRwdXQgfSBmcm9tICcuLi9pbnRlcm5hbC9wYXJzZU91dHB1dCc7XG5pbXBvcnQgeyBSZXF1ZXN0VHJhY2VyIH0gZnJvbSAnLi4vaW50ZXJuYWwvdXRpbCc7XG5pbXBvcnQgeyBLZXljaGFpbiwgS2V5SW5kaWNlcyB9IGZyb20gJy4uL2tleWNoYWlucyc7XG5pbXBvcnQgeyBwcm9taXNlUHJvcHMgfSBmcm9tICcuLi9wcm9taXNlLXV0aWxzJztcbmltcG9ydCB7IENyb3NzQ2hhaW5SZWNvdmVyeVRvb2wgfSBmcm9tICcuLi9yZWNvdmVyeSc7XG5pbXBvcnQgeyBOb2RlQ2FsbGJhY2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBXYWxsZXQgfSBmcm9tICcuLi93YWxsZXQnO1xuaW1wb3J0IHsgUmVjb3ZlcnlBY2NvdW50RGF0YSwgUmVjb3ZlcnlVbnNwZW50IH0gZnJvbSAnLi4vcmVjb3ZlcnkvdHlwZXMnO1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnTGliKCdiaXRnbzp2Mjp1dHhvJyk7XG5jb25zdCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZnlBZGRyZXNzT3B0aW9ucyBleHRlbmRzIEJhc2VWZXJpZnlBZGRyZXNzT3B0aW9ucyB7XG4gIGNoYWluOiBudW1iZXI7XG4gIGluZGV4OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3V0cHV0IHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBhbW91bnQ6IHN0cmluZyB8IG51bWJlcjtcbiAgZXh0ZXJuYWw/OiBib29sZWFuO1xuICBuZWVkc0N1c3RvbUNoYW5nZUtleVNpZ25hdHVyZVZlcmlmaWNhdGlvbj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25GZWUge1xuICBmZWU6IG51bWJlcjtcbiAgZmVlUmF0ZT86IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiB7XG4gIGRpc3BsYXlPcmRlcjogc3RyaW5nW107XG4gIGlkOiBzdHJpbmc7XG4gIG91dHB1dHM6IE91dHB1dFtdLFxuICBjaGFuZ2VPdXRwdXRzOiBPdXRwdXRbXSxcbiAgb3V0cHV0QW1vdW50OiBzdHJpbmc7XG4gIGNoYW5nZUFtb3VudDogbnVtYmVyO1xuICBmZWU6IFRyYW5zYWN0aW9uRmVlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVuc3BlbnQge1xuICBpZDogc3RyaW5nLFxuICB2YWx1ZTogc3RyaW5nLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEhleDogc3RyaW5nO1xuICB0eEluZm8/OiB7IGNoYW5nZUFkZHJlc3Nlczogc3RyaW5nW10sIHVuc3BlbnRzOiBVbnNwZW50W10gfTtcbiAgZmVlSW5mbz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVdHhvTmV0d29yayB7XG4gIHB1YktleUhhc2g6IG51bWJlcjtcbiAgc2NyaXB0SGFzaDogbnVtYmVyO1xuICBhbHRTY3JpcHRIYXNoPzogbnVtYmVyO1xuICBiZWNoMzI6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRTaWduYXR1cmVTY3JpcHQge1xuICBpc1NlZ3dpdElucHV0OiBib29sZWFuO1xuICBpbnB1dENsYXNzaWZpY2F0aW9uOiBzdHJpbmc7XG4gIHNpZ25hdHVyZXM/OiBCdWZmZXJbXTtcbiAgcHVibGljS2V5cz86IEJ1ZmZlcltdO1xuICBwdWJTY3JpcHQ/OiBCdWZmZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhJbmZvPzogYW55O1xuICBibG9ja0hlaWdodD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvblBhcmFtcyBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblBhcmFtcyB7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIGNoYW5nZUFkZHJlc3M/OiBzdHJpbmc7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UGFyYW1zOiBUcmFuc2FjdGlvblBhcmFtcztcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgd2FsbGV0OiBXYWxsZXQ7XG4gIHZlcmlmaWNhdGlvbj86IFZlcmlmaWNhdGlvbk9wdGlvbnM7XG4gIHJlcUlkPzogUmVxdWVzdFRyYWNlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRUcmFuc2FjdGlvbiB7XG4gIGtleWNoYWluczoge1xuICAgIHVzZXI/OiBLZXljaGFpbjtcbiAgICBiYWNrdXA/OiBLZXljaGFpbjtcbiAgICBiaXRnbz86IEtleWNoYWluO1xuICB9O1xuICBrZXlTaWduYXR1cmVzOiB7XG4gICAgYmFja3VwUHViOiBzdHJpbmc7XG4gICAgYml0Z29QdWI6IHN0cmluZztcbiAgfTtcbiAgb3V0cHV0czogT3V0cHV0W107XG4gIG1pc3NpbmdPdXRwdXRzOiBPdXRwdXRbXTtcbiAgZXhwbGljaXRFeHRlcm5hbE91dHB1dHM6IE91dHB1dFtdO1xuICBpbXBsaWNpdEV4dGVybmFsT3V0cHV0czogT3V0cHV0W107XG4gIGNoYW5nZU91dHB1dHM6IE91dHB1dFtdO1xuICBleHBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQ6IG51bWJlcjtcbiAgaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50OiBudW1iZXI7XG4gIG5lZWRzQ3VzdG9tQ2hhbmdlS2V5U2lnbmF0dXJlVmVyaWZpY2F0aW9uOiBib29sZWFuO1xuICBjdXN0b21DaGFuZ2U/OiBDdXN0b21DaGFuZ2VPcHRpb25zO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdlbmVyYXRlQWRkcmVzc09wdGlvbnMge1xuICBhZGRyZXNzVHlwZT86IHN0cmluZztcbiAga2V5Y2hhaW5zOiB7XG4gICAgcHViOiBzdHJpbmc7XG4gICAgYXNwS2V5SWQ/OiBzdHJpbmc7XG4gIH1bXTtcbiAgdGhyZXNob2xkOiBudW1iZXI7XG4gIGNoYWluPzogbnVtYmVyO1xuICBpbmRleDogbnVtYmVyO1xuICBzZWd3aXQ/OiBib29sZWFuO1xuICBiZWNoMzI/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkZHJlc3NEZXRhaWxzIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBjaGFpbjogbnVtYmVyO1xuICBpbmRleDogbnVtYmVyO1xuICBjb2luOiBzdHJpbmc7XG4gIGNvaW5TcGVjaWZpYzogQWRkcmVzc0NvaW5TcGVjaWZpYztcbiAgYWRkcmVzc1R5cGU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IHtcbiAgICB0eEhleDogc3RyaW5nO1xuICAgIHR4SW5mbzoge1xuICAgICAgdW5zcGVudHM6IHtcbiAgICAgICAgY2hhaW4/OiBudW1iZXI7XG4gICAgICAgIGluZGV4PzogbnVtYmVyO1xuICAgICAgICB2YWx1ZT86IG51bWJlcjtcbiAgICAgICAgYWRkcmVzcz86IHN0cmluZztcbiAgICAgICAgcmVkZWVtU2NyaXB0Pzogc3RyaW5nO1xuICAgICAgICB3aXRuZXNzU2NyaXB0Pzogc3RyaW5nO1xuICAgICAgfVtdO1xuICAgIH1cbiAgfTtcbiAgcHJ2OiBzdHJpbmc7XG4gIGlzTGFzdFNpZ25hdHVyZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTXVsdGlTaWdBZGRyZXNzIHtcbiAgb3V0cHV0U2NyaXB0OiBCdWZmZXI7XG4gIHJlZGVlbVNjcmlwdDogQnVmZmVyO1xuICB3aXRuZXNzU2NyaXB0OiBCdWZmZXI7XG4gIGFkZHJlc3M6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPZmZsaW5lVmF1bHRUeEluZm8ge1xuICBpbnB1dHM6IHtcbiAgICBjaGFpblBhdGg6IHN0cmluZztcbiAgfVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJGcm9tV3JvbmdDaGFpbk9wdGlvbnMge1xuICB0eGlkOiBzdHJpbmc7XG4gIHJlY292ZXJ5QWRkcmVzczogc3RyaW5nO1xuICB3YWxsZXQ6IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZTogc3RyaW5nO1xuICB4cHJ2OiBzdHJpbmc7XG4gIGNvaW4/OiBBYnN0cmFjdFV0eG9Db2luO1xuICByZWNvdmVyeUNvaW4/OiBBYnN0cmFjdFV0eG9Db2luO1xuICBzaWduZWQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdHRlZE9mZmxpbmVWYXVsdFR4SW5mbyB7XG4gIHR4SW5mbzoge1xuICAgIHVuc3BlbnRzOiB7XG4gICAgICBjaGFpblBhdGg6IHN0cmluZztcbiAgICAgIGluZGV4Pzogc3RyaW5nO1xuICAgICAgY2hhaW4/OiBzdHJpbmc7XG4gICAgfVtdO1xuICB9O1xuICB0eEhleDogc3RyaW5nO1xuICBmZWVJbmZvOiB7fTtcbiAgY29pbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkZHJlc3NJbmZvIHtcbiAgdHhDb3VudDogbnVtYmVyO1xuICB0b3RhbEJhbGFuY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVbnNwZW50SW5mbyB7XG4gIGFkZHJlc3M6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyUGFyYW1zIHtcbiAgc2Nhbj86IG51bWJlcjtcbiAgdXNlcktleTogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgcmVjb3ZlcnlEZXN0aW5hdGlvbjogc3RyaW5nO1xuICBrcnNQcm92aWRlcjogc3RyaW5nO1xuICBpZ25vcmVBZGRyZXNzVHlwZXM6IHN0cmluZ1tdO1xuICBiaXRnb0tleTogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICBhcGlLZXk/OiBzdHJpbmc7XG4gIHVzZXJLZXlQYXRoPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeUtleVNpZ25hdHVyZXNPcHRpb25zIHtcbiAgdXNlcktleWNoYWluPzogS2V5Y2hhaW47XG4gIGtleWNoYWluVG9WZXJpZnk/OiBLZXljaGFpbjtcbiAga2V5U2lnbmF0dXJlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeVVzZXJQdWJsaWNLZXlPcHRpb25zIHtcbiAgdXNlcktleWNoYWluPzogS2V5Y2hhaW47XG4gIGRpc2FibGVOZXR3b3JraW5nOiBib29sZWFuO1xuICB0eFBhcmFtczogVHJhbnNhY3Rpb25QYXJhbXM7XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdFV0eG9Db2luIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwdWJsaWMgYWx0U2NyaXB0SGFzaD86IG51bWJlcjtcbiAgcHVibGljIHN1cHBvcnRBbHRTY3JpcHREZXN0aW5hdGlvbj86IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgX25ldHdvcms6IFV0eG9OZXR3b3JrO1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28sIG5ldHdvcms6IFV0eG9OZXR3b3JrKSB7XG4gICAgc3VwZXIoYml0Z28pO1xuICAgIGlmICghXy5pc09iamVjdChuZXR3b3JrKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCduZXR3b3JrIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHRoaXMuX25ldHdvcmsgPSBuZXR3b3JrO1xuICB9XG5cbiAgZ2V0IG5ldHdvcmsoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25ldHdvcms7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHZhbGlkQWRkcmVzc1R5cGVzKCk6IFVuc3BlbnRUeXBlW10ge1xuICAgIGNvbnN0IHZhbGlkQWRkcmVzc1R5cGVzOiBVbnNwZW50VHlwZVtdID0gW107XG4gICAgLy8gYmVzdCB3YXkgSSBjb3VsZCBmaW5kIHRvIGxvb3Agb3ZlciBlbnVtIHZhbHVlc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTcxOTgjaXNzdWVjb21tZW50LTQyMzgzNjY1OFxuICAgIC8vIHRoaXMgaXMgYSB0eXBlc2NyaXB0IHJvdWdoIGNvcm5lciBmb3Igc3VyZVxuICAgIGNvbnN0IHVuc3BlbnRUeXBlS2V5czogc3RyaW5nW10gPSBPYmplY3Qua2V5cyhVbnNwZW50VHlwZSk7XG4gICAgY29uc3QgdW5zcGVudFR5cGVzOiBVbnNwZW50VHlwZVtdID0gdW5zcGVudFR5cGVLZXlzXG4gICAgICAubWFwKGsgPT4gVW5zcGVudFR5cGVbayBhcyBhbnldKVxuICAgICAgLm1hcCh2ID0+IHYgYXMgVW5zcGVudFR5cGUpO1xuICAgIGZvciAoY29uc3QgYWRkcmVzc1R5cGUgb2YgdW5zcGVudFR5cGVzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBDb2Rlcy5mb3JUeXBlKGFkZHJlc3NUeXBlKTtcbiAgICAgICAgdmFsaWRBZGRyZXNzVHlwZXMucHVzaChhZGRyZXNzVHlwZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcuIENvZGVzLmZvclR5cGUgd2lsbCB0aHJvdyBpZiB0aGUgYWRkcmVzcyB0eXBlIGhhcyBubyBjaGFpbiBjb2RlcywgbWVhbmluZyBpdCBpcyBpbnZhbGlkIG9uIHRoZVxuICAgICAgICAvLyBCaXRHbyBwbGF0Zm9ybSBhbmQgc2hvdWxkIG5vdCBiZSBhZGRlZCB0byB0aGUgdmFsaWRBZGRyZXNzVHlwZXMgYXJyYXkuXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWxpZEFkZHJlc3NUeXBlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmYWN0b3IgYmV0d2VlbiB0aGUgYmFzZSB1bml0IGFuZCBpdHMgc21hbGxlc3Qgc3ViZGl2aXNvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRCYXNlRmFjdG9yKCkge1xuICAgIHJldHVybiAxZTg7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIHRoZSBsaWJyYXJ5IHdoaWNoIGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gbG93LWxldmVsIG9wZXJhdGlvbnMgZm9yIHRoaXMgY29pblxuICAgKi9cbiAgZ2V0Q29pbkxpYnJhcnkoKSB7XG4gICAgcmV0dXJuIGJpdGNvaW47XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRvIGdldCB0aGUgdmVyc2lvbiBudW1iZXIgZm9yIGFuIGFkZHJlc3NcbiAgICovXG4gIHByb3RlY3RlZCBnZXRBZGRyZXNzVmVyc2lvbihhZGRyZXNzOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIC8vIHRyeSBkZWNvZGluZyBhcyBiYXNlNTggZmlyc3RcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB2ZXJzaW9uIH0gPSB0aGlzLmdldENvaW5MaWJyYXJ5KCkuYWRkcmVzcy5mcm9tQmFzZTU4Q2hlY2soYWRkcmVzcyk7XG4gICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpZiB0aGF0IGZhaWxzLCBhbmQgd2UgYXJlbid0IHN1cHBvcnRpbmcgcDJ3c2gsIHRoZW4gd2UgYXJlIGRvbmUgYW5kIGRpZCBub3QgZmluZCBhIHZlcnNpb25cbiAgICAgIGlmICghdGhpcy5zdXBwb3J0c1Ayd3NoKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSwgdHJ5IGRlY29kaW5nIGFzIGJlY2gzMlxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHZlcnNpb24sIHByZWZpeCB9ID0gdGhpcy5nZXRDb2luTGlicmFyeSgpLmFkZHJlc3MuZnJvbUJlY2gzMihhZGRyZXNzKTtcbiAgICAgIGlmIChfLmlzU3RyaW5nKHRoaXMubmV0d29yay5iZWNoMzIpICYmIHByZWZpeCA9PT0gdGhpcy5uZXR3b3JrLmJlY2gzMikge1xuICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpZ25vcmUgZXJyb3JzLCBqdXN0IGZhbGwgdGhyb3VnaCBhbmQgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZ2V0IHRoZSBiZWNoMzIgcHJlZml4IGZvciBhbiBhZGRyZXNzXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0QWRkcmVzc1ByZWZpeChhZGRyZXNzOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIC8vIG90aGVyd2lzZSwgdHJ5IGRlY29kaW5nIGFzIGJlY2gzMlxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHByZWZpeCB9ID0gdGhpcy5nZXRDb2luTGlicmFyeSgpLmFkZHJlc3MuZnJvbUJlY2gzMihhZGRyZXNzKTtcbiAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWdub3JlIGVycm9ycywganVzdCBmYWxsIHRocm91Z2ggYW5kIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYWRkcmVzcyBpcyB2YWxpZFxuICAgKiBAcGFyYW0gYWRkcmVzc1xuICAgKiBAcGFyYW0gZm9yY2VBbHRTY3JpcHRTdXBwb3J0XG4gICAqL1xuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcsIGZvcmNlQWx0U2NyaXB0U3VwcG9ydCA9IGZhbHNlKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdmFsaWRWZXJzaW9ucyA9IFtcbiAgICAgIHRoaXMubmV0d29yay5wdWJLZXlIYXNoLFxuICAgICAgdGhpcy5uZXR3b3JrLnNjcmlwdEhhc2gsXG4gICAgXTtcbiAgICBpZiAodGhpcy5hbHRTY3JpcHRIYXNoICYmIChmb3JjZUFsdFNjcmlwdFN1cHBvcnQgfHwgdGhpcy5zdXBwb3J0QWx0U2NyaXB0RGVzdGluYXRpb24pKSB7XG4gICAgICB2YWxpZFZlcnNpb25zLnB1c2godGhpcy5hbHRTY3JpcHRIYXNoKTtcbiAgICB9XG5cbiAgICBjb25zdCBhZGRyZXNzVmVyc2lvbiA9IHRoaXMuZ2V0QWRkcmVzc1ZlcnNpb24oYWRkcmVzcyk7XG5cbiAgICAvLyB0aGUgYWRkcmVzcyB2ZXJzaW9uIG5lZWRzIHRvIGJlIGFtb25nIHRoZSB2YWxpZCBvbmVzXG4gICAgY29uc3QgYWRkcmVzc1ZlcnNpb25WYWxpZCA9IF8uaXNOdW1iZXIoYWRkcmVzc1ZlcnNpb24pICYmIHZhbGlkVmVyc2lvbnMuaW5jbHVkZXMoYWRkcmVzc1ZlcnNpb24pO1xuICAgIGNvbnN0IGFkZHJlc3NQcmVmaXggPSB0aGlzLmdldEFkZHJlc3NQcmVmaXgoYWRkcmVzcyk7XG5cbiAgICBpZiAoIXRoaXMuc3VwcG9ydHNQMndzaCgpIHx8IF8uaXNVbmRlZmluZWQoYWRkcmVzc1ByZWZpeCkpIHtcbiAgICAgIHJldHVybiBhZGRyZXNzVmVyc2lvblZhbGlkO1xuICAgIH1cblxuICAgIC8vIGFkZHJlc3MgaGFzIGEgcG90ZW50aWFsIGJlY2gzMiBwcmVmaXgsIHZhbGlkYXRlIHRoYXRcbiAgICByZXR1cm4gXy5pc1N0cmluZyh0aGlzLm5ldHdvcmsuYmVjaDMyKSAmJiB0aGlzLm5ldHdvcmsuYmVjaDMyID09PSBhZGRyZXNzUHJlZml4O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHB1YiB0aGUgcHViIHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFB1YihwdWI6IHN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KHB1Yik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGF0ZXN0IGJsb2NrIGhlaWdodFxuICAgKiBAcGFyYW0gcmVxSWRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBnZXRMYXRlc3RCbG9ja0hlaWdodChyZXFJZD86IFJlcXVlc3RUcmFjZXIsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPG51bWJlcj4pOiBCbHVlYmlyZDxudW1iZXI+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288bnVtYmVyPihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKHJlcUlkKSB7XG4gICAgICAgIHRoaXMuYml0Z28uX3JlcUlkID0gcmVxSWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFpbmhlYWQgPSB5aWVsZCBzZWxmLmJpdGdvLmdldChzZWxmLnVybCgnL3B1YmxpYy9ibG9jay9sYXRlc3QnKSkucmVzdWx0KCk7XG4gICAgICByZXR1cm4gY2hhaW5oZWFkLmhlaWdodDtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBjdXN0b20gY29pbiBsb2dpYyBhZnRlciBhIHRyYW5zYWN0aW9uIHByZWJ1aWxkIGhhcyBiZWVuIHJlY2VpdmVkIGZyb20gQml0R29cbiAgICogQHBhcmFtIHByZWJ1aWxkXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcG9zdFByb2Nlc3NQcmVidWlsZChwcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZCwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8VHJhbnNhY3Rpb25QcmVidWlsZD4pOiBCbHVlYmlyZDxUcmFuc2FjdGlvblByZWJ1aWxkPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFRyYW5zYWN0aW9uUHJlYnVpbGQ+KGZ1bmN0aW9uICooKSB7XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwcmVidWlsZC50eEhleCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR4UHJlYnVpbGQgcHJvcGVydHkgdHhIZXgnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYml0Y29pbi5UcmFuc2FjdGlvbi5mcm9tSGV4KHByZWJ1aWxkLnR4SGV4LCBzZWxmLm5ldHdvcmspO1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocHJlYnVpbGQuYmxvY2tIZWlnaHQpKSB7XG4gICAgICAgIHByZWJ1aWxkLmJsb2NrSGVpZ2h0ID0gKHlpZWxkIHNlbGYuZ2V0TGF0ZXN0QmxvY2tIZWlnaHQoKSkgYXMgbnVtYmVyO1xuICAgICAgfVxuICAgICAgLy8gTG9jayB0cmFuc2FjdGlvbiB0byB0aGUgbmV4dCBibG9jayB0byBkaXNjb3VyYWdlIGZlZSBzbmlwaW5nXG4gICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpdGNvaW4vYmxvYi9mYjBhYzQ4MmVlZTc2MWVjMTdlZDJjMTFkZjExZTA1NDM0N2EwMjZkL3NyYy93YWxsZXQvd2FsbGV0LmNwcCNMMjEzM1xuICAgICAgdHJhbnNhY3Rpb24ubG9ja3RpbWUgPSBwcmVidWlsZC5ibG9ja0hlaWdodDtcbiAgICAgIHJldHVybiBfLmV4dGVuZCh7fSwgcHJlYnVpbGQsIHsgdHhIZXg6IHRyYW5zYWN0aW9uLnRvSGV4KCkgfSk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIG91dHB1dHMgdGhhdCBhcmUgd2l0aGluIGV4cGVjdGVkIG91dHB1dHMgYnV0IG5vdCB3aXRoaW4gYWN0dWFsIG91dHB1dHMsIGluY2x1ZGluZyBkdXBsaWNhdGVzXG4gICAqIEBwYXJhbSBleHBlY3RlZE91dHB1dHNcbiAgICogQHBhcmFtIGFjdHVhbE91dHB1dHNcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cbiAgcHJvdGVjdGVkIHN0YXRpYyBmaW5kTWlzc2luZ091dHB1dHMoZXhwZWN0ZWRPdXRwdXRzOiBPdXRwdXRbXSwgYWN0dWFsT3V0cHV0czogT3V0cHV0W10pOiBPdXRwdXRbXSB7XG4gICAgY29uc3Qga2V5RnVuYyA9ICh7IGFkZHJlc3MsIGFtb3VudCB9OiBPdXRwdXQpOiBzdHJpbmcgPT4gYCR7YWRkcmVzc306JHtOdW1iZXIoYW1vdW50KX1gO1xuICAgIGNvbnN0IGdyb3VwZWRPdXRwdXRzID0gXy5ncm91cEJ5KGV4cGVjdGVkT3V0cHV0cywga2V5RnVuYyk7XG5cbiAgICBhY3R1YWxPdXRwdXRzLmZvckVhY2goKG91dHB1dCkgPT4ge1xuICAgICAgY29uc3QgZ3JvdXAgPSBncm91cGVkT3V0cHV0c1trZXlGdW5jKG91dHB1dCldO1xuICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgIGdyb3VwLnBvcCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIF8uZmxhdHRlbihfLnZhbHVlcyhncm91cGVkT3V0cHV0cykpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBhbiBhZGRyZXNzJyB0eXBlIGJhc2VkIG9uIGl0cyB3aXRuZXNzIGFuZCByZWRlZW0gc2NyaXB0IHByZXNlbmNlXG4gICAqIEBwYXJhbSBhZGRyZXNzRGV0YWlsc1xuICAgKi9cbiAgc3RhdGljIGluZmVyQWRkcmVzc1R5cGUoYWRkcmVzc0RldGFpbHM6IHsgY29pblNwZWNpZmljOiBBZGRyZXNzQ29pblNwZWNpZmljIH0pOiBzdHJpbmcgfCBudWxsIHtcbiAgICBpZiAoXy5pc09iamVjdChhZGRyZXNzRGV0YWlscy5jb2luU3BlY2lmaWMpKSB7XG4gICAgICBpZiAoXy5pc1N0cmluZyhhZGRyZXNzRGV0YWlscy5jb2luU3BlY2lmaWMucmVkZWVtU2NyaXB0KSAmJiBfLmlzU3RyaW5nKGFkZHJlc3NEZXRhaWxzLmNvaW5TcGVjaWZpYy53aXRuZXNzU2NyaXB0KSkge1xuICAgICAgICByZXR1cm4gQ29kZXMuVW5zcGVudFR5cGVUY29tYigncDJzaFAyd3NoJyk7XG4gICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoYWRkcmVzc0RldGFpbHMuY29pblNwZWNpZmljLnJlZGVlbVNjcmlwdCkpIHtcbiAgICAgICAgcmV0dXJuIENvZGVzLlVuc3BlbnRUeXBlVGNvbWIoJ3Ayc2gnKTtcbiAgICAgIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhhZGRyZXNzRGV0YWlscy5jb2luU3BlY2lmaWMud2l0bmVzc1NjcmlwdCkpIHtcbiAgICAgICAgcmV0dXJuIENvZGVzLlVuc3BlbnRUeXBlVGNvbWIoJ3Ayd3NoJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgYW5kIGZpbGwgdHJhbnNhY3Rpb24gZGV0YWlscyBzdWNoIGFzIGludGVybmFsL2NoYW5nZSBzcGVuZCwgZXh0ZXJuYWwgc3BlbmQgKGV4cGxpY2l0IHZzLiBpbXBsaWNpdCksIGV0Yy5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFBhcnNlZFRyYW5zYWN0aW9uPik6IEJsdWViaXJkPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFBhcnNlZFRyYW5zYWN0aW9uPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eFBhcmFtcyxcbiAgICAgICAgdHhQcmVidWlsZCxcbiAgICAgICAgd2FsbGV0LFxuICAgICAgICB2ZXJpZmljYXRpb24gPSB7fSxcbiAgICAgICAgcmVxSWQsXG4gICAgICB9ID0gcGFyYW1zO1xuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQodmVyaWZpY2F0aW9uLmRpc2FibGVOZXR3b3JraW5nKSAmJiAhXy5pc0Jvb2xlYW4odmVyaWZpY2F0aW9uLmRpc2FibGVOZXR3b3JraW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcmlmaWNhdGlvbi5kaXNhYmxlTmV0d29ya2luZyBtdXN0IGJlIGEgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlzYWJsZU5ldHdvcmtpbmcgPSB2ZXJpZmljYXRpb24uZGlzYWJsZU5ldHdvcmtpbmc7XG5cbiAgICAgIGFzeW5jIGZ1bmN0aW9uIGZldGNoS2V5Y2hhaW5zKHdhbGxldDogV2FsbGV0KTogUHJvbWlzZTxWZXJpZmljYXRpb25PcHRpb25zWydrZXljaGFpbnMnXT4ge1xuICAgICAgICByZXR1cm4gcHJvbWlzZVByb3BzKHtcbiAgICAgICAgICB1c2VyOiBzZWxmLmtleWNoYWlucygpLmdldCh7IGlkOiB3YWxsZXQua2V5SWRzKClbS2V5SW5kaWNlcy5VU0VSXSwgcmVxSWQgfSksXG4gICAgICAgICAgYmFja3VwOiBzZWxmLmtleWNoYWlucygpLmdldCh7IGlkOiB3YWxsZXQua2V5SWRzKClbS2V5SW5kaWNlcy5CQUNLVVBdLCByZXFJZCB9KSxcbiAgICAgICAgICBiaXRnbzogc2VsZi5rZXljaGFpbnMoKS5nZXQoeyBpZDogd2FsbGV0LmtleUlkcygpW0tleUluZGljZXMuQklUR09dLCByZXFJZCB9KSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9idGFpbiB0aGUga2V5Y2hhaW5zIGFuZCBrZXkgc2lnbmF0dXJlc1xuICAgICAgbGV0IGtleWNoYWluczogVmVyaWZpY2F0aW9uT3B0aW9uc1sna2V5Y2hhaW5zJ10gfCB1bmRlZmluZWQgPSB2ZXJpZmljYXRpb24ua2V5Y2hhaW5zO1xuICAgICAgaWYgKCFrZXljaGFpbnMpIHtcbiAgICAgICAgaWYgKGRpc2FibGVOZXR3b3JraW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZmV0Y2gga2V5Y2hhaW5zIHdpdGhvdXQgbmV0d29ya2luZycpO1xuICAgICAgICB9XG4gICAgICAgIGtleWNoYWlucyA9IHlpZWxkIGZldGNoS2V5Y2hhaW5zKHdhbGxldCk7XG4gICAgICB9XG5cbiAgICAgIGlmICgha2V5Y2hhaW5zIHx8ICFrZXljaGFpbnMudXNlciB8fCAha2V5Y2hhaW5zLmJhY2t1cCB8fCAha2V5Y2hhaW5zLmJpdGdvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5Y2hhaW5zIGFyZSByZXF1aXJlZCwgYnV0IGNvdWxkIG5vdCBiZSBmZXRjaGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleWNoYWluQXJyYXk6IFtLZXljaGFpbiwgS2V5Y2hhaW4sIEtleWNoYWluXSA9IFtrZXljaGFpbnMudXNlciwga2V5Y2hhaW5zLmJhY2t1cCwga2V5Y2hhaW5zLmJpdGdvXTtcblxuICAgICAgY29uc3Qga2V5U2lnbmF0dXJlcyA9IF8uZ2V0KHdhbGxldCwgJ193YWxsZXQua2V5U2lnbmF0dXJlcycpO1xuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh0eFByZWJ1aWxkLnR4SGV4KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgdHhQcmVidWlsZCBwcm9wZXJ0eSB0eEhleCcpO1xuICAgICAgfVxuICAgICAgLy8gb2J0YWluIGFsbCBvdXRwdXRzXG4gICAgICBjb25zdCBleHBsYW5hdGlvbjogVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiA9IHlpZWxkIHNlbGYuZXhwbGFpblRyYW5zYWN0aW9uKHtcbiAgICAgICAgdHhIZXg6IHR4UHJlYnVpbGQudHhIZXgsXG4gICAgICAgIHR4SW5mbzogdHhQcmVidWlsZC50eEluZm8sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgYWxsT3V0cHV0cyA9IFsuLi5leHBsYW5hdGlvbi5vdXRwdXRzLCAuLi5leHBsYW5hdGlvbi5jaGFuZ2VPdXRwdXRzXTtcblxuICAgICAgLy8gdmVyaWZ5IHRoYXQgZWFjaCByZWNpcGllbnQgZnJvbSB0eFBhcmFtcyBoYXMgdGhlaXIgb3duIG91dHB1dFxuICAgICAgY29uc3QgZXhwZWN0ZWRPdXRwdXRzID0gXy5nZXQodHhQYXJhbXMsICdyZWNpcGllbnRzJywgW10gYXMgVHJhbnNhY3Rpb25SZWNpcGllbnRbXSk7XG4gICAgICBjb25zdCBtaXNzaW5nT3V0cHV0cyA9IEFic3RyYWN0VXR4b0NvaW4uZmluZE1pc3NpbmdPdXRwdXRzKGV4cGVjdGVkT3V0cHV0cywgYWxsT3V0cHV0cyk7XG5cbiAgICAgIC8vIGdldCB0aGUga2V5Y2hhaW5zIGZyb20gdGhlIGN1c3RvbSBjaGFuZ2Ugd2FsbGV0IGlmIG5lZWRlZFxuICAgICAgbGV0IGN1c3RvbUNoYW5nZTogQ3VzdG9tQ2hhbmdlT3B0aW9ucyB8IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IHsgY3VzdG9tQ2hhbmdlV2FsbGV0SWQgPSB1bmRlZmluZWQgfSA9IHdhbGxldC5jb2luU3BlY2lmaWMoKSB8fCB7fTtcbiAgICAgIGlmIChjdXN0b21DaGFuZ2VXYWxsZXRJZCkge1xuICAgICAgICAvLyBmZXRjaCBrZXljaGFpbnMgZnJvbSBjdXN0b20gY2hhbmdlIHdhbGxldCBmb3IgZGVyaXZpbmcgYWRkcmVzc2VzLlxuICAgICAgICAvLyBUaGVzZSBrZXljaGFpbnMgc2hvdWxkIGJlIHNpZ25lZCBhbmQgdGhpcyBzaG91bGQgYmUgdmVyaWZpZWQgaW4gdmVyaWZ5VHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgY3VzdG9tQ2hhbmdlS2V5U2lnbmF0dXJlcyA9IF8uZ2V0KHdhbGxldCwgJ193YWxsZXQuY3VzdG9tQ2hhbmdlS2V5U2lnbmF0dXJlcycsIHt9KTtcbiAgICAgICAgY29uc3QgY3VzdG9tQ2hhbmdlV2FsbGV0OiBXYWxsZXQgPSB5aWVsZCBzZWxmLndhbGxldHMoKS5nZXQoeyBpZDogY3VzdG9tQ2hhbmdlV2FsbGV0SWQgfSk7XG4gICAgICAgIGNvbnN0IGN1c3RvbUNoYW5nZUtleXMgPSB5aWVsZCBmZXRjaEtleWNoYWlucyhjdXN0b21DaGFuZ2VXYWxsZXQpO1xuXG4gICAgICAgIGlmICghY3VzdG9tQ2hhbmdlS2V5cykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGZldGNoIGtleWNoYWlucyBmb3IgY3VzdG9tIGNoYW5nZSB3YWxsZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXN0b21DaGFuZ2VLZXljaGFpbnM6IFtLZXljaGFpbiwgS2V5Y2hhaW4sIEtleWNoYWluXSA9IFtjdXN0b21DaGFuZ2VLZXlzLnVzZXIsIGN1c3RvbUNoYW5nZUtleXMuYmFja3VwLCBjdXN0b21DaGFuZ2VLZXlzLmJpdGdvXTtcblxuICAgICAgICBpZiAoY3VzdG9tQ2hhbmdlS2V5Y2hhaW5zICYmIGN1c3RvbUNoYW5nZVdhbGxldCkge1xuICAgICAgICAgIGN1c3RvbUNoYW5nZSA9IHtcbiAgICAgICAgICAgIGtleXM6IGN1c3RvbUNoYW5nZUtleWNoYWlucyxcbiAgICAgICAgICAgIHNpZ25hdHVyZXM6IFtjdXN0b21DaGFuZ2VLZXlTaWduYXR1cmVzLnVzZXIsIGN1c3RvbUNoYW5nZUtleVNpZ25hdHVyZXMuYmFja3VwLCBjdXN0b21DaGFuZ2VLZXlTaWduYXR1cmVzLmJpdGdvXSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogTG9vcCB0aHJvdWdoIGFsbCB0aGUgb3V0cHV0cyBhbmQgY2xhc3NpZnkgZWFjaCBvZiB0aGVtIGFzIGVpdGhlciBpbnRlcm5hbCBzcGVuZHNcbiAgICAgICAqIG9yIGV4dGVybmFsIHNwZW5kcyBieSBzZXR0aW5nIHRoZSBcImV4dGVybmFsXCIgcHJvcGVydHkgdG8gdHJ1ZSBvciBmYWxzZSBvbiB0aGUgb3V0cHV0IG9iamVjdC5cbiAgICAgICAqL1xuICAgICAgY29uc3QgYWxsT3V0cHV0RGV0YWlsczogT3V0cHV0W10gPSB5aWVsZCBCbHVlYmlyZC5tYXAoYWxsT3V0cHV0cywgKGN1cnJlbnRPdXRwdXQpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhcnNlT3V0cHV0KHtcbiAgICAgICAgICBjdXJyZW50T3V0cHV0LFxuICAgICAgICAgIGNvaW46IHNlbGYsXG4gICAgICAgICAgdHhQcmVidWlsZCxcbiAgICAgICAgICB2ZXJpZmljYXRpb24sXG4gICAgICAgICAga2V5Y2hhaW5BcnJheSxcbiAgICAgICAgICB3YWxsZXQsXG4gICAgICAgICAgdHhQYXJhbXMsXG4gICAgICAgICAgY3VzdG9tQ2hhbmdlLFxuICAgICAgICAgIHJlcUlkLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBuZWVkc0N1c3RvbUNoYW5nZUtleVNpZ25hdHVyZVZlcmlmaWNhdGlvbiA9IGFsbE91dHB1dERldGFpbHMuc29tZSgob3V0cHV0KSA9PiBvdXRwdXQubmVlZHNDdXN0b21DaGFuZ2VLZXlTaWduYXR1cmVWZXJpZmljYXRpb24pO1xuXG4gICAgICBjb25zdCBjaGFuZ2VPdXRwdXRzID0gXy5maWx0ZXIoYWxsT3V0cHV0RGV0YWlscywgeyBleHRlcm5hbDogZmFsc2UgfSk7XG5cbiAgICAgIC8vIHRoZXNlIGFyZSBhbGwgdGhlIG91dHB1dHMgdGhhdCB3ZXJlIG5vdCBvcmlnaW5hbGx5IGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHJlY2lwaWVudHNcbiAgICAgIGNvbnN0IGltcGxpY2l0T3V0cHV0cyA9IEFic3RyYWN0VXR4b0NvaW4uZmluZE1pc3NpbmdPdXRwdXRzKGFsbE91dHB1dERldGFpbHMsIGV4cGVjdGVkT3V0cHV0cyk7XG5cbiAgICAgIGNvbnN0IGV4cGxpY2l0T3V0cHV0cyA9IEFic3RyYWN0VXR4b0NvaW4uZmluZE1pc3NpbmdPdXRwdXRzKGFsbE91dHB1dERldGFpbHMsIGltcGxpY2l0T3V0cHV0cyk7XG5cbiAgICAgIC8vIHRoZXNlIGFyZSBhbGwgdGhlIG5vbi13YWxsZXQgb3V0cHV0cyB0aGF0IGhhZCBiZWVuIG9yaWdpbmFsbHkgZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gcmVjaXBpZW50c1xuICAgICAgY29uc3QgZXhwbGljaXRFeHRlcm5hbE91dHB1dHMgPSBfLmZpbHRlcihleHBsaWNpdE91dHB1dHMsIHsgZXh0ZXJuYWw6IHRydWUgfSk7XG5cbiAgICAgIC8vIHRoaXMgaXMgdGhlIHN1bSBvZiBhbGwgdGhlIG9yaWdpbmFsbHkgZXhwbGljaXRseSBzcGVjaWZpZWQgbm9uLXdhbGxldCBvdXRwdXQgdmFsdWVzXG4gICAgICBjb25zdCBleHBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQgPSBfLnN1bUJ5KGV4cGxpY2l0RXh0ZXJuYWxPdXRwdXRzLCAnYW1vdW50Jyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGNhbGN1bGF0aW9uIG9mIHRoZSBpbXBsaWNpdCBleHRlcm5hbCBzcGVuZCBhbW91bnQgcGVydGFpbnMgdG8gdmVyaWZ5aW5nIHRoZSBwYXktYXMteW91LWdvLWZlZSBCaXRHb1xuICAgICAgICogYXV0b21hdGljYWxseSBhcHBsaWVzIHRvIHRyYW5zYWN0aW9ucyBzZW5kaW5nIG1vbmV5IG91dCBvZiB0aGUgd2FsbGV0LiBUaGUgbG9naWMgaXMgZmFpcmx5IHN0cmFpZ2h0Zm9yd2FyZFxuICAgICAgICogaW4gdGhhdCB3ZSBjb21wYXJlIHRoZSBleHRlcm5hbCBzcGVuZCBhbW91bnQgdGhhdCB3YXMgc3BlY2lmaWVkIGV4cGxpY2l0bHkgYnkgdGhlIHVzZXIgdG8gdGhlIHBvcnRpb25cbiAgICAgICAqIHRoYXQgd2FzIHNwZWNpZmllZCBpbXBsaWNpdGx5LiBUbyBwcm90ZWN0IGN1c3RvbWVycyBmcm9tIHBlb3BsZSB0YW1wZXJpbmcgd2l0aCB0aGUgdHJhbnNhY3Rpb24gb3V0cHV0cywgd2VcbiAgICAgICAqIGRlZmluZSBhIHRocmVzaG9sZCBmb3IgdGhlIG1heGltdW0gcGVyY2VudGFnZSBvZiB0aGUgaW1wbGljaXQgZXh0ZXJuYWwgc3BlbmQgaW4gcmVsYXRpb24gdG8gdGhlIGV4cGxpY2l0XG4gICAgICAgKiBleHRlcm5hbCBzcGVuZC5cbiAgICAgICAqL1xuXG4gICAgICAvLyBtYWtlIHN1cmUgdGhhdCBhbGwgdGhlIGV4dHJhIGFkZHJlc3NlcyBhcmUgY2hhbmdlIGFkZHJlc3Nlc1xuICAgICAgLy8gZ2V0IGFsbCB0aGUgYWRkaXRpb25hbCBleHRlcm5hbCBvdXRwdXRzIHRoZSBzZXJ2ZXIgYWRkZWQgYW5kIGNhbGN1bGF0ZSB0aGVpciB2YWx1ZXNcbiAgICAgIGNvbnN0IGltcGxpY2l0RXh0ZXJuYWxPdXRwdXRzID0gXy5maWx0ZXIoaW1wbGljaXRPdXRwdXRzLCB7IGV4dGVybmFsOiB0cnVlIH0pO1xuICAgICAgY29uc3QgaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50ID0gXy5zdW1CeShpbXBsaWNpdEV4dGVybmFsT3V0cHV0cywgJ2Ftb3VudCcpO1xuXG4gICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFRyYW5zYWN0aW9uID0ge1xuICAgICAgICBrZXljaGFpbnMsXG4gICAgICAgIGtleVNpZ25hdHVyZXMsXG4gICAgICAgIG91dHB1dHM6IGFsbE91dHB1dERldGFpbHMsXG4gICAgICAgIG1pc3NpbmdPdXRwdXRzLFxuICAgICAgICBleHBsaWNpdEV4dGVybmFsT3V0cHV0cyxcbiAgICAgICAgaW1wbGljaXRFeHRlcm5hbE91dHB1dHMsXG4gICAgICAgIGNoYW5nZU91dHB1dHMsXG4gICAgICAgIGV4cGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudCxcbiAgICAgICAgaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50LFxuICAgICAgICBuZWVkc0N1c3RvbUNoYW5nZUtleVNpZ25hdHVyZVZlcmlmaWNhdGlvbixcbiAgICAgICAgY3VzdG9tQ2hhbmdlLFxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNyeXB0IHRoZSB3YWxsZXQncyB1c2VyIHByaXZhdGUga2V5IGFuZCB2ZXJpZnkgdGhhdCB0aGUgY2xhaW1lZCBwdWJsaWMga2V5IG1hdGNoZXNcbiAgICogQHBhcmFtIHtWZXJpZnlVc2VyUHVibGljS2V5T3B0aW9uc30gcGFyYW1zXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RlY3RlZCB2ZXJpZnlVc2VyUHVibGljS2V5KHBhcmFtczogVmVyaWZ5VXNlclB1YmxpY0tleU9wdGlvbnMpOiBib29sZWFuIHtcbiAgICBjb25zdCB7IHVzZXJLZXljaGFpbiwgdHhQYXJhbXMsIGRpc2FibGVOZXR3b3JraW5nIH0gPSBwYXJhbXM7XG4gICAgaWYgKCF1c2VyS2V5Y2hhaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndXNlciBrZXljaGFpbiBpcyByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXJQdWIgPSB1c2VyS2V5Y2hhaW4ucHViO1xuXG4gICAgLy8gZGVjcnlwdCB0aGUgdXNlciBwcml2YXRlIGtleSBzbyB3ZSBjYW4gdmVyaWZ5IHRoYXQgdGhlIGNsYWltZWQgcHVibGljIGtleSBpcyBhIG1hdGNoXG4gICAgbGV0IHVzZXJQcnYgPSB1c2VyS2V5Y2hhaW4ucHJ2O1xuICAgIGlmIChfLmlzRW1wdHkodXNlclBydikpIHtcbiAgICAgIGNvbnN0IGVuY3J5cHRlZFBydiA9IHVzZXJLZXljaGFpbi5lbmNyeXB0ZWRQcnY7XG4gICAgICBpZiAoIV8uaXNFbXB0eShlbmNyeXB0ZWRQcnYpKSB7XG4gICAgICAgIC8vIGlmIHRoZSBkZWNyeXB0aW9uIGZhaWxzLCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gICAgICAgIHVzZXJQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICAgIGlucHV0OiBlbmNyeXB0ZWRQcnYsXG4gICAgICAgICAgcGFzc3dvcmQ6IHR4UGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfLmlzRW1wdHkodXNlclBydikpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICd1c2VyIHByaXZhdGUga2V5IHVuYXZhaWxhYmxlIGZvciB2ZXJpZmljYXRpb24nO1xuICAgICAgaWYgKGRpc2FibGVOZXR3b3JraW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1c2VyUHJpdmF0ZUtleSA9IGJpdGNvaW4uSEROb2RlLmZyb21CYXNlNTgodXNlclBydik7XG4gICAgICBpZiAodXNlclByaXZhdGVLZXkudG9CYXNlNTgoKSA9PT0gdXNlclByaXZhdGVLZXkubmV1dGVyZWQoKS50b0Jhc2U1OCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndXNlciBwcml2YXRlIGtleSBpcyBvbmx5IHB1YmxpYycpO1xuICAgICAgfVxuICAgICAgaWYgKHVzZXJQcml2YXRlS2V5Lm5ldXRlcmVkKCkudG9CYXNlNTgoKSAhPT0gdXNlclB1Yikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZXIgcHJpdmF0ZSBrZXkgZG9lcyBub3QgbWF0Y2ggcHVibGljIGtleScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBzaWduYXR1cmVzIHByb2R1Y2VkIGJ5IHRoZSB1c2VyIGtleSBvdmVyIHRoZSBiYWNrdXAgYW5kIGJpdGdvIGtleXMuXG4gICAqXG4gICAqIElmIHNldCwgdGhlc2Ugc2lnbmF0dXJlcyBlbnN1cmUgdGhhdCB0aGUgd2FsbGV0IGtleXMgY2Fubm90IGJlIGNoYW5nZWQgYWZ0ZXIgdGhlIHdhbGxldCBoYXMgYmVlbiBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge1ZlcmlmeUtleVNpZ25hdHVyZXNPcHRpb25zfSBwYXJhbXNcbiAgICogQHJldHVybiB7e2JhY2t1cDogYm9vbGVhbiwgYml0Z286IGJvb2xlYW59fVxuICAgKi9cbiAgcHJvdGVjdGVkIHZlcmlmeUtleVNpZ25hdHVyZShwYXJhbXM6IFZlcmlmeUtleVNpZ25hdHVyZXNPcHRpb25zKTogYm9vbGVhbiB7XG4gICAgLy8gZmlyc3QsIGxldCdzIHZlcmlmeSB0aGUgaW50ZWdyaXR5IG9mIHRoZSB1c2VyIGtleSwgd2hvc2UgcHVibGljIGtleSBpcyB1c2VkIGZvciBzdWJzZXF1ZW50IHZlcmlmaWNhdGlvbnNcbiAgICBjb25zdCB7IHVzZXJLZXljaGFpbiwga2V5Y2hhaW5Ub1ZlcmlmeSwga2V5U2lnbmF0dXJlIH0gPSBwYXJhbXM7XG4gICAgaWYgKCF1c2VyS2V5Y2hhaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndXNlciBrZXljaGFpbiBpcyByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIGlmICgha2V5Y2hhaW5Ub1ZlcmlmeSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXljaGFpbiB0byB2ZXJpZnkgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoIWtleVNpZ25hdHVyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXkgc2lnbmF0dXJlIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgLy8gdmVyaWZ5IHRoZSBzaWduYXR1cmUgYWdhaW5zdCB0aGUgdXNlciBwdWJsaWMga2V5XG4gICAgY29uc3Qgc2lnbmluZ0FkZHJlc3MgPSBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KHVzZXJLZXljaGFpbi5wdWIpLmtleVBhaXIuZ2V0QWRkcmVzcygpO1xuXG4gICAgLy8gQkctNTcwMzogdXNlIEJUQyBtYWlubmV0IHByZWZpeCBmb3IgYWxsIGtleSBzaWduYXR1cmUgb3BlcmF0aW9uc1xuICAgIC8vICh0aGlzIG1lYW5zIGRvIG5vdCBwYXNzIGEgcHJlZml4IHBhcmFtZXRlciwgYW5kIGxldCBpdCB1c2UgdGhlIGRlZmF1bHQgcHJlZml4IGluc3RlYWQpXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBiaXRjb2luTWVzc2FnZS52ZXJpZnkoa2V5Y2hhaW5Ub1ZlcmlmeS5wdWIsIHNpZ25pbmdBZGRyZXNzLCBCdWZmZXIuZnJvbShrZXlTaWduYXR1cmUsICdoZXgnKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoJ2Vycm9yIHRocm93biBmcm9tIGJpdGNvaW5tZXNzYWdlIHdoaWxlIHZlcmlmeWluZyBrZXkgc2lnbmF0dXJlJywgZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBzaWduYXR1cmVzIGFnYWluc3QgdGhlIHVzZXIgcHJpdmF0ZSBrZXkgb3ZlciB0aGUgY2hhbmdlIHdhbGxldCBleHRlbmRlZCBrZXlzXG4gICAqIEBwYXJhbSB7UGFyc2VkVHJhbnNhY3Rpb259IHR4XG4gICAqIEBwYXJhbSB7S2V5Y2hhaW59IHVzZXJLZXljaGFpblxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90ZWN0ZWQgdmVyaWZ5Q3VzdG9tQ2hhbmdlS2V5U2lnbmF0dXJlcyh0eDogUGFyc2VkVHJhbnNhY3Rpb24sIHVzZXJLZXljaGFpbjogS2V5Y2hhaW4pOiBib29sZWFuIHtcbiAgICBpZiAoIXR4LmN1c3RvbUNoYW5nZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJzZWQgdHJhbnNhY3Rpb24gaXMgbWlzc2luZyByZXF1aXJlZCBjdXN0b20gY2hhbmdlIHZlcmlmaWNhdGlvbiBkYXRhJyk7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR4LmN1c3RvbUNoYW5nZS5rZXlzKSB8fCAhQXJyYXkuaXNBcnJheSh0eC5jdXN0b21DaGFuZ2Uuc2lnbmF0dXJlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3VzdG9tQ2hhbmdlIHByb3BlcnR5IGlzIG1pc3Npbmcga2V5cyBvciBzaWduYXR1cmVzJyk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXlJbmRleCBvZiBbS2V5SW5kaWNlcy5VU0VSLCBLZXlJbmRpY2VzLkJBQ0tVUCwgS2V5SW5kaWNlcy5CSVRHT10pIHtcbiAgICAgIGNvbnN0IGtleWNoYWluVG9WZXJpZnkgPSB0eC5jdXN0b21DaGFuZ2Uua2V5c1trZXlJbmRleF07XG4gICAgICBjb25zdCBrZXlTaWduYXR1cmUgPSB0eC5jdXN0b21DaGFuZ2Uuc2lnbmF0dXJlc1trZXlJbmRleF07XG4gICAgICBpZiAoIWtleWNoYWluVG9WZXJpZnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIHJlcXVpcmVkIGN1c3RvbSBjaGFuZ2UgJHtLZXlJbmRpY2VzW2tleUluZGV4XS50b0xvd2VyQ2FzZSgpfSBrZXljaGFpbiBwdWJsaWMga2V5YCk7XG4gICAgICB9XG4gICAgICBpZiAoIWtleVNpZ25hdHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgcmVxdWlyZWQgY3VzdG9tIGNoYW5nZSAke0tleUluZGljZXNba2V5SW5kZXhdLnRvTG93ZXJDYXNlKCl9IGtleWNoYWluIHNpZ25hdHVyZWApO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnZlcmlmeUtleVNpZ25hdHVyZSh7IHVzZXJLZXljaGFpbiwga2V5Y2hhaW5Ub1ZlcmlmeSwga2V5U2lnbmF0dXJlIH0pKSB7XG4gICAgICAgIGRlYnVnKCdmYWlsZWQgdG8gdmVyaWZ5IGN1c3RvbSBjaGFuZ2UgJXMga2V5IHNpZ25hdHVyZSEnLCBLZXlJbmRpY2VzW2tleUluZGV4XS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGF0IGEgdHJhbnNhY3Rpb24gcHJlYnVpbGQgY29tcGxpZXMgd2l0aCB0aGUgb3JpZ2luYWwgaW50ZW50aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50eFBhcmFtcyBwYXJhbXMgb2JqZWN0IHBhc3NlZCB0byBzZW5kXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZCBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgc2VydmVyXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZC50eEhleCBwcmVidWlsdCB0cmFuc2FjdGlvbidzIHR4SGV4IGZvcm1cbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXQgV2FsbGV0IG9iamVjdCB0byBvYnRhaW4ga2V5cyB0byB2ZXJpZnkgYWdhaW5zdFxuICAgKiBAcGFyYW0gcGFyYW1zLnZlcmlmaWNhdGlvbiBPYmplY3Qgc3BlY2lmeWluZyBzb21lIHZlcmlmaWNhdGlvbiBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBwYXJhbXMudmVyaWZpY2F0aW9uLmRpc2FibGVOZXR3b3JraW5nIERpc2FsbG93IGZldGNoaW5nIGFueSBkYXRhIGZyb20gdGhlIGludGVybmV0IGZvciB2ZXJpZmljYXRpb24gcHVycG9zZXNcbiAgICogQHBhcmFtIHBhcmFtcy52ZXJpZmljYXRpb24ua2V5Y2hhaW5zIFBhc3Mga2V5Y2hhaW5zIG1hbnVhbGx5IHJhdGhlciB0aGFuIGZldGNoaW5nIHRoZW0gYnkgaWRcbiAgICogQHBhcmFtIHBhcmFtcy52ZXJpZmljYXRpb24uYWRkcmVzc2VzIEFkZHJlc3MgZGV0YWlscyB0byBwYXNzIGluIGZvciBvdXQtb2YtYmFuZCB2ZXJpZmljYXRpb25cbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGJvb2xlYW4+KTogQmx1ZWJpcmQ8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxib29sZWFuPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgeyB0eFBhcmFtcywgdHhQcmVidWlsZCwgd2FsbGV0LCB2ZXJpZmljYXRpb24gPSB7fSwgcmVxSWQgfSA9IHBhcmFtcztcbiAgICAgIGNvbnN0IGRpc2FibGVOZXR3b3JraW5nID0gISF2ZXJpZmljYXRpb24uZGlzYWJsZU5ldHdvcmtpbmc7XG4gICAgICBjb25zdCBwYXJzZWRUcmFuc2FjdGlvbjogUGFyc2VkVHJhbnNhY3Rpb24gPSB5aWVsZCBzZWxmLnBhcnNlVHJhbnNhY3Rpb24oeyB0eFBhcmFtcywgdHhQcmVidWlsZCwgd2FsbGV0LCB2ZXJpZmljYXRpb24sIHJlcUlkIH0pO1xuXG4gICAgICBjb25zdCBrZXljaGFpbnMgPSBwYXJzZWRUcmFuc2FjdGlvbi5rZXljaGFpbnM7XG5cbiAgICAgIC8vIHZlcmlmeSB0aGF0IHRoZSBjbGFpbWVkIHVzZXIgcHVibGljIGtleSBjb3JyZXNwb25kcyB0byB0aGUgd2FsbGV0J3MgdXNlciBwcml2YXRlIGtleVxuICAgICAgbGV0IHVzZXJQdWJsaWNLZXlWZXJpZmllZCA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gdmVyaWZ5IHRoZSB1c2VyIHB1YmxpYyBrZXkgbWF0Y2hlcyB0aGUgcHJpdmF0ZSBrZXkgLSB0aGlzIHdpbGwgdGhyb3cgaWYgdGhlcmUgaXMgbm8gbWF0Y2hcbiAgICAgICAgdXNlclB1YmxpY0tleVZlcmlmaWVkID0gc2VsZi52ZXJpZnlVc2VyUHVibGljS2V5KHsgdXNlcktleWNoYWluOiBrZXljaGFpbnMudXNlciwgZGlzYWJsZU5ldHdvcmtpbmcsIHR4UGFyYW1zIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1ZygnZmFpbGVkIHRvIHZlcmlmeSB1c2VyIHB1YmxpYyBrZXkhJywgZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGxldCdzIHZlcmlmeSB0aGVzZSBrZXljaGFpbnNcbiAgICAgIGNvbnN0IGtleVNpZ25hdHVyZXMgPSBwYXJzZWRUcmFuc2FjdGlvbi5rZXlTaWduYXR1cmVzO1xuICAgICAgaWYgKCFfLmlzRW1wdHkoa2V5U2lnbmF0dXJlcykpIHtcbiAgICAgICAgY29uc3QgdmVyaWZ5ID0gKGtleSwgcHViKSA9PiBzZWxmLnZlcmlmeUtleVNpZ25hdHVyZSh7IHVzZXJLZXljaGFpbjoga2V5Y2hhaW5zLnVzZXIsIGtleWNoYWluVG9WZXJpZnk6IGtleSwga2V5U2lnbmF0dXJlOiBwdWIgfSk7XG4gICAgICAgIGNvbnN0IGlzQmFja3VwS2V5U2lnbmF0dXJlVmFsaWQgPSB2ZXJpZnkoa2V5Y2hhaW5zLmJhY2t1cCwga2V5U2lnbmF0dXJlcy5iYWNrdXBQdWIpO1xuICAgICAgICBjb25zdCBpc0JpdGdvS2V5U2lnbmF0dXJlVmFsaWQgPSB2ZXJpZnkoa2V5Y2hhaW5zLmJpdGdvLCBrZXlTaWduYXR1cmVzLmJpdGdvUHViKTtcbiAgICAgICAgaWYgKCFpc0JhY2t1cEtleVNpZ25hdHVyZVZhbGlkIHx8ICFpc0JpdGdvS2V5U2lnbmF0dXJlVmFsaWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZGFyeSBwdWJsaWMga2V5IHNpZ25hdHVyZXMgaW52YWxpZCcpO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCdzdWNjZXNzZnVsbHkgdmVyaWZpZWQgYmFja3VwIGFuZCBiaXRnbyBrZXkgc2lnbmF0dXJlcycpO1xuICAgICAgfSBlbHNlIGlmICghZGlzYWJsZU5ldHdvcmtpbmcpIHtcbiAgICAgICAgLy8gdGhlc2Uga2V5cyB3ZXJlIG9idGFpbmVkIG9ubGluZSBhbmQgdGhlaXIgc2lnbmF0dXJlcyB3ZXJlIG5vdCB2ZXJpZmllZFxuICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGRhbmdlcm91c1xuICAgICAgICBjb25zb2xlLmxvZygndW5zaWduZWQga2V5cyBvYnRhaW5lZCBvbmxpbmUgYXJlIGJlaW5nIHVzZWQgZm9yIGFkZHJlc3MgdmVyaWZpY2F0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJzZWRUcmFuc2FjdGlvbi5uZWVkc0N1c3RvbUNoYW5nZUtleVNpZ25hdHVyZVZlcmlmaWNhdGlvbikge1xuICAgICAgICBpZiAoIWtleWNoYWlucy51c2VyIHx8ICF1c2VyUHVibGljS2V5VmVyaWZpZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHJlcXVpcmVzIHZlcmlmaWNhdGlvbiBvZiB1c2VyIHB1YmxpYyBrZXksIGJ1dCBpdCB3YXMgdW5hYmxlIHRvIGJlIHZlcmlmaWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VzdG9tQ2hhbmdlS2V5U2lnbmF0dXJlc1ZlcmlmaWVkID0gc2VsZi52ZXJpZnlDdXN0b21DaGFuZ2VLZXlTaWduYXR1cmVzKHBhcnNlZFRyYW5zYWN0aW9uLCBrZXljaGFpbnMudXNlcik7XG4gICAgICAgIGlmICghY3VzdG9tQ2hhbmdlS2V5U2lnbmF0dXJlc1ZlcmlmaWVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiByZXF1aXJlcyB2ZXJpZmljYXRpb24gb2YgY3VzdG9tIGNoYW5nZSBrZXkgc2lnbmF0dXJlcywgYnV0IHRoZXkgd2VyZSB1bmFibGUgdG8gYmUgdmVyaWZpZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zygnc3VjY2Vzc2Z1bGx5IHZlcmlmaWVkIHVzZXIgcHVibGljIGtleSBhbmQgY3VzdG9tIGNoYW5nZSBrZXkgc2lnbmF0dXJlcycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtaXNzaW5nT3V0cHV0cyA9IHBhcnNlZFRyYW5zYWN0aW9uLm1pc3NpbmdPdXRwdXRzO1xuICAgICAgaWYgKG1pc3NpbmdPdXRwdXRzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAvLyB0aGVyZSBhcmUgc29tZSBvdXRwdXRzIGluIHRoZSByZWNpcGllbnRzIGxpc3QgdGhhdCBoYXZlIG5vdCBtYWRlIGl0IGludG8gdGhlIGFjdHVhbCB0cmFuc2FjdGlvblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIG91dHB1dHMgbWlzc2luZyBpbiB0cmFuc2FjdGlvbiBwcmVidWlsZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbnRlbmRlZEV4dGVybmFsU3BlbmQgPSBwYXJzZWRUcmFuc2FjdGlvbi5leHBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQ7XG5cbiAgICAgIC8vIHRoaXMgaXMgYSBsaW1pdCB3ZSBpbXBvc2UgZm9yIHRoZSB0b3RhbCB2YWx1ZSB0aGF0IGlzIGFtZW5kZWQgdG8gdGhlIHRyYW5zYWN0aW9uIGJleW9uZCB3aGF0IHdhcyBvcmlnaW5hbGx5IGludGVuZGVkXG4gICAgICBjb25zdCBwYXlBc1lvdUdvTGltaXQgPSBpbnRlbmRlZEV4dGVybmFsU3BlbmQgKiAwLjAxNTsgLy8gMTUwIGJhc2lzIHBvaW50cyBpcyB0aGUgYWJzb2x1dGUgcGVybWl0dGVkIG1heGltdW1cblxuICAgICAgLypcbiAgICAgIFNvbWUgZXhwbGFuYXRpb24gZm9yIHdoeSB3ZSdyZSBkb2luZyB3aGF0IHdlJ3JlIGRvaW5nOlxuICAgICAgU29tZSBjdXN0b21lcnMgd2lsbCBoYXZlIGFuIG91dHB1dCB0byBCaXRHbydzIFBBWUdvIHdhbGxldCBhZGRlZCB0byB0aGVpciB0cmFuc2FjdGlvbiwgYW5kIHdlIG5lZWQgdG8gYWNjb3VudCBmb3JcbiAgICAgIGl0IGhlcmUuIFRvIHByb3RlY3Qgc29tZW9uZSB0YW1wZXJpbmcgd2l0aCB0aGUgb3V0cHV0IHRvIG1ha2UgaXQgc2VuZCBtb3JlIHRoYW4gaXQgc2hvdWxkIHRvIEJpdEdvLCB3ZSBkZWZpbmUgYVxuICAgICAgdGhyZXNob2xkIGZvciB0aGUgb3V0cHV0J3MgdmFsdWUgYWJvdmUgd2hpY2ggd2UnbGwgdGhyb3cgYW4gZXJyb3IsIGJlY2F1c2UgdGhlIHBheWdvIG91dHB1dCBzaG91bGQgbmV2ZXIgYmUgdGhhdFxuICAgICAgaGlnaC5cbiAgICAgICAqL1xuXG4gICAgICAvLyBtYWtlIHN1cmUgdGhhdCBhbGwgdGhlIGV4dHJhIGFkZHJlc3NlcyBhcmUgY2hhbmdlIGFkZHJlc3Nlc1xuICAgICAgLy8gZ2V0IGFsbCB0aGUgYWRkaXRpb25hbCBleHRlcm5hbCBvdXRwdXRzIHRoZSBzZXJ2ZXIgYWRkZWQgYW5kIGNhbGN1bGF0ZSB0aGVpciB2YWx1ZXNcbiAgICAgIGNvbnN0IG5vbkNoYW5nZUFtb3VudCA9IHBhcnNlZFRyYW5zYWN0aW9uLmltcGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudDtcblxuICAgICAgZGVidWcoJ0ludGVuZGVkIHNwZW5kIGlzICVzLCBOb24tY2hhbmdlIGFtb3VudCBpcyAlcywgcGF5Z28gbGltaXQgaXMgJXMnLCBpbnRlbmRlZEV4dGVybmFsU3BlbmQsIG5vbkNoYW5nZUFtb3VudCwgcGF5QXNZb3VHb0xpbWl0KTtcblxuICAgICAgLy8gdGhlIGFkZGl0aW9uYWwgZXh0ZXJuYWwgb3V0cHV0cyBjYW4gb25seSBiZSBCaXRHbydzIHBheS1hcy15b3UtZ28gZmVlLCBidXQgd2UgY2Fubm90IHZlcmlmeSB0aGUgd2FsbGV0IGFkZHJlc3NcbiAgICAgIGlmIChub25DaGFuZ2VBbW91bnQgPiBwYXlBc1lvdUdvTGltaXQpIHtcbiAgICAgICAgLy8gdGhlcmUgYXJlIHNvbWUgYWRkcmVzc2VzIHRoYXQgYXJlIG91dHNpZGUgdGhlIHNjb3BlIG9mIGludGVuZGVkIHJlY2lwaWVudHMgdGhhdCBhcmUgbm90IGNoYW5nZSBhZGRyZXNzZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmVidWlsZCBhdHRlbXB0cyB0byBzcGVuZCB0byB1bmludGVuZGVkIGV4dGVybmFsIHJlY2lwaWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWxsT3V0cHV0cyA9IHBhcnNlZFRyYW5zYWN0aW9uLm91dHB1dHM7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGJpdGNvaW4uVHJhbnNhY3Rpb24uZnJvbUhleCh0eFByZWJ1aWxkLnR4SGV4LCBzZWxmLm5ldHdvcmspO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25DYWNoZSA9IHt9O1xuICAgICAgY29uc3QgaW5wdXRzID0geWllbGQgQmx1ZWJpcmQubWFwKHRyYW5zYWN0aW9uLmlucywgY28oZnVuY3Rpb24gKihjdXJyZW50SW5wdXQpIHtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IChCdWZmZXIuZnJvbShjdXJyZW50SW5wdXQuaGFzaCkucmV2ZXJzZSgpIGFzIEJ1ZmZlcikudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICBjb25zdCB0eEhleCA9IF8uZ2V0KHR4UHJlYnVpbGQsIGB0eEluZm8udHhIZXhlcy4ke3RyYW5zYWN0aW9uSWR9YCk7XG4gICAgICAgIGlmICh0eEhleCkge1xuICAgICAgICAgIGNvbnN0IGxvY2FsVHggPSBiaXRjb2luLlRyYW5zYWN0aW9uLmZyb21IZXgodHhIZXgsIHNlbGYubmV0d29yayk7XG4gICAgICAgICAgaWYgKGxvY2FsVHguZ2V0SWQoKSAhPT0gdHJhbnNhY3Rpb25JZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCB0cmFuc2FjdGlvbiBoZXggZG9lcyBub3QgbWF0Y2ggaWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY3VycmVudE91dHB1dCA9IGxvY2FsVHgub3V0c1tjdXJyZW50SW5wdXQuaW5kZXhdO1xuICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBiaXRjb2luLmFkZHJlc3MuZnJvbU91dHB1dFNjcmlwdChjdXJyZW50T3V0cHV0LnNjcmlwdCwgc2VsZi5uZXR3b3JrKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50T3V0cHV0LnZhbHVlLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoIXRyYW5zYWN0aW9uQ2FjaGVbdHJhbnNhY3Rpb25JZF0pIHtcbiAgICAgICAgICBpZiAoZGlzYWJsZU5ldHdvcmtpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXR0ZW1wdGluZyB0byByZXRyaWV2ZSB0cmFuc2FjdGlvbiBkZXRhaWxzIGV4dGVybmFsbHkgd2l0aCBuZXR3b3JraW5nIGRpc2FibGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXFJZCkge1xuICAgICAgICAgICAgc2VsZi5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHJlcUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhbnNhY3Rpb25DYWNoZVt0cmFuc2FjdGlvbklkXSA9IHlpZWxkIHNlbGYuYml0Z28uZ2V0KHNlbGYudXJsKGAvcHVibGljL3R4LyR7dHJhbnNhY3Rpb25JZH1gKSkucmVzdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25EZXRhaWxzID0gdHJhbnNhY3Rpb25DYWNoZVt0cmFuc2FjdGlvbklkXTtcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uRGV0YWlscy5vdXRwdXRzW2N1cnJlbnRJbnB1dC5pbmRleF07XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcblxuICAgICAgY29uc3QgaW5wdXRBbW91bnQgPSBfLnN1bUJ5KGlucHV0cywgJ3ZhbHVlJyk7XG4gICAgICBjb25zdCBvdXRwdXRBbW91bnQgPSBfLnN1bUJ5KGFsbE91dHB1dHMsICdhbW91bnQnKTtcbiAgICAgIGNvbnN0IGZlZSA9IGlucHV0QW1vdW50IC0gb3V0cHV0QW1vdW50O1xuXG4gICAgICBpZiAoZmVlIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF0dGVtcHRpbmcgdG8gc3BlbmQgJHtvdXRwdXRBbW91bnR9IHNhdG9zaGlzLCB3aGljaCBleGNlZWRzIHRoZSBpbnB1dCBhbW91bnQgKCR7aW5wdXRBbW91bnR9IHNhdG9zaGlzKSBieSAkey1mZWV9YCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBzdXJlIGFuIGFkZHJlc3MgaXMgdmFsaWQgYW5kIHRocm93IGFuIGVycm9yIGlmIGl0J3Mgbm90LlxuICAgKiBAcGFyYW0gcGFyYW1zLmFkZHJlc3MgVGhlIGFkZHJlc3Mgc3RyaW5nIG9uIHRoZSBuZXR3b3JrXG4gICAqIEBwYXJhbSBwYXJhbXMuYWRkcmVzc1R5cGVcbiAgICogQHBhcmFtIHBhcmFtcy5rZXljaGFpbnMgS2V5Y2hhaW4gb2JqZWN0cyB3aXRoIHhwdWJzXG4gICAqIEBwYXJhbSBwYXJhbXMuY29pblNwZWNpZmljIENvaW4tc3BlY2lmaWMgZGV0YWlscyBmb3IgdGhlIGFkZHJlc3Mgc3VjaCBhcyBhIHdpdG5lc3Mgc2NyaXB0XG4gICAqIEBwYXJhbSBwYXJhbXMuY2hhaW4gRGVyaXZhdGlvbiBjaGFpblxuICAgKiBAcGFyYW0gcGFyYW1zLmluZGV4IERlcml2YXRpb24gaW5kZXhcbiAgICogQHRocm93cyB7SW52YWxpZEFkZHJlc3NFcnJvcn1cbiAgICogQHRocm93cyB7SW52YWxpZEFkZHJlc3NEZXJpdmF0aW9uUHJvcGVydHlFcnJvcn1cbiAgICogQHRocm93cyB7VW5leHBlY3RlZEFkZHJlc3NFcnJvcn1cbiAgICovXG4gIHZlcmlmeUFkZHJlc3MocGFyYW1zOiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHsgYWRkcmVzcywgYWRkcmVzc1R5cGUsIGtleWNoYWlucywgY29pblNwZWNpZmljLCBjaGFpbiwgaW5kZXggfSA9IHBhcmFtcztcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IGVycm9ycy5JbnZhbGlkQWRkcmVzc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICBpZiAoKF8uaXNVbmRlZmluZWQoY2hhaW4pICYmIF8uaXNVbmRlZmluZWQoaW5kZXgpKSB8fCAoIShfLmlzRmluaXRlKGNoYWluKSAmJiBfLmlzRmluaXRlKGluZGV4KSkpKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBZGRyZXNzRGVyaXZhdGlvblByb3BlcnR5RXJyb3IoYGFkZHJlc3MgdmFsaWRhdGlvbiBmYWlsdXJlOiBpbnZhbGlkIGNoYWluICgke2NoYWlufSkgb3IgaW5kZXggKCR7aW5kZXh9KWApO1xuICAgIH1cblxuICAgIGlmICghXy5pc09iamVjdChjb2luU3BlY2lmaWMpKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBZGRyZXNzVmVyaWZpY2F0aW9uT2JqZWN0UHJvcGVydHlFcnJvcignYWRkcmVzcyB2YWxpZGF0aW9uIGZhaWx1cmU6IGNvaW5TcGVjaWZpYyBmaWVsZCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cblxuICAgIGlmICgha2V5Y2hhaW5zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcGFyYW0ga2V5Y2hhaW5zJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZXhwZWN0ZWRBZGRyZXNzID0gdGhpcy5nZW5lcmF0ZUFkZHJlc3Moe1xuICAgICAgYWRkcmVzc1R5cGUsXG4gICAgICBrZXljaGFpbnMsXG4gICAgICB0aHJlc2hvbGQ6IDIsXG4gICAgICBjaGFpbixcbiAgICAgIGluZGV4LFxuICAgIH0pO1xuXG4gICAgaWYgKGV4cGVjdGVkQWRkcmVzcy5hZGRyZXNzICE9PSBhZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLlVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IoYGFkZHJlc3MgdmFsaWRhdGlvbiBmYWlsdXJlOiBleHBlY3RlZCAke2V4cGVjdGVkQWRkcmVzcy5hZGRyZXNzfSBidXQgZ290ICR7YWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBjb2luIHN1cHBvcnRzIGEgYmxvY2sgdGFyZ2V0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3VwcG9ydHNCbG9ja1RhcmdldCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBhIGNvaW4gc3VwcG9ydHMgd3JhcHBlZCBzZWd3aXQgb3V0cHV0c1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN1cHBvcnRzUDJzaFAyd3NoKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBhIGNvaW4gc3VwcG9ydHMgbmF0aXZlIHNlZ3dpdCBvdXRwdXRzXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3VwcG9ydHNQMndzaCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVE9ETyhCRy0xMTQ4Nyk6IFJlbW92ZSBhZGRyZXNzVHlwZSwgc2Vnd2l0LCBhbmQgYmVjaDMyIHBhcmFtcyBpbiBTREt2NlxuICAgKiBHZW5lcmF0ZSBhbiBhZGRyZXNzIGZvciBhIHdhbGxldCBiYXNlZCBvbiBhIHNldCBvZiBjb25maWd1cmF0aW9uc1xuICAgKiBAcGFyYW0gcGFyYW1zLmFkZHJlc3NUeXBlIHtzdHJpbmd9ICAgRGVwcmVjYXRlZFxuICAgKiBAcGFyYW0gcGFyYW1zLmtleWNoYWlucyAgIHtbb2JqZWN0XX0gQXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHhwdWJzXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZXNob2xkICAge251bWJlcn0gICBNaW5pbXVtIG51bWJlciBvZiBzaWduYXR1cmVzXG4gICAqIEBwYXJhbSBwYXJhbXMuY2hhaW4gICAgICAge251bWJlcn0gICBEZXJpdmF0aW9uIGNoYWluIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL0JpdEdvL3Vuc3BlbnRzL2Jsb2IvbWFzdGVyL3NyYy9jb2Rlcy50cyBmb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGNvcnJlc3BvbmRpbmcgYWRkcmVzcyB0eXBlIG9mIGEgZ2l2ZW4gY2hhaW4gY29kZSlcbiAgICogQHBhcmFtIHBhcmFtcy5pbmRleCAgICAgICB7bnVtYmVyfSAgIERlcml2YXRpb24gaW5kZXhcbiAgICogQHBhcmFtIHBhcmFtcy5zZWd3aXQgICAgICB7Ym9vbGVhbn0gIERlcHJlY2F0ZWRcbiAgICogQHBhcmFtIHBhcmFtcy5iZWNoMzIgICAgICB7Ym9vbGVhbn0gIERlcHJlY2F0ZWRcbiAgICogQHJldHVybnMge3tjaGFpbjogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBjb2luOiBudW1iZXIsIGNvaW5TcGVjaWZpYzoge291dHB1dFNjcmlwdCwgcmVkZWVtU2NyaXB0fX19XG4gICAqL1xuICBnZW5lcmF0ZUFkZHJlc3MocGFyYW1zOiBHZW5lcmF0ZUFkZHJlc3NPcHRpb25zKTogQWRkcmVzc0RldGFpbHMge1xuICAgIGNvbnN0IHsga2V5Y2hhaW5zLCB0aHJlc2hvbGQsIGNoYWluLCBpbmRleCwgc2Vnd2l0ID0gZmFsc2UsIGJlY2gzMiA9IGZhbHNlIH0gPSBwYXJhbXM7XG4gICAgbGV0IGRlcml2YXRpb25DaGFpbiA9IDA7XG4gICAgaWYgKF8uaXNOdW1iZXIoY2hhaW4pICYmIF8uaXNJbnRlZ2VyKGNoYWluKSAmJiBjaGFpbiA+IDApIHtcbiAgICAgIGRlcml2YXRpb25DaGFpbiA9IGNoYWluO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRGbGFnc1RvQWRkcmVzc1R5cGUoKTogc3RyaW5nIHtcbiAgICAgIGlmIChfLmlzQm9vbGVhbihzZWd3aXQpICYmIHNlZ3dpdCkge1xuICAgICAgICByZXR1cm4gQ29kZXMuVW5zcGVudFR5cGVUY29tYigncDJzaFAyd3NoJyk7XG4gICAgICB9IGVsc2UgaWYgKF8uaXNCb29sZWFuKGJlY2gzMikgJiYgYmVjaDMyKSB7XG4gICAgICAgIHJldHVybiBDb2Rlcy5VbnNwZW50VHlwZVRjb21iKCdwMndzaCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIENvZGVzLlVuc3BlbnRUeXBlVGNvbWIoJ3Ayc2gnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhZGRyZXNzVHlwZSA9IHBhcmFtcy5hZGRyZXNzVHlwZSB8fCBjb252ZXJ0RmxhZ3NUb0FkZHJlc3NUeXBlKCk7XG5cbiAgICBzd2l0Y2ggKGFkZHJlc3NUeXBlKSB7XG4gICAgICBjYXNlIENvZGVzLlVuc3BlbnRUeXBlVGNvbWIoJ3Ayc2gnKTpcbiAgICAgICAgaWYgKCFDb2Rlcy5pc1Ayc2goZGVyaXZhdGlvbkNoYWluKSkge1xuICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuQWRkcmVzc1R5cGVDaGFpbk1pc21hdGNoRXJyb3IoYWRkcmVzc1R5cGUsIGRlcml2YXRpb25DaGFpbik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvZGVzLlVuc3BlbnRUeXBlVGNvbWIoJ3Ayc2hQMndzaCcpOlxuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNQMnNoUDJ3c2goKSkge1xuICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuUDJzaFAyd3NoVW5zdXBwb3J0ZWRFcnJvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFDb2Rlcy5pc1Ayc2hQMndzaChkZXJpdmF0aW9uQ2hhaW4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5BZGRyZXNzVHlwZUNoYWluTWlzbWF0Y2hFcnJvcihhZGRyZXNzVHlwZSwgZGVyaXZhdGlvbkNoYWluKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29kZXMuVW5zcGVudFR5cGVUY29tYigncDJ3c2gnKTpcbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzUDJ3c2goKSkge1xuICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuUDJ3c2hVbnN1cHBvcnRlZEVycm9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUNvZGVzLmlzUDJ3c2goZGVyaXZhdGlvbkNoYWluKSkge1xuICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuQWRkcmVzc1R5cGVDaGFpbk1pc21hdGNoRXJyb3IoYWRkcmVzc1R5cGUsIGRlcml2YXRpb25DaGFpbik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLlVuc3VwcG9ydGVkQWRkcmVzc1R5cGVFcnJvcigpO1xuICAgIH1cblxuICAgIGxldCBzaWduYXR1cmVUaHJlc2hvbGQgPSAyO1xuICAgIGlmIChfLmlzSW50ZWdlcih0aHJlc2hvbGQpKSB7XG4gICAgICBzaWduYXR1cmVUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gICAgICBpZiAoc2lnbmF0dXJlVGhyZXNob2xkIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aHJlc2hvbGQgaGFzIHRvIGJlIHBvc2l0aXZlJyk7XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmF0dXJlVGhyZXNob2xkID4ga2V5Y2hhaW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RocmVzaG9sZCBjYW5ub3QgZXhjZWVkIG51bWJlciBvZiBrZXlzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGRlcml2YXRpb25JbmRleCA9IDA7XG4gICAgaWYgKF8uaXNJbnRlZ2VyKGluZGV4KSAmJiBpbmRleCA+IDApIHtcbiAgICAgIGRlcml2YXRpb25JbmRleCA9IGluZGV4O1xuICAgIH1cblxuICAgIGNvbnN0IHBhdGggPSAnbS8wLzAvJyArIGRlcml2YXRpb25DaGFpbiArICcvJyArIGRlcml2YXRpb25JbmRleDtcbiAgICBjb25zdCBoZE5vZGVzID0ga2V5Y2hhaW5zLm1hcCgoeyBwdWIgfSkgPT4gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OChwdWIpKTtcbiAgICBjb25zdCBkZXJpdmVkS2V5cyA9IGhkTm9kZXMubWFwKGhkTm9kZSA9PiBoZFBhdGgoaGROb2RlKS5kZXJpdmVLZXkocGF0aCkuZ2V0UHVibGljS2V5QnVmZmVyKCkpO1xuXG4gICAgY29uc3QgeyBvdXRwdXRTY3JpcHQsIHJlZGVlbVNjcmlwdCwgd2l0bmVzc1NjcmlwdCwgYWRkcmVzcyB9ID1cbiAgICAgIHRoaXMuY3JlYXRlTXVsdGlTaWdBZGRyZXNzKGFkZHJlc3NUeXBlLCBzaWduYXR1cmVUaHJlc2hvbGQsIGRlcml2ZWRLZXlzKTtcblxuICAgIHJldHVybiB7XG4gICAgICBhZGRyZXNzLFxuICAgICAgY2hhaW46IGRlcml2YXRpb25DaGFpbixcbiAgICAgIGluZGV4OiBkZXJpdmF0aW9uSW5kZXgsXG4gICAgICBjb2luOiB0aGlzLmdldENoYWluKCksXG4gICAgICBjb2luU3BlY2lmaWM6IHtcbiAgICAgICAgb3V0cHV0U2NyaXB0OiBvdXRwdXRTY3JpcHQudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICByZWRlZW1TY3JpcHQ6IHJlZGVlbVNjcmlwdCAmJiByZWRlZW1TY3JpcHQudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICB3aXRuZXNzU2NyaXB0OiB3aXRuZXNzU2NyaXB0ICYmIHdpdG5lc3NTY3JpcHQudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgfSxcbiAgICAgIGFkZHJlc3NUeXBlLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZCB0cmFuc2FjdGlvbiBwcmVidWlsZCBmcm9tIGJpdGdvIHNlcnZlclxuICAgKiBAcGFyYW0gcGFyYW1zLnBydiBwcml2YXRlIGtleSB0byBiZSB1c2VkIGZvciBzaWduaW5nXG4gICAqIEBwYXJhbSBwYXJhbXMuaXNMYXN0U2lnbmF0dXJlIFRydWUgaWYgYFRyYW5zYWN0aW9uQnVpbGRlci5idWlsZCgpYCBzaG91bGQgYmUgY2FsbGVkIGFuZCBub3QgYFRyYW5zYWN0aW9uQnVpbGRlci5idWlsZEluY29tcGxldGUoKWBcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj59XG4gICAqL1xuICBzaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxTaWduZWRUcmFuc2FjdGlvbj4pOiBCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxTaWduZWRUcmFuc2FjdGlvbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IHR4UHJlYnVpbGQgPSBwYXJhbXMudHhQcmVidWlsZDtcbiAgICAgIGNvbnN0IHVzZXJQcnYgPSBwYXJhbXMucHJ2O1xuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh0eFByZWJ1aWxkKSB8fCAhXy5pc09iamVjdCh0eFByZWJ1aWxkKSkge1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQodHhQcmVidWlsZCkgJiYgIV8uaXNPYmplY3QodHhQcmVidWlsZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHR4UHJlYnVpbGQgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCB0eXBlICR7dHlwZW9mIHR4UHJlYnVpbGR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHR4UHJlYnVpbGQgcGFyYW1ldGVyJyk7XG4gICAgICB9XG4gICAgICBsZXQgdHJhbnNhY3Rpb24gPSBiaXRjb2luLlRyYW5zYWN0aW9uLmZyb21IZXgodHhQcmVidWlsZC50eEhleCwgc2VsZi5uZXR3b3JrKTtcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uLmlucy5sZW5ndGggIT09IHR4UHJlYnVpbGQudHhJbmZvLnVuc3BlbnRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiB1bnNwZW50cyBhcnJheSBzaG91bGQgZXF1YWwgdG8gdGhlIG51bWJlciBvZiB0cmFuc2FjdGlvbiBpbnB1dHMnKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGlzTGFzdFNpZ25hdHVyZSA9IGZhbHNlO1xuICAgICAgaWYgKF8uaXNCb29sZWFuKHBhcmFtcy5pc0xhc3RTaWduYXR1cmUpKSB7XG4gICAgICAgIC8vIGlmIGJ1aWxkIGlzIGNhbGxlZCBpbnN0ZWFkIG9mIGJ1aWxkSW5jb21wbGV0ZSwgbm8gc2lnbmF0dXJlIHBsYWNlaG9sZGVycyBhcmUgbGVmdCBpbiB0aGUgc2lnIHNjcmlwdFxuICAgICAgICBpc0xhc3RTaWduYXR1cmUgPSBwYXJhbXMuaXNMYXN0U2lnbmF0dXJlO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh1c2VyUHJ2KSB8fCAhXy5pc1N0cmluZyh1c2VyUHJ2KSkge1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQodXNlclBydikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBydiBtdXN0IGJlIGEgc3RyaW5nLCBnb3QgdHlwZSAke3R5cGVvZiB1c2VyUHJ2fWApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwcnYgcGFyYW1ldGVyIHRvIHNpZ24gdHJhbnNhY3Rpb24nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2V5Y2hhaW4gPSBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KHVzZXJQcnYpO1xuICAgICAgY29uc3Qga2V5Y2hhaW5IZFBhdGggPSBoZFBhdGgoa2V5Y2hhaW4pO1xuICAgICAgY29uc3QgdHhiID0gYml0Y29pbi5UcmFuc2FjdGlvbkJ1aWxkZXIuZnJvbVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBzZWxmLm5ldHdvcmspO1xuICAgICAgc2VsZi5wcmVwYXJlVHJhbnNhY3Rpb25CdWlsZGVyKHR4Yik7XG5cbiAgICAgIGNvbnN0IGdldFNpZ25hdHVyZUNvbnRleHQgPSAodHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZCwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50VW5zcGVudCA9IHR4UHJlYnVpbGQudHhJbmZvLnVuc3BlbnRzW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbnB1dEluZGV4OiBpbmRleCxcbiAgICAgICAgICB1bnNwZW50OiBjdXJyZW50VW5zcGVudCxcbiAgICAgICAgICBwYXRoOiAnbS8wLzAvJyArIGN1cnJlbnRVbnNwZW50LmNoYWluICsgJy8nICsgY3VycmVudFVuc3BlbnQuaW5kZXgsXG4gICAgICAgICAgaXNQMndzaDogIWN1cnJlbnRVbnNwZW50LnJlZGVlbVNjcmlwdCxcbiAgICAgICAgICBpc0JpdEdvVGFpbnRlZFVuc3BlbnQ6IHNlbGYuaXNCaXRHb1RhaW50ZWRVbnNwZW50KGN1cnJlbnRVbnNwZW50KSxcbiAgICAgICAgICBlcnJvcjogdW5kZWZpbmVkIGFzIEVycm9yIHwgdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgY29uc3Qgc2lnbmF0dXJlSXNzdWVzOiBSZXR1cm5UeXBlPHR5cGVvZiBnZXRTaWduYXR1cmVDb250ZXh0PltdID0gW107XG4gICAgICAvLyBTaWduIGlucHV0c1xuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRyYW5zYWN0aW9uLmlucy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgZGVidWcoJ1NpZ25pbmcgaW5wdXQgJWQgb2YgJWQnLCBpbmRleCArIDEsIHRyYW5zYWN0aW9uLmlucy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmVDb250ZXh0ID0gZ2V0U2lnbmF0dXJlQ29udGV4dCh0eFByZWJ1aWxkLCBpbmRleCk7XG4gICAgICAgIGlmIChzaWduYXR1cmVDb250ZXh0LmlzQml0R29UYWludGVkVW5zcGVudCkge1xuICAgICAgICAgIGRlYnVnKFxuICAgICAgICAgICAgJ1NraXBwaW5nIGlucHV0ICVkIG9mICVkICh1bnNwZW50IGZyb20gcmVwbGF5IHByb3RlY3Rpb24gYWRkcmVzcyB3aGljaCBpcyBwbGF0Zm9ybSBzaWduZWQgb25seSknLFxuICAgICAgICAgICAgaW5kZXggKyAxLCB0cmFuc2FjdGlvbi5pbnMubGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcml2S2V5ID0ga2V5Y2hhaW5IZFBhdGguZGVyaXZlS2V5KHNpZ25hdHVyZUNvbnRleHQucGF0aCk7XG4gICAgICAgIHByaXZLZXkubmV0d29yayA9IHNlbGYubmV0d29yaztcblxuICAgICAgICBkZWJ1ZygnSW5wdXQgZGV0YWlsczogJU8nLCBzaWduYXR1cmVDb250ZXh0KTtcblxuICAgICAgICBjb25zdCBzaWdIYXNoVHlwZSA9IHNlbGYuZGVmYXVsdFNpZ0hhc2hUeXBlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzaWduYXR1cmVDb250ZXh0LmlzUDJ3c2gpIHtcbiAgICAgICAgICAgIGRlYnVnKCdTaWduaW5nIHAyd3NoIGlucHV0Jyk7XG4gICAgICAgICAgICBjb25zdCB3aXRuZXNzU2NyaXB0ID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlQ29udGV4dC51bnNwZW50LndpdG5lc3NTY3JpcHQsICdoZXgnKTtcbiAgICAgICAgICAgIGNvbnN0IHdpdG5lc3NTY3JpcHRIYXNoID0gYml0Y29pbi5jcnlwdG8uc2hhMjU2KHdpdG5lc3NTY3JpcHQpO1xuICAgICAgICAgICAgY29uc3QgcHJldk91dFNjcmlwdCA9IGJpdGNvaW4uc2NyaXB0LndpdG5lc3NTY3JpcHRIYXNoLm91dHB1dC5lbmNvZGUod2l0bmVzc1NjcmlwdEhhc2gpO1xuICAgICAgICAgICAgdHhiLnNpZ24oaW5kZXgsIHByaXZLZXksIHByZXZPdXRTY3JpcHQsIHNpZ0hhc2hUeXBlLCBzaWduYXR1cmVDb250ZXh0LnVuc3BlbnQudmFsdWUsIHdpdG5lc3NTY3JpcHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHQgPSBCdWZmZXIuZnJvbShzaWduYXR1cmVDb250ZXh0LnVuc3BlbnQucmVkZWVtU2NyaXB0LCAnaGV4Jyk7XG4gICAgICAgICAgICBjb25zdCBpc1Ayc2hQMndzaCA9ICEhc2lnbmF0dXJlQ29udGV4dC51bnNwZW50LndpdG5lc3NTY3JpcHQ7XG4gICAgICAgICAgICBpZiAoaXNQMnNoUDJ3c2gpIHtcbiAgICAgICAgICAgICAgZGVidWcoJ1NpZ25pbmcgcDJzaFAyd3NoIGlucHV0Jyk7XG4gICAgICAgICAgICAgIGNvbnN0IHdpdG5lc3NTY3JpcHQgPSBCdWZmZXIuZnJvbShzaWduYXR1cmVDb250ZXh0LnVuc3BlbnQud2l0bmVzc1NjcmlwdCwgJ2hleCcpO1xuICAgICAgICAgICAgICB0eGIuc2lnbihpbmRleCwgcHJpdktleSwgc3Vic2NyaXB0LCBzaWdIYXNoVHlwZSwgc2lnbmF0dXJlQ29udGV4dC51bnNwZW50LnZhbHVlLCB3aXRuZXNzU2NyaXB0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdTaWduaW5nIHAyc2ggaW5wdXQnKTtcbiAgICAgICAgICAgICAgdHhiLnNpZ24oaW5kZXgsIHByaXZLZXksIHN1YnNjcmlwdCwgc2lnSGFzaFR5cGUsIHNpZ25hdHVyZUNvbnRleHQudW5zcGVudC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1ZygnRmFpbGVkIHRvIHNpZ24gaW5wdXQ6JywgZSk7XG4gICAgICAgICAgc2lnbmF0dXJlQ29udGV4dC5lcnJvciA9IGU7XG4gICAgICAgICAgc2lnbmF0dXJlSXNzdWVzLnB1c2goc2lnbmF0dXJlQ29udGV4dCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ1N1Y2Nlc3NmdWxseSBzaWduZWQgaW5wdXQgJWQgb2YgJWQnLCBpbmRleCArIDEsIHRyYW5zYWN0aW9uLmlucy5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNMYXN0U2lnbmF0dXJlKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uID0gdHhiLmJ1aWxkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2FjdGlvbiA9IHR4Yi5idWlsZEluY29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IGlucHV0IHNpZ25hdHVyZXNcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0cmFuc2FjdGlvbi5pbnMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIGRlYnVnKCdWZXJpZnlpbmcgaW5wdXQgc2lnbmF0dXJlICVkIG9mICVkJywgaW5kZXggKyAxLCB0cmFuc2FjdGlvbi5pbnMubGVuZ3RoKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlQ29udGV4dCA9IGdldFNpZ25hdHVyZUNvbnRleHQodHhQcmVidWlsZCwgaW5kZXgpO1xuICAgICAgICBpZiAoc2lnbmF0dXJlQ29udGV4dC5pc0JpdEdvVGFpbnRlZFVuc3BlbnQpIHtcbiAgICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICAgICdTa2lwcGluZyBpbnB1dCBzaWduYXR1cmUgJWQgb2YgJWQgKHVuc3BlbnQgZnJvbSByZXBsYXkgcHJvdGVjdGlvbiBhZGRyZXNzIHdoaWNoIGlzIHBsYXRmb3JtIHNpZ25lZCBvbmx5KScsXG4gICAgICAgICAgICBpbmRleCArIDEsIHRyYW5zYWN0aW9uLmlucy5sZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNpZ25hdHVyZUNvbnRleHQuaXNQMndzaCkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLnNldElucHV0U2NyaXB0KGluZGV4LCBCdWZmZXIuYWxsb2MoMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNWYWxpZFNpZ25hdHVyZSA9IHNlbGYudmVyaWZ5U2lnbmF0dXJlKHRyYW5zYWN0aW9uLCBpbmRleCwgc2lnbmF0dXJlQ29udGV4dC51bnNwZW50LnZhbHVlKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkU2lnbmF0dXJlKSB7XG4gICAgICAgICAgZGVidWcoJ0ludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgICAgICAgc2lnbmF0dXJlQ29udGV4dC5lcnJvciA9IG5ldyBFcnJvcignaW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICAgICAgICBzaWduYXR1cmVJc3N1ZXMucHVzaChzaWduYXR1cmVDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2lnbmF0dXJlSXNzdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZmFpbGVkSW5kaWNlcyA9IHNpZ25hdHVyZUlzc3Vlcy5tYXAoY3VycmVudElzc3VlID0+IGN1cnJlbnRJc3N1ZS5pbnB1dEluZGV4KTtcbiAgICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcihgRmFpbGVkIHRvIHNpZ24gaW5wdXRzIGF0IGluZGljZXMgJHtmYWlsZWRJbmRpY2VzLmpvaW4oJywgJyl9YCk7XG4gICAgICAgIGVycm9yLmNvZGUgPSAnaW5wdXRfc2lnbmF0dXJlX2ZhaWx1cmUnO1xuICAgICAgICBlcnJvci5zaWduaW5nRXJyb3JzID0gc2lnbmF0dXJlSXNzdWVzO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHhIZXg6IHRyYW5zYWN0aW9uLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgfTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbHdheXMgZmFsc2UgZm9yIGNvaW5zIG90aGVyIHRoYW4gQkNIIGFuZCBUQkNILlxuICAgKiBAcGFyYW0gdW5zcGVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQml0R29UYWludGVkVW5zcGVudCh1bnNwZW50OiBVbnNwZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmeSB0aGUgdHJhbnNhY3Rpb24gYnVpbGRlciB0byBjb21wbHkgd2l0aCB0aGUgc3BlY2lmaWMgY29pbidzIHJlcXVpcmVtZW50cyBzdWNoIGFzIHZlcnNpb24gYW5kIGJyYW5jaCBpZFxuICAgKiBAcGFyYW0gdHhCdWlsZGVyXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgcHJlcGFyZVRyYW5zYWN0aW9uQnVpbGRlcih0eEJ1aWxkZXI6IGFueSk6IGFueSB7XG4gICAgcmV0dXJuIHR4QnVpbGRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgc2lnaGFzaCB0eXBlIHRvIGJlIHVzZWQgd2hlbiBzaWduaW5nIHRyYW5zYWN0aW9uc1xuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRlZmF1bHRTaWdIYXNoVHlwZSgpOiBudW1iZXIge1xuICAgIHJldHVybiBiaXRjb2luLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgdHJhbnNhY3Rpb24ncyBzaWduYXR1cmUgc2NyaXB0IHRvIG9idGFpbiBwdWJsaWMga2V5cywgc2lnbmF0dXJlcywgdGhlIHNpZyBzY3JpcHQsIGFuZCBvdGhlciBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gaW5wdXRJbmRleFxuICAgKiBAcmV0dXJucyB7IGlzU2Vnd2l0SW5wdXQ6IGJvb2xlYW4sIGlucHV0Q2xhc3NpZmljYXRpb246IHN0cmluZywgc2lnbmF0dXJlczogW0J1ZmZlcl0sIHB1YmxpY0tleXM6IFtCdWZmZXJdLCBwdWJTY3JpcHQ6IEJ1ZmZlciB9XG4gICAqL1xuICBwYXJzZVNpZ25hdHVyZVNjcmlwdCh0cmFuc2FjdGlvbjogYW55LCBpbnB1dEluZGV4OiBudW1iZXIpOiBQYXJzZWRTaWduYXR1cmVTY3JpcHQge1xuICAgIGNvbnN0IGN1cnJlbnRJbnB1dCA9IHRyYW5zYWN0aW9uLmluc1tpbnB1dEluZGV4XTtcbiAgICBjb25zdCBpc1NlZ3dpdElucHV0ID0gY3VycmVudElucHV0LndpdG5lc3MubGVuZ3RoID4gMDtcbiAgICBjb25zdCBpc05hdGl2ZVNlZ3dpdElucHV0ID0gY3VycmVudElucHV0LnNjcmlwdC5sZW5ndGggPT09IDA7XG4gICAgbGV0IGRlY29tcGlsZWRTaWdTY3JpcHQsIGlucHV0Q2xhc3NpZmljYXRpb247XG4gICAgaWYgKGlzU2Vnd2l0SW5wdXQpIHtcbiAgICAgIC8vIFRoZSBkZWNvbXBpbGVkU2lnU2NyaXB0IGlzIHRoZSBzY3JpcHQgY29udGFpbmluZyB0aGUgc2lnbmF0dXJlcywgcHVibGljIGtleXMsIGFuZCB0aGUgc2NyaXB0IHRoYXQgd2FzIGNvbW1pdHRlZFxuICAgICAgLy8gdG8gKHB1YlNjcmlwdCkuIElmIHRoaXMgaXMgYSBzZWd3aXQgaW5wdXQgdGhlIGRlY29tcGlsZWRTaWdTY3JpcHQgaXMgaW4gdGhlIHdpdG5lc3MsIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBpdFxuICAgICAgLy8gaXMgbmF0aXZlIG9yIG5vdC4gVGhlIGlucHV0Q2xhc3NpZmljYXRpb24gaXMgZGV0ZXJtaW5lZCBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCB0aGUgaW5wdXQgaXMgbmF0aXZlIHRvIGdpdmUgYW5cbiAgICAgIC8vIGFjY3VyYXRlIGNsYXNzaWZpY2F0aW9uLiBOb3RlIHRoYXQgcDJzaFAyd3NoIGlucHV0cyB3aWxsIGJlIGNsYXNzaWZpZWQgYXMgcDJzaCBhbmQgbm90IHAyd3NoLlxuICAgICAgZGVjb21waWxlZFNpZ1NjcmlwdCA9IGN1cnJlbnRJbnB1dC53aXRuZXNzO1xuICAgICAgaWYgKGlzTmF0aXZlU2Vnd2l0SW5wdXQpIHtcbiAgICAgICAgaW5wdXRDbGFzc2lmaWNhdGlvbiA9IGJpdGNvaW4uc2NyaXB0LmNsYXNzaWZ5V2l0bmVzcyhiaXRjb2luLnNjcmlwdC5jb21waWxlKGRlY29tcGlsZWRTaWdTY3JpcHQpLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0Q2xhc3NpZmljYXRpb24gPSBiaXRjb2luLnNjcmlwdC5jbGFzc2lmeUlucHV0KGN1cnJlbnRJbnB1dC5zY3JpcHQsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dENsYXNzaWZpY2F0aW9uID0gYml0Y29pbi5zY3JpcHQuY2xhc3NpZnlJbnB1dChjdXJyZW50SW5wdXQuc2NyaXB0LCB0cnVlKTtcbiAgICAgIGRlY29tcGlsZWRTaWdTY3JpcHQgPSBiaXRjb2luLnNjcmlwdC5kZWNvbXBpbGUoY3VycmVudElucHV0LnNjcmlwdCk7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0Q2xhc3NpZmljYXRpb24gPT09IGJpdGNvaW4uc2NyaXB0LnR5cGVzLlAyUEtIKSB7XG4gICAgICBjb25zdCBbc2lnbmF0dXJlLCBwdWJsaWNLZXldID0gZGVjb21waWxlZFNpZ1NjcmlwdDtcbiAgICAgIGNvbnN0IHB1YmxpY0tleXMgPSBbcHVibGljS2V5XTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZXMgPSBbc2lnbmF0dXJlXTtcbiAgICAgIGNvbnN0IHB1YlNjcmlwdCA9IGJpdGNvaW4uc2NyaXB0LnB1YktleUhhc2gub3V0cHV0LmVuY29kZShiaXRjb2luLmNyeXB0by5oYXNoMTYwKHB1YmxpY0tleSkpO1xuXG4gICAgICByZXR1cm4geyBpc1NlZ3dpdElucHV0LCBpbnB1dENsYXNzaWZpY2F0aW9uLCBzaWduYXR1cmVzLCBwdWJsaWNLZXlzLCBwdWJTY3JpcHQgfTtcbiAgICB9IGVsc2UgaWYgKGlucHV0Q2xhc3NpZmljYXRpb24gPT09IGJpdGNvaW4uc2NyaXB0LnR5cGVzLlAyU0hcbiAgICAgICAgfHwgaW5wdXRDbGFzc2lmaWNhdGlvbiA9PT0gYml0Y29pbi5zY3JpcHQudHlwZXMuUDJXU0gpIHtcbiAgICAgIC8vIE5vdGUgdGhlIGFzc3VtcHRpb24gaGVyZSB0aGF0IGlmIHdlIGhhdmUgYSBwMnNoIG9yIHAyd3NoIGlucHV0IGl0IHdpbGwgYmUgbXVsdGlzaWcgKGFwcHJvcHJpYXRlIGJlY2F1c2UgdGhlXG4gICAgICAvLyBCaXRHbyBwbGF0Zm9ybSBvbmx5IHN1cHBvcnRzIG11bHRpc2lnIHdpdGhpbiB0aGVzZSB0eXBlcyBvZiBpbnB1dHMpLiBTaWduYXR1cmVzIGFyZSBhbGwgYnV0IHRoZSBsYXN0IGVudHJ5IGluXG4gICAgICAvLyB0aGUgZGVjb21waWxlZFNpZ1NjcmlwdC4gVGhlIHJlZGVlbVNjcmlwdC93aXRuZXNzU2NyaXB0IChkZXBlbmRpbmcgb24gd2hpY2ggdHlwZSBvZiBpbnB1dCB0aGlzIGlzKSBpcyB0aGUgbGFzdFxuICAgICAgLy8gZW50cnkgaW4gdGhlIGRlY29tcGlsZWRTaWdTY3JpcHQgKGRlbm90ZWQgaGVyZSBhcyB0aGUgcHViU2NyaXB0KS4gVGhlIHB1YmxpYyBrZXlzIGFyZSB0aGUgc2Vjb25kIHRocm91Z2hcbiAgICAgIC8vIGFudGVwZW51bHRpbWF0ZSBlbnRyaWVzIGluIHRoZSBkZWNvbXBpbGVkUHViU2NyaXB0LiBTZWUgYmVsb3cgZm9yIGEgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0eXBpY2FsIDItb2YtM1xuICAgICAgLy8gbXVsdGlzaWcgc2V0dXA6XG4gICAgICAvL1xuICAgICAgLy8gZGVjb21waWxlZFNpZ1NjcmlwdCA9IDAgPHNpZzE+IDxzaWcyPiA8cHViU2NyaXB0PlxuICAgICAgLy8gZGVjb21waWxlZFB1YlNjcmlwdCA9IDIgPHB1YjE+IDxwdWIyPiA8cHViMz4gMyBPUF9DSEVDS01VTFRJU0lHXG4gICAgICBjb25zdCBzaWduYXR1cmVzID0gZGVjb21waWxlZFNpZ1NjcmlwdC5zbGljZSgwLCAtMSk7XG4gICAgICBjb25zdCBwdWJTY3JpcHQgPSBfLmxhc3Q8QnVmZmVyPihkZWNvbXBpbGVkU2lnU2NyaXB0KTtcbiAgICAgIGNvbnN0IGRlY29tcGlsZWRQdWJTY3JpcHQgPSBiaXRjb2luLnNjcmlwdC5kZWNvbXBpbGUocHViU2NyaXB0KTtcbiAgICAgIGNvbnN0IHB1YmxpY0tleXMgPSBkZWNvbXBpbGVkUHViU2NyaXB0LnNsaWNlKDEsIC0yKTtcblxuICAgICAgLy8gT3AgY29kZXMgODEgdGhyb3VnaCA5NiByZXByZXNlbnQgbnVtYmVycyAxIHRocm91Z2ggMTYgKHNlZSBodHRwczovL2VuLmJpdGNvaW4uaXQvd2lraS9TY3JpcHQjT3Bjb2RlcyksIHdoaWNoIGlzXG4gICAgICAvLyB3aHkgd2Ugc3VidHJhY3QgYnkgODAgdG8gZ2V0IHRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyAobikgYW5kIHRoZSBudW1iZXIgb2YgcHVibGljIGtleXMgKG0pIGluIGFuIG4tb2YtbSBzZXR1cC5cbiAgICAgIGNvbnN0IGxlbiA9IGRlY29tcGlsZWRQdWJTY3JpcHQubGVuZ3RoO1xuICAgICAgY29uc3QgblNpZ25hdHVyZXMgPSBkZWNvbXBpbGVkUHViU2NyaXB0WzBdIC0gODA7XG4gICAgICBjb25zdCBuUHViS2V5cyA9IGRlY29tcGlsZWRQdWJTY3JpcHRbbGVuIC0gMl0gLSA4MDtcblxuICAgICAgLy8gRHVlIHRvIGEgYnVnIGluIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBtdWx0aXNpZ25hdHVyZSBpbiB0aGUgYml0Y29pbiBwcm90b2NvbCwgYSAwIGlzIGFkZGVkIHRvIHRoZSBzaWduYXR1cmVcbiAgICAgIC8vIHNjcmlwdCwgc28gd2UgYWRkIDEgd2hlbiBhc3NlcnRpbmcgdGhlIG51bWJlciBvZiBzaWduYXR1cmVzIG1hdGNoZXMgdGhlIG51bWJlciBvZiBzaWduYXR1cmVzIGV4cGVjdGVkIGJ5IHRoZVxuICAgICAgLy8gcHViIHNjcmlwdC4gQWxzbywgbm90ZSB0aGF0IHdlIGNvbnNpZGVyIGEgc2lnbmF0dXJlIHNjcmlwdCB3aXRoIHRoZSB0aGUgc2FtZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyBhcyBwdWJsaWNcbiAgICAgIC8vIGtleXMgKCsxIGFzIG5vdGVkIGFib3ZlKSB2YWxpZCBiZWNhdXNlIHdlIHVzZSBwbGFjZWhvbGRlciBzaWduYXR1cmVzIHdoZW4gcGFyc2luZyBhIGhhbGYtc2lnbmVkIHNpZ25hdHVyZVxuICAgICAgLy8gc2NyaXB0LlxuICAgICAgaWYgKHNpZ25hdHVyZXMubGVuZ3RoICE9PSBuU2lnbmF0dXJlcyArIDEgJiYgc2lnbmF0dXJlcy5sZW5ndGggIT09IG5QdWJLZXlzICsgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7blNpZ25hdHVyZXN9IG9yICR7blB1YktleXN9IHNpZ25hdHVyZXMsIGdvdCAke3NpZ25hdHVyZXMubGVuZ3RoIC0gMX1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHB1YmxpY0tleXMubGVuZ3RoICE9PSBuUHViS2V5cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7blB1YktleXN9IHB1YmxpYyBrZXlzLCBnb3QgJHtwdWJsaWNLZXlzLmxlbmd0aH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGFzdE9wQ29kZSA9IGRlY29tcGlsZWRQdWJTY3JpcHRbbGVuIC0gMV07XG4gICAgICBpZiAobGFzdE9wQ29kZSAhPT0gYml0Y29pbi5vcGNvZGVzLk9QX0NIRUNLTVVMVElTSUcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBvcGNvZGUgIyR7Yml0Y29pbi5vcGNvZGVzLk9QX0NIRUNLTVVMVElTSUd9LCBnb3Qgb3Bjb2RlICMke2xhc3RPcENvZGV9YCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGlzU2Vnd2l0SW5wdXQsIGlucHV0Q2xhc3NpZmljYXRpb24sIHNpZ25hdHVyZXMsIHB1YmxpY0tleXMsIHB1YlNjcmlwdCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBpc1NlZ3dpdElucHV0LCBpbnB1dENsYXNzaWZpY2F0aW9uIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgaGFzaCB0byB2ZXJpZnkgdGhlIHNpZ25hdHVyZSBhZ2FpbnN0XG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbiBUcmFuc2FjdGlvbiBvYmplY3RcbiAgICogQHBhcmFtIGlucHV0SW5kZXhcbiAgICogQHBhcmFtIHB1YlNjcmlwdFxuICAgKiBAcGFyYW0gYW1vdW50IFRoZSBwcmV2aW91cyBvdXRwdXQncyBhbW91bnRcbiAgICogQHBhcmFtIGhhc2hUeXBlXG4gICAqIEBwYXJhbSBpc1NlZ3dpdElucHV0XG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgY2FsY3VsYXRlU2lnbmF0dXJlSGFzaCh0cmFuc2FjdGlvbjogYW55LCBpbnB1dEluZGV4OiBudW1iZXIsIHB1YlNjcmlwdDogQnVmZmVyLCBhbW91bnQ6IG51bWJlciwgaGFzaFR5cGU6IG51bWJlciwgaXNTZWd3aXRJbnB1dDogYm9vbGVhbik6IEJ1ZmZlciB7XG4gICAgaWYgKGlzU2Vnd2l0SW5wdXQpIHtcbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbi5oYXNoRm9yV2l0bmVzc1YwKGlucHV0SW5kZXgsIHB1YlNjcmlwdCwgYW1vdW50LCBoYXNoVHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbi5oYXNoRm9yU2lnbmF0dXJlKGlucHV0SW5kZXgsIHB1YlNjcmlwdCwgaGFzaFR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhlIHNpZ25hdHVyZSBvbiBhIChoYWxmLXNpZ25lZCkgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uIGJpdGNvaW5qcy1saWIgdHggb2JqZWN0XG4gICAqIEBwYXJhbSBpbnB1dEluZGV4IFRoZSBpbnB1dCB3aGVyZXJmb3JlIHRvIGNoZWNrIHRoZSBzaWduYXR1cmVcbiAgICogQHBhcmFtIGFtb3VudCBGb3Igc2Vnd2l0IGFuZCBCQ0gsIHRoZSBpbnB1dCBhbW91bnQgbmVlZHMgdG8gYmUga25vd24gZm9yIHNpZ25hdHVyZSB2ZXJpZmljYXRpb25cbiAgICogQHBhcmFtIHZlcmlmaWNhdGlvblNldHRpbmdzXG4gICAqIEBwYXJhbSB2ZXJpZmljYXRpb25TZXR0aW5ncy5zaWduYXR1cmVJbmRleCBUaGUgaW5kZXggb2YgdGhlIHNpZ25hdHVyZSB0byB2ZXJpZnkgKG9ubHkgaXRlcmF0ZXMgb3ZlciBub24tZW1wdHkgc2lnbmF0dXJlcylcbiAgICogQHBhcmFtIHZlcmlmaWNhdGlvblNldHRpbmdzLnB1YmxpY0tleSBUaGUgaGV4IG9mIHRoZSBwdWJsaWMga2V5IHRvIHZlcmlmeSAod2lsbCB2ZXJpZnkgYWxsIHNpZ25hdHVyZXMpXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgdmVyaWZ5U2lnbmF0dXJlKHRyYW5zYWN0aW9uOiBhbnksIGlucHV0SW5kZXg6IG51bWJlciwgYW1vdW50OiBudW1iZXIsIHZlcmlmaWNhdGlvblNldHRpbmdzOiB7XG4gICAgc2lnbmF0dXJlSW5kZXg/OiBudW1iZXI7XG4gICAgcHVibGljS2V5Pzogc3RyaW5nO1xuICB9ID0ge30pOiBib29sZWFuIHtcbiAgICBjb25zdCB7IHNpZ25hdHVyZXMsIHB1YmxpY0tleXMsIGlzU2Vnd2l0SW5wdXQsIGlucHV0Q2xhc3NpZmljYXRpb24sIHB1YlNjcmlwdCB9ID1cbiAgICAgICAgdGhpcy5wYXJzZVNpZ25hdHVyZVNjcmlwdCh0cmFuc2FjdGlvbiwgaW5wdXRJbmRleCk7XG5cbiAgICBpZiAoIVtiaXRjb2luLnNjcmlwdC50eXBlcy5QMldTSCwgYml0Y29pbi5zY3JpcHQudHlwZXMuUDJTSCwgYml0Y29pbi5zY3JpcHQudHlwZXMuUDJQS0hdLmluY2x1ZGVzKGlucHV0Q2xhc3NpZmljYXRpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFwdWJsaWNLZXlzIHx8IHB1YmxpY0tleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzU2Vnd2l0SW5wdXQgJiYgIWFtb3VudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgZmlyc3Qgbm9uLWVtcHR5IHNpZ25hdHVyZSBhbmQgdmVyaWZ5IGl0IGFnYWluc3QgYWxsIHB1YmxpYyBrZXlzXG4gICAgY29uc3Qgbm9uRW1wdHlTaWduYXR1cmVzID0gXy5maWx0ZXIoc2lnbmF0dXJlcywgcyA9PiAhXy5pc0VtcHR5KHMpKTtcblxuICAgIC8qXG4gICAgV2UgZWl0aGVyIHdhbnQgdG8gdmVyaWZ5IGFsbCBzaWduYXR1cmUvcHVia2V5IGNvbWJpbmF0aW9ucywgb3IgZG8gYW4gZXhwbGljaXQgY29tYmluYXRpb25cblxuICAgIElmIGEgc2lnbmF0dXJlIGluZGV4IGlzIHNwZWNpZmllZCwgb25seSB0aGF0IHNpZ25hdHVyZSBpcyBjaGVja2VkLiBJdCdzIHZlcmlmaWVkIGFnYWluc3QgYWxsIHB1YmxpYyBrZXlzLlxuICAgIElmIGEgc2luZ2xlIHB1YmxpYyBrZXkgaXMgZm91bmQgdG8gYmUgdmFsaWQsIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUuXG5cbiAgICBJZiBhIHB1YmxpYyBrZXkgaXMgc3BlY2lmaWVkLCB3ZSBpdGVyYXRlIG92ZXIgYWxsIHNpZ25hdHVyZXMuIElmIGEgc2luZ2xlIG9uZSBtYXRjaGVzIHRoZSBwdWJsaWMga2V5LCB0aGUgZnVuY3Rpb25cbiAgICByZXR1cm5zIHRydWUuXG5cbiAgICBJZiBuZWl0aGVyIGlzIHNwZWNpZmllZCwgYWxsIHNpZ25hdHVyZXMgYXJlIGNoZWNrZWQgYWdhaW5zdCBhbGwgcHVibGljIGtleXMuIEVhY2ggc2lnbmF0dXJlIG11c3QgaGF2ZSBpdHMgb3duIGRpc3RpbmN0XG4gICAgcHVibGljIGtleSB0aGF0IGl0IG1hdGNoZXMgZm9yIHRoZSBmdW5jdGlvbiB0byByZXR1cm4gdHJ1ZS5cbiAgICAgKi9cbiAgICBsZXQgc2lnbmF0dXJlc1RvQ2hlY2sgPSBub25FbXB0eVNpZ25hdHVyZXM7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHZlcmlmaWNhdGlvblNldHRpbmdzLnNpZ25hdHVyZUluZGV4KSkge1xuICAgICAgc2lnbmF0dXJlc1RvQ2hlY2sgPSBbbm9uRW1wdHlTaWduYXR1cmVzW3ZlcmlmaWNhdGlvblNldHRpbmdzLnNpZ25hdHVyZUluZGV4XV07XG4gICAgfVxuXG4gICAgY29uc3QgcHVibGljS2V5SGV4ID0gdmVyaWZpY2F0aW9uU2V0dGluZ3MucHVibGljS2V5O1xuICAgIGNvbnN0IG1hdGNoZWRQdWJsaWNLZXlJbmRpY2VzID0ge307XG4gICAgbGV0IGFyZUFsbFNpZ25hdHVyZXNWYWxpZCA9IHRydWU7XG5cbiAgICAvLyBnbyBvdmVyIGFsbCBzaWduYXR1cmVzXG4gICAgZm9yIChjb25zdCBzaWduYXR1cmVCdWZmZXIgb2Ygc2lnbmF0dXJlc1RvQ2hlY2spIHtcblxuICAgICAgbGV0IGlzU2lnbmF0dXJlVmFsaWQgPSBmYWxzZTtcblxuICAgICAgY29uc3QgaGFzU2lnbmF0dXJlQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyKHNpZ25hdHVyZUJ1ZmZlcikgJiYgc2lnbmF0dXJlQnVmZmVyLmxlbmd0aCA+IDA7XG4gICAgICBpZiAoaGFzU2lnbmF0dXJlQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihwdWJTY3JpcHQpICYmIHB1YlNjcmlwdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHNsaWNlIHRoZSBsYXN0IGJ5dGUgZnJvbSB0aGUgc2lnbmF0dXJlIGhhc2ggaW5wdXQgYmVjYXVzZSBpdCdzIHRoZSBoYXNoIHR5cGVcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYml0Y29pbi5FQ1NpZ25hdHVyZS5mcm9tREVSKHNpZ25hdHVyZUJ1ZmZlci5zbGljZSgwLCAtMSkpO1xuICAgICAgICBjb25zdCBoYXNoVHlwZSA9IF8ubGFzdChzaWduYXR1cmVCdWZmZXIpO1xuICAgICAgICBpZiAoIWhhc2hUeXBlKSB7XG4gICAgICAgICAgLy8gbWlzc2luZyBoYXNoVHlwZSBieXRlIC0gc2lnbmF0dXJlIGNhbm5vdCBiZSB2YWxpZGF0ZWRcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlSGFzaCA9IHRoaXMuY2FsY3VsYXRlU2lnbmF0dXJlSGFzaCh0cmFuc2FjdGlvbiwgaW5wdXRJbmRleCwgcHViU2NyaXB0LCBhbW91bnQsIGhhc2hUeXBlLCBpc1NlZ3dpdElucHV0KTtcblxuICAgICAgICBmb3IgKGxldCBwdWJsaWNLZXlJbmRleCA9IDA7IHB1YmxpY0tleUluZGV4IDwgcHVibGljS2V5cy5sZW5ndGg7IHB1YmxpY0tleUluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCBwdWJsaWNLZXlCdWZmZXIgPSBwdWJsaWNLZXlzW3B1YmxpY0tleUluZGV4XTtcbiAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQocHVibGljS2V5SGV4KSAmJiBwdWJsaWNLZXlCdWZmZXIudG9TdHJpbmcoJ2hleCcpICE9PSBwdWJsaWNLZXlIZXgpIHtcbiAgICAgICAgICAgIC8vIHdlIGFyZSBvbmx5IGxvb2tpbmcgdG8gdmVyaWZ5IG9uZSBzcGVjaWZpYyBwdWJsaWMga2V5J3Mgc2lnbmF0dXJlIChwdWJsaWNLZXlIZXgpXG4gICAgICAgICAgICAvLyB0aGlzIHBhcnRpY3VsYXIgcHVibGljIGtleSBpcyBub3QgdGhlIG9uZSB3aG9zZSBzaWduYXR1cmUgd2UncmUgdHJ5aW5nIHRvIHZlcmlmeVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1hdGNoZWRQdWJsaWNLZXlJbmRpY2VzW3B1YmxpY0tleUluZGV4XSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcHVibGljS2V5ID0gYml0Y29pbi5FQ1BhaXIuZnJvbVB1YmxpY0tleUJ1ZmZlcihwdWJsaWNLZXlCdWZmZXIpO1xuICAgICAgICAgIGlmIChwdWJsaWNLZXkudmVyaWZ5KHNpZ25hdHVyZUhhc2gsIHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgIGlzU2lnbmF0dXJlVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgbWF0Y2hlZFB1YmxpY0tleUluZGljZXNbcHVibGljS2V5SW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQocHVibGljS2V5SGV4KSAmJiBpc1NpZ25hdHVyZVZhbGlkKSB7XG4gICAgICAgIC8vIFdlIHdlcmUgdHJ5aW5nIHRvIHNlZSBpZiBhbnkgb2YgdGhlIHNpZ25hdHVyZXMgd2FzIHZhbGlkIGZvciB0aGUgZ2l2ZW4gcHVibGljIGtleS4gRXZpZGVudGx5IHllcy5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNTaWduYXR1cmVWYWxpZCAmJiBfLmlzVW5kZWZpbmVkKHB1YmxpY0tleUhleCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBhcmVBbGxTaWduYXR1cmVzVmFsaWQgPSBpc1NpZ25hdHVyZVZhbGlkICYmIGFyZUFsbFNpZ25hdHVyZXNWYWxpZDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJlQWxsU2lnbmF0dXJlc1ZhbGlkO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcG9zZSBhIHJhdyB0cmFuc2FjdGlvbiBpbnRvIHVzZWZ1bCBpbmZvcm1hdGlvbiwgc3VjaCBhcyB0aGUgdG90YWwgYW1vdW50cyxcbiAgICogY2hhbmdlIGFtb3VudHMsIGFuZCB0cmFuc2FjdGlvbiBvdXRwdXRzLlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZXhwbGFpblRyYW5zYWN0aW9uKHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4pOiBCbHVlYmlyZDxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+KGZ1bmN0aW9uICooKSB7XG4gICAgICBjb25zdCB0eEhleCA9IF8uZ2V0KHBhcmFtcywgJ3R4SGV4Jyk7XG4gICAgICBpZiAoIXR4SGV4IHx8ICFfLmlzU3RyaW5nKHR4SGV4KSB8fCAhdHhIZXgubWF0Y2goL14oW2EtZjAtOV17Mn0pKyQvaSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHRyYW5zYWN0aW9uIGhleCwgbXVzdCBiZSBhIHZhbGlkIGhleCBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHRyYW5zYWN0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHJhbnNhY3Rpb24gPSBiaXRjb2luLlRyYW5zYWN0aW9uLmZyb21IZXgodHhIZXgsIHNlbGYubmV0d29yayk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHBhcnNlIHRyYW5zYWN0aW9uIGhleCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpZCA9IHRyYW5zYWN0aW9uLmdldElkKCk7XG4gICAgICBsZXQgY2hhbmdlQWRkcmVzc2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgbGV0IHNwZW5kQW1vdW50ID0gMDtcbiAgICAgIGxldCBjaGFuZ2VBbW91bnQgPSAwO1xuICAgICAgY29uc3QgdHhJbmZvID0gXy5nZXQocGFyYW1zLCAndHhJbmZvJyk7XG4gICAgICBpZiAodHhJbmZvICYmIHR4SW5mby5jaGFuZ2VBZGRyZXNzZXMpIHtcbiAgICAgICAgY2hhbmdlQWRkcmVzc2VzID0gdHhJbmZvLmNoYW5nZUFkZHJlc3NlcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4cGxhbmF0aW9uOiBhbnkgPSB7XG4gICAgICAgIGRpc3BsYXlPcmRlcjogWydpZCcsICdvdXRwdXRBbW91bnQnLCAnY2hhbmdlQW1vdW50JywgJ291dHB1dHMnLCAnY2hhbmdlT3V0cHV0cyddLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBjaGFuZ2VPdXRwdXRzOiBbXSxcbiAgICAgIH07XG5cbiAgICAgIHRyYW5zYWN0aW9uLm91dHMuZm9yRWFjaCgoY3VycmVudE91dHB1dCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50QWRkcmVzcyA9IHNlbGYuZ2V0Q29pbkxpYnJhcnkoKS5hZGRyZXNzLmZyb21PdXRwdXRTY3JpcHQoY3VycmVudE91dHB1dC5zY3JpcHQsIHNlbGYubmV0d29yayk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBbW91bnQgPSBjdXJyZW50T3V0cHV0LnZhbHVlO1xuXG4gICAgICAgIGlmIChjaGFuZ2VBZGRyZXNzZXMuaW5kZXhPZihjdXJyZW50QWRkcmVzcykgIT09IC0xKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBjaGFuZ2VcbiAgICAgICAgICBjaGFuZ2VBbW91bnQgKz0gY3VycmVudEFtb3VudDtcbiAgICAgICAgICBleHBsYW5hdGlvbi5jaGFuZ2VPdXRwdXRzLnB1c2goe1xuICAgICAgICAgICAgYWRkcmVzczogY3VycmVudEFkZHJlc3MsXG4gICAgICAgICAgICBhbW91bnQ6IGN1cnJlbnRBbW91bnQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3BlbmRBbW91bnQgKz0gY3VycmVudEFtb3VudDtcbiAgICAgICAgZXhwbGFuYXRpb24ub3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICBhZGRyZXNzOiBjdXJyZW50QWRkcmVzcyxcbiAgICAgICAgICBhbW91bnQ6IGN1cnJlbnRBbW91bnQsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBleHBsYW5hdGlvbi5vdXRwdXRBbW91bnQgPSBzcGVuZEFtb3VudDtcbiAgICAgIGV4cGxhbmF0aW9uLmNoYW5nZUFtb3VudCA9IGNoYW5nZUFtb3VudDtcblxuICAgICAgLy8gYWRkIGZlZSBpbmZvIGlmIGF2YWlsYWJsZVxuICAgICAgaWYgKHBhcmFtcy5mZWVJbmZvKSB7XG4gICAgICAgIGV4cGxhbmF0aW9uLmRpc3BsYXlPcmRlci5wdXNoKCdmZWUnKTtcbiAgICAgICAgZXhwbGFuYXRpb24uZmVlID0gcGFyYW1zLmZlZUluZm87XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzSW50ZWdlcih0cmFuc2FjdGlvbi5sb2NrdGltZSkgJiYgdHJhbnNhY3Rpb24ubG9ja3RpbWUgPiAwKSB7XG4gICAgICAgIGV4cGxhbmF0aW9uLmxvY2t0aW1lID0gdHJhbnNhY3Rpb24ubG9ja3RpbWU7XG4gICAgICAgIGV4cGxhbmF0aW9uLmRpc3BsYXlPcmRlci5wdXNoKCdsb2NrdGltZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1bnNwZW50VmFsdWVzID0ge307XG5cbiAgICAgIC8vIGdldCBpbmZvcm1hdGlvbiBvbiB0eCBpbnB1dHNcbiAgICAgIGNvbnN0IGlucHV0U2lnbmF0dXJlcyA9IHRyYW5zYWN0aW9uLmlucy5tYXAoKGlucHV0LCBpZHgpID0+IHtcbiAgICAgICAgY29uc3QgaGFzU2lnU2NyaXB0ID0gIV8uaXNFbXB0eShpbnB1dC5zY3JpcHQpO1xuICAgICAgICBjb25zdCBoYXNXaXRuZXNzU2NyaXB0ID0gIV8uaXNFbXB0eShpbnB1dC53aXRuZXNzKTtcblxuICAgICAgICBpZiAoIWhhc1NpZ1NjcmlwdCAmJiAhaGFzV2l0bmVzc1NjcmlwdCkge1xuICAgICAgICAgIC8vIG5vIHNpZyBzY3JpcHQgb3Igd2l0bmVzcyBkYXRhIGZvciB0aGlzIGlucHV0XG4gICAgICAgICAgZGVidWcoJ25vIHNpZ25hdHVyZSBzY3JpcHQgb3Igd2l0bmVzcyBzY3JpcHQgZGF0YSBmb3IgaW5wdXQgJXMnLCBpZHgpO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBhcnNlZFNpZ1NjcmlwdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWRTaWdTY3JpcHQgPSBzZWxmLnBhcnNlU2lnbmF0dXJlU2NyaXB0KHRyYW5zYWN0aW9uLCBpZHgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1dpdG5lc3NTY3JpcHQpIHtcbiAgICAgICAgICBpZiAoIXR4SW5mbyB8fCAhdHhJbmZvLnVuc3BlbnRzKSB7XG4gICAgICAgICAgICAvLyBzZWd3aXQgdHhzIHJlcXVpcmUgaW5wdXQgdmFsdWVzLCBjYW5ub3QgdmFsaWRhdGUgc2lnbmF0dXJlc1xuICAgICAgICAgICAgZGVidWcoJ3VuYWJsZSB0byByZXRyaWV2ZSBpbnB1dCBhbW91bnRzIGZyb20gdW5zcGVudHMgLSBjYW5ub3QgdmFsaWRhdGUgc2Vnd2l0IGlucHV0IHNpZ25hdHVyZXMnKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGxhemlseSBwb3B1bGF0ZSB1bnNwZW50IHZhbHVlc1xuICAgICAgICAgIGlmIChfLmlzRW1wdHkodW5zcGVudFZhbHVlcykpIHtcbiAgICAgICAgICAgIHR4SW5mby51bnNwZW50cy5mb3JFYWNoKCh1bnNwZW50KSA9PiB7XG4gICAgICAgICAgICAgIHVuc3BlbnRWYWx1ZXNbdW5zcGVudC5pZF0gPSB1bnNwZW50LnZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9uRW1wdHlTaWduYXR1cmVzID0gcGFyc2VkU2lnU2NyaXB0LnNpZ25hdHVyZXMuZmlsdGVyKChzaWcpID0+ICFfLmlzRW1wdHkoc2lnKSk7XG4gICAgICAgIGNvbnN0IHZhbGlkU2lnbmF0dXJlcyA9IG5vbkVtcHR5U2lnbmF0dXJlcy5tYXAoKHNpZywgc2lnSW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoXy5pc0VtcHR5KHNpZykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBwYXJlbnRUeElkID0gKEJ1ZmZlci5mcm9tKGlucHV0Lmhhc2gpLnJldmVyc2UoKSBhcyBCdWZmZXIpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICBjb25zdCBpbnB1dElkID0gYCR7cGFyZW50VHhJZH06JHtpbnB1dC5pbmRleH1gO1xuICAgICAgICAgIGNvbnN0IGFtb3VudCA9IHVuc3BlbnRWYWx1ZXNbaW5wdXRJZF07XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYudmVyaWZ5U2lnbmF0dXJlKHRyYW5zYWN0aW9uLCBpZHgsIGFtb3VudCwgeyBzaWduYXR1cmVJbmRleDogc2lnSW5kZXggfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkU2lnbmF0dXJlcy5yZWR1Y2UoKHZhbGlkQ291bnQsIGlzVmFsaWQpID0+IGlzVmFsaWQgPyB2YWxpZENvdW50ICsgMSA6IHZhbGlkQ291bnQsIDApO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGxhbmF0aW9uLmlucHV0U2lnbmF0dXJlcyA9IGlucHV0U2lnbmF0dXJlcztcbiAgICAgIGV4cGxhbmF0aW9uLnNpZ25hdHVyZXMgPSBfLm1heChpbnB1dFNpZ25hdHVyZXMpO1xuICAgICAgcmV0dXJuIGV4cGxhbmF0aW9uO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbXVsdGlzaWcgYWRkcmVzcyBvZiBhIGdpdmVuIHR5cGUgZnJvbSBhIGxpc3Qgb2Yga2V5Y2hhaW5zIGFuZCBhIHNpZ25pbmcgdGhyZXNob2xkXG4gICAqIEBwYXJhbSBhZGRyZXNzVHlwZVxuICAgKiBAcGFyYW0gc2lnbmF0dXJlVGhyZXNob2xkXG4gICAqIEBwYXJhbSBrZXlzXG4gICAqL1xuICBjcmVhdGVNdWx0aVNpZ0FkZHJlc3MoYWRkcmVzc1R5cGU6IHN0cmluZywgc2lnbmF0dXJlVGhyZXNob2xkOiBudW1iZXIsIGtleXM6IEJ1ZmZlcltdKTogTXVsdGlTaWdBZGRyZXNzIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVXaXRuZXNzUHJvZ3JhbShpbnB1dFNjcmlwdCkge1xuICAgICAgY29uc3Qgd2l0bmVzc1NjcmlwdEhhc2ggPSBiaXRjb2luLmNyeXB0by5zaGEyNTYoaW5wdXRTY3JpcHQpO1xuICAgICAgcmV0dXJuIGJpdGNvaW4uc2NyaXB0LndpdG5lc3NTY3JpcHRIYXNoLm91dHB1dC5lbmNvZGUod2l0bmVzc1NjcmlwdEhhc2gpO1xuICAgIH1cblxuICAgIGNvbnN0IG11bHRpU2lnU2NyaXB0ID0gYml0Y29pbi5zY3JpcHQubXVsdGlzaWcub3V0cHV0LmVuY29kZShzaWduYXR1cmVUaHJlc2hvbGQsIGtleXMpO1xuICAgIGxldCBvdXRwdXRTY3JpcHQsIHJlZGVlbVNjcmlwdCwgd2l0bmVzc1NjcmlwdDtcbiAgICBzd2l0Y2ggKGFkZHJlc3NUeXBlKSB7XG4gICAgICBjYXNlIENvZGVzLlVuc3BlbnRUeXBlVGNvbWIoJ3Ayc2gnKTpcbiAgICAgICAgY29uc3QgbXVsdGlzaWdTY3JpcHRIYXNoID0gYml0Y29pbi5jcnlwdG8uaGFzaDE2MChtdWx0aVNpZ1NjcmlwdCk7XG4gICAgICAgIG91dHB1dFNjcmlwdCA9IGJpdGNvaW4uc2NyaXB0LnNjcmlwdEhhc2gub3V0cHV0LmVuY29kZShtdWx0aXNpZ1NjcmlwdEhhc2gpO1xuICAgICAgICByZWRlZW1TY3JpcHQgPSBtdWx0aVNpZ1NjcmlwdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvZGVzLlVuc3BlbnRUeXBlVGNvbWIoJ3Ayc2hQMndzaCcpOlxuICAgICAgICBjb25zdCB3aXRuZXNzUHJvZ3JhbSA9IGNyZWF0ZVdpdG5lc3NQcm9ncmFtKG11bHRpU2lnU2NyaXB0KTtcbiAgICAgICAgY29uc3Qgd2l0bmVzc1Byb2dyYW1IYXNoID0gYml0Y29pbi5jcnlwdG8uaGFzaDE2MCh3aXRuZXNzUHJvZ3JhbSk7XG4gICAgICAgIG91dHB1dFNjcmlwdCA9IGJpdGNvaW4uc2NyaXB0LnNjcmlwdEhhc2gub3V0cHV0LmVuY29kZSh3aXRuZXNzUHJvZ3JhbUhhc2gpO1xuICAgICAgICByZWRlZW1TY3JpcHQgPSB3aXRuZXNzUHJvZ3JhbTtcbiAgICAgICAgd2l0bmVzc1NjcmlwdCA9IG11bHRpU2lnU2NyaXB0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29kZXMuVW5zcGVudFR5cGVUY29tYigncDJ3c2gnKTpcbiAgICAgICAgb3V0cHV0U2NyaXB0ID0gY3JlYXRlV2l0bmVzc1Byb2dyYW0obXVsdGlTaWdTY3JpcHQpO1xuICAgICAgICB3aXRuZXNzU2NyaXB0ID0gbXVsdGlTaWdTY3JpcHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIGFkZHJlc3NUeXBlICR7YWRkcmVzc1R5cGV9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dFNjcmlwdCxcbiAgICAgIHJlZGVlbVNjcmlwdCxcbiAgICAgIHdpdG5lc3NTY3JpcHQsXG4gICAgICBhZGRyZXNzOiBiaXRjb2luLmFkZHJlc3MuZnJvbU91dHB1dFNjcmlwdChvdXRwdXRTY3JpcHQsIHRoaXMubmV0d29yayksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gc2NyaXB0SGFzaFNjcmlwdFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgLy8gVE9ETyhCRy0xMTYzOCk6IHJlbW92ZSBpbiBuZXh0IFNESyBtYWpvciB2ZXJzaW9uIHJlbGVhc2VcbiAgY2FsY3VsYXRlUmVjb3ZlcnlBZGRyZXNzKHNjcmlwdEhhc2hTY3JpcHQ6IEJ1ZmZlcikge1xuICAgIHJldHVybiB0aGlzLmdldENvaW5MaWJyYXJ5KCkuYWRkcmVzcy5mcm9tT3V0cHV0U2NyaXB0KHNjcmlwdEhhc2hTY3JpcHQsIHRoaXMubmV0d29yayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgc3RhdGljIGZlZSByYXRlIHdoaWNoIGlzIHVzZWQgaW4gcmVjb3Zlcnkgc2l0dWF0aW9uc1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0UmVjb3ZlcnlGZWVQZXJCeXRlcygpOiBCbHVlYmlyZDxudW1iZXI+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSgxMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHVybCB3aGljaCBjYW4gYmUgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgcmVjb3ZlcnkgZmVlIHJhdGVzXG4gICAqL1xuICBnZXRSZWNvdmVyeUZlZVJlY29tbWVuZGF0aW9uQXBpQmFzZVVybCgpOiBCbHVlYmlyZDxzdHJpbmc+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVqZWN0KG5ldyBFcnJvcignQWJ0cmFjdFV0eG9Db2luIG1ldGhvZCBub3QgaW1wbGVtZW50ZWQnKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IG1hcmtldCBwcmljZSBmcm9tIGEgdGhpcmQgcGFydHkgdG8gYmUgdXNlZCBmb3IgcmVjb3ZlcnlcbiAgICovXG4gIGdldFJlY292ZXJ5TWFya2V0UHJpY2UoKTogQmx1ZWJpcmQ8c3RyaW5nPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPHN0cmluZz4oZnVuY3Rpb24gKmdldFJlY292ZXJ5TWFya2V0UHJpY2UoKSB7XG4gICAgICBjb25zdCBmYW1pbHlOYW1lc1RvQ29pbkdlY2tvSWRzID0gbmV3IE1hcCgpXG4gICAgICAgIC5zZXQoJ0JUQycsICdiaXRjb2luJylcbiAgICAgICAgLnNldCgnTFRDJywgJ2xpdGVjb2luJylcbiAgICAgICAgLnNldCgnQkNIJywgJ2JpdGNvaW4tY2FzaCcpXG4gICAgICAgIC5zZXQoJ1pFQycsICd6Y2FzaCcpXG4gICAgICAgIC5zZXQoJ0RBU0gnLCAnZGFzaCcpXG4gICAgICAgIC5zZXQoJ0JTVicsICdiaXRjb2luLXN2Jyk7XG4gICAgICBjb25zdCBjb2luR2Vja29JZCA9IGZhbWlseU5hbWVzVG9Db2luR2Vja29JZHMuZ2V0KHNlbGYuZ2V0RmFtaWx5KCkudG9VcHBlckNhc2UoKSk7XG4gICAgICBpZiAoIWNvaW5HZWNrb0lkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgbm8gQ29pbkdlY2tvIGlkIGZvciBmYW1pbHkgbmFtZSAke3NlbGYuZ2V0RmFtaWx5KCkudG9VcHBlckNhc2UoKX0uYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb2luR2Vja29VcmwgPSBjb25maWcuY29pbkdlY2tvQmFzZVVybCArIGBzaW1wbGUvcHJpY2U/aWRzPSR7Y29pbkdlY2tvSWR9JnZzX2N1cnJlbmNpZXM9VVNEYDtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgcmVxdWVzdC5nZXQoY29pbkdlY2tvVXJsKS5yZXRyeSgyKS5yZXN1bHQoKTtcblxuICAgICAgLy8gQW4gZXhhbXBsZSBvZiByZXNwb25zZVxuICAgICAgLy8ge1xuICAgICAgLy8gICBcImV0aGVyZXVtXCI6IHtcbiAgICAgIC8vICAgICBcInVzZFwiOiAyMjAuNjRcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfVxuICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byByZWFjaCBDb2luIEdlY2tvIEFQSSBmb3IgcHJpY2UgZGF0YScpO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXNwb25zZVtjb2luR2Vja29JZF1bJ3VzZCddIHx8IHR5cGVvZiByZXNwb25zZVtjb2luR2Vja29JZF1bJ3VzZCddICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UgZnJvbSBDb2luIEdlY2tvIEFQSSBmb3IgcHJpY2UgZGF0YScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2VbY29pbkdlY2tvSWRdWyd1c2QnXTtcbiAgICB9KS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgcmVjb3ZlcigpXG4gICAqIFRoaXMgdHJhbnNmb3JtcyB0aGUgdHhJbmZvIGZyb20gcmVjb3ZlciBpbnRvIHRoZSBmb3JtYXQgdGhhdCBvZmZsaW5lLXNpZ25pbmctdG9vbCBleHBlY3RzXG4gICAqIEBwYXJhbSB0eEluZm9cbiAgICogQHBhcmFtIHR4SGV4XG4gICAqIEByZXR1cm5zIHt7dHhIZXg6ICosIHR4SW5mbzoge3Vuc3BlbnRzOiAqfSwgZmVlSW5mbzoge30sIGNvaW46IHZvaWR9fVxuICAgKi9cbiAgZm9ybWF0Rm9yT2ZmbGluZVZhdWx0KHR4SW5mbzogT2ZmbGluZVZhdWx0VHhJbmZvLCB0eEhleDogc3RyaW5nKTogRm9ybWF0dGVkT2ZmbGluZVZhdWx0VHhJbmZvIHtcbiAgICBjb25zdCByZXNwb25zZTogRm9ybWF0dGVkT2ZmbGluZVZhdWx0VHhJbmZvID0ge1xuICAgICAgdHhIZXgsXG4gICAgICB0eEluZm86IHtcbiAgICAgICAgdW5zcGVudHM6IHR4SW5mby5pbnB1dHMsXG4gICAgICB9LFxuICAgICAgZmVlSW5mbzoge30sXG4gICAgICBjb2luOiB0aGlzLmdldENoYWluKCksXG4gICAgfTtcbiAgICBfLm1hcChyZXNwb25zZS50eEluZm8udW5zcGVudHMsIGZ1bmN0aW9uKHVuc3BlbnQpIHtcbiAgICAgIGNvbnN0IHBhdGhBcnJheSA9IHVuc3BlbnQuY2hhaW5QYXRoLnNwbGl0KCcvJyk7XG4gICAgICAvLyBOb3RlIHRoaXMgY29kZSB3b3JrcyBiZWNhdXNlIHdlIGFzc3VtZSBvdXIgY2hhaW5QYXRoIGlzIG0vMC8wL2NoYWluL2luZGV4IC0gdGhpcyB3aWxsIGJlIGluY29ycmVjdCBmb3IgY3VzdG9tIGRlcml2YXRpb24gc2NoZW1lc1xuICAgICAgdW5zcGVudC5pbmRleCA9IHBhdGhBcnJheVs0XTtcbiAgICAgIHVuc3BlbnQuY2hhaW4gPSBwYXRoQXJyYXlbM107XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldEFkZHJlc3NJbmZvRnJvbUV4cGxvcmVyKGFkZHJlc3M6IHN0cmluZywgYXBpS2V5Pzogc3RyaW5nKTogQmx1ZWJpcmQ8QWRkcmVzc0luZm8+O1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0VW5zcGVudEluZm9Gcm9tRXhwbG9yZXIoYWRkcmVzczogc3RyaW5nLCBhcGlLZXk/OiBzdHJpbmcpOiBCbHVlYmlyZDxVbnNwZW50SW5mb1tdPjtcblxuICAvKipcbiAgICogRGVyaXZlIGNoaWxkIGtleXMgYXQgc3BlY2lmaWMgaW5kZXgsIGZyb20gcHJvdmlkZWQgcGFyZW50IGtleXNcbiAgICogQHBhcmFtIHtiaXRjb2luLkhETm9kZVtdfSBrZXlBcnJheVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHJldHVybnMge2JpdGNvaW4uSEROb2RlW119XG4gICAqL1xuICBkZXJpdmVLZXlzKGtleUFycmF5OiBiaXRjb2luLkhETm9kZVtdLCBpbmRleDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIGtleUFycmF5Lm1hcCgoaykgPT4gay5kZXJpdmUoaW5kZXgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBmdW5kcyByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRob3V0IEJpdEdvXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSB1c2VyS2V5OiBbZW5jcnlwdGVkXSB4cHJ2LCBvciB4cHViXG4gICAqIC0gYmFja3VwS2V5OiBbZW5jcnlwdGVkXSB4cHJ2LCBvciB4cHViIGlmIHRoZSB4cHJ2IGlzIGhlbGQgYnkgYSBLUlMgcHJvdmlkZXJcbiAgICogLSB3YWxsZXRQYXNzcGhyYXNlOiBuZWNlc3NhcnkgaWYgb25lIG9mIHRoZSB4cHJ2cyBpcyBlbmNyeXB0ZWRcbiAgICogLSBiaXRnb0tleTogeHB1YlxuICAgKiAtIGtyc1Byb3ZpZGVyOiBuZWNlc3NhcnkgaWYgYmFja3VwIGtleSBpcyBoZWxkIGJ5IEtSU1xuICAgKiAtIHJlY292ZXJ5RGVzdGluYXRpb246IHRhcmdldCBhZGRyZXNzIHRvIHNlbmQgcmVjb3ZlcmVkIGZ1bmRzIHRvXG4gICAqIC0gc2NhbjogdGhlIGFtb3VudCBvZiBjb25zZWN1dGl2ZSBhZGRyZXNzZXMgd2l0aG91dCB1bnNwZW50cyB0byBzY2FuIHRocm91Z2ggYmVmb3JlIHN0b3BwaW5nXG4gICAqIC0gaWdub3JlQWRkcmVzc1R5cGVzOiAob3B0aW9uYWwpIGFycmF5IG9mIEFkZHJlc3NUeXBlcyB0byBpZ25vcmUsIHRoZXNlIGFyZSBzdHJpbmdzIGRlZmluZWQgaW4gQ29kZXMuVW5zcGVudFR5cGVUY29tYlxuICAgKiAgICAgICAgZm9yIGV4YW1wbGU6IFsncDJzaFAyd3NoJywgJ3Ayd3NoJ10gd2lsbCBwcmV2ZW50IGNvZGUgZnJvbSBjaGVja2luZyBmb3Igd3JhcHBlZC1zZWd3aXQgYW5kIG5hdGl2ZS1zZWd3aXQgY2hhaW5zIG9uIHRoZSBwdWJsaWMgYmxvY2sgZXhwbG9yZXJzXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcmVjb3ZlcihwYXJhbXM6IFJlY292ZXJQYXJhbXMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKnJlY292ZXIoKSB7XG4gICAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09SEVMUEVSIEZVTkNUSU9OUz09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgIGZ1bmN0aW9uIHF1ZXJ5QmxvY2tjaGFpblVuc3BlbnRzUGF0aChrZXlBcnJheTogYml0Y29pbi5IRE5vZGVbXSwgYmFzZVBhdGg6IHN0cmluZywgYWRkcmVzc2VzQnlJZCkge1xuICAgICAgICByZXR1cm4gY28oZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICBjb25zdCBNQVhfU0VRVUVOVElBTF9BRERSRVNTRVNfV0lUSE9VVF9UWFMgPSBwYXJhbXMuc2NhbiB8fCAyMDtcbiAgICAgICAgICBsZXQgbnVtU2VxdWVudGlhbEFkZHJlc3Nlc1dpdGhvdXRUeHMgPSAwO1xuXG4gICAgICAgICAgLy8gZ2V0IHVuc3BlbnRzIGZvciB0aGVzZSBhZGRyZXNzZXNcbiAgICAgICAgICBjb25zdCBnYXRoZXJVbnNwZW50cyA9IGNvKGZ1bmN0aW9uKiBjb0dhdGhlclVuc3BlbnRzKGFkZHJJbmRleCkge1xuICAgICAgICAgICAgY29uc3QgZGVyaXZlZEtleXMgPSBzZWxmLmRlcml2ZUtleXMoa2V5QXJyYXksIGFkZHJJbmRleCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNoYWluID0gTnVtYmVyKGJhc2VQYXRoLnNwbGl0KCcvJykucG9wKCkpOyAvLyBleHRyYWN0cyB0aGUgY2hhaW4gZnJvbSB0aGUgYmFzZVBhdGhcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBkZXJpdmVkS2V5cy5tYXAoayA9PiBrLmdldFB1YmxpY0tleUJ1ZmZlcigpKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3M6IGFueSA9IHNlbGYuY3JlYXRlTXVsdGlTaWdBZGRyZXNzKENvZGVzLnR5cGVGb3JDb2RlKGNoYWluKSwgMiwga2V5cyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFkZHJJbmZvOiBBZGRyZXNzSW5mbyA9IHlpZWxkIHNlbGYuZ2V0QWRkcmVzc0luZm9Gcm9tRXhwbG9yZXIoYWRkcmVzcy5hZGRyZXNzLCBwYXJhbXMuYXBpS2V5KTtcbiAgICAgICAgICAgIC8vIHdlIHVzZSB0eENvdW50IGhlcmUgYmVjYXVzZSBpdCBpbXBsaWVzIHVzYWdlIC0gaGF2aW5nIHR4J2VzIG1lYW5zIHRoZSBhZGRyIHdhcyBnZW5lcmF0ZWQgYW5kIHVzZWRcbiAgICAgICAgICAgIGlmIChhZGRySW5mby50eENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIG51bVNlcXVlbnRpYWxBZGRyZXNzZXNXaXRob3V0VHhzKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBudW1TZXF1ZW50aWFsQWRkcmVzc2VzV2l0aG91dFR4cyA9IDA7XG5cbiAgICAgICAgICAgICAgaWYgKGFkZHJJbmZvLnRvdGFsQmFsYW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgYW4gYWRkcmVzcyB3aXRoIGJhbGFuY2U6ICR7YWRkcmVzcy5hZGRyZXNzfSB3aXRoIGJhbGFuY2UgJHthZGRySW5mby50b3RhbEJhbGFuY2V9YClcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFkZHJlc3MgaGFzIGEgYmFsYW5jZS5cbiAgICAgICAgICAgICAgICBhZGRyZXNzLmNoYWluUGF0aCA9IGJhc2VQYXRoICsgJy8nICsgYWRkckluZGV4O1xuICAgICAgICAgICAgICAgIGFkZHJlc3MudXNlcktleSA9IGRlcml2ZWRLZXlzWzBdO1xuICAgICAgICAgICAgICAgIGFkZHJlc3MuYmFja3VwS2V5ID0gZGVyaXZlZEtleXNbMV07XG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzQnlJZFthZGRyZXNzLmFkZHJlc3NdID0gYWRkcmVzcztcblxuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBmaW5kIHVuc3BlbnRzIG9uIGl0LlxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NVbnNwZW50czogVW5zcGVudEluZm9bXSA9IHlpZWxkIHNlbGYuZ2V0VW5zcGVudEluZm9Gcm9tRXhwbG9yZXIoYWRkcmVzcy5hZGRyZXNzLCBwYXJhbXMuYXBpS2V5KTtcblxuICAgICAgICAgICAgICAgIGFkZHJlc3NVbnNwZW50cy5mb3JFYWNoKGZ1bmN0aW9uIGFkZEFkZHJlc3NUb1Vuc3BlbnQodW5zcGVudCkge1xuICAgICAgICAgICAgICAgICAgdW5zcGVudC5hZGRyZXNzID0gYWRkcmVzcy5hZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgd2FsbGV0VW5zcGVudHMucHVzaCh1bnNwZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobnVtU2VxdWVudGlhbEFkZHJlc3Nlc1dpdGhvdXRUeHMgPj0gTUFYX1NFUVVFTlRJQUxfQUREUkVTU0VTX1dJVEhPVVRfVFhTKSB7XG4gICAgICAgICAgICAgIC8vIHN0b3Agc2VhcmNoaW5nIGZvciBhZGRyZXNzZXMgd2l0aCB1bnNwZW50cyBpbiB0aGVtLCB3ZSd2ZSBmb3VuZCAke01BWF9TRVFVRU5USUFMX0FERFJFU1NFU19XSVRIT1VUX1RYU30gaW4gYSByb3cgd2l0aCBub25lXG4gICAgICAgICAgICAgIC8vIHdlIGFyZSBkb25lXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdhdGhlclVuc3BlbnRzKGFkZHJJbmRleCArIDEpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3Qgd2FsbGV0VW5zcGVudHM6IFVuc3BlbnRJbmZvW10gPSBbXTtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgcG9wdWxhdGUgd2FsbGV0QWRkcmVzc2VzXG4gICAgICAgICAgeWllbGQgZ2F0aGVyVW5zcGVudHMoMCk7XG5cbiAgICAgICAgICBpZiAod2FsbGV0VW5zcGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBDb3VsZG4ndCBmaW5kIGFueSBhZGRyZXNzZXMgd2l0aCBmdW5kc1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB3YWxsZXRVbnNwZW50cztcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PUxPR0lDPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnVzZXJLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB1c2VyS2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5iYWNrdXBLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBiYWNrdXBLZXknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pIHx8ICFzZWxmLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVjb3ZlcnlEZXN0aW5hdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLnNjYW4pICYmICghXy5pc0ludGVnZXIocGFyYW1zLnNjYW4pIHx8IHBhcmFtcy5zY2FuIDwgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY2FuIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzS3JzUmVjb3ZlcnkgPSBwYXJhbXMuYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSAmJiAhcGFyYW1zLnVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpO1xuICAgICAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gcGFyYW1zLmJhY2t1cEtleS5zdGFydHNXaXRoKCd4cHViJykgJiYgcGFyYW1zLnVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpO1xuICAgICAgY29uc3Qga3JzUHJvdmlkZXIgPSBjb25maWcua3JzUHJvdmlkZXJzW3BhcmFtcy5rcnNQcm92aWRlcl07XG5cbiAgICAgIGlmIChpc0tyc1JlY292ZXJ5ICYmIF8uaXNVbmRlZmluZWQoa3JzUHJvdmlkZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkgcmVjb3Zlcnkgc2VydmljZSBwcm92aWRlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNLcnNSZWNvdmVyeSAmJiAhKGtyc1Byb3ZpZGVyLnN1cHBvcnRlZENvaW5zLmluY2x1ZGVzKHNlbGYuZ2V0RmFtaWx5KCkpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwZWNpZmllZCBrZXkgcmVjb3Zlcnkgc2VydmljZSBkb2VzIG5vdCBzdXBwb3J0IHJlY292ZXJpZXMgZm9yIHRoaXMgY29pbicpO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayB3aGV0aGVyIGtleSBtYXRlcmlhbCBhbmQgcGFzc3dvcmQgYXV0aGVudGljYXRlIHRoZSB1c2VycyBhbmQgcmV0dXJuIHBhcmVudCBrZXlzIG9mIGFsbCB0aHJlZSBrZXlzIG9mIHRoZSB3YWxsZXRcbiAgICAgIGNvbnN0IGtleXMgPSB5aWVsZCBzZWxmLmluaXRpYXRlUmVjb3ZlcnkocGFyYW1zKTtcblxuICAgICAgY29uc3QgW3VzZXJLZXksIGJhY2t1cEtleSwgYml0Z29LZXldID0ga2V5cztcbiAgICAgIGxldCBkZXJpdmVkVXNlcktleTtcbiAgICAgIGxldCBiYXNlS2V5UGF0aDtcbiAgICAgIGlmIChwYXJhbXMudXNlcktleVBhdGgpIHtcbiAgICAgICAgZGVyaXZlZFVzZXJLZXkgPSBkZXJpdmVLZXlCeVBhdGgodXNlcktleSwgcGFyYW1zLnVzZXJLZXlQYXRoKTtcbiAgICAgICAgY29uc3QgdHdvS2V5cyA9IHNlbGYuZGVyaXZlS2V5cyhzZWxmLmRlcml2ZUtleXMoW2JhY2t1cEtleSwgYml0Z29LZXldLCAwKSwgMCk7XG4gICAgICAgIGJhc2VLZXlQYXRoID0gW2Rlcml2ZWRVc2VyS2V5LCAuLi50d29LZXlzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VLZXlQYXRoID0gc2VsZi5kZXJpdmVLZXlzKHNlbGYuZGVyaXZlS2V5cyhrZXlzLCAwKSwgMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHF1ZXJpZXM6IGFueVtdID0gW107XG4gICAgICBjb25zdCBhZGRyZXNzZXNCeUlkID0ge307XG5cbiAgICAgIF8uZm9yRWFjaChPYmplY3Qua2V5cyhDb2Rlcy5VbnNwZW50VHlwZVRjb21iLm1ldGEubWFwKSwgZnVuY3Rpb24oYWRkcmVzc1R5cGUpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IGlnbm9yaW5nIHRoZSBhZGRyZXNzIHR5cGUsIHdlIGRlcml2ZSB0aGUgcHVibGljIGtleSBhbmQgY29uc3RydWN0IHRoZSBxdWVyeSBmb3IgdGhlIGV4dGVybmFsIGFuZFxuICAgICAgICAvLyBpbnRlcm5hbCBpbmRpY2VzXG4gICAgICAgIGlmICghXy5pbmNsdWRlcyhwYXJhbXMuaWdub3JlQWRkcmVzc1R5cGVzLCBhZGRyZXNzVHlwZSkpIHtcbiAgICAgICAgICBpZiAoYWRkcmVzc1R5cGUgPT09IENvZGVzLlVuc3BlbnRUeXBlVGNvbWIoJ3Ayc2hQMndzaCcpICYmICFzZWxmLnN1cHBvcnRzUDJzaFAyd3NoKCkpIHtcbiAgICAgICAgICAgIC8vIFAyc2hQMndzaCBpcyBub3Qgc3VwcG9ydGVkLiBTa2lwLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhZGRyZXNzVHlwZSA9PT0gQ29kZXMuVW5zcGVudFR5cGVUY29tYigncDJ3c2gnKSAmJiAhc2VsZi5zdXBwb3J0c1Ayd3NoKCkpIHtcbiAgICAgICAgICAgIC8vIFAyd3NoIGlzIG5vdCBzdXBwb3J0ZWQuIFNraXAuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGNvZGVzO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb2RlcyA9IENvZGVzLmZvclR5cGUoQ29kZXMuVW5zcGVudFR5cGVUY29tYihhZGRyZXNzVHlwZSkgYXMgYW55KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBUaGUgdW5zcGVudCB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYml0Z28gc28gYXR0ZW1wdGluZyB0byBnZXQgaXRzIGNoYWluIGNvZGVzIHRocm93cy4gQ2F0Y2ggdGhhdCBlcnJvclxuICAgICAgICAgICAgLy8gYW5kIGNvbnRpbnVlLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBleHRlcm5hbENoYWluQ29kZSA9IGNvZGVzLmV4dGVybmFsO1xuICAgICAgICAgIGNvbnN0IGludGVybmFsQ2hhaW5Db2RlID0gY29kZXMuaW50ZXJuYWw7XG4gICAgICAgICAgY29uc3QgZXh0ZXJuYWxLZXkgPSBzZWxmLmRlcml2ZUtleXMoYmFzZUtleVBhdGgsIGV4dGVybmFsQ2hhaW5Db2RlKTtcbiAgICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IHNlbGYuZGVyaXZlS2V5cyhiYXNlS2V5UGF0aCwgaW50ZXJuYWxDaGFpbkNvZGUpO1xuICAgICAgICAgIHF1ZXJpZXMucHVzaChxdWVyeUJsb2NrY2hhaW5VbnNwZW50c1BhdGgoZXh0ZXJuYWxLZXksICcvMC8wLycgKyBleHRlcm5hbENoYWluQ29kZSwgYWRkcmVzc2VzQnlJZCkpO1xuICAgICAgICAgIHF1ZXJpZXMucHVzaChxdWVyeUJsb2NrY2hhaW5VbnNwZW50c1BhdGgoaW50ZXJuYWxLZXksICcvMC8wLycgKyBpbnRlcm5hbENoYWluQ29kZSwgYWRkcmVzc2VzQnlJZCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gRXhlY3V0ZSB0aGUgcXVlcmllcyBhbmQgZ2F0aGVyIHRoZSB1bnNwZW50c1xuICAgICAgY29uc3QgcXVlcnlSZXNwb25zZXMgPSB5aWVsZCBQcm9taXNlLmFsbChxdWVyaWVzKTtcbiAgICAgIGNvbnN0IHVuc3BlbnRzOiBhbnlbXSA9IF8uZmxhdHRlbihxdWVyeVJlc3BvbnNlcyk7IC8vIHRoaXMgZmxhdHRlbnMgdGhlIGFycmF5ICh0dXJucyBhbiBhcnJheSBvZiBhcnJheXMgaW50byBqdXN0IG9uZSBhcnJheSlcbiAgICAgIGNvbnN0IHRvdGFsSW5wdXRBbW91bnQgPSBfLnN1bUJ5KHVuc3BlbnRzLCAnYW1vdW50Jyk7XG4gICAgICBpZiAodG90YWxJbnB1dEFtb3VudCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuRXJyb3JOb0lucHV0VG9SZWNvdmVyKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJ1aWxkIHRoZSB0cmFuc2FjdGlvblxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25CdWlsZGVyID0gbmV3IGJpdGNvaW4uVHJhbnNhY3Rpb25CdWlsZGVyKHNlbGYubmV0d29yayk7XG4gICAgICBzZWxmLnByZXBhcmVUcmFuc2FjdGlvbkJ1aWxkZXIodHJhbnNhY3Rpb25CdWlsZGVyKTtcbiAgICAgIGNvbnN0IHR4SW5mbzogYW55ID0ge307XG5cbiAgICAgIGNvbnN0IGZlZVBlckJ5dGUgPSB5aWVsZCBzZWxmLmdldFJlY292ZXJ5RmVlUGVyQnl0ZXMoKTtcblxuICAgICAgLy8gS1JTIHJlY292ZXJ5IHRyYW5zYWN0aW9ucyBoYXZlIGEgMm5kIG91dHB1dCB0byBwYXkgdGhlIHJlY292ZXJ5IGZlZSwgbGlrZSBwYXlnbyBmZWVzLiBVc2UgcDJ3c2ggb3V0cHV0cyBiZWNhdXNlXG4gICAgICAvLyB0aGV5IGFyZSB0aGUgbGFyZ2VzdCBvdXRwdXRzIGFuZCB0aHVzIHRoZSBtb3N0IGNvbnNlcnZhdGl2ZSBlc3RpbWF0ZSB0byB1c2UgaW4gY2FsY3VsYXRpbmcgZmVlcy4gQWxzbyB1c2VcbiAgICAgIC8vIHNlZ3dpdCBvdmVyaGVhZCBzaXplIGFuZCBwMnNoIGlucHV0cyBmb3IgdGhlIHNhbWUgcmVhc29uLlxuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IChpc0tyc1JlY292ZXJ5ID8gMiA6IDEpICogVmlydHVhbFNpemVzLnR4UDJ3c2hPdXRwdXRTaXplO1xuICAgICAgY29uc3QgYXBwcm94aW1hdGVTaXplID1cbiAgICAgICAgVmlydHVhbFNpemVzLnR4U2VnT3ZlcmhlYWRWU2l6ZSArIG91dHB1dFNpemUgKyAoVmlydHVhbFNpemVzLnR4UDJzaElucHV0U2l6ZSAqIHVuc3BlbnRzLmxlbmd0aCk7XG4gICAgICBjb25zdCBhcHByb3hpbWF0ZUZlZSA9IGFwcHJveGltYXRlU2l6ZSAqIGZlZVBlckJ5dGU7XG5cbiAgICAgIC8vIENvbnN0cnVjdCBhIHRyYW5zYWN0aW9uXG4gICAgICB0eEluZm8uaW5wdXRzID0gdW5zcGVudHMubWFwKGZ1bmN0aW9uIGFkZElucHV0Rm9yVW5zcGVudCh1bnNwZW50KSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhZGRyZXNzZXNCeUlkW3Vuc3BlbnQuYWRkcmVzc107XG5cbiAgICAgICAgdHJhbnNhY3Rpb25CdWlsZGVyLmFkZElucHV0KHVuc3BlbnQudHhpZCwgdW5zcGVudC5uLCAweGZmZmZmZmZmLCBhZGRyZXNzLm91dHB1dFNjcmlwdCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGFpblBhdGg6IGFkZHJlc3MuY2hhaW5QYXRoLFxuICAgICAgICAgIHJlZGVlbVNjcmlwdDogYWRkcmVzcy5yZWRlZW1TY3JpcHQgJiYgYWRkcmVzcy5yZWRlZW1TY3JpcHQudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgIHdpdG5lc3NTY3JpcHQ6IGFkZHJlc3Mud2l0bmVzc1NjcmlwdCAmJiBhZGRyZXNzLndpdG5lc3NTY3JpcHQudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgIHZhbHVlOiB1bnNwZW50LmFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgcmVjb3ZlcnlBbW91bnQgPSB0b3RhbElucHV0QW1vdW50IC0gYXBwcm94aW1hdGVGZWU7XG4gICAgICBsZXQga3JzRmVlO1xuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBrcnNGZWUgPSB5aWVsZCBzZWxmLmNhbGN1bGF0ZUZlZUFtb3VudCh7IHByb3ZpZGVyOiBwYXJhbXMua3JzUHJvdmlkZXIsIGFtb3VudDogcmVjb3ZlcnlBbW91bnQgfSk7XG4gICAgICAgICAgcmVjb3ZlcnlBbW91bnQgLT0ga3JzRmVlO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBEb24ndCBsZXQgdGhpcyBlcnJvciBibG9jayB0aGUgcmVjb3ZlcnkgLVxuICAgICAgICAgIGNvbnNvbGUuZGlyKGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlY292ZXJ5QW1vdW50IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRoaXMgd2FsbGV0XFwncyBiYWxhbmNlIGlzIHRvbyBsb3cgdG8gcGF5IHRoZSBmZWVzIHNwZWNpZmllZCBieSB0aGUgS1JTIHByb3ZpZGVyLiBcbiAgICAgICAgICBFeGlzdGluZyBiYWxhbmNlIG9uIHdhbGxldDogJHt0b3RhbElucHV0QW1vdW50fS4gRXN0aW1hdGVkIG5ldHdvcmsgZmVlIGZvciB0aGUgcmVjb3ZlcnkgdHJhbnNhY3Rpb25cbiAgICAgICAgICA6ICR7YXBwcm94aW1hdGVGZWV9LCBLUlMgZmVlIHRvIHBheTogJHtrcnNGZWV9LiBBZnRlciBkZWR1Y3RpbmcgZmVlcywgeW91ciB0b3RhbCByZWNvdmVyYWJsZSBiYWxhbmNlXG4gICAgICAgICAgaXMgJHtyZWNvdmVyeUFtb3VudH1gKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNhY3Rpb25CdWlsZGVyLmFkZE91dHB1dChwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbiwgcmVjb3ZlcnlBbW91bnQpO1xuXG4gICAgICBpZiAoaXNLcnNSZWNvdmVyeSAmJiBrcnNGZWUgPiAwKSB7XG4gICAgICAgIGNvbnN0IGtyc0ZlZUFkZHJlc3MgPSBrcnNQcm92aWRlci5mZWVBZGRyZXNzZXNbc2VsZi5nZXRDaGFpbigpXTtcblxuICAgICAgICBpZiAoIWtyc0ZlZUFkZHJlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoaXMgS1JTIHByb3ZpZGVyIGhhcyBub3QgY29uZmlndXJlZCB0aGVpciBmZWUgc3RydWN0dXJlIHlldCAtIHJlY292ZXJ5IGNhbm5vdCBiZSBjb21wbGV0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zYWN0aW9uQnVpbGRlci5hZGRPdXRwdXQoa3JzRmVlQWRkcmVzcywga3JzRmVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICBjb25zdCB0eEhleCA9IHRyYW5zYWN0aW9uQnVpbGRlci5idWlsZEluY29tcGxldGUoKS50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0Rm9yT2ZmbGluZVZhdWx0KHR4SW5mbywgdHhIZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2lnbmVkVHggPSBzZWxmLnNpZ25SZWNvdmVyeVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uQnVpbGRlciwgdW5zcGVudHMsIGFkZHJlc3Nlc0J5SWQsICFpc0tyc1JlY292ZXJ5KTtcbiAgICAgICAgdHhJbmZvLnRyYW5zYWN0aW9uSGV4ID0gc2lnbmVkVHguYnVpbGQoKS50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0eEluZm8udHggPSB5aWVsZCBzZWxmLnZlcmlmeVJlY292ZXJ5VHJhbnNhY3Rpb24odHhJbmZvKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIHNvbWUgY29pbnMgZG9uJ3QgaGF2ZSBhIHJlbGlhYmxlIHRoaXJkIHBhcnR5IHZlcmlmaWNhdGlvbiBlbmRwb2ludCwgb3Igc29tZXRpbWVzIHRoZSB0aGlyZCBwYXJ0eSBlbmRwb2ludFxuICAgICAgICAgIC8vIGNvdWxkIGJlIHVuYXZhaWxhYmxlIGR1ZSB0byBzZXJ2aWNlIG91dGFnZSwgc28gd2UgY29udGludWUgd2l0aG91dCB2ZXJpZmljYXRpb24gZm9yIHRob3NlIGNvaW5zLCBidXQgd2Ugd2lsbFxuICAgICAgICAgIC8vIGxldCB1c2VycyBrbm93IHRoYXQgdGhleSBzaG91bGQgdmVyaWZ5IHRoZWlyIG93blxuICAgICAgICAgIC8vIHRoaXMgbWVzc2FnZSBzaG91bGQgYmUgcGlwZWQgdG8gV1JXIGFuZCBkaXNwbGF5ZWQgb24gdGhlIFVJXG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBlcnJvcnMuTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvciB8fCBlIGluc3RhbmNlb2YgZXJyb3JzLkJsb2NrRXhwbG9yZXJVbmF2YWlsYWJsZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1BsZWFzZSB2ZXJpZnkgeW91ciB0cmFuc2FjdGlvbiBieSBkZWNvZGluZyB0aGUgdHggaGV4IHVzaW5nIGEgdGhpcmQtcGFydHkgYXBpIG9mIHlvdXIgY2hvaWNlJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgICAgIHR4SW5mby5jb2luID0gc2VsZi5nZXRDaGFpbigpO1xuICAgICAgICB0eEluZm8uYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleTtcbiAgICAgICAgdHhJbmZvLnJlY292ZXJ5QW1vdW50ID0gcmVjb3ZlcnlBbW91bnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eEluZm87XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBzaWduYXR1cmVzIHRvIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gdXNpbmcgdXNlciArIGJhY2t1cCBrZXlcbiAgICogQHBhcmFtIHR4YiB7T2JqZWN0fSBhIHRyYW5zYWN0aW9uIGJ1aWxkZXIgb2JqZWN0ICh3aXRoIGlucHV0cyBhbmQgb3V0cHV0cylcbiAgICogQHBhcmFtIHVuc3BlbnRzIHtBcnJheX0gdGhlIHVuc3BlbnRzIHRvIHVzZSBpbiB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIGFkZHJlc3NlcyB7QXJyYXl9IHRoZSBhZGRyZXNzIGFuZCByZWRlZW0gc2NyaXB0IGluZm8gZm9yIHRoZSB1bnNwZW50c1xuICAgKiBAcGFyYW0gY29zaWduIHtCb29sZWFufSB3aGV0aGVyIHRvIGNvc2lnbiB0aGlzIHRyYW5zYWN0aW9uIHdpdGggdGhlIHVzZXIncyBiYWNrdXAga2V5IChmYWxzZSBpZiBLUlMgcmVjb3ZlcnkpXG4gICAqIEByZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiBidWlsZGVyIG9yaWdpbmFsbHkgcGFzc2VkIGluIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgc2lnblJlY292ZXJ5VHJhbnNhY3Rpb24odHhiOiBhbnksIHVuc3BlbnRzOiBPdXRwdXRbXSwgYWRkcmVzc2VzOiBhbnksIGNvc2lnbjogYm9vbGVhbik6IGFueSB7XG4gICAgaW50ZXJmYWNlIFNpZ25hdHVyZUlzc3VlIHtcbiAgICAgIGlucHV0SW5kZXg6IG51bWJlcjtcbiAgICAgIHVuc3BlbnQ6IE91dHB1dDtcbiAgICAgIGVycm9yOiBFcnJvciB8IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qgc2lnbmF0dXJlSXNzdWVzOiBTaWduYXR1cmVJc3N1ZVtdID0gW107XG4gICAgdW5zcGVudHMuZm9yRWFjaCgodW5zcGVudCwgaSkgPT4ge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IGFkZHJlc3Nlc1t1bnNwZW50LmFkZHJlc3NdO1xuICAgICAgY29uc3QgYmFja3VwUHJpdmF0ZUtleSA9IGFkZHJlc3MuYmFja3VwS2V5LmtleVBhaXI7XG4gICAgICBjb25zdCB1c2VyUHJpdmF0ZUtleSA9IGFkZHJlc3MudXNlcktleS5rZXlQYWlyO1xuICAgICAgLy8gZm9yY2Utb3ZlcnJpZGUgbmV0d29ya3NcbiAgICAgIGJhY2t1cFByaXZhdGVLZXkubmV0d29yayA9IHRoaXMubmV0d29yaztcbiAgICAgIHVzZXJQcml2YXRlS2V5Lm5ldHdvcmsgPSB0aGlzLm5ldHdvcms7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRTaWduYXR1cmVJc3N1ZTogU2lnbmF0dXJlSXNzdWUgPSB7XG4gICAgICAgIGlucHV0SW5kZXg6IGksXG4gICAgICAgIHVuc3BlbnQ6IHVuc3BlbnQsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfTtcblxuICAgICAgaWYgKGNvc2lnbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHR4Yi5zaWduKGksIGJhY2t1cFByaXZhdGVLZXksIGFkZHJlc3MucmVkZWVtU2NyaXB0LCB0aGlzLmRlZmF1bHRTaWdIYXNoVHlwZSwgdW5zcGVudC5hbW91bnQsIGFkZHJlc3Mud2l0bmVzc1NjcmlwdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjdXJyZW50U2lnbmF0dXJlSXNzdWUuZXJyb3IgPSBlO1xuICAgICAgICAgIHNpZ25hdHVyZUlzc3Vlcy5wdXNoKGN1cnJlbnRTaWduYXR1cmVJc3N1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdHhiLnNpZ24oaSwgdXNlclByaXZhdGVLZXksIGFkZHJlc3MucmVkZWVtU2NyaXB0LCB0aGlzLmRlZmF1bHRTaWdIYXNoVHlwZSwgdW5zcGVudC5hbW91bnQsIGFkZHJlc3Mud2l0bmVzc1NjcmlwdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGN1cnJlbnRTaWduYXR1cmVJc3N1ZS5lcnJvciA9IGU7XG4gICAgICAgIHNpZ25hdHVyZUlzc3Vlcy5wdXNoKGN1cnJlbnRTaWduYXR1cmVJc3N1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc2lnbmF0dXJlSXNzdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGZhaWxlZEluZGljZXMgPSBzaWduYXR1cmVJc3N1ZXMubWFwKGN1cnJlbnRJc3N1ZSA9PiBjdXJyZW50SXNzdWUuaW5wdXRJbmRleCk7XG4gICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKGBGYWlsZWQgdG8gc2lnbiBpbnB1dHMgYXQgaW5kaWNlcyAke2ZhaWxlZEluZGljZXMuam9pbignLCAnKX1gKTtcbiAgICAgIGVycm9yLmNvZGUgPSAnaW5wdXRfc2lnbmF0dXJlX2ZhaWx1cmUnO1xuICAgICAgZXJyb3Iuc2lnbmluZ0Vycm9ycyA9IHNpZ25hdHVyZUlzc3VlcztcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiB0eGI7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgYW1vdW50IChpbiBiYXNlIHVuaXRzKSB0byBwYXkgYSBLUlMgcHJvdmlkZXIgd2hlbiBidWlsZGluZyBhIHJlY292ZXJ5IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5wcm92aWRlciB7U3RyaW5nfSB0aGUgS1JTIHByb3ZpZGVyIHRoYXQgaG9sZHMgdGhlIGJhY2t1cCBrZXlcbiAgICogQHBhcmFtIHBhcmFtcy5hbW91bnQge051bWJlcn0gYW1vdW50IChpbiBiYXNlIHVuaXRzKSB0byBiZSByZWNvdmVyZWRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgY2FsY3VsYXRlRmVlQW1vdW50KHBhcmFtczogeyBwcm92aWRlcjogc3RyaW5nLCBhbW91bnQ/OiBudW1iZXIgfSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8bnVtYmVyPik6IEJsdWViaXJkPG51bWJlcj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxudW1iZXI+KGZ1bmN0aW9uICpjYWxjdWxhdGVGZWVBbW91bnQoKSB7XG4gICAgICBjb25zdCBrcnNQcm92aWRlciA9IGNvbmZpZy5rcnNQcm92aWRlcnNbcGFyYW1zLnByb3ZpZGVyXTtcblxuICAgICAgaWYgKGtyc1Byb3ZpZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBmZWUgc3RydWN0dXJlIHNwZWNpZmllZCBmb3IgcHJvdmlkZXIgJHtwYXJhbXMucHJvdmlkZXJ9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChrcnNQcm92aWRlci5mZWVUeXBlID09PSAnZmxhdFVzZCcpIHtcbiAgICAgICAgY29uc3QgZmVlQW1vdW50VXNkID0ga3JzUHJvdmlkZXIuZmVlQW1vdW50O1xuICAgICAgICBjb25zdCBjdXJyZW50UHJpY2UgPSB5aWVsZCBzZWxmLmdldFJlY292ZXJ5TWFya2V0UHJpY2UoKTtcblxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChmZWVBbW91bnRVc2QgLyBjdXJyZW50UHJpY2UgKiBzZWxmLmdldEJhc2VGYWN0b3IoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBjYW4gYWRkIG1vcmUgZmVlIHN0cnVjdHVyZXMgaGVyZSBhcyBuZWVkZWQgZm9yIGRpZmZlcmVudCBwcm92aWRlcnMsIHN1Y2ggYXMgcGVyY2VudGFnZSBvZiByZWNvdmVyeSBhbW91bnRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGZWUgc3RydWN0dXJlIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgICAgfVxuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmVjb3ZlciBCVEMgdGhhdCB3YXMgc2VudCB0byB0aGUgd3JvbmcgY2hhaW5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnR4aWQgVGhlIHR4aWQgb2YgdGhlIGZhdWx0eSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zLnJlY292ZXJ5QWRkcmVzcyBhZGRyZXNzIHRvIHNlbmQgcmVjb3ZlcmVkIGZ1bmRzIHRvXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0IHRoZSB3YWxsZXQgdGhhdCByZWNlaXZlZCB0aGUgZnVuZHNcbiAgICogQHBhcmFtIHBhcmFtcy5yZWNvdmVyeUNvaW4gdGhlIGNvaW4gdHlwZSBvZiB0aGUgd2FsbGV0IHRoYXQgcmVjZWl2ZWQgdGhlIGZ1bmRzXG4gICAqIEBwYXJhbSBwYXJhbXMuc2lnbmVkIHJldHVybiBhIGhhbGYtc2lnbmVkIHRyYW5zYWN0aW9uIChkZWZhdWx0PXRydWUpXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSB0aGUgd2FsbGV0IHBhc3NwaHJhc2VcbiAgICogQHBhcmFtIHBhcmFtcy54cHJ2IHRoZSB1bmVuY3J5cHRlZCB4cHJ2ICh1c2VkIGluc3RlYWQgb2Ygd2FsbGV0IHBhc3NwaHJhc2UpXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHJlY292ZXJGcm9tV3JvbmdDaGFpbihwYXJhbXM6IFJlY292ZXJGcm9tV3JvbmdDaGFpbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKnJlY292ZXJGcm9tV3JvbmdDaGFpbigpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHhpZCxcbiAgICAgICAgcmVjb3ZlcnlBZGRyZXNzLFxuICAgICAgICB3YWxsZXQsXG4gICAgICAgIHdhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgIHhwcnYsXG4gICAgICB9ID0gcGFyYW1zO1xuXG4gICAgICAvLyBwYXJhbXMucmVjb3ZlcnlDb2luIHVzZWQgdG8gYmUgcGFyYW1zLmNvaW4sIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICBjb25zdCByZWNvdmVyeUNvaW4gPSBwYXJhbXMuY29pbiB8fCBwYXJhbXMucmVjb3ZlcnlDb2luO1xuICAgICAgaWYgKCFyZWNvdmVyeUNvaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIG9iamVjdCByZWNvdmVyeUNvaW4nKTtcbiAgICAgIH1cbiAgICAgIC8vIHNpZ25lZCBzaG91bGQgZGVmYXVsdCB0byB0cnVlLCBhbmQgb25seSBiZSBkaXNhYmxlZCBpZiBleHBsaWNpdGx5IHNldCB0byBmYWxzZSAobm90IHVuZGVmaW5lZClcbiAgICAgIGNvbnN0IHNpZ25lZCA9IHBhcmFtcy5zaWduZWQgIT09IGZhbHNlO1xuXG4gICAgICBjb25zdCBzb3VyY2VDb2luRmFtaWx5ID0gc2VsZi5nZXRGYW1pbHkoKTtcbiAgICAgIGNvbnN0IHJlY292ZXJ5Q29pbkZhbWlseSA9IHJlY292ZXJ5Q29pbi5nZXRGYW1pbHkoKTtcbiAgICAgIGNvbnN0IHN1cHBvcnRlZFJlY292ZXJ5Q29pbnMgPSBjb25maWcuc3VwcG9ydGVkQ3Jvc3NDaGFpblJlY292ZXJpZXNbc291cmNlQ29pbkZhbWlseV07XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHN1cHBvcnRlZFJlY292ZXJ5Q29pbnMpIHx8ICFzdXBwb3J0ZWRSZWNvdmVyeUNvaW5zLmluY2x1ZGVzKHJlY292ZXJ5Q29pbkZhbWlseSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNvdmVyeSBvZiAke3NvdXJjZUNvaW5GYW1pbHl9IGJhbGFuY2VzIGZyb20gJHtyZWNvdmVyeUNvaW5GYW1pbHl9IHdhbGxldHMgaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVjb3ZlcnlUb29sID0gbmV3IENyb3NzQ2hhaW5SZWNvdmVyeVRvb2woe1xuICAgICAgICBiaXRnbzogc2VsZi5iaXRnbyxcbiAgICAgICAgc291cmNlQ29pbjogc2VsZixcbiAgICAgICAgcmVjb3ZlcnlDb2luOiByZWNvdmVyeUNvaW4sXG4gICAgICAgIGxvZ2dpbmc6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIHlpZWxkIHJlY292ZXJ5VG9vbC5idWlsZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgd2FsbGV0OiB3YWxsZXQsXG4gICAgICAgIGZhdWx0eVR4SWQ6IHR4aWQsXG4gICAgICAgIHJlY292ZXJ5QWRkcmVzczogcmVjb3ZlcnlBZGRyZXNzLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzaWduZWQpIHtcbiAgICAgICAgeWllbGQgcmVjb3ZlcnlUb29sLnNpZ25UcmFuc2FjdGlvbih7IHBhc3NwaHJhc2U6IHdhbGxldFBhc3NwaHJhc2UsIHBydjogeHBydiB9KTtcbiAgICAgICAgcmV0dXJuIHJlY292ZXJ5VG9vbC5leHBvcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB5aWVsZCByZWNvdmVyeVRvb2wuYnVpbGRVbnNpZ25lZCgpO1xuICAgICAgfVxuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgc2VjcDI1NmsxIGtleSBwYWlyXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGdlbmVyYXRlZCBwdWIgYW5kIHBydlxuICAgKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ6IEJ1ZmZlcik6IHsgcHViOiBzdHJpbmcsIHBydjogc3RyaW5nIH0ge1xuICAgIGlmICghc2VlZCkge1xuICAgICAgLy8gQW4gZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgaGFzIGJvdGggYSBub3JtYWwgMjU2IGJpdCBwcml2YXRlIGtleSBhbmQgYSAyNTZcbiAgICAgIC8vIGJpdCBjaGFpbiBjb2RlLCBib3RoIG9mIHdoaWNoIG11c3QgYmUgcmFuZG9tLiA1MTIgYml0cyBpcyB0aGVyZWZvcmUgdGhlXG4gICAgICAvLyBtYXhpbXVtIGVudHJvcHkgYW5kIGdpdmVzIHVzIG1heGltdW0gc2VjdXJpdHkgYWdhaW5zdCBjcmFja2luZy5cbiAgICAgIHNlZWQgPSByYW5kb21CeXRlcyg1MTIgLyA4KTtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5kZWRLZXkgPSBiaXRjb2luLkhETm9kZS5mcm9tU2VlZEJ1ZmZlcihzZWVkKTtcbiAgICBjb25zdCB4cHViID0gZXh0ZW5kZWRLZXkubmV1dGVyZWQoKS50b0Jhc2U1OCgpO1xuICAgIHJldHVybiB7XG4gICAgICBwdWI6IHhwdWIsXG4gICAgICBwcnY6IGV4dGVuZGVkS2V5LnRvQmFzZTU4KCksXG4gICAgfTtcbiAgfVxuXG4gIGdldEV4dHJhUHJlYnVpbGRQYXJhbXMoYnVpbGRQYXJhbXM6IEV4dHJhUHJlYnVpbGRQYXJhbXNPcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUoe30pLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgcHJlQ3JlYXRlQml0R28ocGFyYW1zOiBQcmVjcmVhdGVCaXRHb09wdGlvbnMpOiB2b2lkIHt9XG5cbiAgcHJlc2lnblRyYW5zYWN0aW9uKHBhcmFtczogUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucywgY2FsbGJhY2s/OiAoZXJyOiBFcnJvciwgcmVzOiBhbnkpID0+IHZvaWQpOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZShwYXJhbXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgc3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0KHdhbGxldFBhcmFtczogU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucywga2V5Y2hhaW5zOiBLZXljaGFpbnNUcmlwbGV0KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUod2FsbGV0UGFyYW1zKTtcbiAgfVxuXG4gIHRyYW5zYWN0aW9uRGF0YUFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZlcmlmeVJlY292ZXJ5VHJhbnNhY3Rpb24odHhJbmZvOiBWZXJpZnlSZWNvdmVyeVRyYW5zYWN0aW9uT3B0aW9ucyk6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZWplY3QobmV3IGVycm9ycy5NZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yKCkpO1xuICB9XG5cbiAgc2lnbk1lc3NhZ2Uoa2V5OiB7IHBydjogc3RyaW5nIH0sIG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlciwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8QnVmZmVyPik6IEJsdWViaXJkPEJ1ZmZlcj4ge1xuICAgIHJldHVybiBjbzxCdWZmZXI+KGZ1bmN0aW9uKiBjb3NpZ25NZXNzYWdlKCkge1xuICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IGJpdGNvaW4uSEROb2RlLmZyb21CYXNlNTgoa2V5LnBydikuZ2V0S2V5KCk7XG4gICAgICBjb25zdCBwcml2YXRlS2V5QnVmZmVyID0gcHJpdmF0ZUtleS5kLnRvQnVmZmVyKDMyKTtcbiAgICAgIGNvbnN0IGlzQ29tcHJlc3NlZCA9IHByaXZhdGVLZXkuY29tcHJlc3NlZDtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGJpdGNvaW4ubmV0d29ya3MuYml0Y29pbi5tZXNzYWdlUHJlZml4O1xuICAgICAgcmV0dXJuIGJpdGNvaW5NZXNzYWdlLnNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleUJ1ZmZlciwgaXNDb21wcmVzc2VkLCBwcmVmaXgpO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG59XG4iXX0=