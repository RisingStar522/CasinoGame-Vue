"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var unspents_1 = require("@bitgo/unspents");
var request = require("superagent");
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var _ = require("lodash");
var bitcoin = require("@bitgo/utxo-lib");
/**
 * An instance of the recovery tool, which encapsulates the recovery functions
 * Instantiated with parameters:
 *   - bitgo: an instance of the bitgo SDK
 *   - sourceCoin: the coin that needs to be recovered
 *   - recoveryCoin: the type of address the faulty transaction was sent to
 */
var CrossChainRecoveryTool = /** @class */ (function () {
    function CrossChainRecoveryTool(opts) {
        this.bitgo = opts.bitgo;
        this.logging = opts.logging;
        if (_.isUndefined(this.bitgo)) {
            throw new Error('Please instantiate the recovery tool with a bitgo instance.');
        }
        // List of coins we support. Add modifiers (e.g. segwit) after the dash
        this.supportedCoins = ['btc', 'bch', 'ltc', 'btc-segwit', 'bsv'];
        if (_.isUndefined(opts.sourceCoin) || !this.supportedCoins.includes(opts.sourceCoin.getFamily())) {
            throw new Error('Please set a valid source coin');
        }
        this.sourceCoin = opts.sourceCoin;
        if (_.isUndefined(opts.recoveryCoin) || !this.supportedCoins.includes(opts.recoveryCoin.getFamily())) {
            throw new Error('Please set a valid recovery type');
        }
        this.recoveryCoin = opts.recoveryCoin;
        this.wallet = null;
        this.feeRates = {
            bch: 20,
            tbch: 20,
            bsv: 20,
            tbsv: 20,
            btc: 80,
            tbtc: 80,
            ltc: 100,
            tltc: 100,
        };
        this.recoveryTx = new bitcoin.TransactionBuilder(this.sourceCoin.network);
    }
    /**
     * Internal logging function (either uses provided logger or console.log, can be turned off)
     * @param args - the arguments to pass to the logger
     * @private
     */
    CrossChainRecoveryTool.prototype._log = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!this.logging) {
            return;
        }
        this.logger ? this.logger.apply(this, args) : console.log.apply(console, args);
    };
    /**
     * Sets the wallet ID of the recoveryCoin wallet. This is needed to find the private keys to sign the transaction.
     * @param walletId {String} wallet ID
     * @param callback
     */
    CrossChainRecoveryTool.prototype.setWallet = function (walletId, callback) {
        var self = this;
        return co(function setWallet() {
            var coinType, wallet, e_1, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        coinType = self.recoveryCoin.getChain();
                        if (_.isUndefined(walletId)) {
                            throw new Error('Please provide wallet id');
                        }
                        self._log("Fetching " + coinType + " wallet...");
                        if (self.sourceCoin.type !== coinType && self.recoveryCoin.type !== coinType) {
                            throw new Error('Cannot set a wallet for this coin type - this is not a coin involved in the recovery tx.');
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, self.bitgo
                                .coin(coinType)
                                .wallets()
                                .get({ id: walletId })];
                    case 2:
                        wallet = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        if (e_1.status !== 404 && e_1.status !== 400) {
                            throw e_1;
                        }
                        wallet = undefined;
                        return [3 /*break*/, 4];
                    case 4:
                        if (!(_.isUndefined(wallet) && coinType.endsWith('btc'))) return [3 /*break*/, 8];
                        _a.label = 5;
                    case 5:
                        _a.trys.push([5, 7, , 8]);
                        self._log('Could not find v2 wallet. Falling back to v1...');
                        return [4 /*yield*/, self.bitgo.wallets().get({ id: walletId })];
                    case 6:
                        wallet = _a.sent();
                        wallet.isV1 = true;
                        return [3 /*break*/, 8];
                    case 7:
                        e_2 = _a.sent();
                        if (e_2.status !== 404) {
                            throw e_2;
                        }
                        return [3 /*break*/, 8];
                    case 8:
                        if (_.isUndefined(wallet)) {
                            throw new Error("Cannot find " + coinType + " wallet.");
                        }
                        self.wallet = wallet;
                        return [2 /*return*/];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Retrieves and stores the unspents from the faulty transaction
     * @param faultyTxId {String} the txid of the faulty transaction
     * @param callback
     */
    CrossChainRecoveryTool.prototype.findUnspents = function (faultyTxId, callback) {
        var self = this;
        return co(function findUnspents() {
            var TX_INFO_URL, res, faultyTxInfo, txOutputAddresses, outputAddresses, _i, txOutputAddresses_1, address, methodName, walletAddress, e_3, ADDRESS_UNSPENTS_URL, addressRes, unspents;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (_.isUndefined(faultyTxId)) {
                            throw new Error('Please provide a faultyTxId');
                        }
                        self._log('Grabbing info for faulty tx...');
                        TX_INFO_URL = self.sourceCoin.url("/public/tx/" + faultyTxId);
                        return [4 /*yield*/, request.get(TX_INFO_URL)];
                    case 1:
                        res = _a.sent();
                        faultyTxInfo = res.body;
                        self._log('Getting unspents on output addresses..');
                        txOutputAddresses = faultyTxInfo.outputs.map(function (input) { return input.address; });
                        outputAddresses = [];
                        _i = 0, txOutputAddresses_1 = txOutputAddresses;
                        _a.label = 2;
                    case 2:
                        if (!(_i < txOutputAddresses_1.length)) return [3 /*break*/, 7];
                        address = txOutputAddresses_1[_i];
                        if (self.sourceCoin.getFamily() === 'ltc') {
                            try {
                                address = self.sourceCoin.canonicalAddress(address, 1);
                            }
                            catch (e) {
                                return [3 /*break*/, 6];
                            }
                        }
                        if (self.recoveryCoin.getFamily() === 'ltc') {
                            try {
                                address = self.recoveryCoin.canonicalAddress(address, 2);
                            }
                            catch (e) {
                                return [3 /*break*/, 6];
                            }
                        }
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        methodName = self.wallet.isV1 ? 'address' : 'getAddress';
                        return [4 /*yield*/, self.wallet[methodName]({ address: address })];
                    case 4:
                        walletAddress = _a.sent();
                        outputAddresses.push(walletAddress.address);
                        return [3 /*break*/, 6];
                    case 5:
                        e_3 = _a.sent();
                        self._log("Address " + address + " not found on wallet");
                        return [3 /*break*/, 6];
                    case 6:
                        _i++;
                        return [3 /*break*/, 2];
                    case 7:
                        if (outputAddresses.length === 0) {
                            throw new Error('Could not find tx outputs belonging to the specified wallet. Please check the given parameters.');
                        }
                        if (self.recoveryCoin.getFamily() === 'ltc') {
                            outputAddresses = outputAddresses.map(function (address) { return self.recoveryCoin.canonicalAddress(address, 1); });
                        }
                        if (self.sourceCoin.getFamily() === 'ltc') {
                            outputAddresses = outputAddresses.map(function (address) { return self.sourceCoin.canonicalAddress(address, 2); });
                        }
                        self._log("Finding unspents for these output addresses: " + outputAddresses.join(', '));
                        ADDRESS_UNSPENTS_URL = self.sourceCoin.url("/public/addressUnspents/" + _.uniq(outputAddresses).join(','));
                        return [4 /*yield*/, request.get(ADDRESS_UNSPENTS_URL)];
                    case 8:
                        addressRes = _a.sent();
                        unspents = addressRes.body;
                        self.unspents = unspents;
                        return [2 /*return*/, unspents];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Constructs transaction inputs from a set of unspents.
     * @param unspents {Object[]} array of unspents from the faulty transaction
     * @param callback
     * @returns {Object} partial txInfo object with transaction inputs
     */
    CrossChainRecoveryTool.prototype.buildInputs = function (unspents, callback) {
        var self = this;
        return co(function buildInputs() {
            var txInfo, totalFound, noSegwit, _i, unspents_2, unspent, searchAddress, unspentAddress, methodName, e_4, _a, txHash, index, inputIndex, hash, inputData, addressInfo, _b, txid, nOut;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        self._log('Building inputs for recovery transaction...');
                        unspents = unspents || self.unspents;
                        if (_.isUndefined(unspents) || unspents.length === 0) {
                            throw new Error('Could not find unspents. Either supply an argument or call findUnspents');
                        }
                        txInfo = {
                            inputAmount: 0,
                            outputAmount: 0,
                            spendAmount: 0,
                            inputs: [],
                            outputs: [],
                            unspents: [],
                            externalOutputs: [],
                            changeOutputs: [],
                            minerFee: 0,
                            payGoFee: 0,
                        };
                        totalFound = 0;
                        noSegwit = self.recoveryCoin.getFamily() === 'btc' && self.sourceCoin.getFamily() === 'bch';
                        _i = 0, unspents_2 = unspents;
                        _c.label = 1;
                    case 1:
                        if (!(_i < unspents_2.length)) return [3 /*break*/, 10];
                        unspent = unspents_2[_i];
                        if (unspent.witnessScript && noSegwit) {
                            throw new Error('Warning! It appears one of the unspents is on a Segwit address. The tool only recovers BCH from non-Segwit BTC addresses. Aborting.');
                        }
                        searchAddress = unspent.address;
                        if (self.sourceCoin.type.endsWith('ltc')) {
                            searchAddress = self.sourceCoin.canonicalAddress(searchAddress, 1);
                        }
                        if (self.recoveryCoin.type.endsWith('ltc')) {
                            searchAddress = self.recoveryCoin.canonicalAddress(searchAddress, 2);
                        }
                        unspentAddress = void 0;
                        _c.label = 2;
                    case 2:
                        _c.trys.push([2, 4, , 5]);
                        methodName = self.wallet.isV1 ? 'address' : 'getAddress';
                        return [4 /*yield*/, self.wallet[methodName]({ address: searchAddress })];
                    case 3:
                        unspentAddress = _c.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        e_4 = _c.sent();
                        self._log("Could not find address on wallet for " + searchAddress);
                        return [3 /*break*/, 9];
                    case 5:
                        self._log("Found " + unspent.value * 1e-8 + " " + self.sourceCoin.type + " at address " + unspent.address);
                        _a = unspent.id.split(':'), txHash = _a[0], index = _a[1];
                        inputIndex = parseInt(index, 10);
                        hash = Buffer.from(txHash, 'hex');
                        hash = Buffer.from(Array.prototype.reverse.call(hash));
                        try {
                            self.recoveryTx.addInput(hash, inputIndex);
                        }
                        catch (e) {
                            throw new Error("Error adding unspent " + unspent.id);
                        }
                        inputData = {};
                        if (!self.wallet.isV1) return [3 /*break*/, 7];
                        return [4 /*yield*/, self.wallet.address({ address: unspentAddress.address })];
                    case 6:
                        addressInfo = _c.sent();
                        unspentAddress.path = unspentAddress.path || "/" + unspentAddress.chain + "/" + unspentAddress.index;
                        _b = unspent.id.split(':'), txid = _b[0], nOut = _b[1];
                        inputData = {
                            redeemScript: addressInfo.redeemScript,
                            witnessScript: addressInfo.witnessScript,
                            path: '/0/0' + unspentAddress.path,
                            chainPath: unspentAddress.path,
                            index: unspentAddress.index,
                            chain: unspentAddress.chain,
                            txHash: txid,
                            txOutputN: parseInt(nOut, 10),
                            txValue: unspent.value,
                            value: parseInt(unspent.value, 10),
                        };
                        return [3 /*break*/, 8];
                    case 7:
                        inputData = {
                            redeemScript: unspentAddress.coinSpecific.redeemScript,
                            witnessScript: unspentAddress.coinSpecific.witnessScript,
                            index: unspentAddress.index,
                            chain: unspentAddress.chain,
                            wallet: self.wallet.id(),
                            fromWallet: self.wallet.id(),
                        };
                        _c.label = 8;
                    case 8:
                        txInfo.inputs.push(Object.assign({}, unspent, inputData));
                        txInfo.inputAmount += parseInt(unspent.value, 10);
                        totalFound += parseInt(unspent.value, 10);
                        _c.label = 9;
                    case 9:
                        _i++;
                        return [3 /*break*/, 1];
                    case 10:
                        txInfo.unspents = _.clone(txInfo.inputs);
                        // Normalize total found to base unit before we print it out
                        self._log("Found lost " + totalFound * 1e-8 + " " + self.sourceCoin.type + ".");
                        self.txInfo = txInfo;
                        return [2 /*return*/, txInfo];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Sets the txInfo.minerFee field by calculating the size of the transaction and multiplying it by the fee rate for
     * the source coin.
     * @param recoveryTx {Object} recovery transaction containing inputs
     * @returns {Number} recovery fee for the transaction
     */
    CrossChainRecoveryTool.prototype.setFees = function (recoveryTx) {
        recoveryTx = recoveryTx || this.recoveryTx;
        // Determine fee with default fee rate
        var feeRate = this.feeRates[this.sourceCoin.type];
        // Note that we assume one output here (all funds should be recovered to a single address)
        var txSize = unspents_1.VirtualSizes.txP2shInputSize * recoveryTx.tx.ins.length +
            unspents_1.VirtualSizes.txP2pkhOutputSize +
            unspents_1.VirtualSizes.txOverheadSize;
        var recoveryFee = feeRate * txSize;
        if (this.txInfo) {
            this.txInfo.minerFee = recoveryFee;
        }
        return recoveryFee;
    };
    /**
     * Constructs a single output to the recovery address.
     * @param recoveryAddress {String} address to recover funds to
     * @param outputAmount {Number} amount to send to the recovery address
     * @param recoveryFee {Number} miner fee for the transaction
     */
    CrossChainRecoveryTool.prototype.buildOutputs = function (recoveryAddress, outputAmount, recoveryFee) {
        if (_.isUndefined(outputAmount) && _.isUndefined(this.txInfo)) {
            throw new Error('Could not find transaction info. Please provide an output amount, or call buildInputs.');
        }
        this._log("Building outputs for recovery transaction. Funds will be sent to " + recoveryAddress + "...");
        var txInputAmount = outputAmount || (this.txInfo && this.txInfo.inputAmount);
        var txFeeAmount = recoveryFee || (this.txInfo && this.txInfo.minerFee);
        if (!txInputAmount) {
            throw new Error('could not determine transaction input amount');
        }
        if (!txFeeAmount) {
            throw new Error('could not determine transaction fee amount');
        }
        var txOutputAmount = txInputAmount - txFeeAmount;
        if (txOutputAmount <= 0) {
            throw new Error('This recovery transaction cannot pay its own fees. Aborting.');
        }
        if (!_.isUndefined(this.txInfo)) {
            this.txInfo.outputAmount = txOutputAmount;
            this.txInfo.spendAmount = txOutputAmount;
        }
        this.recoveryAddress = recoveryAddress;
        this.recoveryAmount = txOutputAmount;
        this.recoveryTx.addOutput(recoveryAddress, txOutputAmount);
        var outputData = {
            address: recoveryAddress,
            value: outputAmount,
            valueString: txOutputAmount.toString(),
            wallet: this.wallet.id(),
            change: false,
        };
        if (this.txInfo) {
            this.txInfo.outputs.push(outputData);
            this.txInfo.externalOutputs.push(outputData);
        }
    };
    /**
     * Half-signs the built transaction with the user's private key or keychain
     * @param params
     * @param params.prv {String} private key
     * @param params.passphrase {String} wallet passphrase
     * @param callback
     * @returns {Object} half-signed transaction
     */
    CrossChainRecoveryTool.prototype.signTransaction = function (params, callback) {
        var self = this;
        return co(function signTransaction() {
            var transactionHex, prv, _a, txPrebuild, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (_.isUndefined(self.txInfo)) {
                            throw new Error('Could not find txInfo. Please build a transaction');
                        }
                        self._log('Signing the transaction...');
                        transactionHex = self.recoveryTx.buildIncomplete().toHex();
                        if (!_.isString(params.prv)) return [3 /*break*/, 1];
                        _a = params.prv;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, self.getKeys(params.passphrase)];
                    case 2:
                        _a = _c.sent();
                        _c.label = 3;
                    case 3:
                        prv = _a;
                        txPrebuild = { txHex: transactionHex, txInfo: self.txInfo };
                        _b = self;
                        return [4 /*yield*/, self.sourceCoin.signTransaction({ txPrebuild: txPrebuild, prv: prv })];
                    case 4:
                        _b.halfSignedRecoveryTx = _c.sent();
                        return [2 /*return*/, self.halfSignedRecoveryTx];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Gets the wallet's encrypted keychain, then decrypts it with the wallet passphrase
     * @param passphrase {String} wallet passphrase
     * @param callback
     * @returns {String} decrypted wallet private key
     */
    CrossChainRecoveryTool.prototype.getKeys = function (passphrase, callback) {
        var self = this;
        return co(function getKeys() {
            var prv, keychain, e_5, encryptedPrv;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, self.wallet.getEncryptedUserKeychain()];
                    case 1:
                        keychain = _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_5 = _a.sent();
                        if (e_5.status !== 404) {
                            throw e_5;
                        }
                        return [3 /*break*/, 3];
                    case 3:
                        if (_.isUndefined(passphrase)) {
                            throw new Error('You have an encrypted user keychain - please provide the passphrase to decrypt it');
                        }
                        if (self.wallet.isV1) {
                            if (_.isUndefined(keychain)) {
                                throw new Error('V1 wallets need a user keychain - could not find the proper keychain. Aborting');
                            }
                        }
                        if (keychain) {
                            try {
                                encryptedPrv = self.wallet.isV1 ? keychain.encryptedXprv : keychain.encryptedPrv;
                                prv = self.bitgo.decrypt({ input: encryptedPrv, password: passphrase });
                            }
                            catch (e) {
                                throw new Error('Error reading private key. Please check that you have the correct wallet passphrase');
                            }
                        }
                        return [2 /*return*/, prv];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    CrossChainRecoveryTool.prototype.buildTransaction = function (params, callback) {
        var self = this;
        return co(function buildTransaction() {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.setWallet(params.wallet)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, self.findUnspents(params.faultyTxId)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, self.buildInputs()];
                    case 3:
                        _a.sent();
                        self.setFees();
                        self.buildOutputs(params.recoveryAddress);
                        return [2 /*return*/, self.recoveryTx];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    CrossChainRecoveryTool.prototype.buildUnsigned = function (callback) {
        var self = this;
        return co(function () {
            var incomplete, txInfo, _i, _a, input, feeInfo;
            return __generator(this, function (_b) {
                if (_.isUndefined(self.txInfo)) {
                    throw new Error('Could not find txInfo. Please build a transaction');
                }
                incomplete = self.recoveryTx.buildIncomplete();
                txInfo = {
                    nP2SHInputs: 0,
                    nSegwitInputs: 0,
                };
                for (_i = 0, _a = self.txInfo.inputs; _i < _a.length; _i++) {
                    input = _a[_i];
                    if (input.chain === 10 || input.chain === 11) {
                        txInfo.nSegwitInputs++;
                    }
                    else {
                        txInfo.nP2SHInputs++;
                    }
                }
                txInfo.nOutputs = 1;
                txInfo.unspents = _.map(self.txInfo.inputs, _.partialRight(_.pick, ['chain', 'index', 'redeemScript', 'id', 'address', 'value']));
                txInfo.changeAddresses = [];
                txInfo.walletAddressDetails = {};
                feeInfo = {};
                feeInfo.size =
                    unspents_1.VirtualSizes.txOverheadSize +
                        unspents_1.VirtualSizes.txP2shInputSize * self.txInfo.inputs.length +
                        unspents_1.VirtualSizes.txP2pkhOutputSize;
                feeInfo.feeRate = self.feeRates[self.sourceCoin.type];
                feeInfo.fee = Math.round((feeInfo.size / 1000) * feeInfo.feeRate);
                feeInfo.payGoFee = 0;
                feeInfo.payGoFeeString = '0';
                return [2 /*return*/, {
                        txHex: incomplete.toHex(),
                        txInfo: txInfo,
                        feeInfo: feeInfo,
                        walletId: self.wallet.id(),
                        amount: self.recoveryAmount,
                        address: self.recoveryAddress,
                        coin: self.sourceCoin.type,
                    }];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    CrossChainRecoveryTool.prototype.export = function () {
        return {
            version: this.wallet.isV1 ? 1 : 2,
            sourceCoin: this.sourceCoin.type,
            recoveryCoin: this.recoveryCoin.type,
            walletId: this.wallet.id(),
            recoveryAddress: this.recoveryAddress,
            recoveryAmount: this.recoveryAmount,
            txHex: this.halfSignedRecoveryTx && (this.halfSignedRecoveryTx.txHex || this.halfSignedRecoveryTx.tx),
            txInfo: this.txInfo,
        };
    };
    return CrossChainRecoveryTool;
}());
exports.CrossChainRecoveryTool = CrossChainRecoveryTool;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVjb3ZlcnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdjIvcmVjb3ZlcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILDRDQUErQztBQUMvQyxvQ0FBc0M7QUFFdEMsbUNBQXFDO0FBQ3JDLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUFDOUIsMEJBQTRCO0FBRTVCLHlDQUEyQztBQXdDM0M7Ozs7OztHQU1HO0FBQ0g7SUFnQkUsZ0NBQVksSUFBbUM7UUFDN0MsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUU1QixJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzdCLE1BQU0sSUFBSSxLQUFLLENBQUMsNkRBQTZELENBQUMsQ0FBQztTQUNoRjtRQUVELHVFQUF1RTtRQUN2RSxJQUFJLENBQUMsY0FBYyxHQUFHLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRWpFLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUU7WUFDaEcsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO1NBQ25EO1FBQ0QsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBRWxDLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFD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QUU3QixzQkFBTzt3QkFDTCxLQUFLLEVBQUUsVUFBVSxDQUFDLEtBQUssRUFBRTt3QkFDekIsTUFBTSxFQUFFLE1BQU07d0JBQ2QsT0FBTyxFQUFFLE9BQU87d0JBQ2hCLFFBQVEsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRTt3QkFDMUIsTUFBTSxFQUFFLElBQUksQ0FBQyxjQUFjO3dCQUMzQixPQUFPLEVBQUUsSUFBSSxDQUFDLGVBQWU7d0JBQzdCLElBQUksRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUk7cUJBQzNCLEVBQUM7O1NBQ0gsQ0FBQzthQUNDLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDVixVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVELHVDQUFNLEdBQU47UUFDRSxPQUFPO1lBQ0wsT0FBTyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakMsVUFBVSxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSTtZQUNoQyxZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJO1lBQ3BDLFFBQVEsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRTtZQUMxQixlQUFlLEVBQUUsSUFBSSxDQUFDLGVBQWU7WUFDckMsY0FBYyxFQUFFLElBQUksQ0FBQyxjQUFjO1lBQ25DLEtBQUssRUFBRSxJQUFJLENBQUMsb0JBQW9CLElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFLENBQUM7WUFDckcsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO1NBQ3BCLENBQUM7SUFDSixDQUFDO0lBQ0gsNkJBQUM7QUFBRCxDQUFDLEFBN2lCRCxJQTZpQkM7QUE3aUJZLHdEQUFzQiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCB7IFZpcnR1YWxTaXplcyB9IGZyb20gJ0BiaXRnby91bnNwZW50cyc7XG5pbXBvcnQgKiBhcyByZXF1ZXN0IGZyb20gJ3N1cGVyYWdlbnQnO1xuaW1wb3J0IHsgTm9kZUNhbGxiYWNrIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5jb25zdCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vYml0Z28nO1xuaW1wb3J0ICogYXMgYml0Y29pbiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0IHsgQWJzdHJhY3RVdHhvQ29pbiB9IGZyb20gJy4vY29pbnMvYWJzdHJhY3RVdHhvQ29pbic7XG5pbXBvcnQgeyBMdGMgfSBmcm9tICcuL2NvaW5zL2x0Yyc7XG5pbXBvcnQgeyBXYWxsZXQgfSBmcm9tICcuL3dhbGxldCc7XG5cbmludGVyZmFjZSBDcm9zc0NoYWluUmVjb3ZlcnlUb29sT3B0aW9ucyB7XG4gIGJpdGdvOiBCaXRHbztcbiAgc291cmNlQ29pbj86IEFic3RyYWN0VXR4b0NvaW47XG4gIHJlY292ZXJ5Q29pbj86IEFic3RyYWN0VXR4b0NvaW47XG4gIGxvZ2dpbmc6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnblJlY292ZXJ5VHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgcHJ2Pzogc3RyaW5nO1xuICBwYXNzcGhyYXNlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnVpbGRSZWNvdmVyeVRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHdhbGxldDogc3RyaW5nO1xuICBmYXVsdHlUeElkOiBzdHJpbmc7XG4gIHJlY292ZXJ5QWRkcmVzczogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJ5VHhJbmZvIHtcbiAgaW5wdXRBbW91bnQ6IG51bWJlcjtcbiAgb3V0cHV0QW1vdW50OiBudW1iZXI7XG4gIHNwZW5kQW1vdW50OiBudW1iZXI7XG4gIGlucHV0czogYW55W107XG4gIG91dHB1dHM6IGFueVtdO1xuICBleHRlcm5hbE91dHB1dHM6IGFueVtdO1xuICBjaGFuZ2VPdXRwdXRzOiBhbnlbXTtcbiAgbWluZXJGZWU6IG51bWJlcjtcbiAgcGF5R29GZWU6IG51bWJlcjtcbiAgdW5zcGVudHM6IGFueVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhhbGZTaWduZWRSZWNvdmVyeVR4IHtcbiAgdHhIZXg6IHN0cmluZztcbiAgdHg/OiBzdHJpbmc7XG59XG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSByZWNvdmVyeSB0b29sLCB3aGljaCBlbmNhcHN1bGF0ZXMgdGhlIHJlY292ZXJ5IGZ1bmN0aW9uc1xuICogSW5zdGFudGlhdGVkIHdpdGggcGFyYW1ldGVyczpcbiAqICAgLSBiaXRnbzogYW4gaW5zdGFuY2Ugb2YgdGhlIGJpdGdvIFNES1xuICogICAtIHNvdXJjZUNvaW46IHRoZSBjb2luIHRoYXQgbmVlZHMgdG8gYmUgcmVjb3ZlcmVkXG4gKiAgIC0gcmVjb3ZlcnlDb2luOiB0aGUgdHlwZSBvZiBhZGRyZXNzIHRoZSBmYXVsdHkgdHJhbnNhY3Rpb24gd2FzIHNlbnQgdG9cbiAqL1xuZXhwb3J0IGNsYXNzIENyb3NzQ2hhaW5SZWNvdmVyeVRvb2wge1xuICBiaXRnbzogQml0R287XG4gIHNvdXJjZUNvaW46IEFic3RyYWN0VXR4b0NvaW47XG4gIHJlY292ZXJ5Q29pbjogQWJzdHJhY3RVdHhvQ29pbjtcbiAgbG9nZ2luZzogYm9vbGVhbjtcbiAgc3VwcG9ydGVkQ29pbnM6IHN0cmluZ1tdO1xuICB3YWxsZXQ6IGFueTsgLy8gVGhpcyBjYW4gYmUgZWl0aGVyIGEgdjEgb3IgdjIgd2FsbGV0XG4gIGZlZVJhdGVzOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9O1xuICByZWNvdmVyeVR4OiBhbnk7XG4gIGxvZ2dlcjogYW55O1xuICBwcml2YXRlIHVuc3BlbnRzPzogYW55O1xuICB0eEluZm8/OiBSZWNvdmVyeVR4SW5mbztcbiAgcmVjb3ZlcnlBZGRyZXNzPzogc3RyaW5nO1xuICByZWNvdmVyeUFtb3VudD86IG51bWJlcjtcbiAgaGFsZlNpZ25lZFJlY292ZXJ5VHg/OiBIYWxmU2lnbmVkUmVjb3ZlcnlUeDtcblxuICBjb25zdHJ1Y3RvcihvcHRzOiBDcm9zc0NoYWluUmVjb3ZlcnlUb29sT3B0aW9ucykge1xuICAgIHRoaXMuYml0Z28gPSBvcHRzLmJpdGdvO1xuICAgIHRoaXMubG9nZ2luZyA9IG9wdHMubG9nZ2luZztcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHRoaXMuYml0Z28pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBpbnN0YW50aWF0ZSB0aGUgcmVjb3ZlcnkgdG9vbCB3aXRoIGEgYml0Z28gaW5zdGFuY2UuJyk7XG4gICAgfVxuXG4gICAgLy8gTGlzdCBvZiBjb2lucyB3ZSBzdXBwb3J0LiBBZGQgbW9kaWZpZXJzIChlLmcuIHNlZ3dpdCkgYWZ0ZXIgdGhlIGRhc2hcbiAgICB0aGlzLnN1cHBvcnRlZENvaW5zID0gWydidGMnLCAnYmNoJywgJ2x0YycsICdidGMtc2Vnd2l0JywgJ2JzdiddO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQob3B0cy5zb3VyY2VDb2luKSB8fCAhdGhpcy5zdXBwb3J0ZWRDb2lucy5pbmNsdWRlcyhvcHRzLnNvdXJjZUNvaW4uZ2V0RmFtaWx5KCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBzZXQgYSB2YWxpZCBzb3VyY2UgY29pbicpO1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZUNvaW4gPSBvcHRzLnNvdXJjZUNvaW47XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChvcHRzLnJlY292ZXJ5Q29pbikgfHwgIXRoaXMuc3VwcG9ydGVkQ29pbnMuaW5jbHVkZXMob3B0cy5yZWNvdmVyeUNvaW4uZ2V0RmFtaWx5KCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBzZXQgYSB2YWxpZCByZWNvdmVyeSB0eXBlJyk7XG4gICAgfVxuICAgIHRoaXMucmVjb3ZlcnlDb2luID0gb3B0cy5yZWNvdmVyeUNvaW47XG5cbiAgICB0aGlzLndhbGxldCA9IG51bGw7XG5cbiAgICB0aGlzLmZlZVJhdGVzID0ge1xuICAgICAgYmNoOiAyMCxcbiAgICAgIHRiY2g6IDIwLFxuICAgICAgYnN2OiAyMCxcbiAgICAgIHRic3Y6IDIwLFxuICAgICAgYnRjOiA4MCxcbiAgICAgIHRidGM6IDgwLFxuICAgICAgbHRjOiAxMDAsXG4gICAgICB0bHRjOiAxMDAsXG4gICAgfTtcblxuICAgIHRoaXMucmVjb3ZlcnlUeCA9IG5ldyBiaXRjb2luLlRyYW5zYWN0aW9uQnVpbGRlcih0aGlzLnNvdXJjZUNvaW4ubmV0d29yayk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgbG9nZ2luZyBmdW5jdGlvbiAoZWl0aGVyIHVzZXMgcHJvdmlkZWQgbG9nZ2VyIG9yIGNvbnNvbGUubG9nLCBjYW4gYmUgdHVybmVkIG9mZilcbiAgICogQHBhcmFtIGFyZ3MgLSB0aGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGxvZ2dlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2xvZyguLi5hcmdzKSB7XG4gICAgaWYgKCF0aGlzLmxvZ2dpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlciA/IHRoaXMubG9nZ2VyKC4uLmFyZ3MpIDogY29uc29sZS5sb2coLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgd2FsbGV0IElEIG9mIHRoZSByZWNvdmVyeUNvaW4gd2FsbGV0LiBUaGlzIGlzIG5lZWRlZCB0byBmaW5kIHRoZSBwcml2YXRlIGtleXMgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB3YWxsZXRJZCB7U3RyaW5nfSB3YWxsZXQgSURcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBwcm90ZWN0ZWQgc2V0V2FsbGV0KHdhbGxldElkPzogc3RyaW5nLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8dm9pZD4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzx2b2lkPihmdW5jdGlvbiogc2V0V2FsbGV0KCkge1xuICAgICAgY29uc3QgY29pblR5cGUgPSBzZWxmLnJlY292ZXJ5Q29pbi5nZXRDaGFpbigpO1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQod2FsbGV0SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgd2FsbGV0IGlkJyk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuX2xvZyhgRmV0Y2hpbmcgJHtjb2luVHlwZX0gd2FsbGV0Li4uYCk7XG5cbiAgICAgIGlmIChzZWxmLnNvdXJjZUNvaW4udHlwZSAhPT0gY29pblR5cGUgJiYgc2VsZi5yZWNvdmVyeUNvaW4udHlwZSAhPT0gY29pblR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IGEgd2FsbGV0IGZvciB0aGlzIGNvaW4gdHlwZSAtIHRoaXMgaXMgbm90IGEgY29pbiBpbnZvbHZlZCBpbiB0aGUgcmVjb3ZlcnkgdHguJyk7XG4gICAgICB9XG5cbiAgICAgIGxldCB3YWxsZXQ6IFdhbGxldCB8IHVuZGVmaW5lZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdhbGxldCA9IHlpZWxkIHNlbGYuYml0Z29cbiAgICAgICAgICAuY29pbihjb2luVHlwZSlcbiAgICAgICAgICAud2FsbGV0cygpXG4gICAgICAgICAgLmdldCh7IGlkOiB3YWxsZXRJZCB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUuc3RhdHVzICE9PSA0MDQgJiYgZS5zdGF0dXMgIT09IDQwMCkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cblxuICAgICAgICB3YWxsZXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHdhbGxldCkgJiYgY29pblR5cGUuZW5kc1dpdGgoJ2J0YycpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2VsZi5fbG9nKCdDb3VsZCBub3QgZmluZCB2MiB3YWxsZXQuIEZhbGxpbmcgYmFjayB0byB2MS4uLicpO1xuICAgICAgICAgIHdhbGxldCA9IHlpZWxkIHNlbGYuYml0Z28ud2FsbGV0cygpLmdldCh7IGlkOiB3YWxsZXRJZCB9KTtcbiAgICAgICAgICAod2FsbGV0IGFzIGFueSkuaXNWMSA9IHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZS5zdGF0dXMgIT09IDQwNCkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQod2FsbGV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kICR7Y29pblR5cGV9IHdhbGxldC5gKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi53YWxsZXQgPSB3YWxsZXQ7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGFuZCBzdG9yZXMgdGhlIHVuc3BlbnRzIGZyb20gdGhlIGZhdWx0eSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gZmF1bHR5VHhJZCB7U3RyaW5nfSB0aGUgdHhpZCBvZiB0aGUgZmF1bHR5IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcHJvdGVjdGVkIGZpbmRVbnNwZW50cyhmYXVsdHlUeElkPzogc3RyaW5nLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uKiBmaW5kVW5zcGVudHMoKSB7XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChmYXVsdHlUeElkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgZmF1bHR5VHhJZCcpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9sb2coJ0dyYWJiaW5nIGluZm8gZm9yIGZhdWx0eSB0eC4uLicpO1xuXG4gICAgICBjb25zdCBUWF9JTkZPX1VSTCA9IHNlbGYuc291cmNlQ29pbi51cmwoYC9wdWJsaWMvdHgvJHtmYXVsdHlUeElkfWApO1xuICAgICAgY29uc3QgcmVzID0geWllbGQgcmVxdWVzdC5nZXQoVFhfSU5GT19VUkwpO1xuICAgICAgY29uc3QgZmF1bHR5VHhJbmZvID0gcmVzLmJvZHk7XG5cbiAgICAgIHNlbGYuX2xvZygnR2V0dGluZyB1bnNwZW50cyBvbiBvdXRwdXQgYWRkcmVzc2VzLi4nKTtcblxuICAgICAgLy8gR2V0IG91dHB1dCBhZGRyZXNzZXMgdGhhdCBkbyBub3QgYmVsb25nIHRvIHdhbGxldFxuICAgICAgLy8gVGhlc2UgYXJlIHdoZXJlIHRoZSAnbG9zdCBjb2lucycgbGl2ZVxuICAgICAgY29uc3QgdHhPdXRwdXRBZGRyZXNzZXMgPSBmYXVsdHlUeEluZm8ub3V0cHV0cy5tYXAoaW5wdXQgPT4gaW5wdXQuYWRkcmVzcyk7XG5cbiAgICAgIGxldCBvdXRwdXRBZGRyZXNzZXM6IHN0cmluZ1tdID0gW107XG4gICAgICBmb3IgKGxldCBhZGRyZXNzIG9mIHR4T3V0cHV0QWRkcmVzc2VzKSB7XG4gICAgICAgIGlmIChzZWxmLnNvdXJjZUNvaW4uZ2V0RmFtaWx5KCkgPT09ICdsdGMnKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSAoc2VsZi5zb3VyY2VDb2luIGFzIEx0YykuY2Fub25pY2FsQWRkcmVzcyhhZGRyZXNzLCAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5yZWNvdmVyeUNvaW4uZ2V0RmFtaWx5KCkgPT09ICdsdGMnKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSAoc2VsZi5yZWNvdmVyeUNvaW4gYXMgTHRjKS5jYW5vbmljYWxBZGRyZXNzKGFkZHJlc3MsIDIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgbWV0aG9kTmFtZSA9IHNlbGYud2FsbGV0LmlzVjEgPyAnYWRkcmVzcycgOiAnZ2V0QWRkcmVzcyc7XG4gICAgICAgICAgY29uc3Qgd2FsbGV0QWRkcmVzcyA9IHlpZWxkIHNlbGYud2FsbGV0W21ldGhvZE5hbWVdKHsgYWRkcmVzczogYWRkcmVzcyB9KTtcbiAgICAgICAgICBvdXRwdXRBZGRyZXNzZXMucHVzaCh3YWxsZXRBZGRyZXNzLmFkZHJlc3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc2VsZi5fbG9nKGBBZGRyZXNzICR7YWRkcmVzc30gbm90IGZvdW5kIG9uIHdhbGxldGApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvdXRwdXRBZGRyZXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ291bGQgbm90IGZpbmQgdHggb3V0cHV0cyBiZWxvbmdpbmcgdG8gdGhlIHNwZWNpZmllZCB3YWxsZXQuIFBsZWFzZSBjaGVjayB0aGUgZ2l2ZW4gcGFyYW1ldGVycy4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnJlY292ZXJ5Q29pbi5nZXRGYW1pbHkoKSA9PT0gJ2x0YycpIHtcbiAgICAgICAgb3V0cHV0QWRkcmVzc2VzID0gb3V0cHV0QWRkcmVzc2VzLm1hcChhZGRyZXNzID0+IChzZWxmLnJlY292ZXJ5Q29pbiBhcyBMdGMpLmNhbm9uaWNhbEFkZHJlc3MoYWRkcmVzcywgMSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5zb3VyY2VDb2luLmdldEZhbWlseSgpID09PSAnbHRjJykge1xuICAgICAgICBvdXRwdXRBZGRyZXNzZXMgPSBvdXRwdXRBZGRyZXNzZXMubWFwKGFkZHJlc3MgPT4gKHNlbGYuc291cmNlQ29pbiBhcyBMdGMpLmNhbm9uaWNhbEFkZHJlc3MoYWRkcmVzcywgMikpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9sb2coYEZpbmRpbmcgdW5zcGVudHMgZm9yIHRoZXNlIG91dHB1dCBhZGRyZXNzZXM6ICR7b3V0cHV0QWRkcmVzc2VzLmpvaW4oJywgJyl9YCk7XG5cbiAgICAgIC8vIEdldCB1bnNwZW50cyBmb3IgYWRkcmVzc2VzXG4gICAgICBjb25zdCBBRERSRVNTX1VOU1BFTlRTX1VSTCA9IHNlbGYuc291cmNlQ29pbi51cmwoYC9wdWJsaWMvYWRkcmVzc1Vuc3BlbnRzLyR7Xy51bmlxKG91dHB1dEFkZHJlc3Nlcykuam9pbignLCcpfWApO1xuICAgICAgY29uc3QgYWRkcmVzc1JlcyA9IHlpZWxkIHJlcXVlc3QuZ2V0KEFERFJFU1NfVU5TUEVOVFNfVVJMKTtcbiAgICAgIGNvbnN0IHVuc3BlbnRzID0gYWRkcmVzc1Jlcy5ib2R5O1xuXG4gICAgICBzZWxmLnVuc3BlbnRzID0gdW5zcGVudHM7XG4gICAgICByZXR1cm4gdW5zcGVudHM7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0cyB0cmFuc2FjdGlvbiBpbnB1dHMgZnJvbSBhIHNldCBvZiB1bnNwZW50cy5cbiAgICogQHBhcmFtIHVuc3BlbnRzIHtPYmplY3RbXX0gYXJyYXkgb2YgdW5zcGVudHMgZnJvbSB0aGUgZmF1bHR5IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBwYXJ0aWFsIHR4SW5mbyBvYmplY3Qgd2l0aCB0cmFuc2FjdGlvbiBpbnB1dHNcbiAgICovXG4gIHByb3RlY3RlZCBidWlsZElucHV0cyh1bnNwZW50cz86IGFueSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiogYnVpbGRJbnB1dHMoKSB7XG4gICAgICBzZWxmLl9sb2coJ0J1aWxkaW5nIGlucHV0cyBmb3IgcmVjb3ZlcnkgdHJhbnNhY3Rpb24uLi4nKTtcblxuICAgICAgdW5zcGVudHMgPSB1bnNwZW50cyB8fCBzZWxmLnVuc3BlbnRzO1xuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh1bnNwZW50cykgfHwgdW5zcGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgdW5zcGVudHMuIEVpdGhlciBzdXBwbHkgYW4gYXJndW1lbnQgb3IgY2FsbCBmaW5kVW5zcGVudHMnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHhJbmZvOiBhbnkgPSB7XG4gICAgICAgIGlucHV0QW1vdW50OiAwLFxuICAgICAgICBvdXRwdXRBbW91bnQ6IDAsXG4gICAgICAgIHNwZW5kQW1vdW50OiAwLFxuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgdW5zcGVudHM6IFtdLFxuICAgICAgICBleHRlcm5hbE91dHB1dHM6IFtdLFxuICAgICAgICBjaGFuZ2VPdXRwdXRzOiBbXSxcbiAgICAgICAgbWluZXJGZWU6IDAsXG4gICAgICAgIHBheUdvRmVlOiAwLFxuICAgICAgfTtcblxuICAgICAgbGV0IHRvdGFsRm91bmQgPSAwO1xuICAgICAgY29uc3Qgbm9TZWd3aXQgPSBzZWxmLnJlY292ZXJ5Q29pbi5nZXRGYW1pbHkoKSA9PT0gJ2J0YycgJiYgc2VsZi5zb3VyY2VDb2luLmdldEZhbWlseSgpID09PSAnYmNoJztcbiAgICAgIGZvciAoY29uc3QgdW5zcGVudCBvZiB1bnNwZW50cykge1xuICAgICAgICBpZiAodW5zcGVudC53aXRuZXNzU2NyaXB0ICYmIG5vU2Vnd2l0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1dhcm5pbmchIEl0IGFwcGVhcnMgb25lIG9mIHRoZSB1bnNwZW50cyBpcyBvbiBhIFNlZ3dpdCBhZGRyZXNzLiBUaGUgdG9vbCBvbmx5IHJlY292ZXJzIEJDSCBmcm9tIG5vbi1TZWd3aXQgQlRDIGFkZHJlc3Nlcy4gQWJvcnRpbmcuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2VhcmNoQWRkcmVzcyA9IHVuc3BlbnQuYWRkcmVzcztcblxuICAgICAgICBpZiAoc2VsZi5zb3VyY2VDb2luLnR5cGUuZW5kc1dpdGgoJ2x0YycpKSB7XG4gICAgICAgICAgc2VhcmNoQWRkcmVzcyA9IChzZWxmLnNvdXJjZUNvaW4gYXMgTHRjKS5jYW5vbmljYWxBZGRyZXNzKHNlYXJjaEFkZHJlc3MsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYucmVjb3ZlcnlDb2luLnR5cGUuZW5kc1dpdGgoJ2x0YycpKSB7XG4gICAgICAgICAgc2VhcmNoQWRkcmVzcyA9IChzZWxmLnJlY292ZXJ5Q29pbiBhcyBMdGMpLmNhbm9uaWNhbEFkZHJlc3Moc2VhcmNoQWRkcmVzcywgMik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdW5zcGVudEFkZHJlc3M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgbWV0aG9kTmFtZSA9IHNlbGYud2FsbGV0LmlzVjEgPyAnYWRkcmVzcycgOiAnZ2V0QWRkcmVzcyc7XG4gICAgICAgICAgdW5zcGVudEFkZHJlc3MgPSB5aWVsZCBzZWxmLndhbGxldFttZXRob2ROYW1lXSh7IGFkZHJlc3M6IHNlYXJjaEFkZHJlc3MgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzZWxmLl9sb2coYENvdWxkIG5vdCBmaW5kIGFkZHJlc3Mgb24gd2FsbGV0IGZvciAke3NlYXJjaEFkZHJlc3N9YCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLl9sb2coYEZvdW5kICR7dW5zcGVudC52YWx1ZSAqIDFlLTh9ICR7c2VsZi5zb3VyY2VDb2luLnR5cGV9IGF0IGFkZHJlc3MgJHt1bnNwZW50LmFkZHJlc3N9YCk7XG5cbiAgICAgICAgY29uc3QgW3R4SGFzaCwgaW5kZXhdID0gdW5zcGVudC5pZC5zcGxpdCgnOicpO1xuICAgICAgICBjb25zdCBpbnB1dEluZGV4ID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgICAgICAgbGV0IGhhc2ggPSBCdWZmZXIuZnJvbSh0eEhhc2gsICdoZXgnKTtcbiAgICAgICAgaGFzaCA9IEJ1ZmZlci5mcm9tKEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwoaGFzaCkpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2VsZi5yZWNvdmVyeVR4LmFkZElucHV0KGhhc2gsIGlucHV0SW5kZXgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBhZGRpbmcgdW5zcGVudCAke3Vuc3BlbnQuaWR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaW5wdXREYXRhID0ge307XG5cbiAgICAgICAgLy8gQWRkIHYxIHNwZWNpZmljIGlucHV0IGZpZWxkc1xuICAgICAgICBpZiAoc2VsZi53YWxsZXQuaXNWMSkge1xuICAgICAgICAgIGNvbnN0IGFkZHJlc3NJbmZvID0geWllbGQgc2VsZi53YWxsZXQuYWRkcmVzcyh7IGFkZHJlc3M6IHVuc3BlbnRBZGRyZXNzLmFkZHJlc3MgfSk7XG5cbiAgICAgICAgICB1bnNwZW50QWRkcmVzcy5wYXRoID0gdW5zcGVudEFkZHJlc3MucGF0aCB8fCBgLyR7dW5zcGVudEFkZHJlc3MuY2hhaW59LyR7dW5zcGVudEFkZHJlc3MuaW5kZXh9YDtcbiAgICAgICAgICBjb25zdCBbdHhpZCwgbk91dF0gPSB1bnNwZW50LmlkLnNwbGl0KCc6Jyk7XG5cbiAgICAgICAgICBpbnB1dERhdGEgPSB7XG4gICAgICAgICAgICByZWRlZW1TY3JpcHQ6IGFkZHJlc3NJbmZvLnJlZGVlbVNjcmlwdCxcbiAgICAgICAgICAgIHdpdG5lc3NTY3JpcHQ6IGFkZHJlc3NJbmZvLndpdG5lc3NTY3JpcHQsXG4gICAgICAgICAgICBwYXRoOiAnLzAvMCcgKyB1bnNwZW50QWRkcmVzcy5wYXRoLFxuICAgICAgICAgICAgY2hhaW5QYXRoOiB1bnNwZW50QWRkcmVzcy5wYXRoLFxuICAgICAgICAgICAgaW5kZXg6IHVuc3BlbnRBZGRyZXNzLmluZGV4LFxuICAgICAgICAgICAgY2hhaW46IHVuc3BlbnRBZGRyZXNzLmNoYWluLFxuICAgICAgICAgICAgdHhIYXNoOiB0eGlkLFxuICAgICAgICAgICAgdHhPdXRwdXROOiBwYXJzZUludChuT3V0LCAxMCksXG4gICAgICAgICAgICB0eFZhbHVlOiB1bnNwZW50LnZhbHVlLFxuICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KHVuc3BlbnQudmFsdWUsIDEwKSxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucHV0RGF0YSA9IHtcbiAgICAgICAgICAgIHJlZGVlbVNjcmlwdDogdW5zcGVudEFkZHJlc3MuY29pblNwZWNpZmljLnJlZGVlbVNjcmlwdCxcbiAgICAgICAgICAgIHdpdG5lc3NTY3JpcHQ6IHVuc3BlbnRBZGRyZXNzLmNvaW5TcGVjaWZpYy53aXRuZXNzU2NyaXB0LFxuICAgICAgICAgICAgaW5kZXg6IHVuc3BlbnRBZGRyZXNzLmluZGV4LFxuICAgICAgICAgICAgY2hhaW46IHVuc3BlbnRBZGRyZXNzLmNoYWluLFxuICAgICAgICAgICAgd2FsbGV0OiBzZWxmLndhbGxldC5pZCgpLFxuICAgICAgICAgICAgZnJvbVdhbGxldDogc2VsZi53YWxsZXQuaWQoKSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdHhJbmZvLmlucHV0cy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIHVuc3BlbnQsIGlucHV0RGF0YSkpO1xuXG4gICAgICAgIHR4SW5mby5pbnB1dEFtb3VudCArPSBwYXJzZUludCh1bnNwZW50LnZhbHVlLCAxMCk7XG4gICAgICAgIHRvdGFsRm91bmQgKz0gcGFyc2VJbnQodW5zcGVudC52YWx1ZSwgMTApO1xuICAgICAgfVxuXG4gICAgICB0eEluZm8udW5zcGVudHMgPSBfLmNsb25lKHR4SW5mby5pbnB1dHMpO1xuXG4gICAgICAvLyBOb3JtYWxpemUgdG90YWwgZm91bmQgdG8gYmFzZSB1bml0IGJlZm9yZSB3ZSBwcmludCBpdCBvdXRcbiAgICAgIHNlbGYuX2xvZyhgRm91bmQgbG9zdCAke3RvdGFsRm91bmQgKiAxZS04fSAke3NlbGYuc291cmNlQ29pbi50eXBlfS5gKTtcblxuICAgICAgc2VsZi50eEluZm8gPSB0eEluZm87XG4gICAgICByZXR1cm4gdHhJbmZvO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHR4SW5mby5taW5lckZlZSBmaWVsZCBieSBjYWxjdWxhdGluZyB0aGUgc2l6ZSBvZiB0aGUgdHJhbnNhY3Rpb24gYW5kIG11bHRpcGx5aW5nIGl0IGJ5IHRoZSBmZWUgcmF0ZSBmb3JcbiAgICogdGhlIHNvdXJjZSBjb2luLlxuICAgKiBAcGFyYW0gcmVjb3ZlcnlUeCB7T2JqZWN0fSByZWNvdmVyeSB0cmFuc2FjdGlvbiBjb250YWluaW5nIGlucHV0c1xuICAgKiBAcmV0dXJucyB7TnVtYmVyfSByZWNvdmVyeSBmZWUgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgcHJvdGVjdGVkIHNldEZlZXMocmVjb3ZlcnlUeD86IGFueSk6IG51bWJlciB7XG4gICAgcmVjb3ZlcnlUeCA9IHJlY292ZXJ5VHggfHwgdGhpcy5yZWNvdmVyeVR4O1xuXG4gICAgLy8gRGV0ZXJtaW5lIGZlZSB3aXRoIGRlZmF1bHQgZmVlIHJhdGVcbiAgICBjb25zdCBmZWVSYXRlID0gdGhpcy5mZWVSYXRlc1t0aGlzLnNvdXJjZUNvaW4udHlwZV07XG5cbiAgICAvLyBOb3RlIHRoYXQgd2UgYXNzdW1lIG9uZSBvdXRwdXQgaGVyZSAoYWxsIGZ1bmRzIHNob3VsZCBiZSByZWNvdmVyZWQgdG8gYSBzaW5nbGUgYWRkcmVzcylcbiAgICBjb25zdCB0eFNpemUgPVxuICAgICAgVmlydHVhbFNpemVzLnR4UDJzaElucHV0U2l6ZSAqIHJlY292ZXJ5VHgudHguaW5zLmxlbmd0aCArXG4gICAgICBWaXJ0dWFsU2l6ZXMudHhQMnBraE91dHB1dFNpemUgK1xuICAgICAgVmlydHVhbFNpemVzLnR4T3ZlcmhlYWRTaXplO1xuICAgIGNvbnN0IHJlY292ZXJ5RmVlID0gZmVlUmF0ZSAqIHR4U2l6ZTtcblxuICAgIGlmICh0aGlzLnR4SW5mbykge1xuICAgICAgdGhpcy50eEluZm8ubWluZXJGZWUgPSByZWNvdmVyeUZlZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjb3ZlcnlGZWU7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIHNpbmdsZSBvdXRwdXQgdG8gdGhlIHJlY292ZXJ5IGFkZHJlc3MuXG4gICAqIEBwYXJhbSByZWNvdmVyeUFkZHJlc3Mge1N0cmluZ30gYWRkcmVzcyB0byByZWNvdmVyIGZ1bmRzIHRvXG4gICAqIEBwYXJhbSBvdXRwdXRBbW91bnQge051bWJlcn0gYW1vdW50IHRvIHNlbmQgdG8gdGhlIHJlY292ZXJ5IGFkZHJlc3NcbiAgICogQHBhcmFtIHJlY292ZXJ5RmVlIHtOdW1iZXJ9IG1pbmVyIGZlZSBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwcm90ZWN0ZWQgYnVpbGRPdXRwdXRzKHJlY292ZXJ5QWRkcmVzczogc3RyaW5nLCBvdXRwdXRBbW91bnQ/OiBudW1iZXIsIHJlY292ZXJ5RmVlPzogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQob3V0cHV0QW1vdW50KSAmJiBfLmlzVW5kZWZpbmVkKHRoaXMudHhJbmZvKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB0cmFuc2FjdGlvbiBpbmZvLiBQbGVhc2UgcHJvdmlkZSBhbiBvdXRwdXQgYW1vdW50LCBvciBjYWxsIGJ1aWxkSW5wdXRzLicpO1xuICAgIH1cblxuICAgIHRoaXMuX2xvZyhgQnVpbGRpbmcgb3V0cHV0cyBmb3IgcmVjb3ZlcnkgdHJhbnNhY3Rpb24uIEZ1bmRzIHdpbGwgYmUgc2VudCB0byAke3JlY292ZXJ5QWRkcmVzc30uLi5gKTtcblxuICAgIGNvbnN0IHR4SW5wdXRBbW91bnQgPSBvdXRwdXRBbW91bnQgfHwgKHRoaXMudHhJbmZvICYmIHRoaXMudHhJbmZvLmlucHV0QW1vdW50KTtcbiAgICBjb25zdCB0eEZlZUFtb3VudCA9IHJlY292ZXJ5RmVlIHx8ICh0aGlzLnR4SW5mbyAmJiB0aGlzLnR4SW5mby5taW5lckZlZSk7XG5cbiAgICBpZiAoIXR4SW5wdXRBbW91bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IGRldGVybWluZSB0cmFuc2FjdGlvbiBpbnB1dCBhbW91bnQnKTtcbiAgICB9XG4gICAgaWYgKCF0eEZlZUFtb3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgZGV0ZXJtaW5lIHRyYW5zYWN0aW9uIGZlZSBhbW91bnQnKTtcbiAgICB9XG4gICAgY29uc3QgdHhPdXRwdXRBbW91bnQgPSB0eElucHV0QW1vdW50IC0gdHhGZWVBbW91bnQ7XG5cbiAgICBpZiAodHhPdXRwdXRBbW91bnQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIGNhbm5vdCBwYXkgaXRzIG93biBmZWVzLiBBYm9ydGluZy4nKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQodGhpcy50eEluZm8pKSB7XG4gICAgICB0aGlzLnR4SW5mby5vdXRwdXRBbW91bnQgPSB0eE91dHB1dEFtb3VudDtcbiAgICAgIHRoaXMudHhJbmZvLnNwZW5kQW1vdW50ID0gdHhPdXRwdXRBbW91bnQ7XG4gICAgfVxuXG4gICAgdGhpcy5yZWNvdmVyeUFkZHJlc3MgPSByZWNvdmVyeUFkZHJlc3M7XG4gICAgdGhpcy5yZWNvdmVyeUFtb3VudCA9IHR4T3V0cHV0QW1vdW50O1xuXG4gICAgdGhpcy5yZWNvdmVyeVR4LmFkZE91dHB1dChyZWNvdmVyeUFkZHJlc3MsIHR4T3V0cHV0QW1vdW50KTtcblxuICAgIGNvbnN0IG91dHB1dERhdGEgPSB7XG4gICAgICBhZGRyZXNzOiByZWNvdmVyeUFkZHJlc3MsXG4gICAgICB2YWx1ZTogb3V0cHV0QW1vdW50LFxuICAgICAgdmFsdWVTdHJpbmc6IHR4T3V0cHV0QW1vdW50LnRvU3RyaW5nKCksXG4gICAgICB3YWxsZXQ6IHRoaXMud2FsbGV0LmlkKCksXG4gICAgICBjaGFuZ2U6IGZhbHNlLFxuICAgIH07XG5cbiAgICBpZiAodGhpcy50eEluZm8pIHtcbiAgICAgIHRoaXMudHhJbmZvLm91dHB1dHMucHVzaChvdXRwdXREYXRhKTtcbiAgICAgIHRoaXMudHhJbmZvLmV4dGVybmFsT3V0cHV0cy5wdXNoKG91dHB1dERhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYWxmLXNpZ25zIHRoZSBidWlsdCB0cmFuc2FjdGlvbiB3aXRoIHRoZSB1c2VyJ3MgcHJpdmF0ZSBrZXkgb3Iga2V5Y2hhaW5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnBydiB7U3RyaW5nfSBwcml2YXRlIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zLnBhc3NwaHJhc2Uge1N0cmluZ30gd2FsbGV0IHBhc3NwaHJhc2VcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IGhhbGYtc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBTaWduUmVjb3ZlcnlUcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24qIHNpZ25UcmFuc2FjdGlvbigpIHtcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHNlbGYudHhJbmZvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHR4SW5mby4gUGxlYXNlIGJ1aWxkIGEgdHJhbnNhY3Rpb24nKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fbG9nKCdTaWduaW5nIHRoZSB0cmFuc2FjdGlvbi4uLicpO1xuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkhleCA9IHNlbGYucmVjb3ZlcnlUeC5idWlsZEluY29tcGxldGUoKS50b0hleCgpO1xuXG4gICAgICBjb25zdCBwcnY6IHN0cmluZyA9IF8uaXNTdHJpbmcocGFyYW1zLnBydikgPyBwYXJhbXMucHJ2IDogeWllbGQgc2VsZi5nZXRLZXlzKHBhcmFtcy5wYXNzcGhyYXNlKTtcblxuICAgICAgY29uc3QgdHhQcmVidWlsZCA9IHsgdHhIZXg6IHRyYW5zYWN0aW9uSGV4LCB0eEluZm86IHNlbGYudHhJbmZvIH07XG4gICAgICBzZWxmLmhhbGZTaWduZWRSZWNvdmVyeVR4ID0geWllbGQgc2VsZi5zb3VyY2VDb2luLnNpZ25UcmFuc2FjdGlvbih7IHR4UHJlYnVpbGQsIHBydiB9KTtcblxuICAgICAgcmV0dXJuIHNlbGYuaGFsZlNpZ25lZFJlY292ZXJ5VHg7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgd2FsbGV0J3MgZW5jcnlwdGVkIGtleWNoYWluLCB0aGVuIGRlY3J5cHRzIGl0IHdpdGggdGhlIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqIEBwYXJhbSBwYXNzcGhyYXNlIHtTdHJpbmd9IHdhbGxldCBwYXNzcGhyYXNlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBkZWNyeXB0ZWQgd2FsbGV0IHByaXZhdGUga2V5XG4gICAqL1xuICBnZXRLZXlzKHBhc3NwaHJhc2U6IHN0cmluZywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8c3RyaW5nPik6IEJsdWViaXJkPHN0cmluZz4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxzdHJpbmc+KGZ1bmN0aW9uKiBnZXRLZXlzKCkge1xuICAgICAgbGV0IHBydjtcblxuICAgICAgbGV0IGtleWNoYWluO1xuICAgICAgdHJ5IHtcbiAgICAgICAga2V5Y2hhaW4gPSB5aWVsZCBzZWxmLndhbGxldC5nZXRFbmNyeXB0ZWRVc2VyS2V5Y2hhaW4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUuc3RhdHVzICE9PSA0MDQpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhc3NwaHJhc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGhhdmUgYW4gZW5jcnlwdGVkIHVzZXIga2V5Y2hhaW4gLSBwbGVhc2UgcHJvdmlkZSB0aGUgcGFzc3BocmFzZSB0byBkZWNyeXB0IGl0Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLndhbGxldC5pc1YxKSB7XG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGtleWNoYWluKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVjEgd2FsbGV0cyBuZWVkIGEgdXNlciBrZXljaGFpbiAtIGNvdWxkIG5vdCBmaW5kIHRoZSBwcm9wZXIga2V5Y2hhaW4uIEFib3J0aW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGtleWNoYWluKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZW5jcnlwdGVkUHJ2ID0gc2VsZi53YWxsZXQuaXNWMSA/IGtleWNoYWluLmVuY3J5cHRlZFhwcnYgOiBrZXljaGFpbi5lbmNyeXB0ZWRQcnY7XG4gICAgICAgICAgcHJ2ID0gc2VsZi5iaXRnby5kZWNyeXB0KHsgaW5wdXQ6IGVuY3J5cHRlZFBydiwgcGFzc3dvcmQ6IHBhc3NwaHJhc2UgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHJlYWRpbmcgcHJpdmF0ZSBrZXkuIFBsZWFzZSBjaGVjayB0aGF0IHlvdSBoYXZlIHRoZSBjb3JyZWN0IHdhbGxldCBwYXNzcGhyYXNlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBydjtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIGJ1aWxkVHJhbnNhY3Rpb24ocGFyYW1zOiBCdWlsZFJlY292ZXJ5VHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uKiBidWlsZFRyYW5zYWN0aW9uKCkge1xuICAgICAgeWllbGQgc2VsZi5zZXRXYWxsZXQocGFyYW1zLndhbGxldCk7XG5cbiAgICAgIHlpZWxkIHNlbGYuZmluZFVuc3BlbnRzKHBhcmFtcy5mYXVsdHlUeElkKTtcbiAgICAgIHlpZWxkIHNlbGYuYnVpbGRJbnB1dHMoKTtcbiAgICAgIHNlbGYuc2V0RmVlcygpO1xuICAgICAgc2VsZi5idWlsZE91dHB1dHMocGFyYW1zLnJlY292ZXJ5QWRkcmVzcyk7XG5cbiAgICAgIHJldHVybiBzZWxmLnJlY292ZXJ5VHg7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICBidWlsZFVuc2lnbmVkKGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24qKCkge1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoc2VsZi50eEluZm8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgdHhJbmZvLiBQbGVhc2UgYnVpbGQgYSB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5jb21wbGV0ZSA9IHNlbGYucmVjb3ZlcnlUeC5idWlsZEluY29tcGxldGUoKTtcblxuICAgICAgY29uc3QgdHhJbmZvOiBhbnkgPSB7XG4gICAgICAgIG5QMlNISW5wdXRzOiAwLFxuICAgICAgICBuU2Vnd2l0SW5wdXRzOiAwLFxuICAgICAgfTtcblxuICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBzZWxmLnR4SW5mby5pbnB1dHMpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYWluID09PSAxMCB8fCBpbnB1dC5jaGFpbiA9PT0gMTEpIHtcbiAgICAgICAgICB0eEluZm8ublNlZ3dpdElucHV0cysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR4SW5mby5uUDJTSElucHV0cysrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHR4SW5mby5uT3V0cHV0cyA9IDE7XG4gICAgICB0eEluZm8udW5zcGVudHMgPSBfLm1hcChcbiAgICAgICAgc2VsZi50eEluZm8uaW5wdXRzLFxuICAgICAgICBfLnBhcnRpYWxSaWdodChfLnBpY2ssIFsnY2hhaW4nLCAnaW5kZXgnLCAncmVkZWVtU2NyaXB0JywgJ2lkJywgJ2FkZHJlc3MnLCAndmFsdWUnXSlcbiAgICAgICk7XG4gICAgICB0eEluZm8uY2hhbmdlQWRkcmVzc2VzID0gW107XG4gICAgICB0eEluZm8ud2FsbGV0QWRkcmVzc0RldGFpbHMgPSB7fTtcblxuICAgICAgY29uc3QgZmVlSW5mbzogYW55ID0ge307XG5cbiAgICAgIGZlZUluZm8uc2l6ZSA9XG4gICAgICAgIFZpcnR1YWxTaXplcy50eE92ZXJoZWFkU2l6ZSArXG4gICAgICAgIFZpcnR1YWxTaXplcy50eFAyc2hJbnB1dFNpemUgKiBzZWxmLnR4SW5mby5pbnB1dHMubGVuZ3RoICtcbiAgICAgICAgVmlydHVhbFNpemVzLnR4UDJwa2hPdXRwdXRTaXplO1xuXG4gICAgICBmZWVJbmZvLmZlZVJhdGUgPSBzZWxmLmZlZVJhdGVzW3NlbGYuc291cmNlQ29pbi50eXBlXTtcbiAgICAgIGZlZUluZm8uZmVlID0gTWF0aC5yb3VuZCgoZmVlSW5mby5zaXplIC8gMTAwMCkgKiBmZWVJbmZvLmZlZVJhdGUpO1xuICAgICAgZmVlSW5mby5wYXlHb0ZlZSA9IDA7XG4gICAgICBmZWVJbmZvLnBheUdvRmVlU3RyaW5nID0gJzAnO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eEhleDogaW5jb21wbGV0ZS50b0hleCgpLFxuICAgICAgICB0eEluZm86IHR4SW5mbyxcbiAgICAgICAgZmVlSW5mbzogZmVlSW5mbyxcbiAgICAgICAgd2FsbGV0SWQ6IHNlbGYud2FsbGV0LmlkKCksXG4gICAgICAgIGFtb3VudDogc2VsZi5yZWNvdmVyeUFtb3VudCxcbiAgICAgICAgYWRkcmVzczogc2VsZi5yZWNvdmVyeUFkZHJlc3MsXG4gICAgICAgIGNvaW46IHNlbGYuc291cmNlQ29pbi50eXBlLFxuICAgICAgfTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIGV4cG9ydCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvbjogdGhpcy53YWxsZXQuaXNWMSA/IDEgOiAyLFxuICAgICAgc291cmNlQ29pbjogdGhpcy5zb3VyY2VDb2luLnR5cGUsXG4gICAgICByZWNvdmVyeUNvaW46IHRoaXMucmVjb3ZlcnlDb2luLnR5cGUsXG4gICAgICB3YWxsZXRJZDogdGhpcy53YWxsZXQuaWQoKSxcbiAgICAgIHJlY292ZXJ5QWRkcmVzczogdGhpcy5yZWNvdmVyeUFkZHJlc3MsXG4gICAgICByZWNvdmVyeUFtb3VudDogdGhpcy5yZWNvdmVyeUFtb3VudCxcbiAgICAgIHR4SGV4OiB0aGlzLmhhbGZTaWduZWRSZWNvdmVyeVR4ICYmICh0aGlzLmhhbGZTaWduZWRSZWNvdmVyeVR4LnR4SGV4IHx8IHRoaXMuaGFsZlNpZ25lZFJlY292ZXJ5VHgudHgpLFxuICAgICAgdHhJbmZvOiB0aGlzLnR4SW5mbyxcbiAgICB9O1xuICB9XG59XG4iXX0=