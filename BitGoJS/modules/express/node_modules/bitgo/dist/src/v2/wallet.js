"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_js_1 = require("bignumber.js");
var Bluebird = require("bluebird");
var _ = require("lodash");
var debugLib = require("debug");
var bitcoin_1 = require("../bitcoin");
var common = require("../common");
var errors_1 = require("../errors");
var internal = require("./internal/internal");
var keycard_1 = require("./internal/keycard");
var tradingAccount_1 = require("./trading/tradingAccount");
var pendingApproval_1 = require("./pendingApproval");
var util_1 = require("./internal/util");
var debug = debugLib('bitgo:v2:wallet');
var co = Bluebird.coroutine;
var Wallet = /** @class */ (function () {
    function Wallet(bitgo, baseCoin, walletData) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
        this._wallet = walletData;
        var userId = _.get(bitgo, '_user.id');
        if (_.isString(userId)) {
            var userDetails = _.find(walletData.users, { user: userId });
            this._permissions = _.get(userDetails, 'permissions');
        }
    }
    /**
     * Build a URL using this wallet's id which can be used for BitGo API operations
     * @param extra API specific string to append to the wallet id
     */
    Wallet.prototype.url = function (extra) {
        if (extra === void 0) { extra = ''; }
        return this.baseCoin.url('/wallet/' + this.id() + extra);
    };
    /**
     * Get this wallet's id
     */
    Wallet.prototype.id = function () {
        return this._wallet.id;
    };
    /**
     * Get the number of approvals required for spending funds from this wallet
     */
    Wallet.prototype.approvalsRequired = function () {
        return this._wallet.approvalsRequired;
    };
    /**
     * Get the current balance of this wallet
     */
    Wallet.prototype.balance = function () {
        return this._wallet.balance;
    };
    Wallet.prototype.prebuildWhitelistedParams = function () {
        return [
            'addressType', 'changeAddress', 'consolidateAddresses', 'cpfpFeeRate', 'cpfpTxIds', 'enforceMinConfirmsForChange',
            'feeRate', 'gasLimit', 'gasPrice', 'idfSignedTimestamp', 'idfUserId', 'idfVersion', 'instant',
            'lastLedgerSequence', 'ledgerSequenceDelta', 'maxFee', 'maxFeeRate', 'maxValue', 'memo', 'message', 'minConfirms',
            'minValue', 'noSplitChange', 'numBlocks', 'recipients', 'reservation', 'sequenceId', 'strategy',
            'targetWalletUnspents', 'trustlines', 'type', 'unspents', 'validFromBlock', 'validToBlock',
        ];
    };
    /**
     * This is a strict sub-set of prebuildWhitelistedParams
     */
    Wallet.prototype.prebuildConsolidateAccountParams = function () {
        return [
            'consolidateAddresses', 'feeRate', 'maxFeeRate', 'memo', 'validFromBlock', 'validToBlock',
        ];
    };
    /**
     * Get the confirmed balance of this wallet
     */
    Wallet.prototype.confirmedBalance = function () {
        return this._wallet.confirmedBalance;
    };
    /**
     * Get the spendable balance of this wallet
     */
    Wallet.prototype.spendableBalance = function () {
        return this._wallet.spendableBalance;
    };
    /**
     * Get a string representation of the balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    Wallet.prototype.balanceString = function () {
        return this._wallet.balanceString;
    };
    /**
     * Get a string representation of the confirmed balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    Wallet.prototype.confirmedBalanceString = function () {
        return this._wallet.confirmedBalanceString;
    };
    /**
     * Get a string representation of the spendable balance of this wallet
     *
     * This is useful when balances have the potential to overflow standard javascript numbers
     */
    Wallet.prototype.spendableBalanceString = function () {
        return this._wallet.spendableBalanceString;
    };
    /**
     * Get the coin identifier for the type of coin this wallet holds
     */
    Wallet.prototype.coin = function () {
        return this._wallet.coin;
    };
    /**
     * Get the label (name) for this wallet
     */
    Wallet.prototype.label = function () {
        return this._wallet.label;
    };
    /**
     * Get the public object ids for the keychains on this wallet.
     */
    Wallet.prototype.keyIds = function () {
        return this._wallet.keys;
    };
    /**
     * Get a receive address for this wallet
     */
    Wallet.prototype.receiveAddress = function () {
        return this._wallet.receiveAddress.address;
    };
    /**
     * Get the wallet id of the wallet that this wallet was migrated from.
     *
     * For example, if this is a BCH wallet that was created from a BTC wallet,
     * the BCH wallet migrated from field would have the BTC wallet id.
     */
    Wallet.prototype.migratedFrom = function () {
        return this._wallet.migratedFrom;
    };
    /**
     * Return the token flush thresholds for this wallet
     * @return {*|Object} pairs of { [tokenName]: thresholds } base units
     */
    Wallet.prototype.tokenFlushThresholds = function () {
        if (this.baseCoin.getFamily() !== 'eth') {
            throw new Error('not supported for this wallet');
        }
        return this._wallet.coinSpecific.tokenFlushThresholds;
    };
    /**
     * Get wallet properties which are specific to certain coin implementations
     */
    Wallet.prototype.coinSpecific = function () {
        return this._wallet.coinSpecific;
    };
    /**
     * Get all pending approvals on this wallet
     */
    Wallet.prototype.pendingApprovals = function () {
        var _this = this;
        return this._wallet.pendingApprovals.map(function (currentApproval) {
            return new pendingApproval_1.PendingApproval(_this.bitgo, _this.baseCoin, currentApproval, _this);
        });
    };
    /**
     * Refresh the wallet object by syncing with the back-end
     * @param params
     * @param callback
     * @returns {Wallet}
     */
    Wallet.prototype.refresh = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = self;
                        return [4 /*yield*/, self.bitgo.get(self.url()).result()];
                    case 1:
                        _a._wallet = _b.sent();
                        return [2 /*return*/, this];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * List the transactions for a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.transactions = function (params, callback) {
        if (params === void 0) { params = {}; }
        var query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        return this.bitgo.get(this.baseCoin.url('/wallet/' + this._wallet.id + '/tx'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * List the transactions for a given wallet
     * @param params
     *  - txHash the transaction hash to search for
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.getTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['txHash'], [], callback);
        var query = {};
        if (!_.isUndefined(params.prevId)) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (!_.isUndefined(params.limit)) {
            if (!_.isInteger(params.limit) || params.limit < 1) {
                throw new Error('invalid limit argument, expecting positive integer');
            }
            query.limit = params.limit;
        }
        return this.bitgo.get(this.url('/tx/' + params.txHash))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * List the transfers for a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.transfers = function (params, callback) {
        if (params === void 0) { params = {}; }
        var query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        if (params.allTokens) {
            if (!_.isBoolean(params.allTokens)) {
                throw new Error('invalid allTokens argument, expecting boolean');
            }
            query.allTokens = params.allTokens;
        }
        if (params.searchLabel) {
            if (!_.isString(params.searchLabel)) {
                throw new Error('invalid searchLabel argument, expecting string');
            }
            query.searchLabel = params.searchLabel;
        }
        if (params.address) {
            if (!_.isArray(params.address) && !_.isString(params.address)) {
                throw new Error('invalid address argument, expecting string or array');
            }
            if (_.isArray(params.address)) {
                params.address.forEach(function (address) {
                    if (!_.isString(address)) {
                        throw new Error('invalid address argument, expecting array of address strings');
                    }
                });
            }
            query.address = params.address;
        }
        if (params.dateGte) {
            if (!_.isString(params.dateGte)) {
                throw new Error('invalid dateGte argument, expecting string');
            }
            query.dateGte = params.dateGte;
        }
        if (params.dateLt) {
            if (!_.isString(params.dateLt)) {
                throw new Error('invalid dateLt argument, expecting string');
            }
            query.dateLt = params.dateLt;
        }
        if (!_.isNil(params.valueGte)) {
            if (!_.isNumber(params.valueGte)) {
                throw new Error('invalid valueGte argument, expecting number');
            }
            query.valueGte = params.valueGte;
        }
        if (!_.isNil(params.valueLt)) {
            if (!_.isNumber(params.valueLt)) {
                throw new Error('invalid valueLt argument, expecting number');
            }
            query.valueLt = params.valueLt;
        }
        if (!_.isNil(params.includeHex)) {
            if (!_.isBoolean(params.includeHex)) {
                throw new Error('invalid includeHex argument, expecting boolean');
            }
            query.includeHex = params.includeHex;
        }
        if (!_.isNil(params.state)) {
            if (!Array.isArray(params.state) && !_.isString(params.state)) {
                throw new Error('invalid state argument, expecting string or array');
            }
            if (Array.isArray(params.state)) {
                params.state.forEach(function (state) {
                    if (!_.isString(state)) {
                        throw new Error('invalid state argument, expecting array of state strings');
                    }
                });
            }
            query.state = params.state;
        }
        if (!_.isNil(params.type)) {
            if (!_.isString(params.type)) {
                throw new Error('invalid type argument, expecting string');
            }
            query.type = params.type;
        }
        return this.bitgo.get(this.url('/transfer'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * Get transfers on this wallet
     * @param params
     * @param callback
     */
    Wallet.prototype.getTransfer = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['id'], [], callback);
        return this.bitgo.get(this.url('/transfer/' + params.id))
            .result()
            .nodeify(callback);
    };
    /**
     * Get a transaction by sequence id for a given wallet
     * @param params
     * @param callback
     */
    Wallet.prototype.transferBySequenceId = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['sequenceId'], [], callback);
        return this.bitgo.get(this.url('/transfer/sequenceId/' + params.sequenceId))
            .result()
            .nodeify(callback);
    };
    /**
     * Get the maximum amount you can spend in a single transaction
     *
     * @param {Object} params - parameters object
     * @param {Number} params.limit - maximum number of selectable unspents
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
     * @param {Number} params.feeRate - fee rate to use in calculation of maximum spendable in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {String} params.recipientAddress - recipient addresses for a more accurate calculation of the maximum available to send
     * @param callback
     * @returns {{maximumSpendable: Number, coin: String}}
     * NOTE : feeTxConfirmTarget omitted on purpose because gauging the maximum spendable amount with dynamic fees does not make sense
     */
    Wallet.prototype.maximumSpendable = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var filteredParams;
            return __generator(this, function (_a) {
                filteredParams = _.pick(params, [
                    'enforceMinConfirmsForChange', 'feeRate', 'limit', 'maxFeeRate', 'maxValue', 'minConfirms', 'minHeight',
                    'minValue', 'plainTarget', 'recipientAddress', 'target',
                ]);
                return [2 /*return*/, self.bitgo.get(self.url('/maximumSpendable'))
                        .query(filteredParams)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * List the unspents for a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.unspents = function (params, callback) {
        if (params === void 0) { params = {}; }
        var query = _.pick(params, [
            'chains', 'limit', 'maxValue', 'minConfirms', 'minHeight', 'minValue', 'prevId', 'segwit', 'target',
        ]);
        return this.bitgo.get(this.url('/unspents'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * Consolidate or fanout unspents on a wallet
     *
     * @param {String} routeName - either `consolidate` or `fanout`
     *
     * @param {Object} params - parameters object
     *
     * Wallet parameters:
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     *
     * Fee parameters:
     * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     *
     * Input parameters:
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - if true, minConfirms also applies to change outputs
     * @param {Number} params.limit                for routeName === 'consolidate'
     *                 params.maxNumInputsToUse    for routeName === 'fanout'
     *                  - maximum number of unspents you want to use in the transaction
     * Output parameters:
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     *
     * @param callback
     */
    Wallet.prototype.manageUnspents = function (routeName, params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var reqId, filteredParams, response, keychain, transactionParams, signedTransaction, selectParams, finalTxParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, [], ['walletPassphrase', 'xprv'], callback);
                        reqId = new util_1.RequestTracer();
                        filteredParams = _.pick(params, [
                            'feeRate',
                            'maxFeeRate',
                            'maxFeePercentage',
                            'feeTxConfirmTarget',
                            'minValue',
                            'maxValue',
                            'minHeight',
                            'minConfirms',
                            'enforceMinConfirmsForChange',
                            'targetAddress',
                            routeName === 'consolidate' ? 'limit' : 'maxNumInputsToUse',
                            'numUnspentsToMake',
                        ]);
                        self.bitgo.setRequestTracer(reqId);
                        return [4 /*yield*/, self.bitgo.post(self.url("/" + routeName + "Unspents"))
                                .send(filteredParams)
                                .result()];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, self.baseCoin.keychains().get({ id: self._wallet.keys[0], reqId: reqId })];
                    case 2:
                        keychain = _a.sent();
                        transactionParams = _.extend({}, params, { txPrebuild: response, keychain: keychain });
                        return [4 /*yield*/, self.signTransaction(transactionParams)];
                    case 3:
                        signedTransaction = _a.sent();
                        selectParams = _.pick(params, ['comment', 'otp']);
                        finalTxParams = _.extend({}, signedTransaction, selectParams);
                        self.bitgo.setRequestTracer(reqId);
                        return [2 /*return*/, self.bitgo.post(self.baseCoin.url('/wallet/' + self._wallet.id + '/tx/send'))
                                .send(finalTxParams)
                                .result()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Consolidate unspents on a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {Number} params.feeRate - The fee rate to use for the consolidation in satoshis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.maxFeePercentage - the maximum relative portion that you're willing to spend towards fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     * @param {Number} params.minValue - the minimum value of unspents to use in satoshis
     * @param {Number} params.maxValue - the maximum value of unspents to use in satoshis
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - if true, minConfirms also applies to change outputs
     * @param {Number} params.limit                for routeName === 'consolidate'
     *                 params.maxNumInputsToUse    for routeName === 'fanout'
     *                  - maximum number of unspents you want to use in the transaction
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     * @param callback
     */
    Wallet.prototype.consolidateUnspents = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.manageUnspents('consolidate', params, callback);
    };
    /**
     * Fanout unspents on a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {Number} params.minValue - the minimum value of unspents to use
     * @param {Number} params.maxValue - the maximum value of unspents to use
     * @param {Number} params.minHeight - the minimum height of unspents on the block chain to use
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Number} params.maxFeePercentage - the maximum proportion of an unspent you are willing to lose to fees
     * @param {Number} params.feeTxConfirmTarget - estimate the fees to aim for first confirmation with this number of blocks
     * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
     * @param {Number} params.maxFeeRate - The max limit for a fee rate in satoshis/kB
     * @param {Number} params.maxNumInputsToUse - the number of unspents you want to use in the transaction
     * @param {Number} params.numUnspentsToMake - the number of new unspents to make
     * @param callback
     */
    Wallet.prototype.fanoutUnspents = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.manageUnspents('fanout', params, callback);
    };
    /**
     * Set the token flush thresholds for the wallet. Updates the wallet.
     * Tokens will only be flushed from forwarder contracts if the balance is greater than the threshold defined here.
     * @param thresholds {Object} - pairs of { [tokenName]: threshold } (base units)
     * @param [callback]
     */
    Wallet.prototype.updateTokenFlushThresholds = function (thresholds, callback) {
        if (thresholds === void 0) { thresholds = {}; }
        var self = this;
        return co(function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (self.baseCoin.getFamily() !== 'eth') {
                            throw new Error('not supported for this wallet');
                        }
                        _a = self;
                        return [4 /*yield*/, self.bitgo.put(self.url()).send({
                                tokenFlushThresholds: thresholds
                            }).result()];
                    case 1:
                        _a._wallet = _b.sent();
                        return [2 /*return*/];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Sweep funds for a wallet
     *
     * @param {Object} params - parameters object
     * @param {String} params.address - The address to send all the funds in the wallet to
     * @param {String} params.walletPassphrase - the users wallet passphrase
     * @param {String} params.xprv - the private key in string form if the walletPassphrase is not available
     * @param {String} params.otp - Two factor auth code to enable sending the transaction
     * @param {Number} params.feeTxConfirmTarget - Estimate the fees to aim for first confirmation within this number of blocks
     * @param {Number} params.feeRate - The desired fee rate for the transaction in satoshis/kB
     * @param {Number} [params.maxFeeRate] - upper limit for feeRate in satoshis/kB
     * @param {Boolean} [params.allowPartialSweep] - allows sweeping 200 unspents when the wallet has more than that
     * @param [callback]
     * @returns txHex {String} the txHex of the signed transaction
     */
    Wallet.prototype.sweep = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var value, reqId, filteredParams, response, keychain, transactionParams, signedTransaction, selectParams, finalTxParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = params || {};
                        common.validateParams(params, ['address'], ['walletPassphrase', 'xprv', 'otp'], callback);
                        if (['eth', 'xrp'].includes(self.baseCoin.getFamily())) {
                            if (self.confirmedBalanceString() !== self.balanceString()) {
                                throw new Error('cannot sweep when unconfirmed funds exist on the wallet, please wait until all inbound transactions confirm');
                            }
                            value = self.spendableBalanceString();
                            if (_.isUndefined(value) || value === '0') {
                                throw new Error('no funds to sweep');
                            }
                            params.recipients = [{
                                    address: params.address,
                                    amount: value,
                                }];
                            return [2 /*return*/, self.sendMany(params)];
                        }
                        reqId = new util_1.RequestTracer();
                        filteredParams = _.pick(params, ['address', 'feeRate', 'maxFeeRate', 'feeTxConfirmTarget', 'allowPartialSweep']);
                        self.bitgo.setRequestTracer(reqId);
                        return [4 /*yield*/, self.bitgo.post(self.url('/sweepWallet'))
                                .send(filteredParams)
                                .result()];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, self.baseCoin.keychains().get({ id: self._wallet.keys[0], reqId: reqId })];
                    case 2:
                        keychain = _a.sent();
                        transactionParams = _.extend({}, params, { txPrebuild: response, keychain: keychain, prv: params.xprv });
                        return [4 /*yield*/, self.signTransaction(transactionParams)];
                    case 3:
                        signedTransaction = _a.sent();
                        selectParams = _.pick(params, ['otp']);
                        finalTxParams = _.extend({}, signedTransaction, selectParams);
                        self.bitgo.setRequestTracer(reqId);
                        return [2 /*return*/, self.bitgo.post(self.baseCoin.url('/wallet/' + self._wallet.id + '/tx/send'))
                                .send(finalTxParams)
                                .result()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Freeze a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.freeze = function (params, callback) {
        if (params === void 0) { params = {}; }
        params = params || {};
        common.validateParams(params, [], [], callback);
        if (params.duration) {
            if (!_.isNumber(params.duration)) {
                throw new Error('invalid duration: should be number of seconds');
            }
        }
        return this.bitgo.post(this.url('/freeze'))
            .result()
            .nodeify(callback);
    };
    /**
     * Update comment of a transfer
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.transferComment = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['id'], ['comment'], callback);
        return this.bitgo.post(this.baseCoin.url('/wallet/' + this._wallet.id + '/transfer/' + params.id + '/comment'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * List the addresses for a given wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.addresses = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, [], [], callback);
        var query = {};
        if (params.mine) {
            query.mine = !!params.mine;
        }
        if (!_.isUndefined(params.prevId)) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.sort) {
            if (!_.isNumber(params.sort)) {
                throw new Error('invalid sort argument, expecting number');
            }
            query.sort = params.sort;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        if (params.labelContains) {
            if (!_.isString(params.labelContains)) {
                throw new Error('invalid labelContains argument, expecting string');
            }
            query.labelContains = params.labelContains;
        }
        if (!_.isUndefined(params.segwit)) {
            if (!_.isBoolean(params.segwit)) {
                throw new Error('invalid segwit argument, expecting boolean');
            }
            query.segwit = params.segwit;
        }
        if (!_.isUndefined(params.chains)) {
            if (!_.isArray(params.chains)) {
                throw new Error('invalid chains argument, expecting array of numbers');
            }
            query.chains = params.chains;
        }
        return this.bitgo.get(this.baseCoin.url('/wallet/' + this._wallet.id + '/addresses'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * Get a single wallet address by its id
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.getAddress = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, [], ['address', 'id'], callback);
        var query;
        if (_.isUndefined(params.address) && _.isUndefined(params.id)) {
            throw new Error('address or id of address required');
        }
        if (params.address) {
            query = params.address;
        }
        else {
            query = params.id;
        }
        if (params.reqId) {
            this.bitgo.setRequestTracer(params.reqId);
        }
        return this.bitgo.get(this.baseCoin.url("/wallet/" + this._wallet.id + "/address/" + encodeURIComponent(query)))
            .result()
            .nodeify(callback);
    };
    /**
     * Create one or more new address(es) for use with this wallet.
     *
     * If the `count` field is defined and greater than 1, an object with a single
     * array property named `addresses` containing `count` address objects
     * will be returned. Otherwise, a single address object is returned.
     *
     * @param params
     * @param {Number} params.chain on which the new address should be created
     * @param {(Number|String)} params.gasPrice gas price for new address creation, if applicable
     * @param {String} params.label label for the new address(es)
     * @param {Number} params.count=1 number of new addresses which should be created (maximum 250)
     * @param {Boolean} params.lowPriority Ethereum-specific param to create address using low priority fee address
     * @param callback
     */
    Wallet.prototype.createAddress = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var addressParams, reqId, chain, gasPrice, label, lowPriority, _a, count, keychains, rootAddress, newAddresses, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        addressParams = {};
                        reqId = new util_1.RequestTracer();
                        chain = params.chain, gasPrice = params.gasPrice, label = params.label, lowPriority = params.lowPriority, _a = params.count, count = _a === void 0 ? 1 : _a;
                        if (!_.isUndefined(chain)) {
                            if (!_.isInteger(chain)) {
                                throw new Error('chain has to be an integer');
                            }
                            addressParams.chain = chain;
                        }
                        if (!_.isUndefined(gasPrice)) {
                            if (!_.isInteger(gasPrice) && (isNaN(Number(gasPrice)) || !_.isString(gasPrice))) {
                                throw new Error('gasPrice has to be an integer or numeric string');
                            }
                            addressParams.gasPrice = gasPrice;
                        }
                        if (!_.isUndefined(label)) {
                            if (!_.isString(label)) {
                                throw new Error('label has to be a string');
                            }
                            addressParams.label = label;
                        }
                        if (!_.isInteger(count) || count <= 0 || count > 250) {
                            throw new Error('count has to be a number between 1 and 250');
                        }
                        if (!_.isUndefined(lowPriority)) {
                            if (!_.isBoolean(lowPriority)) {
                                throw new Error('lowPriority has to be a boolean');
                            }
                            addressParams.lowPriority = lowPriority;
                        }
                        return [4 /*yield*/, Bluebird.map(self._wallet.keys, function (k) { return self.baseCoin.keychains().get({ id: k, reqId: reqId }); })];
                    case 1:
                        keychains = _c.sent();
                        rootAddress = _.get(self._wallet, 'receiveAddress.address');
                        newAddresses = _.times(count, co(function createAndVerifyAddress() {
                            var newAddress, AbstractUtxoCoin_1, verificationData;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        self.bitgo.setRequestTracer(reqId);
                                        return [4 /*yield*/, self.bitgo.post(self.baseCoin.url('/wallet/' + self._wallet.id + '/address'))
                                                .send(addressParams)
                                                .result()];
                                    case 1:
                                        newAddress = _a.sent();
                                        // infer its address type
                                        if (_.isObject(newAddress.coinSpecific)) {
                                            AbstractUtxoCoin_1 = require('./coins/abstractUtxoCoin').AbstractUtxoCoin;
                                            newAddress.addressType = AbstractUtxoCoin_1.inferAddressType(newAddress);
                                        }
                                        newAddress.keychains = keychains;
                                        verificationData = _.merge({}, newAddress, { rootAddress: rootAddress });
                                        if (verificationData.error) {
                                            throw new errors_1.AddressGenerationError(verificationData.error);
                                        }
                                        if (verificationData.coinSpecific && !verificationData.coinSpecific.pendingChainInitialization) {
                                            // can't verify addresses which are pending chain initialization, as the address is hidden
                                            self.baseCoin.verifyAddress(verificationData);
                                        }
                                        return [2 /*return*/, newAddress];
                                }
                            });
                        }).bind(this));
                        if (newAddresses.length === 1) {
                            return [2 /*return*/, newAddresses[0]];
                        }
                        _b = {};
                        return [4 /*yield*/, Promise.all(newAddresses)];
                    case 2: return [2 /*return*/, (_b.addresses = _c.sent(),
                            _b)];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Update properties on an address
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.updateAddress = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var address, putParams, url;
            return __generator(this, function (_a) {
                address = params.address;
                if (!_.isString(address)) {
                    throw new Error('missing required string parameter address');
                }
                putParams = _.pick(params, ['label']);
                url = self.url('/address/' + encodeURIComponent(address));
                return [2 /*return*/, self.bitgo.put(url).send(putParams).result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * List webhooks on this wallet
     * @param params
     * @param callback
     */
    Wallet.prototype.listWebhooks = function (params, callback) {
        if (params === void 0) { params = {}; }
        var query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        return this.bitgo.get(this.url('/webhooks'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * Simulate wallet webhook, currently for webhooks of type transfer and pending approval
     * @param params
     * - webhookId (required) id of the webhook to be simulated
     * - transferId (optional but required for transfer webhooks) id of the simulated transfer
     * - pendingApprovalId (optional but required for pending approval webhooks) id of the simulated pending approval
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.simulateWebhook = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['webhookId'], ['transferId', 'pendingApprovalId'], callback);
        var hasTransferId = !!params.transferId;
        var hasPendingApprovalId = !!params.pendingApprovalId;
        if (!hasTransferId && !hasPendingApprovalId) {
            throw new Error('must supply either transferId or pendingApprovalId');
        }
        if (hasTransferId && hasPendingApprovalId) {
            throw new Error('must supply either transferId or pendingApprovalId, but not both');
        }
        // depending on the coin type of the wallet, the txHash has to adhere to its respective format
        // but the server takes care of that
        // only take the transferId and pendingApprovalId properties
        var filteredParams = _.pick(params, ['transferId', 'pendingApprovalId']);
        var webhookId = params.webhookId;
        return this.bitgo.post(this.url('/webhooks/' + webhookId + '/simulate'))
            .send(filteredParams)
            .result()
            .nodeify(callback);
    };
    /**
     * Add a webhook to this wallet
     * @param params
     * @param callback
     */
    Wallet.prototype.addWebhook = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['url', 'type'], [], callback);
        return this.bitgo.post(this.url('/webhooks'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Remove a webhook from this wallet
     * @param params
     * @param callback
     */
    Wallet.prototype.removeWebhook = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['url', 'type'], [], callback);
        return this.bitgo.del(this.url('/webhooks'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Gets the user key chain for this wallet
     *
     * The user key chain is the first keychain of the wallet and usually has the encrypted prv stored on BitGo.
     * Useful when trying to get the users' keychain from the server before decrypting to sign a transaction.
     * @param params
     * @param callback
     */
    Wallet.prototype.getEncryptedUserKeychain = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        var tryKeyChain = co(function (index) {
            var params, keychain;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!self._wallet.keys || index >= self._wallet.keys.length) {
                            throw new Error('No encrypted keychains on this wallet.');
                        }
                        params = { id: self._wallet.keys[index] };
                        return [4 /*yield*/, self.baseCoin.keychains().get(params)];
                    case 1:
                        keychain = _a.sent();
                        // If we find the prv, then this is probably the user keychain we're looking for
                        if (keychain.encryptedPrv) {
                            return [2 /*return*/, keychain];
                        }
                        return [2 /*return*/, tryKeyChain(index + 1)];
                }
            });
        }).bind(this);
        return tryKeyChain(0).nodeify(callback);
    };
    /**
     * Gets the unencrypted private key for this wallet (be careful!)
     * Requires wallet passphrase
     *
     * @param params
     * @param callback
     */
    Wallet.prototype.getPrv = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var userKeychain, userEncryptedPrv, userPrv;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, [], ['walletPassphrase', 'prv'], callback);
                        // Prepare signing key
                        if (_.isUndefined(params.prv) && _.isUndefined(params.walletPassphrase)) {
                            throw new Error('must either provide prv or wallet passphrase');
                        }
                        if (!_.isUndefined(params.prv) && !_.isString(params.prv)) {
                            throw new Error('prv must be a string');
                        }
                        if (!_.isUndefined(params.walletPassphrase) && !_.isString(params.walletPassphrase)) {
                            throw new Error('walletPassphrase must be a string');
                        }
                        if (params.prv) {
                            return [2 /*return*/, params.prv];
                        }
                        return [4 /*yield*/, self.getEncryptedUserKeychain()];
                    case 1:
                        userKeychain = _a.sent();
                        userEncryptedPrv = userKeychain.encryptedPrv;
                        try {
                            userPrv = self.bitgo.decrypt({ input: userEncryptedPrv, password: params.walletPassphrase });
                        }
                        catch (e) {
                            throw new Error('error decrypting wallet passphrase');
                        }
                        return [2 /*return*/, userPrv];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Send an encrypted wallet share to BitGo.
     * @param params
     * @param callback
     */
    Wallet.prototype.createShare = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['user', 'permissions'], [], callback);
        if (params.keychain && !_.isEmpty(params.keychain)) {
            if (!params.keychain.pub || !params.keychain.encryptedPrv || !params.keychain.fromPubKey || !params.keychain.toPubKey || !params.keychain.path) {
                throw new Error('requires keychain parameters - pub, encryptedPrv, fromPubKey, toPubKey, path');
            }
        }
        return this.bitgo.post(this.url('/share'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Share this wallet with another BitGo user.
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.shareWallet = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var needsKeychain, sharing, sharedKeychain, keychain, eckey, secret, newEncryptedPrv, e_1, options;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, ['email', 'permissions'], ['walletPassphrase', 'message'], callback);
                        if (params.reshare !== undefined && !_.isBoolean(params.reshare)) {
                            throw new Error('Expected reshare to be a boolean.');
                        }
                        if (params.skipKeychain !== undefined && !_.isBoolean(params.skipKeychain)) {
                            throw new Error('Expected skipKeychain to be a boolean. ');
                        }
                        needsKeychain = !params.skipKeychain && params.permissions && params.permissions.indexOf('spend') !== -1;
                        if (params.disableEmail !== undefined && !_.isBoolean(params.disableEmail)) {
                            throw new Error('Expected disableEmail to be a boolean.');
                        }
                        if (!_.isString(params.email)) {
                            throw new Error('missing required string parameter email');
                        }
                        return [4 /*yield*/, self.bitgo.getSharingKey({ email: params.email.toLowerCase() })];
                    case 1:
                        sharing = _a.sent();
                        if (!needsKeychain) return [3 /*break*/, 5];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, self.getEncryptedUserKeychain({})];
                    case 3:
                        keychain = _a.sent();
                        // Decrypt the user key with a passphrase
                        if (keychain.encryptedPrv) {
                            if (!params.walletPassphrase) {
                                throw new Error('Missing walletPassphrase argument');
                            }
                            try {
                                keychain.prv = self.bitgo.decrypt({ password: params.walletPassphrase, input: keychain.encryptedPrv });
                            }
                            catch (e) {
                                throw new Error('Unable to decrypt user keychain');
                            }
                            eckey = bitcoin_1.makeRandomKey();
                            secret = self.bitgo.getECDHSecret({ eckey: eckey, otherPubKeyHex: sharing.pubkey });
                            newEncryptedPrv = self.bitgo.encrypt({ password: secret, input: keychain.prv });
                            sharedKeychain = {
                                pub: keychain.pub,
                                encryptedPrv: newEncryptedPrv,
                                fromPubKey: eckey.getPublicKeyBuffer().toString('hex'),
                                toPubKey: sharing.pubkey,
                                path: sharing.path,
                            };
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        if (e_1.message === 'No encrypted keychains on this wallet.') {
                            sharedKeychain = {};
                            // ignore this error because this looks like a cold wallet
                        }
                        else {
                            throw e_1;
                        }
                        return [3 /*break*/, 5];
                    case 5:
                        options = {
                            user: sharing.userId,
                            permissions: params.permissions,
                            reshare: params.reshare,
                            message: params.message,
                            disableEmail: params.disableEmail,
                        };
                        if (sharedKeychain) {
                            options.keychain = sharedKeychain;
                        }
                        else if (params.skipKeychain) {
                            options.keychain = {};
                        }
                        return [2 /*return*/, self.createShare(options)];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Remove user from wallet
     * @param params
     * - userId Id of the user to remove
     * @param callback
     * @return {*}
     */
    Wallet.prototype.removeUser = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['userId'], [], callback);
        var userId = params.userId;
        return this.bitgo.del(this.url('/user/' + userId))
            .result()
            .nodeify(callback);
    };
    /**
     * Fetch a transaction prebuild (unsigned transaction) from BitGo
     *
     * @param {Object} params
     * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
     * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
     * @param {Number} params.feeRate - the desired feeRate for the transaction in base units/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in base units/kB
     * @param {Number} params.minConfirms - Minimum number of confirmations unspents going into this transaction should have
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforce minimum number of confirmations on change (internal) inputs.
     * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet. If the wallet’s current unspent count is lower than the target, up to four additional change outputs will be added to the transaction.
     * @param {Number} params.minValue - Ignore unspents smaller than this amount of base units
     * @param {Number} params.maxValue - Ignore unspents larger than this amount of base units
     * @param {Number} params.sequenceId - The sequence ID of the transaction
     * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
     * @param {String} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
     * @param {Number} params.gasLimit - Custom gas limit to be used for sending the transaction
     * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
     * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
     * @param {String} params.changeAddress - Specifies the destination of the change output
     * @param {Number} params.validFromBlock - (Algorand) The minimum round this will run on
     * @param {Number} params.validToBlock - (Algorand) The maximum round this will run on
     * @param {Boolean} params.instant - Build this transaction to conform with instant sending coin-specific method (if available)
     * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
     * @param {String} params.addressType - The type of address to create for change. One of `p2sh`, `p2shP2wsh`, and `p2wsh`. Case-sensitive.
     * @param {Boolean} params.hop - Build this as an Ethereum hop transaction
     * @param {Object} params.reservation - Object to reserve the unspents that this tx build uses. Format is reservation = { expireTime: ISODateString, pendingApprovalId: String }
     * @param {String} params.walletPassphrase The passphrase to the wallet user key, to sign commitment data for Ethereum hop transactions
     * @param {String} params.walletContractAddress - The contract address used as the "to" field of a transaction
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.prebuildTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var whitelistedParams, extraParams, queryParams, buildQuery, utxoCoin, blockHeightQuery, queries, _a, buildResponse, blockHeight, prebuild;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        whitelistedParams = _.pick(params, self.prebuildWhitelistedParams());
                        debug('prebuilding transaction: %O', whitelistedParams);
                        if (params.reqId) {
                            self.bitgo.setRequestTracer(params.reqId);
                        }
                        return [4 /*yield*/, self.baseCoin.getExtraPrebuildParams(Object.assign(params, { wallet: self }))];
                    case 1:
                        extraParams = _b.sent();
                        Object.assign(whitelistedParams, extraParams);
                        queryParams = {
                            offlineVerification: params.offlineVerification ? true : undefined,
                        };
                        buildQuery = self.bitgo.post(self.baseCoin.url('/wallet/' + self.id() + '/tx/build'))
                            .query(queryParams)
                            .send(whitelistedParams)
                            .result();
                        utxoCoin = self.baseCoin;
                        blockHeightQuery = _.isFunction(utxoCoin.getLatestBlockHeight) ?
                            utxoCoin.getLatestBlockHeight(params.reqId) :
                            Promise.resolve(undefined);
                        queries = [buildQuery, blockHeightQuery];
                        return [4 /*yield*/, Promise.all(queries)];
                    case 2:
                        _a = _b.sent(), buildResponse = _a[0], blockHeight = _a[1];
                        debug('postprocessing transaction prebuild: %O', buildResponse);
                        if (!_.isUndefined(blockHeight)) {
                            buildResponse.blockHeight = blockHeight;
                        }
                        return [4 /*yield*/, self.baseCoin.postProcessPrebuild(Object.assign(buildResponse, { wallet: self, buildParams: whitelistedParams }))];
                    case 3:
                        prebuild = _b.sent();
                        delete prebuild.wallet;
                        delete prebuild.buildParams;
                        prebuild = _.extend({}, prebuild, { walletId: self.id() });
                        if (self._wallet && self._wallet.coinSpecific && !params.walletContractAddress) {
                            prebuild = _.extend({}, prebuild, { walletContractAddress: self._wallet.coinSpecific.baseAddress });
                        }
                        debug('final transaction prebuild: %O', prebuild);
                        return [2 /*return*/, prebuild];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Sign a transaction
     * @param params
     * - txPrebuild
     * - [keychain / key] (object) or prv (string)
     * - walletPassphrase
     * @param callback
     * @return {*}
     */
    Wallet.prototype.signTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var txPrebuild, presign, userPrv, signingParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txPrebuild = params.txPrebuild;
                        if (!txPrebuild || typeof txPrebuild !== 'object') {
                            throw new Error('txPrebuild must be an object');
                        }
                        return [4 /*yield*/, self.baseCoin.presignTransaction(params)];
                    case 1:
                        presign = _a.sent();
                        userPrv = self.getUserPrv(presign);
                        signingParams = _.extend({}, presign, { txPrebuild: txPrebuild, prv: userPrv });
                        return [2 /*return*/, self.baseCoin.signTransaction(signingParams)];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Get the user private key from either a derivation or an encrypted keychain
     * @param [params.keychain / params.key] (object) or params.prv (string)
     * @param params.walletPassphrase (string)
     */
    Wallet.prototype.getUserPrv = function (params) {
        if (params === void 0) { params = {}; }
        var userKeychain = params.keychain || params.key;
        var userPrv = params.prv;
        if (userPrv && typeof userPrv !== 'string') {
            throw new Error('prv must be a string');
        }
        if (userPrv && params.coldDerivationSeed) {
            // the derivation only makes sense when a key already exists
            var derivation = this.baseCoin.deriveKeyWithSeed({ key: userPrv, seed: params.coldDerivationSeed });
            userPrv = derivation.key;
        }
        else if (!userPrv) {
            if (!userKeychain || typeof userKeychain !== 'object') {
                throw new Error('keychain must be an object');
            }
            var userEncryptedPrv = userKeychain.encryptedPrv;
            if (!userEncryptedPrv) {
                throw new Error('keychain does not have property encryptedPrv');
            }
            if (!params.walletPassphrase) {
                throw new Error('walletPassphrase property missing');
            }
            userPrv = this.bitgo.decrypt({ input: userEncryptedPrv, password: params.walletPassphrase });
        }
        return userPrv;
    };
    /**
     * Get a transaction prebuild from BitGo, validate it, and then decrypt the user key and sign the transaction
     * @param params
     * @param callback
     */
    Wallet.prototype.prebuildAndSignTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var error, error, error, txPrebuildQuery, keychains, txPrebuild, verificationParams, e_2, signingParams, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (params.prebuildTx && params.recipients) {
                            error = new Error('Only one of prebuildTx and recipients may be specified');
                            error.code = 'both_prebuildtx_and_recipients_specified';
                            throw error;
                        }
                        if (params.recipients && !Array.isArray(params.recipients)) {
                            error = new Error('expecting recipients array');
                            error.code = 'recipients_not_array';
                            throw error;
                        }
                        if (_.isArray(self._permissions) && !self._permissions.includes('spend')) {
                            error = new Error('no spend permission on this wallet');
                            error.code = 'user_not_allowed_to_spend_from_wallet';
                            throw error;
                        }
                        txPrebuildQuery = params.prebuildTx ? Promise.resolve(params.prebuildTx) : self.prebuildTransaction(params);
                        return [4 /*yield*/, self.baseCoin.keychains().getKeysForSigning({ wallet: self, reqId: params.reqId })];
                    case 1:
                        keychains = _a.sent();
                        return [4 /*yield*/, txPrebuildQuery];
                    case 2:
                        txPrebuild = _a.sent();
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        verificationParams = _.pick(params.verification || {}, ['disableNetworking', 'keychains', 'addresses']);
                        return [4 /*yield*/, self.baseCoin.verifyTransaction({
                                txParams: params,
                                txPrebuild: txPrebuild,
                                wallet: self,
                                verification: verificationParams,
                                reqId: params.reqId,
                            })];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        e_2 = _a.sent();
                        debug('Transaction prebuild failure:', e_2);
                        console.error('transaction prebuild failed local validation:');
                        throw e_2;
                    case 6:
                        signingParams = _.extend({}, params, {
                            txPrebuild: txPrebuild,
                            wallet: {
                                // this is the version of the multisig address at wallet creation time
                                addressVersion: self._wallet.coinSpecific.addressVersion
                            },
                            keychain: keychains[0],
                            backupKeychain: (keychains.length > 1) ? keychains[1] : null,
                            bitgoKeychain: (keychains.length > 2) ? keychains[2] : null,
                        });
                        _a.label = 7;
                    case 7:
                        _a.trys.push([7, 9, , 10]);
                        return [4 /*yield*/, self.signTransaction(signingParams)];
                    case 8: return [2 /*return*/, _a.sent()];
                    case 9:
                        error_1 = _a.sent();
                        if (error_1.message.includes('insufficient funds')) {
                            error_1.code = 'insufficient_funds';
                            error_1.walletBalances = {
                                balanceString: self.balanceString(),
                                confirmedBalanceString: self.confirmedBalanceString(),
                                spendableBalanceString: self.spendableBalanceString(),
                                balance: self.balance(),
                                confirmedBalance: self.confirmedBalance(),
                                spendableBalance: self.spendableBalance()
                            };
                            error_1.txParams = _.omit(params, ['keychain', 'prv', 'passphrase', 'walletPassphrase', 'key']);
                        }
                        throw error_1;
                    case 10: return [2 /*return*/];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Accelerate a transaction's confirmation using Child-Pays-For-Parent (CPFP)
     * @param params
     * @param callback
     */
    Wallet.prototype.accelerateTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var error, error, error, error, error, submitParams, _a, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        // TODO(BG-9349): change the last check to > 0 and the error message once platform allows multiple transactions to
                        //                be bumped in the same CPFP transaction
                        if (_.isUndefined(params.cpfpTxIds) || !Array.isArray(params.cpfpTxIds) || params.cpfpTxIds.length !== 1) {
                            error = new Error('expecting cpfpTxIds to be an array of length 1');
                            error.code = 'cpfptxids_not_array';
                            throw error;
                        }
                        if (_.isUndefined(params.cpfpFeeRate)) {
                            if (params.noCpfpFeeRate !== true) {
                                error = new Error('cpfpFeeRate must be set unless noCpfpFeeRate is set');
                                error.code = 'cpfpfeerate_not_set';
                                throw error;
                            }
                        }
                        else {
                            if (!_.isInteger(params.cpfpFeeRate) || params.cpfpFeeRate < 0) {
                                error = new Error('cpfpFeeRate must be a non-negative integer');
                                error.code = 'cpfpfeerate_not_nonnegative_integer';
                                throw error;
                            }
                        }
                        if (_.isUndefined(params.maxFee)) {
                            if (params.noMaxFee !== true) {
                                error = new Error('maxFee must be set unless noMaxFee is set');
                                error.code = 'maxfee_not_set';
                                throw error;
                            }
                        }
                        else {
                            if (!_.isInteger(params.maxFee) || params.maxFee < 0) {
                                error = new Error('maxFee must be a non-negative integer');
                                error.code = 'maxfee_not_nonnegative_integer';
                                throw error;
                            }
                        }
                        if (params.recipients !== undefined) {
                            if (!Array.isArray(params.recipients) || params.recipients.length !== 0) {
                                throw new Error("invalid value for 'recipients': must be empty array when set");
                            }
                        }
                        params.recipients = [];
                        _b = (_a = Object).assign;
                        _c = [params];
                        return [4 /*yield*/, self.prebuildAndSignTransaction(params)];
                    case 1:
                        submitParams = _b.apply(_a, _c.concat([_d.sent()]));
                        delete submitParams.wallet;
                        return [4 /*yield*/, self.submitTransaction(submitParams)];
                    case 2: return [2 /*return*/, _d.sent()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Submit a half-signed transaction to BitGo
     * @param params
     * - txHex: transaction hex to submit
     * - halfSigned: object containing transaction (txHex or txBase64) to submit
     * @param callback
     */
    Wallet.prototype.submitTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, [], ['otp', 'txHex'], callback);
        var hasTxHex = !!params.txHex;
        var hasHalfSigned = !!params.halfSigned;
        if ((hasTxHex && hasHalfSigned) || (!hasTxHex && !hasHalfSigned)) {
            throw new Error('must supply either txHex or halfSigned, but not both');
        }
        return this.bitgo.post(this.baseCoin.url('/wallet/' + this.id() + '/tx/send'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Send coins to a recipient
     * @param params
     * @param params.address - the destination address
     * @param params.amount - the amount in satoshis/wei/base value to be sent
     * @param params.message - optional message to attach to transaction
     * @param params.data - [Ethereum Specific] optional data to pass to transaction
     * @param params.walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
     * @param params.prv - the private key in string form, if walletPassphrase is not available
     * @param params.minConfirms - the minimum confirmation threshold for inputs
     * @param params.enforceMinConfirmsForChange - whether to enforce minConfirms for change inputs
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.send = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['address'], ['message', 'data'], callback);
        if (_.isUndefined(params.amount)) {
            throw new Error('missing required parameter amount');
        }
        if (_.isUndefined(params.address)) {
            throw new Error('missing required parameter amount');
        }
        var coin = this.baseCoin;
        var amount = new bignumber_js_1.BigNumber(params.amount);
        if (amount.isNegative()) {
            throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
        }
        if (!coin.valuelessTransferAllowed() && amount.isZero()) {
            throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
        }
        var recipients = [{
                address: params.address,
                amount: params.amount,
            }];
        if (params.data && coin.transactionDataAllowed()) {
            recipients[0].data = params.data;
        }
        var sendManyOptions = Object.assign({}, params, { recipients: recipients });
        return this.sendMany(sendManyOptions).nodeify(callback);
    };
    /**
     * Send money to multiple recipients
     * 1. Gets the user keychain by checking the wallet for a key which has an encrypted prv
     * 2. Decrypts user key
     * 3. Creates the transaction with default fee
     * 4. Signs transaction with decrypted user key
     * 5. Sends the transaction to BitGo
     * @param {object} params
     * @param {{address: string, amount: string}} params.recipients - list of recipients and necessary recipient information
     * @param {Number} params.numBlocks - Estimates the approximate fee per kilobyte necessary for a transaction confirmation within numBlocks blocks
     * @param {Number} params.feeRate - the desired feeRate for the transaction in satothis/kB
     * @param {Number} params.maxFeeRate - upper limit for feeRate in satoshis/kB
     * @param {Number} params.minConfirms - all selected unspents will have at least this many confirmations
     * @param {Boolean} params.enforceMinConfirmsForChange - Enforces minConfirms on change inputs
     * @param {Number} params.targetWalletUnspents - The desired count of unspents in the wallet
     * @param {String} params.message - optional message to attach to transaction
     * @param {Number} params.minValue - Ignore unspents smaller than this amount of satoshis
     * @param {Number} params.maxValue - Ignore unspents larger than this amount of satoshis
     * @param {Number} params.sequenceId - The sequence ID of the transaction
     * @param {Number} params.lastLedgerSequence - Absolute max ledger the transaction should be accepted in, whereafter it will be rejected.
     * @param {String} params.ledgerSequenceDelta - Relative ledger height (in relation to the current ledger) that the transaction should be accepted in, whereafter it will be rejected.
     * @param {Number} params.gasPrice - Custom gas price to be used for sending the transaction
     * @param {Boolean} params.noSplitChange - Set to true to disable automatic change splitting for purposes of unspent management
     * @param {Array} params.unspents - The unspents to use in the transaction. Each unspent should be in the form prevTxId:nOutput
     * @param {String} params.comment - Any additional comment to attach to the transaction
     * @param {String} params.otp - Two factor auth code to enable sending the transaction
     * @param {String} params.changeAddress - Specifies the destination of the change output
     * @param {Boolean} params.instant - Send this transaction using coin-specific instant sending method (if available)
     * @param {{value: String, type: String}} params.memo - Memo to use in transaction (supported by Stellar)
     * @param {String} params.type - Type of the transaction (e.g. trustline)
     * @param {{token: params, action: String, limit: String}[]} options.trustlines - Array of trustlines to manage (supported by Stellar)
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.sendMany = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var reqId, coin, halfSignedTransaction, selectParams, finalTxParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, [], ['comment', 'otp'], callback);
                        debug('sendMany called');
                        reqId = params.reqId || new util_1.RequestTracer();
                        params.reqId = reqId;
                        coin = self.baseCoin;
                        if (_.isObject(params.recipients)) {
                            params.recipients.map(function (recipient) {
                                var amount = new bignumber_js_1.BigNumber(recipient.amount);
                                if (amount.isNegative()) {
                                    throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
                                }
                                if (!coin.valuelessTransferAllowed() && amount.isZero()) {
                                    throw new Error('invalid argument for amount - positive number greater than zero or numeric string expected');
                                }
                            });
                        }
                        return [4 /*yield*/, self.prebuildAndSignTransaction(params)];
                    case 1:
                        halfSignedTransaction = _a.sent();
                        selectParams = _.pick(params, [
                            'recipients', 'numBlocks', 'feeRate', 'maxFeeRate', 'minConfirms',
                            'enforceMinConfirmsForChange', 'targetWalletUnspents',
                            'message', 'minValue', 'maxValue', 'sequenceId',
                            'lastLedgerSequence', 'ledgerSequenceDelta', 'gasPrice',
                            'noSplitChange', 'unspents', 'comment', 'otp', 'changeAddress',
                            'instant', 'memo', 'type', 'trustlines',
                        ]);
                        finalTxParams = _.extend({}, halfSignedTransaction, selectParams);
                        self.bitgo.setRequestTracer(reqId);
                        return [2 /*return*/, self.bitgo.post(self.url('/tx/send'))
                                .send(finalTxParams)
                                .result()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Recover an unsupported token from a BitGo multisig wallet
     * params are validated in Eth.prototype.recoverToken
     * @param params
     * @param params.tokenContractAddress the contract address of the unsupported token
     * @param params.recipient the destination address recovered tokens should be sent to
     * @param params.walletPassphrase the wallet passphrase
     * @param params.prv the xprv
     * @param callback
     */
    Wallet.prototype.recoverToken = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var tokenContractAddress, recipient, recoverTokenOptions;
            return __generator(this, function (_a) {
                if (self.baseCoin.getFamily() !== 'eth') {
                    throw new Error('token recovery only supported for eth wallets');
                }
                tokenContractAddress = params.tokenContractAddress, recipient = params.recipient;
                if (_.isUndefined(tokenContractAddress)) {
                    throw new Error('missing required string parameter tokenContractAddress');
                }
                if (_.isUndefined(recipient)) {
                    throw new Error('missing required string parameter recipient');
                }
                recoverTokenOptions = Object.assign({ tokenContractAddress: tokenContractAddress, recipient: recipient }, params, { wallet: self });
                return [2 /*return*/, self.baseCoin.recoverToken(recoverTokenOptions)];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Get transaction metadata for the oldest transaction that is still pending or attempted
     * @param params
     * @param callback
     * @returns {Object} Object with txid, walletId, tx, and fee (if supported for coin)
     */
    Wallet.prototype.getFirstPendingTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        return internal.getFirstPendingTransaction({ walletId: this.id() }, this.baseCoin, this.bitgo).asCallback(callback);
    };
    /**
     * Change the fee on the pending transaction that corresponds to the given txid to the given new fee
     * @param params
     * @param {String} params.txid The transaction Id corresponding to the transaction whose fee is to be changed
     * @param {String} params.fee The new fee to apply to the denoted transaction
     * @param callback
     * @returns {String} The transaction ID of the new transaction that contains the new fee rate
     */
    Wallet.prototype.changeFee = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                common.validateParams(params, ['txid', 'fee'], [], callback);
                return [2 /*return*/, self.bitgo.post(self.baseCoin.url('/wallet/' + self.id() + '/tx/changeFee'))
                        .send(params)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Fetch info from merchant server
     * @param {Object} params The params passed into the function
     * @param {String} params.url The Url to retrieve info from
     * @param callback
     * @returns {Object} The info returned from the merchant server
     * @deprecated
     */
    Wallet.prototype.getPaymentInfo = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function coGetPaymentInfo() {
            return __generator(this, function (_a) {
                params = params || {};
                common.validateParams(params, ['url'], [], callback);
                return [2 /*return*/, self.bitgo.get(self.url('/paymentInfo'))
                        .query(params)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Send json payment response
     * @param {Object} params The params passed into the function
     * @param {String} params.paymentUrl - The url to send the fully signed transaction to
     * @param {String} params.txHex - The transaction hex of the payment
     * @param {String} params.memo {String} - A memo supplied by the merchant, to be inserted into the transfer as the comment
     * @param {String} params.expires {String} - ISO Date format of when the payment request expires
     * @param callback
     * @returns {Object} The info returned from the merchant server Payment Ack
     * @deprecated
     */
    Wallet.prototype.sendPaymentResponse = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.bitgo.post(this.url('/sendPayment'))
            .send(params)
            .result()
            .asCallback(callback);
    };
    /**
     * Create a policy rule
     * @param params
     * @param params.condition condition object
     * @param params.action action object
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.createPolicyRule = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                common.validateParams(params, ['id', 'type'], ['message'], callback);
                if (!_.isObject(params.condition)) {
                    throw new Error('missing parameter: conditions object');
                }
                if (!_.isObject(params.action)) {
                    throw new Error('missing parameter: action object');
                }
                return [2 /*return*/, self.bitgo.post(self.url('/policy/rule'))
                        .send(params)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Update a policy rule
     * @param params
     * @param params.condition condition object
     * @param params.action action object
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.setPolicyRule = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                common.validateParams(params, ['id', 'type'], ['message'], callback);
                if (!_.isObject(params.condition)) {
                    throw new Error('missing parameter: conditions object');
                }
                if (!_.isObject(params.action)) {
                    throw new Error('missing parameter: action object');
                }
                return [2 /*return*/, self.bitgo.put(self.url('/policy/rule'))
                        .send(params)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Remove Policy Rule
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.removePolicyRule = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                common.validateParams(params, ['id'], ['message'], callback);
                return [2 /*return*/, self.bitgo.del(self.url('/policy/rule'))
                        .send(params)
                        .result()];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Remove this wallet
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallet.prototype.remove = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.bitgo.del(this.url()).result().asCallback(callback);
    };
    /**
     * Create a trading account from this wallet
     */
    Wallet.prototype.toTradingAccount = function () {
        if (this.baseCoin.getFamily() !== 'ofc') {
            throw new Error('Can only convert an Offchain (OFC) wallet to a trading account');
        }
        return new tradingAccount_1.TradingAccount(this._wallet.enterprise, this, this.bitgo);
    };
    /**
     * Creates and downloads PDF keycard for wallet (requires response from wallets.generateWallet)
     *
     * Note: this is example code and is not the version used on bitgo.com
     *
     * @param params
     *   * jsPDF - an instance of the jsPDF library
     *   * QRCode - an instance of the QRious library
     *   * userKeychain - a wallet's private user keychain
     *   * backupKeychain - a wallet's private backup keychain
     *   * bitgoKeychain - a wallet's private bitgo keychain
     *   * passphrase - the wallet passphrase
     *   * passcodeEncryptionCode - the encryption secret used for Box D
     *   * activationCode - a randomly generated six-digit activation code
     *   * walletKeyID - the Key ID used for deriving a cold wallet's signing key
     *   * backupKeyID - the Key ID used for deriving a cold wallet's backup key
     * @returns {*}
     */
    Wallet.prototype.downloadKeycard = function (params) {
        if (params === void 0) { params = {}; }
        if (!window || !window.location) {
            throw new Error('The downloadKeycard function is only callable within a browser.');
        }
        // Grab parameters with default for activationCode
        var jsPDF = params.jsPDF, QRCode = params.QRCode, userKeychain = params.userKeychain, backupKeychain = params.backupKeychain, bitgoKeychain = params.bitgoKeychain, passphrase = params.passphrase, passcodeEncryptionCode = params.passcodeEncryptionCode, walletKeyID = params.walletKeyID, backupKeyID = params.backupKeyID, _a = params.activationCode, activationCode = _a === void 0 ? Math.floor(Math.random() * 900000 + 100000).toString() : _a;
        if (!jsPDF || typeof jsPDF !== 'function') {
            throw new Error('Please pass in a valid jsPDF instance');
        }
        // Validate keychains
        if (!userKeychain || typeof userKeychain !== 'object') {
            throw new Error("Wallet keychain must have a 'user' property");
        }
        if (!backupKeychain || typeof backupKeychain !== 'object') {
            throw new Error('Backup keychain is required and must be an object');
        }
        if (!bitgoKeychain || typeof bitgoKeychain !== 'object') {
            throw new Error('Bitgo keychain is required and must be an object');
        }
        if (walletKeyID && typeof walletKeyID !== 'string') {
            throw new Error('walletKeyID must be a string');
        }
        if (backupKeyID && typeof backupKeyID !== 'string') {
            throw new Error('backupKeyID must be a string');
        }
        // Validate activation code if provided
        if (typeof activationCode !== 'string') {
            throw new Error('Activation Code must be a string');
        }
        if (activationCode.length !== 6) {
            throw new Error('Activation code must be six characters');
        }
        var coinShortName = this.baseCoin.type;
        var coinName = this.baseCoin.getFullName();
        var walletLabel = this._wallet.label;
        var doc = keycard_1.drawKeycard({
            jsPDF: jsPDF,
            QRCode: QRCode,
            encrypt: this.bitgo.encrypt,
            coinShortName: coinShortName,
            coinName: coinName,
            activationCode: activationCode,
            walletLabel: walletLabel,
            passphrase: passphrase,
            passcodeEncryptionCode: passcodeEncryptionCode,
            userKeychain: userKeychain,
            backupKeychain: backupKeychain,
            bitgoKeychain: bitgoKeychain,
            walletKeyID: walletKeyID,
            backupKeyID: backupKeyID,
        });
        // Save the PDF on the user's browser
        doc.save("BitGo Keycard for " + walletLabel + ".pdf");
    };
    /**
     * Builds a set of consolidation transactions for a wallet.
     * @param params
     *     fromAddresses - these are the on-chain receive addresses we want to pick a consolidation amount from
     * @param callback
     */
    Wallet.prototype.buildAccountConsolidations = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var whitelistedParams, buildResponse, consolidations, _i, buildResponse_1, consolidateAccountBuild, prebuild;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!self.baseCoin.allowsAccountConsolidations()) {
                            throw new Error(self.baseCoin.getFullName() + " does not allow account consolidations.");
                        }
                        whitelistedParams = _.pick(params, self.prebuildConsolidateAccountParams());
                        debug('prebuilding consolidation transaction: %O', whitelistedParams);
                        if (params.reqId) {
                            self.bitgo.setRequestTracer(params.reqId);
                        }
                        return [4 /*yield*/, self.bitgo.post(self.baseCoin.url('/wallet/' + self.id() + '/consolidateAccount/build'))
                                .send(whitelistedParams)
                                .result()];
                    case 1:
                        buildResponse = _a.sent();
                        consolidations = [];
                        _i = 0, buildResponse_1 = buildResponse;
                        _a.label = 2;
                    case 2:
                        if (!(_i < buildResponse_1.length)) return [3 /*break*/, 5];
                        consolidateAccountBuild = buildResponse_1[_i];
                        return [4 /*yield*/, self.baseCoin.postProcessPrebuild(Object.assign(consolidateAccountBuild, { wallet: self, buildParams: whitelistedParams }))];
                    case 3:
                        prebuild = _a.sent();
                        delete prebuild.wallet;
                        delete prebuild.buildParams;
                        prebuild = _.extend({}, prebuild, { walletId: self.id() });
                        debug('final consolidation transaction prebuild: %O', prebuild);
                        consolidations.push(prebuild);
                        _a.label = 4;
                    case 4:
                        _i++;
                        return [3 /*break*/, 2];
                    case 5: return [2 /*return*/, consolidations];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Builds and sends a set of consolidation transactions for a wallet.
     * @param params
     *     prebuildTx   - this is the pre-build consolidation tx. this is a normally built tx with
     *                    an additional parameter of consolidateId.
     *     verification - normal keychains, etc. for verification
     */
    Wallet.prototype.sendAccountConsolidation = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var signedPrebuild;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!self.baseCoin.allowsAccountConsolidations()) {
                            throw new Error(self.baseCoin.getFullName() + " does not allow account consolidations.");
                        }
                        // one of a set of consolidation transactions
                        if (typeof params.prebuildTx === 'string' || params.prebuildTx === undefined) {
                            throw new Error('Invalid build of account consolidation.');
                        }
                        if (!params.prebuildTx.consolidateId) {
                            throw new Error('Failed to find consolidation id on consolidation transaction.');
                        }
                        return [4 /*yield*/, self.prebuildAndSignTransaction(params)];
                    case 1:
                        signedPrebuild = _a.sent();
                        // decorate with our consolidation id
                        signedPrebuild.consolidateId = params.prebuildTx.consolidateId;
                        delete signedPrebuild.wallet;
                        return [4 /*yield*/, self.submitTransaction(signedPrebuild)];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Builds and sends a set of account consolidations. This is intended to flush many balances to the root wallet balance.
     * @param params
     * @param callback
     */
    Wallet.prototype.sendAccountConsolidations = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var unsignedBuilds, successfulTxs, failedTxs, _i, unsignedBuilds_1, unsignedBuild, unsignedBuildWithOptions, sendTx, e_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!self.baseCoin.allowsAccountConsolidations()) {
                            throw new Error(self.baseCoin.getFullName() + " does not allow account consolidations.");
                        }
                        return [4 /*yield*/, self.buildAccountConsolidations(params)];
                    case 1:
                        unsignedBuilds = _a.sent();
                        if (!(unsignedBuilds && unsignedBuilds.length > 0)) return [3 /*break*/, 8];
                        successfulTxs = [];
                        failedTxs = new Array();
                        _i = 0, unsignedBuilds_1 = unsignedBuilds;
                        _a.label = 2;
                    case 2:
                        if (!(_i < unsignedBuilds_1.length)) return [3 /*break*/, 7];
                        unsignedBuild = unsignedBuilds_1[_i];
                        unsignedBuildWithOptions = Object.assign({}, params);
                        unsignedBuildWithOptions.prebuildTx = unsignedBuild;
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, self.sendAccountConsolidation(unsignedBuildWithOptions)];
                    case 4:
                        sendTx = _a.sent();
                        successfulTxs.push(sendTx);
                        return [3 /*break*/, 6];
                    case 5:
                        e_3 = _a.sent();
                        failedTxs.push(e_3);
                        return [3 /*break*/, 6];
                    case 6:
                        _i++;
                        return [3 /*break*/, 2];
                    case 7: return [2 /*return*/, {
                            success: successfulTxs,
                            failure: failedTxs,
                        }];
                    case 8: return [2 /*return*/];
                }
            });
        }).call(this).asCallback(callback);
    };
    return Wallet;
}());
exports.Wallet = Wallet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3YyL3dhbGxldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZDQUF5QztBQUN6QyxtQ0FBcUM7QUFDckMsMEJBQTRCO0FBQzVCLGdDQUFrQztBQUVsQyxzQ0FBMkM7QUFFM0Msa0NBQW9DO0FBQ3BDLG9DQUFtRDtBQVFuRCw4Q0FBZ0Q7QUFDaEQsOENBQWlEO0FBRWpELDJEQUEwRDtBQUUxRCxxREFBeUU7QUFDekUsd0NBQWdEO0FBRWhELElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBQzFDLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUErWjlCO0lBTUUsZ0JBQVksS0FBWSxFQUFFLFFBQWtCLEVBQUUsVUFBZTtRQUMzRCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsT0FBTyxHQUFHLFVBQVUsQ0FBQztRQUMxQixJQUFNLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxVQUFVLENBQUMsQ0FBQztRQUN4QyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDdEIsSUFBTSxXQUFXLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7WUFDL0QsSUFBSSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxhQUFhLENBQUMsQ0FBQztTQUN2RDtJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSCxvQkFBRyxHQUFILFVBQUksS0FBa0I7UUFBbEIsc0JBQUEsRUFBQSxVQUFrQjtRQUNwQixP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SyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO1NBQ2hDO1FBRUQsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDL0IsTUFBTSxJQUFJLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO2FBQy9EO1lBQ0QsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO1NBQ2hDO1FBRUQsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO2FBQzlEO1lBQ0QsS0FBSyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQzlCO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzdCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRTtnQkFDaEMsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO2FBQ2hFO1lBQ0QsS0FBSyxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDO1NBQ2xDO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQzVCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDL0IsTUFBTSxJQUFJLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO2FBQy9EO1lBQ0QsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO1NBQ2hDO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQy9CLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDbkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxnREFBZ0QsQ0FBQyxDQUFDO2FBQ25FO1lBQ0QsS0FBSyxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDO1NBQ3RDO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzFCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUM3RCxNQUFNLElBQUksS0FBSyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7YUFDdEU7WUFFRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUMvQixNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFBLEtBQUs7b0JBQ3hCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO3dCQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLDBEQUEwRCxDQUFDLENBQUM7cUJBQzdFO2dCQUNILENBQUMsQ0FBQyxDQUFDO2FBQ0o7WUFDRCxLQUFLLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUM7U0FDNUI7UUFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDekIsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7YUFDNUQ7WUFDRCxLQUFLLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUM7U0FDMUI7UUFFRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDekMsS0FBSyxDQUFDLEtBQUssQ0FBQzthQUNaLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDRCQUFXLEdBQVgsVUFBWSxNQUErQixFQUFFLFFBQTRCO1FBQTdELHVCQUFBLEVBQUEsV0FBK0I7UUFDekMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFcEQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksR0FBRyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDdEQsTUFBTSxFQUFFO2FBQ1IsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gscUNBQW9CLEdBQXBCLFVBQXFCLE1BQXdDLEVBQUUsUUFBNEI7UUFBdEUsdUJBQUEsRUFBQSxXQUF3QztRQUMzRCxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUU1RCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsdUJBQXVCLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQ3pFLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7T0FnQkc7SUFDSCxpQ0FBZ0IsR0FBaEIsVUFBaUIsTUFBb0MsRUFBRSxRQUF5QztRQUEvRSx1QkFBQSxFQUFBLFdBQW9DO1FBQ25ELElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBbUI7OztnQkFDcEIsY0FBYyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO29CQUNwQyw2QkFBNkIsRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsYUFBYSxFQUFFLFdBQVc7b0JBQ3ZHLFVBQVUsRUFBRSxhQUFhLEVBQUUsa0JBQWtCLEVBQUUsUUFBUTtpQkFDeEQsQ0FBQyxDQUFDO2dCQUVILHNCQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQzt5QkFDakQsS0FBSyxDQUFDLGNBQWMsQ0FBQzt5QkFDckIsTUFBTSxFQUFFLEVBQUM7O1NBQ2IsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gseUJBQVEsR0FBUixVQUFTLE1BQTRCLEVBQUUsUUFBNEI7UUFBMUQsdUJBQUEsRUFBQSxXQUE0QjtRQUNuQyxJQUFNLEtBQUssR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUN6QixRQUFRLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxhQUFhLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVE7U0FDdEcsQ0FBQyxDQUFDO1FBRUgsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ3pDLEtBQUssQ0FBQyxLQUFLLENBQUM7YUFDWixNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E4Qkc7SUFDSywrQkFBYyxHQUF0QixVQUF1QixTQUF5QixFQUFFLE1BQStELEVBQUUsUUFBNEI7UUFBN0YsdUJBQUEsRUFBQSxXQUErRDtRQUMvRyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQUM7Ozs7O3dCQUNSLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixFQUFFLE1BQU0sQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUVwRSxLQUFLLEdBQUcsSUFBSSxvQkFBYSxFQUFFLENBQUM7d0JBQzVCLGNBQWMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTs0QkFDcEMsU0FBUzs0QkFDVCxZQUFZOzRCQUNaLGtCQUFrQjs0QkFDbEIsb0JBQW9COzRCQUVwQixVQUFVOzRCQUNWLFVBQVU7NEJBQ1YsV0FBVzs0QkFDWCxhQUFhOzRCQUNiLDZCQUE2Qjs0QkFDN0IsZUFBZTs0QkFFZixTQUFTLEtBQUssYUFBYSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLG1CQUFtQjs0QkFDM0QsbUJBQW1CO3lCQUNwQixDQUFDLENBQUM7d0JBQ0gsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQzt3QkFDbEIscUJBQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFJLFNBQVMsYUFBVSxDQUFDLENBQUM7aUNBQ3RFLElBQUksQ0FBQyxjQUFjLENBQUM7aUNBQ3BCLE1BQU0sRUFBRSxFQUFBOzt3QkFGTCxRQUFRLEdBQUcsU0FFTjt3QkFFTSxxQkFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLE9BQUEsRUFBRSxDQUFDLEVBQUE7O3dCQUFuRixRQUFRLEdBQUcsU0FBd0U7d0JBQ25GLGlCQUFpQixHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsUUFBUSxVQUFBLEVBQUUsQ0FBQyxDQUFDO3dCQUN6RCxxQkFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLGlCQUFpQixDQUFDLEVBQUE7O3dCQUFqRSxpQkFBaUIsR0FBRyxTQUE2Qzt3QkFDakUsWUFBWSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7d0JBQ2xELGFBQWEsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxpQkFBaUIsRUFBRSxZQUFZLENBQUMsQ0FBQzt3QkFFcEUsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQzt3QkFDbkMsc0JBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxHQUFHLFVBQVUsQ0FBQyxDQUFDO2lDQUNqRixJQUFJLENBQUMsYUFBYSxDQUFDO2lDQUNuQixNQUFNLEVBQUUsRUFBQzs7O1NBQ2IsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQW9CRztJQUNILG9DQUFtQixHQUFuQixVQUFvQixNQUF1QyxFQUFFLFFBQTRCO1FBQXJFLHVCQUFBLEVBQUEsV0FBdUM7UUFDekQsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLGFBQWEsRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7OztPQWlCRztJQUNILCtCQUFjLEdBQWQsVUFBZSxNQUFrQyxFQUFFLFFBQTRCO1FBQWhFLHVCQUFBLEVBQUEsV0FBa0M7UUFDL0MsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsMkNBQTBCLEdBQTFCLFVBQTJCLFVBQW9CLEVBQUUsUUFBNEI7UUFBbEQsMkJBQUEsRUFBQSxlQUFvQjtRQUM3QyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQUM7Ozs7O3dCQUNSLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsS0FBSyxLQUFLLEVBQUU7NEJBQ3ZDLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLENBQUMsQ0FBQzt5QkFDbEQ7d0JBRUQsS0FBQSxJQUFJLENBQUE7d0JBQVcscUJBQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDO2dDQUNuRCxvQkFBb0IsRUFBRSxVQUFVOzZCQUNqQyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUE7O3dCQUZYLEdBQUssT0FBTyxHQUFHLFNBRUosQ0FBQzs7OztTQUNiLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7T0FjRztJQUNILHNCQUFLLEdBQUwsVUFBTSxNQUF5QixFQUFFLFFBQTRCO1FBQXZELHVCQUFBLEVBQUEsV0FBeUI7UUFDN0IsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFDOzs7Ozt3QkFDUixNQUFNLEdBQUcsTUFBTSxJQUFJLEVBQUUsQ0FBQzt3QkFDdEIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLGtCQUFrQixFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFFMUYsSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxFQUFFOzRCQUN0RCxJQUFJLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxLQUFLLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRTtnQ0FDMUQsTUFBTSxJQUFJLEtBQUssQ0FBQyw2R0FBNkcsQ0FBQyxDQUFDOzZCQUNoSTs0QkFFSyxLQUFLLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUM7NEJBQzVDLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLEtBQUssR0FBRyxFQUFFO2dDQUN6QyxNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7NkJBQ3RDOzRCQUNBLE1BQWMsQ0FBQyxVQUFVLEdBQUcsQ0FBQztvQ0FDNUIsT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPO29DQUN2QixNQUFNLEVBQUUsS0FBSztpQ0FDZCxDQUFDLENBQUM7NEJBRUgsc0JBQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBQzt5QkFDOUI7d0JBR0ssS0FBSyxHQUFHLElBQUksb0JBQWEsRUFBRSxDQUFDO3dCQUM1QixjQUFjLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxvQkFBb0IsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7d0JBQ3ZILElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7d0JBQ2xCLHFCQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7aUNBQzdELElBQUksQ0FBQyxjQUFjLENBQUM7aUNBQ3BCLE1BQU0sRUFBRSxFQUFBOzt3QkFGTCxRQUFRLEdBQUcsU0FFTjt3QkFHTSxxQkFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLE9BQUEsRUFBRSxDQUFDLEVBQUE7O3dCQUFuRixRQUFRLEdBQUcsU0FBd0U7d0JBQ25GLGlCQUFpQixHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7d0JBQ3JGLHFCQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsaUJBQWlCLENBQUMsRUFBQTs7d0JBQWpFLGlCQUFpQixHQUFHLFNBQTZDO3dCQUVqRSxZQUFZLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO3dCQUN2QyxhQUFhLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsaUJBQWlCLEVBQUUsWUFBWSxDQUFDLENBQUM7d0JBQ3BFLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7d0JBQ25DLHNCQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsR0FBRyxVQUFVLENBQUMsQ0FBQztpQ0FDakYsSUFBSSxDQUFDLGFBQWEsQ0FBQztpQ0FDbkIsTUFBTSxFQUFFLEVBQUM7OztTQUNiLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILHVCQUFNLEdBQU4sVUFBTyxNQUEwQixFQUFFLFFBQTRCO1FBQXhELHVCQUFBLEVBQUEsV0FBMEI7UUFDL0IsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7UUFDdEIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUVoRCxJQUFJLE1BQU0sQ0FBQyxRQUFRLEVBQUU7WUFDbkIsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFO2dCQUNoQyxNQUFNLElBQUksS0FBSyxDQUFDLCtDQUErQyxDQUFDLENBQUM7YUFDbEU7U0FDRjtRQUVELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUN4QyxNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsZ0NBQWUsR0FBZixVQUFnQixNQUFtQyxFQUFFLFFBQTRCO1FBQWpFLHVCQUFBLEVBQUEsV0FBbUM7UUFDakQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBRTdELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxHQUFHLFlBQVksR0FBRyxNQUFNLENBQUMsRUFBRSxHQUFHLFVBQVUsQ0FBQyxDQUFDO2FBQzVHLElBQUksQ0FBQyxNQUFNLENBQUM7YUFDWixNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsMEJBQVMsR0FBVCxVQUFVLE1BQTZCLEVBQUUsUUFBNEI7UUFBM0QsdUJBQUEsRUFBQSxXQUE2QjtRQUNyQyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBRWhELElBQU0sS0FBSyxHQUFxQixFQUFFLENBQUM7UUFFbkMsSUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFO1lBQ2YsS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztTQUM1QjtRQUVELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNqQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLENBQUMsQ0FBQzthQUM5RDtZQUNELEtBQUssQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztTQUM5QjtRQUVELElBQUksTUFBTSxDQUFDLElBQUksRUFBRTtZQUNmLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO2FBQzVEO1lBQ0QsS0FBSyxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO1NBQzFCO1FBRUQsSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO2FBQzdEO1lBQ0QsS0FBSyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDO1NBQzVCO1FBRUQsSUFBSSxNQUFNLENBQUMsYUFBYSxFQUFFO1lBQ3hCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRTtnQkFDckMsTUFBTSxJQUFJLEtBQUssQ0FBQyxrREFBa0QsQ0FBQyxDQUFDO2FBQ3JFO1lBQ0QsS0FBSyxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsYUFBYSxDQUFDO1NBQzVDO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2pDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDL0IsTUFBTSxJQUFJLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO2FBQy9EO1lBQ0QsS0FBSyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQzlCO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2pDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO2FBQ3hFO1lBQ0QsS0FBSyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQzlCO1FBRUQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEdBQUcsWUFBWSxDQUFDLENBQUM7YUFDbEYsS0FBSyxDQUFDLEtBQUssQ0FBQzthQUNaLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCwyQkFBVSxHQUFWLFVBQVcsTUFBOEIsRUFBRSxRQUE0QjtRQUE1RCx1QkFBQSxFQUFBLFdBQThCO1FBQ3ZDLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUMvRCxJQUFJLEtBQUssQ0FBQztRQUNWLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDN0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO1NBQ3REO1FBQ0QsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFO1lBQ2xCLEtBQUssR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO1NBQ3hCO2FBQU07WUFDTCxLQUFLLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQztTQUNuQjtRQUVELElBQUksTUFBTSxDQUFDLEtBQUssRUFBRTtZQUNoQixJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMzQztRQUVELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsYUFBVyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsaUJBQVksa0JBQWtCLENBQUMsS0FBSyxDQUFHLENBQUMsQ0FBQzthQUN4RyxNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7OztPQWNHO0lBQ0gsOEJBQWEsR0FBYixVQUFjLE1BQWlDLEVBQUUsUUFBNEI7UUFBL0QsdUJBQUEsRUFBQSxXQUFpQztRQUM3QyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQUM7Ozs7O3dCQUNGLGFBQWEsR0FBeUIsRUFBRSxDQUFDO3dCQUN6QyxLQUFLLEdBQUcsSUFBSSxvQkFBYSxFQUFFLENBQUM7d0JBR2hDLEtBQUssR0FLSCxNQUFNLE1BTEgsRUFDTCxRQUFRLEdBSU4sTUFBTSxTQUpBLEVBQ1IsS0FBSyxHQUdILE1BQU0sTUFISCxFQUNMLFdBQVcsR0FFVCxNQUFNLFlBRkcsRUFDWCxLQUNFLE1BQU0sTUFEQyxFQUFULEtBQUssbUJBQUcsQ0FBQyxLQUFBLENBQ0E7d0JBRVgsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLEVBQUU7NEJBQ3pCLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFO2dDQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7NkJBQy9DOzRCQUNELGFBQWEsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO3lCQUM3Qjt3QkFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsRUFBRTs0QkFDNUIsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUU7Z0NBQ2hGLE1BQU0sSUFBSSxLQUFLLENBQUMsaURBQWlELENBQUMsQ0FBQzs2QkFDcEU7NEJBQ0QsYUFBYSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7eUJBQ25DO3dCQUVELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxFQUFFOzRCQUN6QixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtnQ0FDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDOzZCQUM3Qzs0QkFDRCxhQUFhLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQzt5QkFDN0I7d0JBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsSUFBSSxLQUFLLEdBQUcsR0FBRyxFQUFFOzRCQUNwRCxNQUFNLElBQUksS0FBSyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7eUJBQy9EO3dCQUVELElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxFQUFFOzRCQUMvQixJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsRUFBRTtnQ0FDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDOzZCQUNwRDs0QkFDRCxhQUFhLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQzt5QkFDekM7d0JBR2lCLHFCQUFNLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFnQixFQUNoRSxVQUFBLENBQUMsSUFBSSxPQUFBLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxLQUFLLE9BQUEsRUFBRSxDQUFDLEVBQS9DLENBQStDLENBQ3JELEVBQUE7O3dCQUZLLFNBQVMsR0FBRyxTQUVqQjt3QkFDSyxXQUFXLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLHdCQUF3QixDQUFDLENBQUM7d0JBRTVELFlBQVksR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsU0FBVSxzQkFBc0I7Ozs7O3dDQUNyRSxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDO3dDQUNoQixxQkFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLEdBQUcsVUFBVSxDQUFDLENBQUM7aURBQ25HLElBQUksQ0FBQyxhQUFhLENBQUM7aURBQ25CLE1BQU0sRUFBRSxFQUFBOzt3Q0FGTCxVQUFVLEdBQUcsU0FFUjt3Q0FFWCx5QkFBeUI7d0NBQ3pCLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLEVBQUU7NENBRS9CLHFCQUFxQixPQUFPLENBQUMsMEJBQTBCLENBQUMsaUJBQXhDLENBQXlDOzRDQUNqRSxVQUFVLENBQUMsV0FBVyxHQUFHLGtCQUFnQixDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxDQUFDO3lDQUN4RTt3Q0FFRCxVQUFVLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQzt3Q0FDM0IsZ0JBQWdCLEdBQXlCLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxFQUFFLFdBQVcsYUFBQSxFQUFFLENBQUMsQ0FBQzt3Q0FFeEYsSUFBSSxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUU7NENBQzFCLE1BQU0sSUFBSSwrQkFBc0IsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQzt5Q0FDMUQ7d0NBRUQsSUFBSSxnQkFBZ0IsQ0FBQyxZQUFZLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsMEJBQTBCLEVBQUU7NENBQzlGLDBGQUEwRjs0Q0FDMUYsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzt5Q0FDL0M7d0NBRUQsc0JBQU8sVUFBVSxFQUFDOzs7eUJBQ25CLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQzt3QkFFZixJQUFJLFlBQVksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFOzRCQUM3QixzQkFBTyxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUM7eUJBQ3hCOzt3QkFHWSxxQkFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxFQUFBOzRCQUQ1Qyx1QkFDRSxZQUFTLEdBQUUsU0FBK0I7aUNBQzFDOzs7U0FDSCxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCw4QkFBYSxHQUFiLFVBQWMsTUFBaUMsRUFBRSxRQUE0QjtRQUEvRCx1QkFBQSxFQUFBLFdBQWlDO1FBQzdDLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBQzs7O2dCQUNGLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO2dCQUUvQixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRTtvQkFDeEIsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO2lCQUM5RDtnQkFFSyxTQUFTLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO2dCQUN0QyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsa0JBQWtCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztnQkFFaEUsc0JBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFDOztTQUNyRCxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDZCQUFZLEdBQVosVUFBYSxNQUE4QixFQUFFLFFBQTRCO1FBQTVELHVCQUFBLEVBQUEsV0FBOEI7UUFDekMsSUFBTSxLQUFLLEdBQXNCLEVBQUUsQ0FBQztRQUNwQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDakIsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUM5QixNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7YUFDOUQ7WUFDRCxLQUFLLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7U0FDOUI7UUFFRCxJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUU7WUFDaEIsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUM3QixNQUFNLElBQUksS0FBSyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7YUFDN0Q7WUFDRCxLQUFLLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUM7U0FDNUI7UUFFRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDekMsS0FBSyxDQUFDLEtBQUssQ0FBQzthQUNaLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSCxnQ0FBZSxHQUFmLFVBQWdCLE1BQW1DLEVBQUUsUUFBNEI7UUFBakUsdUJBQUEsRUFBQSxXQUFtQztRQUNqRCxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLG1CQUFtQixDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFNUYsSUFBTSxhQUFhLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUM7UUFDMUMsSUFBTSxvQkFBb0IsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDO1FBQ3hELElBQUksQ0FBQyxhQUFhLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtZQUMzQyxNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7U0FDdkU7UUFFRCxJQUFJLGFBQWEsSUFBSSxvQkFBb0IsRUFBRTtZQUN6QyxNQUFNLElBQUksS0FBSyxDQUFDLGtFQUFrRSxDQUFDLENBQUM7U0FDckY7UUFFRCw4RkFBOEY7UUFDOUYsb0NBQW9DO1FBRXBDLDREQUE0RDtRQUM1RCxJQUFNLGNBQWMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLFlBQVksRUFBRSxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7UUFFM0UsSUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztRQUNuQyxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxHQUFHLFNBQVMsR0FBRyxXQUFXLENBQUMsQ0FBQzthQUNyRSxJQUFJLENBQUMsY0FBYyxDQUFDO2FBQ3BCLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDJCQUFVLEdBQVYsVUFBVyxNQUFpQyxFQUFFLFFBQTRCO1FBQS9ELHVCQUFBLEVBQUEsV0FBaUM7UUFDMUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLEVBQUUsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBRTdELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUMxQyxJQUFJLENBQUMsTUFBTSxDQUFDO2FBQ1osTUFBTSxFQUFFO2FBQ1IsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsOEJBQWEsR0FBYixVQUFjLE1BQWlDLEVBQUUsUUFBNEI7UUFBL0QsdUJBQUEsRUFBQSxXQUFpQztRQUM3QyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFN0QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ3pDLElBQUksQ0FBQyxNQUFNLENBQUM7YUFDWixNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCx5Q0FBd0IsR0FBeEIsVUFBeUIsTUFBZSxFQUFFLFFBQTRCO1FBQTdDLHVCQUFBLEVBQUEsV0FBZTtRQUN0QyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsSUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDLFVBQVcsS0FBYTs7Ozs7d0JBQzdDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxLQUFLLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFOzRCQUMzRCxNQUFNLElBQUksS0FBSyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7eUJBQzNEO3dCQUVLLE1BQU0sR0FBRyxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO3dCQUUvQixxQkFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBQTs7d0JBQXRELFFBQVEsR0FBRyxTQUEyQzt3QkFDNUQsZ0ZBQWdGO3dCQUNoRixJQUFJLFFBQVEsQ0FBQyxZQUFZLEVBQUU7NEJBQ3pCLHNCQUFPLFFBQVEsRUFBQzt5QkFDakI7d0JBQ0Qsc0JBQU8sV0FBVyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsRUFBQzs7O1NBQy9CLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFZCxPQUFPLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILHVCQUFNLEdBQU4sVUFBTyxNQUEwQixFQUFFLFFBQTRCO1FBQXhELHVCQUFBLEVBQUEsV0FBMEI7UUFDL0IsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFDOzs7Ozt3QkFDUixNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSxLQUFLLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFFekUsc0JBQXNCO3dCQUN0QixJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7NEJBQ3ZFLE1BQU0sSUFBSSxLQUFLLENBQUMsOENBQThDLENBQUMsQ0FBQzt5QkFDakU7d0JBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUU7NEJBQ3pELE1BQU0sSUFBSSxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQzt5QkFDekM7d0JBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFOzRCQUNuRixNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7eUJBQ3REO3dCQUVELElBQUksTUFBTSxDQUFDLEdBQUcsRUFBRTs0QkFDZCxzQkFBTyxNQUFNLENBQUMsR0FBRyxFQUFDO3lCQUNuQjt3QkFFb0IscUJBQU0sSUFBSSxDQUFDLHdCQUF3QixFQUFFLEVBQUE7O3dCQUFwRCxZQUFZLEdBQUcsU0FBcUM7d0JBQ3BELGdCQUFnQixHQUFHLFlBQVksQ0FBQyxZQUFZLENBQUM7d0JBR25ELElBQUk7NEJBQ0YsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixFQUFFLFFBQVEsRUFBRSxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDO3lCQUM5Rjt3QkFBQyxPQUFPLENBQUMsRUFBRTs0QkFDVixNQUFNLElBQUksS0FBSyxDQUFDLG9DQUFvQyxDQUFDLENBQUM7eUJBQ3ZEO3dCQUVELHNCQUFPLE9BQU8sRUFBQzs7O1NBQ2hCLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsNEJBQVcsR0FBWCxVQUFZLE1BQStCLEVBQUUsUUFBNEI7UUFBN0QsdUJBQUEsRUFBQSxXQUErQjtRQUN6QyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDLE1BQU0sRUFBRSxhQUFhLENBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFckUsSUFBSSxNQUFNLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDbEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxZQUFZLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFVBQVUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsUUFBUSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUU7Z0JBQzlJLE1BQU0sSUFBSSxLQUFLLENBQUMsOEVBQThFLENBQUMsQ0FBQzthQUNqRztTQUNGO1FBRUQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQ3ZDLElBQUksQ0FBQyxNQUFNLENBQUM7YUFDWixNQUFNLEVBQUU7YUFDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsNEJBQVcsR0FBWCxVQUFZLE1BQStCLEVBQUUsUUFBNEI7UUFBN0QsdUJBQUEsRUFBQSxXQUErQjtRQUN6QyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQUM7Ozs7O3dCQUNSLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxFQUFFLENBQUMsa0JBQWtCLEVBQUUsU0FBUyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7d0JBRW5HLElBQUksTUFBTSxDQUFDLE9BQU8sS0FBSyxTQUFTLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRTs0QkFDaEUsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO3lCQUN0RDt3QkFFRCxJQUFJLE1BQU0sQ0FBQyxZQUFZLEtBQUssU0FBUyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUU7NEJBQzFFLE1BQU0sSUFBSSxLQUFLLENBQUMseUNBQXlDLENBQUMsQ0FBQzt5QkFDNUQ7d0JBQ0ssYUFBYSxHQUFHLENBQUMsTUFBTSxDQUFDLFlBQVksSUFBSSxNQUFNLENBQUMsV0FBVyxJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO3dCQUUvRyxJQUFJLE1BQU0sQ0FBQyxZQUFZLEtBQUssU0FBUyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUU7NEJBQzFFLE1BQU0sSUFBSSxLQUFLLENBQUMsd0NBQXdDLENBQUMsQ0FBQzt5QkFDM0Q7d0JBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFOzRCQUM3QixNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7eUJBQzVEO3dCQUVlLHFCQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxFQUFBOzt3QkFBL0UsT0FBTyxHQUFHLFNBQXFFOzZCQUVqRixhQUFhLEVBQWIsd0JBQWE7Ozs7d0JBRUkscUJBQU0sSUFBSSxDQUFDLHdCQUF3QixDQUFDLEVBQUUsQ0FBQyxFQUFBOzt3QkFBbEQsUUFBUSxHQUFHLFNBQXVDO3dCQUN4RCx5Q0FBeUM7d0JBQ3pDLElBQUksUUFBUSxDQUFDLFlBQVksRUFBRTs0QkFDekIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTtnQ0FDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDOzZCQUN0RDs0QkFDRCxJQUFJO2dDQUNGLFFBQVEsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDLGdCQUFnQixFQUFFLEtBQUssRUFBRSxRQUFRLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQzs2QkFDeEc7NEJBQUMsT0FBTyxDQUFDLEVBQUU7Z0NBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDOzZCQUNwRDs0QkFFSyxLQUFLLEdBQUcsdUJBQWEsRUFBRSxDQUFDOzRCQUN4QixNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLGNBQWMsRUFBRSxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQzs0QkFDcEYsZUFBZSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7NEJBRXRGLGNBQWMsR0FBRztnQ0FDZixHQUFHLEVBQUUsUUFBUSxDQUFDLEdBQUc7Z0NBQ2pCLFlBQVksRUFBRSxlQUFlO2dDQUM3QixVQUFVLEVBQUUsS0FBSyxDQUFDLGtCQUFrQixFQUFFLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQztnQ0FDdEQsUUFBUSxFQUFFLE9BQU8sQ0FBQyxNQUFNO2dDQUN4QixJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUk7NkJBQ25CLENBQUM7eUJBQ0g7Ozs7d0JBRUQsSUFBSSxHQUFDLENBQUMsT0FBTyxLQUFLLHdDQUF3QyxFQUFFOzRCQUMxRCxjQUFjLEdBQUcsRUFBRSxDQUFDOzRCQUNwQiwwREFBMEQ7eUJBQzNEOzZCQUFNOzRCQUNMLE1BQU0sR0FBQyxDQUFDO3lCQUNUOzs7d0JBSUMsT0FBTyxHQUF1Qjs0QkFDbEMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxNQUFNOzRCQUNwQixXQUFXLEVBQUUsTUFBTSxDQUFDLFdBQVc7NEJBQy9CLE9BQU8sRUFBRSxNQUFNLENBQUMsT0FBTzs0QkFDdkIsT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPOzRCQUN2QixZQUFZLEVBQUUsTUFBTSxDQUFDLFlBQVk7eUJBQ2xDLENBQUM7d0JBRUYsSUFBSSxjQUFjLEVBQUU7NEJBQ2xCLE9BQU8sQ0FBQyxRQUFRLEdBQUcsY0FBYyxDQUFDO3lCQUNuQzs2QkFBTSxJQUFJLE1BQU0sQ0FBQyxZQUFZLEVBQUU7NEJBQzlCLE9BQU8sQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO3lCQUN2Qjt3QkFFRCxzQkFBTyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxFQUFDOzs7U0FDbEMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILDJCQUFVLEdBQVYsVUFBVyxNQUE4QixFQUFFLFFBQTRCO1FBQTVELHVCQUFBLEVBQUEsV0FBOEI7UUFDdkMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFeEQsSUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUM3QixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxDQUFDO2FBQy9DLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BZ0NHO0lBQ0gsb0NBQW1CLEdBQW5CLFVBQW9CLE1BQXVDLEVBQUUsUUFBa0Q7UUFBM0YsdUJBQUEsRUFBQSxXQUF1QztRQUN6RCxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQTRCOzs7Ozt3QkFFN0IsaUJBQWlCLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLHlCQUF5QixFQUFFLENBQUMsQ0FBQzt3QkFDM0UsS0FBSyxDQUFDLDZCQUE2QixFQUFFLGlCQUFpQixDQUFDLENBQUM7d0JBRXhELElBQUksTUFBTSxDQUFDLEtBQUssRUFBRTs0QkFDaEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7eUJBQzNDO3dCQUNtQixxQkFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsRUFBQTs7d0JBQWpHLFdBQVcsR0FBRyxTQUFtRjt3QkFDdkcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxXQUFXLENBQUMsQ0FBQzt3QkFDeEMsV0FBVyxHQUFHOzRCQUNsQixtQkFBbUIsRUFBRSxNQUFNLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUzt5QkFDbkUsQ0FBQzt3QkFFSSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBRyxXQUFXLENBQUMsQ0FBQzs2QkFDeEYsS0FBSyxDQUFDLFdBQVcsQ0FBQzs2QkFDbEIsSUFBSSxDQUFDLGlCQUFpQixDQUFDOzZCQUN2QixNQUFNLEVBQUUsQ0FBQzt3QkFDTixRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQTRCLENBQUM7d0JBQzdDLGdCQUFnQixHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQzs0QkFDcEUsUUFBUSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDOzRCQUM3QyxPQUFPLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO3dCQUN2QixPQUFPLEdBQUcsQ0FBQyxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQzt3QkFDVixxQkFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFBOzt3QkFBekQsS0FBK0IsU0FBMEIsRUFBeEQsYUFBYSxRQUFBLEVBQUUsV0FBVyxRQUFBO3dCQUNqQyxLQUFLLENBQUMseUNBQXlDLEVBQUUsYUFBYSxDQUFDLENBQUM7d0JBQ2hFLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxFQUFFOzRCQUMvQixhQUFhLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQzt5QkFDekM7d0JBQ21DLHFCQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQ3pFLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxDQUMvRSxFQUFBOzt3QkFGRyxRQUFRLEdBQXdCLFNBRW5DO3dCQUNELE9BQU8sUUFBUSxDQUFDLE1BQU0sQ0FBQzt3QkFDdkIsT0FBTyxRQUFRLENBQUMsV0FBVyxDQUFDO3dCQUM1QixRQUFRLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsUUFBUSxFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7d0JBQzNELElBQUksSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksSUFBSSxDQUFDLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRTs0QkFDOUUsUUFBUSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLFFBQVEsRUFBRSxFQUFFLHFCQUFxQixFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7eUJBQ3JHO3dCQUNELEtBQUssQ0FBQyxnQ0FBZ0MsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFDbEQsc0JBQU8sUUFBcUMsRUFBQzs7O1NBQzlDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILGdDQUFlLEdBQWYsVUFDRSxNQUF5QyxFQUN6QyxRQUEwQztRQUQxQyx1QkFBQSxFQUFBLFdBQXlDO1FBR3pDLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBb0I7Ozs7O3dCQUNyQixVQUFVLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQzt3QkFDckMsSUFBSSxDQUFDLFVBQVUsSUFBSSxPQUFPLFVBQVUsS0FBSyxRQUFRLEVBQUU7NEJBQ2pELE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQzt5QkFDakQ7d0JBQ2UscUJBQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsRUFBQTs7d0JBQXhELE9BQU8sR0FBRyxTQUE4Qzt3QkFDeEQsT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7d0JBQ25DLGFBQWEsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO3dCQUN0RixzQkFBTyxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsRUFBQzs7O1NBQ3JELENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsMkJBQVUsR0FBVixVQUFXLE1BQThCO1FBQTlCLHVCQUFBLEVBQUEsV0FBOEI7UUFDdkMsSUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDO1FBQ25ELElBQUksT0FBTyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUM7UUFDekIsSUFBSSxPQUFPLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO1lBQzFDLE1BQU0sSUFBSSxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQztTQUN6QztRQUNELElBQUksT0FBTyxJQUFJLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRTtZQUN4Qyw0REFBNEQ7WUFDNUQsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLENBQUM7WUFDdEcsT0FBTyxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUM7U0FDMUI7YUFBTSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ25CLElBQUksQ0FBQyxZQUFZLElBQUksT0FBTyxZQUFZLEtBQUssUUFBUSxFQUFFO2dCQUNyRCxNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QixDQUFDLENBQUM7YUFDL0M7WUFDRCxJQUFNLGdCQUFnQixHQUFHLFlBQVksQ0FBQyxZQUFZLENBQUM7WUFDbkQsSUFBSSxDQUFDLGdCQUFnQixFQUFFO2dCQUNyQixNQUFNLElBQUksS0FBSyxDQUFDLDhDQUE4QyxDQUFDLENBQUM7YUFDakU7WUFDRCxJQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUFFO2dCQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7YUFDdEQ7WUFFRCxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7U0FDOUY7UUFDRCxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDJDQUEwQixHQUExQixVQUEyQixNQUE4QyxFQUFFLFFBQTBDO1FBQTFGLHVCQUFBLEVBQUEsV0FBOEM7UUFDdkUsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFvQjs7Ozs7d0JBQzNCLElBQUksTUFBTSxDQUFDLFVBQVUsSUFBSSxNQUFNLENBQUMsVUFBVSxFQUFFOzRCQUNwQyxLQUFLLEdBQVEsSUFBSSxLQUFLLENBQUMsd0RBQXdELENBQUMsQ0FBQzs0QkFDdkYsS0FBSyxDQUFDLElBQUksR0FBRywwQ0FBMEMsQ0FBQzs0QkFDeEQsTUFBTSxLQUFLLENBQUM7eUJBQ2I7d0JBRUQsSUFBSSxNQUFNLENBQUMsVUFBVSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUU7NEJBQ3BELEtBQUssR0FBUSxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDOzRCQUMzRCxLQUFLLENBQUMsSUFBSSxHQUFHLHNCQUFzQixDQUFDOzRCQUNwQyxNQUFNLEtBQUssQ0FBQzt5QkFDYjt3QkFFRCxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7NEJBQ2xFLEtBQUssR0FBUSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDOzRCQUNuRSxLQUFLLENBQUMsSUFBSSxHQUFHLHVDQUF1QyxDQUFDOzRCQUNyRCxNQUFNLEtBQUssQ0FBQzt5QkFDYjt3QkFJSyxlQUFlLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFHaEcscUJBQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFBOzt3QkFBcEcsU0FBUyxHQUFHLFNBQXdGO3dCQUV2RixxQkFBTSxlQUFlLEVBQUE7O3dCQUFsQyxVQUFVLEdBQUcsU0FBcUI7Ozs7d0JBR2hDLGtCQUFrQixHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksSUFBSSxFQUFFLEVBQUUsQ0FBQyxtQkFBbUIsRUFBRSxXQUFXLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQzt3QkFDOUcscUJBQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQztnQ0FDcEMsUUFBUSxFQUFFLE1BQU07Z0NBQ2hCLFVBQVUsWUFBQTtnQ0FDVixNQUFNLEVBQUUsSUFBSTtnQ0FDWixZQUFZLEVBQUUsa0JBQWtCO2dDQUNoQyxLQUFLLEVBQUUsTUFBTSxDQUFDLEtBQUs7NkJBQ3BCLENBQUMsRUFBQTs7d0JBTkYsU0FNRSxDQUFDOzs7O3dCQUVILEtBQUssQ0FBQywrQkFBK0IsRUFBRSxHQUFDLENBQUMsQ0FBQzt3QkFDMUMsT0FBTyxDQUFDLEtBQUssQ0FBQywrQ0FBK0MsQ0FBQyxDQUFDO3dCQUMvRCxNQUFNLEdBQUMsQ0FBQzs7d0JBSUosYUFBYSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sRUFBRTs0QkFDekMsVUFBVSxFQUFFLFVBQVU7NEJBQ3RCLE1BQU0sRUFBRTtnQ0FDTixzRUFBc0U7Z0NBQ3RFLGNBQWMsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxjQUFjOzZCQUN6RDs0QkFDRCxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQzs0QkFDdEIsY0FBYyxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJOzRCQUM1RCxhQUFhLEVBQUUsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUk7eUJBQzVELENBQUMsQ0FBQzs7Ozt3QkFHTSxxQkFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxFQUFBOzRCQUFoRCxzQkFBTyxTQUF5QyxFQUFDOzs7d0JBRWpELElBQUksT0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsb0JBQW9CLENBQUMsRUFBRTs0QkFDaEQsT0FBSyxDQUFDLElBQUksR0FBRyxvQkFBb0IsQ0FBQzs0QkFDbEMsT0FBSyxDQUFDLGNBQWMsR0FBRztnQ0FDckIsYUFBYSxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUU7Z0NBQ25DLHNCQUFzQixFQUFFLElBQUksQ0FBQyxzQkFBc0IsRUFBRTtnQ0FDckQsc0JBQXNCLEVBQUUsSUFBSSxDQUFDLHNCQUFzQixFQUFFO2dDQUNyRCxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRTtnQ0FDdkIsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixFQUFFO2dDQUN6QyxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7NkJBQzFDLENBQUM7NEJBQ0YsT0FBSyxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLFVBQVUsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLGtCQUFrQixFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7eUJBQy9GO3dCQUNELE1BQU0sT0FBSyxDQUFDOzs7O1NBRWYsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxzQ0FBcUIsR0FBckIsVUFBc0IsTUFBeUMsRUFBRSxRQUE0QjtRQUF2RSx1QkFBQSxFQUFBLFdBQXlDO1FBQzdELElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBQzs7Ozs7d0JBQ1Isa0hBQWtIO3dCQUNsSCx3REFBd0Q7d0JBQ3hELElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7NEJBQ2xHLEtBQUssR0FBUSxJQUFJLEtBQUssQ0FBQyxnREFBZ0QsQ0FBQyxDQUFDOzRCQUMvRSxLQUFLLENBQUMsSUFBSSxHQUFHLHFCQUFxQixDQUFDOzRCQUNuQyxNQUFNLEtBQUssQ0FBQzt5QkFDYjt3QkFFRCxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFFOzRCQUNyQyxJQUFJLE1BQU0sQ0FBQyxhQUFhLEtBQUssSUFBSSxFQUFFO2dDQUMzQixLQUFLLEdBQVEsSUFBSSxLQUFLLENBQUMscURBQXFELENBQUMsQ0FBQztnQ0FDcEYsS0FBSyxDQUFDLElBQUksR0FBRyxxQkFBcUIsQ0FBQztnQ0FDbkMsTUFBTSxLQUFLLENBQUM7NkJBQ2I7eUJBQ0Y7NkJBQU07NEJBQ0wsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxXQUFXLEdBQUcsQ0FBQyxFQUFFO2dDQUN4RCxLQUFLLEdBQVEsSUFBSSxLQUFLLENBQUMsNENBQTRDLENBQUMsQ0FBQztnQ0FDM0UsS0FBSyxDQUFDLElBQUksR0FBRyxxQ0FBcUMsQ0FBQztnQ0FDbkQsTUFBTSxLQUFLLENBQUM7NkJBQ2I7eUJBQ0Y7d0JBRUQsSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTs0QkFDaEMsSUFBSSxNQUFNLENBQUMsUUFBUSxLQUFLLElBQUksRUFBRTtnQ0FDdEIsS0FBSyxHQUFRLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7Z0NBQzFFLEtBQUssQ0FBQyxJQUFJLEdBQUcsZ0JBQWdCLENBQUM7Z0NBQzlCLE1BQU0sS0FBSyxDQUFDOzZCQUNiO3lCQUNGOzZCQUFNOzRCQUNMLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQ0FDOUMsS0FBSyxHQUFRLElBQUksS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7Z0NBQ3RFLEtBQUssQ0FBQyxJQUFJLEdBQUcsZ0NBQWdDLENBQUM7Z0NBQzlDLE1BQU0sS0FBSyxDQUFDOzZCQUNiO3lCQUNGO3dCQUVELElBQUksTUFBTSxDQUFDLFVBQVUsS0FBSyxTQUFTLEVBQUU7NEJBQ25DLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0NBQ3ZFLE1BQU0sSUFBSSxLQUFLLENBQUMsOERBQThELENBQUMsQ0FBQzs2QkFDakY7eUJBQ0Y7d0JBRUQsTUFBTSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUM7d0JBR0YsS0FBQSxDQUFBLEtBQUEsTUFBTSxDQUFBLENBQUMsTUFBTSxDQUFBOzhCQUFDLE1BQU07d0JBQUUscUJBQU0sSUFBSSxDQUFDLDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxFQUFBOzt3QkFBbEYsWUFBWSxHQUFHLHdCQUFzQixTQUE2QyxHQUFDO3dCQUN6RixPQUFPLFlBQVksQ0FBQyxNQUFNLENBQUM7d0JBQ3BCLHFCQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsRUFBQTs0QkFBakQsc0JBQU8sU0FBMEMsRUFBQzs7O1NBQ25ELENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxrQ0FBaUIsR0FBakIsVUFBa0IsTUFBcUMsRUFBRSxRQUE0QjtRQUFuRSx1QkFBQSxFQUFBLFdBQXFDO1FBQ3JELE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUM5RCxJQUFNLFFBQVEsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztRQUNoQyxJQUFNLGFBQWEsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQztRQUUxQyxJQUFJLENBQUMsUUFBUSxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUNoRSxNQUFNLElBQUksS0FBSyxDQUFDLHNEQUFzRCxDQUFDLENBQUM7U0FDekU7UUFDRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUcsVUFBVSxDQUFDLENBQUM7YUFDM0UsSUFBSSxDQUFDLE1BQU0sQ0FBQzthQUNaLE1BQU0sRUFBRTthQUNSLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7T0FhRztJQUNILHFCQUFJLEdBQUosVUFBSyxNQUF3QixFQUFFLFFBQTRCO1FBQXRELHVCQUFBLEVBQUEsV0FBd0I7UUFDM0IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUUxRSxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2hDLE1BQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQztTQUN0RDtRQUVELElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDakMsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO1NBQ3REO1FBRUQsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUUzQixJQUFNLE1BQU0sR0FBRyxJQUFJLHdCQUFTLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzVDLElBQUksTUFBTSxDQUFDLFVBQVUsRUFBRSxFQUFFO1lBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsNEZBQTRGLENBQUMsQ0FBQztTQUMvRztRQUVELElBQUksQ0FBQyxJQUFJLENBQUMsd0JBQXdCLEVBQUUsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDdkQsTUFBTSxJQUFJLEtBQUssQ0FBQyw0RkFBNEYsQ0FBQyxDQUFDO1NBQy9HO1FBRUQsSUFBTSxVQUFVLEdBQWtDLENBQUM7Z0JBQ2pELE9BQU8sRUFBRSxNQUFNLENBQUMsT0FBTztnQkFDdkIsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNO2FBQ3RCLENBQUMsQ0FBQztRQUVILElBQUksTUFBTSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsc0JBQXNCLEVBQUUsRUFBRTtZQUNoRCxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUM7U0FDbEM7UUFFRCxJQUFNLGVBQWUsR0FBb0IsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFLEVBQUUsVUFBVSxZQUFBLEVBQUUsQ0FBQyxDQUFDO1FBQ25GLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpQ0c7SUFDSCx5QkFBUSxHQUFSLFVBQVMsTUFBNEIsRUFBRSxRQUE0QjtRQUExRCx1QkFBQSxFQUFBLFdBQTRCO1FBQ25DLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBQzs7Ozs7d0JBQ1IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUNoRSxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQzt3QkFDbkIsS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLElBQUksSUFBSSxvQkFBYSxFQUFFLENBQUM7d0JBQ2xELE1BQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO3dCQUNmLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO3dCQUMzQixJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFOzRCQUNqQyxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxVQUFTLFNBQVM7Z0NBQ3RDLElBQU0sTUFBTSxHQUFHLElBQUksd0JBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7Z0NBQy9DLElBQUksTUFBTSxDQUFDLFVBQVUsRUFBRSxFQUFFO29DQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLDRGQUE0RixDQUFDLENBQUM7aUNBQy9HO2dDQUNELElBQUksQ0FBQyxJQUFJLENBQUMsd0JBQXdCLEVBQUUsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFLEVBQUU7b0NBQ3ZELE1BQU0sSUFBSSxLQUFLLENBQUMsNEZBQTRGLENBQUMsQ0FBQztpQ0FDL0c7NEJBQ0gsQ0FBQyxDQUFDLENBQUM7eUJBQ0o7d0JBRTZCLHFCQUFNLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxNQUFNLENBQUMsRUFBQTs7d0JBQXJFLHFCQUFxQixHQUFHLFNBQTZDO3dCQUNyRSxZQUFZLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7NEJBQ2xDLFlBQVksRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxhQUFhOzRCQUNqRSw2QkFBNkIsRUFBRSxzQkFBc0I7NEJBQ3JELFNBQVMsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFlBQVk7NEJBQy9DLG9CQUFvQixFQUFFLHFCQUFxQixFQUFFLFVBQVU7NEJBQ3ZELGVBQWUsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxlQUFlOzRCQUM5RCxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxZQUFZO3lCQUN4QyxDQUFDLENBQUM7d0JBQ0csYUFBYSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLHFCQUFxQixFQUFFLFlBQVksQ0FBQyxDQUFDO3dCQUN4RSxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDO3dCQUNuQyxzQkFBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2lDQUN6QyxJQUFJLENBQUMsYUFBYSxDQUFDO2lDQUNuQixNQUFNLEVBQUUsRUFBQzs7O1NBQ2IsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNILDZCQUFZLEdBQVosVUFBYSxNQUFnQyxFQUFFLFFBQTRCO1FBQTlELHVCQUFBLEVBQUEsV0FBZ0M7UUFDM0MsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFDOzs7Z0JBQ1IsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxLQUFLLEtBQUssRUFBRTtvQkFDdkMsTUFBTSxJQUFJLEtBQUssQ0FBQywrQ0FBK0MsQ0FBQyxDQUFDO2lCQUNsRTtnQkFHQyxvQkFBb0IsR0FFbEIsTUFBTSxxQkFGWSxFQUNwQixTQUFTLEdBQ1AsTUFBTSxVQURDLENBQ0E7Z0JBRVgsSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDLG9CQUFvQixDQUFDLEVBQUU7b0JBQ3ZDLE1BQU0sSUFBSSxLQUFLLENBQUMsd0RBQXdELENBQUMsQ0FBQztpQkFDM0U7Z0JBRUQsSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxFQUFFO29CQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLDZDQUE2QyxDQUFDLENBQUM7aUJBQ2hFO2dCQUVLLG1CQUFtQixHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxvQkFBb0Isc0JBQUEsRUFBRSxTQUFTLFdBQUEsRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO2dCQUN6RyxzQkFBUSxJQUFJLENBQUMsUUFBZ0IsQ0FBQyxZQUFZLENBQUMsbUJBQW1CLENBQUMsRUFBQzs7U0FDakUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsMkNBQTBCLEdBQTFCLFVBQTJCLE1BQWUsRUFBRSxRQUE0QjtRQUE3Qyx1QkFBQSxFQUFBLFdBQWU7UUFDeEMsT0FBTyxRQUFRLENBQUMsMEJBQTBCLENBQUMsRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3RILENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsMEJBQVMsR0FBVCxVQUFVLE1BQTZCLEVBQUUsUUFBNEI7UUFBM0QsdUJBQUEsRUFBQSxXQUE2QjtRQUNyQyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQUM7O2dCQUNSLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFFN0Qsc0JBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBRyxlQUFlLENBQUMsQ0FBQzt5QkFDaEYsSUFBSSxDQUFDLE1BQU0sQ0FBQzt5QkFDWixNQUFNLEVBQUUsRUFBQzs7U0FDYixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILCtCQUFjLEdBQWQsVUFBZSxNQUE4QixFQUFFLFFBQTRCO1FBQTVELHVCQUFBLEVBQUEsV0FBOEI7UUFDM0MsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFDLFNBQVUsZ0JBQWdCOztnQkFDbEMsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7Z0JBQ3RCLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2dCQUVyRCxzQkFBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO3lCQUM1QyxLQUFLLENBQUMsTUFBTSxDQUFDO3lCQUNiLE1BQU0sRUFBRSxFQUFDOztTQUNiLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0gsb0NBQW1CLEdBQW5CLFVBQW9CLE1BQWUsRUFBRSxRQUE0QjtRQUE3Qyx1QkFBQSxFQUFBLFdBQWU7UUFDakMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO2FBQzdDLElBQUksQ0FBQyxNQUFNLENBQUM7YUFDWixNQUFNLEVBQUU7YUFDUixVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxpQ0FBZ0IsR0FBaEIsVUFBaUIsTUFBb0MsRUFBRSxRQUE0QjtRQUFsRSx1QkFBQSxFQUFBLFdBQW9DO1FBQ25ELElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBQzs7Z0JBQ1IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFFckUsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxFQUFFO29CQUNqQyxNQUFNLElBQUksS0FBSyxDQUFDLHNDQUFzQyxDQUFDLENBQUM7aUJBQ3pEO2dCQUVELElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtvQkFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO2lCQUNyRDtnQkFFRCxzQkFBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO3lCQUM3QyxJQUFJLENBQUMsTUFBTSxDQUFDO3lCQUNaLE1BQU0sRUFBRSxFQUFDOztTQUNiLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsOEJBQWEsR0FBYixVQUFjLE1BQWdCLEVBQUUsUUFBNEI7UUFBOUMsdUJBQUEsRUFBQSxXQUFnQjtRQUM1QixJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQUM7O2dCQUNSLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7Z0JBRXJFLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRTtvQkFDakMsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO2lCQUN6RDtnQkFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7b0JBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsa0NBQWtDLENBQUMsQ0FBQztpQkFDckQ7Z0JBRUQsc0JBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQzt5QkFDNUMsSUFBSSxDQUFDLE1BQU0sQ0FBQzt5QkFDWixNQUFNLEVBQUUsRUFBQzs7U0FDYixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxpQ0FBZ0IsR0FBaEIsVUFBaUIsTUFBb0MsRUFBRSxRQUE0QjtRQUFsRSx1QkFBQSxFQUFBLFdBQW9DO1FBQ25ELElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBQzs7Z0JBQ1IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO2dCQUU3RCxzQkFBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO3lCQUM1QyxJQUFJLENBQUMsTUFBTSxDQUFDO3lCQUNaLE1BQU0sRUFBRSxFQUFDOztTQUNiLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILHVCQUFNLEdBQU4sVUFBTyxNQUFlLEVBQUUsUUFBNEI7UUFBN0MsdUJBQUEsRUFBQSxXQUFlO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFFRDs7T0FFRztJQUNILGlDQUFnQixHQUFoQjtRQUNFLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsS0FBSyxLQUFLLEVBQUU7WUFDdkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxnRUFBZ0UsQ0FBQyxDQUFDO1NBQ25GO1FBQ0QsT0FBTyxJQUFJLCtCQUFjLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2RSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O09BaUJHO0lBQ0gsZ0NBQWUsR0FBZixVQUFnQixNQUFtQztRQUFuQyx1QkFBQSxFQUFBLFdBQW1DO1FBQ2pELElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFO1lBQy9CLE1BQU0sSUFBSSxLQUFLLENBQUMsaUVBQWlFLENBQUMsQ0FBQztTQUNwRjtRQUVELGtEQUFrRDtRQUVoRCxJQUFBLG9CQUFLLEVBQ0wsc0JBQU0sRUFDTixrQ0FBWSxFQUNaLHNDQUFjLEVBQ2Qsb0NBQWEsRUFDYiw4QkFBVSxFQUNWLHNEQUFzQixFQUN0QixnQ0FBVyxFQUNYLGdDQUFXLEVBQ1gsMEJBQXVFLEVBQXZFLDRGQUF1RSxDQUM5RDtRQUVYLElBQUksQ0FBQyxLQUFLLElBQUksT0FBTyxLQUFLLEtBQUssVUFBVSxFQUFFO1lBQ3pDLE1BQU0sSUFBSSxLQUFLLENBQUMsdUNBQXVDLENBQUMsQ0FBQztTQUMxRDtRQUVELHFCQUFxQjtRQUNyQixJQUFJLENBQUMsWUFBWSxJQUFJLE9BQU8sWUFBWSxLQUFLLFFBQVEsRUFBRTtZQUNyRCxNQUFNLElBQUksS0FBSyxDQUFDLDZDQUE2QyxDQUFDLENBQUM7U0FDaEU7UUFFRCxJQUFJLENBQUMsY0FBYyxJQUFJLE9BQU8sY0FBYyxLQUFLLFFBQVEsRUFBRTtZQUN6RCxNQUFNLElBQUksS0FBSyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7U0FDdEU7UUFFRCxJQUFJLENBQUMsYUFBYSxJQUFJLE9BQU8sYUFBYSxLQUFLLFFBQVEsRUFBRTtZQUN2RCxNQUFNLElBQUksS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQUM7U0FDckU7UUFFRCxJQUFJLFdBQVcsSUFBSSxPQUFPLFdBQVcsS0FBSyxRQUFRLEVBQUU7WUFDbEQsTUFBTSxJQUFJLEtBQUssQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO1NBQ2pEO1FBRUQsSUFBSSxXQUFXLElBQUksT0FBTyxXQUFXLEtBQUssUUFBUSxFQUFFO1lBQ2xELE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQztTQUNqRDtRQUVELHVDQUF1QztRQUN2QyxJQUFJLE9BQU8sY0FBYyxLQUFLLFFBQVEsRUFBRTtZQUN0QyxNQUFNLElBQUksS0FBSyxDQUFDLGtDQUFrQyxDQUFDLENBQUM7U0FDckQ7UUFFRCxJQUFJLGNBQWMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQy9CLE1BQU0sSUFBSSxLQUFLLENBQUMsd0NBQXdDLENBQUMsQ0FBQztTQUMzRDtRQUVELElBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO1FBQ3pDLElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDN0MsSUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7UUFFdkMsSUFBTSxHQUFHLEdBQUcscUJBQVcsQ0FBQztZQUN0QixLQUFLLE9BQUE7WUFDTCxNQUFNLFFBQUE7WUFDTixPQUFPLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPO1lBQzNCLGFBQWEsZUFBQTtZQUNiLFFBQVEsVUFBQTtZQUNSLGNBQWMsZ0JBQUE7WUFDZCxXQUFXLGFBQUE7WUFDWCxVQUFVLFlBQUE7WUFDVixzQkFBc0Isd0JBQUE7WUFDdEIsWUFBWSxjQUFBO1lBQ1osY0FBYyxnQkFBQTtZQUNkLGFBQWEsZUFBQTtZQUNiLFdBQVcsYUFBQTtZQUNYLFdBQVcsYUFBQTtTQUNaLENBQUMsQ0FBQztRQUVILHFDQUFxQztRQUNyQyxHQUFHLENBQUMsSUFBSSxDQUFDLHVCQUFxQixXQUFXLFNBQU0sQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILDJDQUEwQixHQUExQixVQUEyQixNQUFpRCxFQUFFLFFBQW9EO1FBQXZHLHVCQUFBLEVBQUEsV0FBaUQ7UUFDMUUsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUE4Qjs7Ozs7d0JBQ3JDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLDJCQUEyQixFQUFFLEVBQUU7NEJBQ2hELE1BQU0sSUFBSSxLQUFLLENBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsNENBQXlDLENBQUMsQ0FBQzt5QkFDMUY7d0JBR0ssaUJBQWlCLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLGdDQUFnQyxFQUFFLENBQUMsQ0FBQzt3QkFDbEYsS0FBSyxDQUFDLDJDQUEyQyxFQUFFLGlCQUFpQixDQUFDLENBQUM7d0JBRXRFLElBQUksTUFBTSxDQUFDLEtBQUssRUFBRTs0QkFDaEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7eUJBQzNDO3dCQUdxQixxQkFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFHLDJCQUEyQixDQUFDLENBQUM7aUNBQ2pILElBQUksQ0FBQyxpQkFBaUIsQ0FBQztpQ0FDdkIsTUFBTSxFQUFFLEVBQUE7O3dCQUZMLGFBQWEsR0FBRyxTQUVYO3dCQUdMLGNBQWMsR0FBeUIsRUFBRSxDQUFDOzhCQUNHLEVBQWIsK0JBQWE7Ozs2QkFBYixDQUFBLDJCQUFhLENBQUE7d0JBQXhDLHVCQUF1Qjt3QkFDSSxxQkFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLG1CQUFtQixDQUN6RSxNQUFNLENBQUMsTUFBTSxDQUFDLHVCQUF1QixFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxDQUN6RixFQUFBOzt3QkFGRyxRQUFRLEdBQXdCLFNBRW5DO3dCQUVELE9BQU8sUUFBUSxDQUFDLE1BQU0sQ0FBQzt3QkFDdkIsT0FBTyxRQUFRLENBQUMsV0FBVyxDQUFDO3dCQUU1QixRQUFRLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsUUFBUSxFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7d0JBQzNELEtBQUssQ0FBQyw4Q0FBOEMsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFFaEUsY0FBYyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzs7O3dCQVhNLElBQWEsQ0FBQTs7NEJBY25ELHNCQUFPLGNBQWMsRUFBQzs7O1NBQ3ZCLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCx5Q0FBd0IsR0FBeEIsVUFBeUIsTUFBOEMsRUFBRSxRQUE0QjtRQUE1RSx1QkFBQSxFQUFBLFdBQThDO1FBQ3JFLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixPQUFPLEVBQUUsQ0FBTTs7Ozs7d0JBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsMkJBQTJCLEVBQUUsRUFBRTs0QkFDaEQsTUFBTSxJQUFJLEtBQUssQ0FBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSw0Q0FBeUMsQ0FBQyxDQUFDO3lCQUMxRjt3QkFFRCw2Q0FBNkM7d0JBQzdDLElBQUksT0FBTyxNQUFNLENBQUMsVUFBVSxLQUFLLFFBQVEsSUFBSSxNQUFNLENBQUMsVUFBVSxLQUFLLFNBQVMsRUFBRTs0QkFDNUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO3lCQUM1RDt3QkFFRCxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQUU7NEJBQ3BDLE1BQU0sSUFBSSxLQUFLLENBQUMsK0RBQStELENBQUMsQ0FBQzt5QkFDbEY7d0JBRXNCLHFCQUFNLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxNQUFNLENBQUMsRUFBQTs7d0JBQTlELGNBQWMsR0FBRyxTQUE2Qzt3QkFFcEUscUNBQXFDO3dCQUNyQyxjQUFjLENBQUMsYUFBYSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDO3dCQUUvRCxPQUFPLGNBQWMsQ0FBQyxNQUFNLENBQUM7d0JBRXRCLHFCQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxjQUFjLENBQUMsRUFBQTs0QkFBbkQsc0JBQU8sU0FBNEMsRUFBQzs7O1NBQ3JELENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsMENBQXlCLEdBQXpCLFVBQTBCLE1BQWlELEVBQUUsUUFBNEI7UUFBL0UsdUJBQUEsRUFBQSxXQUFpRDtRQUN6RSxJQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsT0FBTyxFQUFFLENBQU07Ozs7O3dCQUNiLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLDJCQUEyQixFQUFFLEVBQUU7NEJBQ2hELE1BQU0sSUFBSSxLQUFLLENBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsNENBQXlDLENBQUMsQ0FBQzt5QkFDMUY7d0JBR3NCLHFCQUFNLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxNQUFNLENBQUMsRUFBQTs7d0JBQTlELGNBQWMsR0FBRyxTQUE2Qzs2QkFDaEUsQ0FBQSxjQUFjLElBQUksY0FBYyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUEsRUFBM0Msd0JBQTJDO3dCQUN2QyxhQUFhLEdBQVUsRUFBRSxDQUFDO3dCQUMxQixTQUFTLEdBQUcsSUFBSSxLQUFLLEVBQVMsQ0FBQzs4QkFDSyxFQUFkLGlDQUFjOzs7NkJBQWQsQ0FBQSw0QkFBYyxDQUFBO3dCQUEvQixhQUFhO3dCQUVoQix3QkFBd0IsR0FBc0MsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUM7d0JBQzlGLHdCQUF3QixDQUFDLFVBQVUsR0FBRyxhQUFhLENBQUM7Ozs7d0JBRW5DLHFCQUFNLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFBOzt3QkFBdEUsTUFBTSxHQUFHLFNBQTZEO3dCQUM1RSxhQUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDOzs7O3dCQUUzQixTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUMsQ0FBQyxDQUFDOzs7d0JBUk0sSUFBYyxDQUFBOzs0QkFZMUMsc0JBQU87NEJBQ0wsT0FBTyxFQUFFLGFBQWE7NEJBQ3RCLE9BQU8sRUFBRSxTQUFTO3lCQUNuQixFQUFDOzs7O1NBRUwsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUNILGFBQUM7QUFBRCxDQUFDLEFBajhERCxJQWk4REM7QUFqOERZLHdCQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIGRlYnVnTGliIGZyb20gJ2RlYnVnJztcblxuaW1wb3J0IHsgbWFrZVJhbmRvbUtleSB9IGZyb20gJy4uL2JpdGNvaW4nO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi9iaXRnbyc7XG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IEFkZHJlc3NHZW5lcmF0aW9uRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtcbiAgQmFzZUNvaW4sXG4gIFNpZ25lZFRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBWZXJpZmljYXRpb25PcHRpb25zLCBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbn0gZnJvbSAnLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBBYnN0cmFjdFV0eG9Db2luIH0gZnJvbSAnLi9jb2lucy9hYnN0cmFjdFV0eG9Db2luJztcbmltcG9ydCB7IEV0aCB9IGZyb20gJy4vY29pbnMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC9pbnRlcm5hbCc7XG5pbXBvcnQgeyBkcmF3S2V5Y2FyZCB9IGZyb20gJy4vaW50ZXJuYWwva2V5Y2FyZCc7XG5pbXBvcnQgeyBLZXljaGFpbiB9IGZyb20gJy4va2V5Y2hhaW5zJztcbmltcG9ydCB7IFRyYWRpbmdBY2NvdW50IH0gZnJvbSAnLi90cmFkaW5nL3RyYWRpbmdBY2NvdW50JztcbmltcG9ydCB7IE5vZGVDYWxsYmFjayB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgUGVuZGluZ0FwcHJvdmFsLCBQZW5kaW5nQXBwcm92YWxEYXRhIH0gZnJvbSAnLi9wZW5kaW5nQXBwcm92YWwnO1xuaW1wb3J0IHsgUmVxdWVzdFRyYWNlciB9IGZyb20gJy4vaW50ZXJuYWwvdXRpbCc7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdMaWIoJ2JpdGdvOnYyOndhbGxldCcpO1xuY29uc3QgY28gPSBCbHVlYmlyZC5jb3JvdXRpbmU7XG5cbnR5cGUgTWFuYWdlVW5zcGVudHMgPSAnY29uc29saWRhdGUnIHwgJ2Zhbm91dCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWF4aW11bVNwZW5kYWJsZU9wdGlvbnMge1xuICAgIG1pblZhbHVlPzogbnVtYmVyO1xuICAgIG1heFZhbHVlPzogbnVtYmVyO1xuICAgIG1pbkhlaWdodD86IG51bWJlcjtcbiAgICBtaW5Db25maXJtcz86IG51bWJlcjtcbiAgICBlbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2U/OiBib29sZWFuO1xuICAgIGZlZVJhdGU/OiBudW1iZXI7XG4gICAgbWF4RmVlUmF0ZT86IG51bWJlcjtcbiAgICByZWNpcGllbnRBZGRyZXNzPzogc3RyaW5nO1xuICAgIGxpbWl0PzogbnVtYmVyO1xuICAgIHRhcmdldD86IG51bWJlcjtcbiAgICBwbGFpblRhcmdldD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYXhpbXVtU3BlbmRhYmxlIHtcbiAgICBtYXhpbXVtU3BlbmRhYmxlOiBudW1iZXI7XG4gICAgY29pbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lbW8ge1xuICAgIHZhbHVlOiBzdHJpbmc7XG4gICAgdHlwZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHBhcmFtZXRlcnMgc2hvdWxkIGJlIHVzZWQgZm9yIGJ1aWxkaW5nIGEgY29uc29saWRhdGlvbiB0cmFuc2FjdGlvbjpcbiAqIC0gd2FsbGV0UGFzc3BocmFzZSAtIG5lY2Vzc2FyeSBmb3Igc2lnbmluZ1xuICogLSBmZWVSYXRlXG4gKiAtIG1heEZlZVJhdGVcbiAqIC0gdmFsaWRGcm9tQmxvY2tcbiAqIC0gdmFsaWRUb0Jsb2NrXG4gKlxuICogV2hhdCBzaG91bGRuJ3QgYmUgcGFzc2VkICh0aGVzZSB3aWxsIGJlIGlnbm9yZWQpOlxuICogLSByZWNpcGllbnRzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQnVpbGRDb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgUHJlYnVpbGRUcmFuc2FjdGlvbk9wdGlvbnMge1xuICBmcm9tQWRkcmVzc2VzPzogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJlYnVpbGRUcmFuc2FjdGlvbk9wdGlvbnMge1xuICAgIHJlcUlkPzogUmVxdWVzdFRyYWNlcjtcbiAgICByZWNpcGllbnRzPzoge1xuICAgICAgICBhZGRyZXNzOiBzdHJpbmc7XG4gICAgICAgIGFtb3VudDogc3RyaW5nIHwgbnVtYmVyO1xuICAgIH1bXTtcbiAgICBudW1CbG9ja3M/OiBudW1iZXI7XG4gICAgZmVlUmF0ZT86IG51bWJlcjtcbiAgICBtYXhGZWVSYXRlPzogbnVtYmVyO1xuICAgIG1pbkNvbmZpcm1zPzogbnVtYmVyO1xuICAgIGVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZT86IGJvb2xlYW47XG4gICAgdGFyZ2V0V2FsbGV0VW5zcGVudHM/OiBudW1iZXI7XG4gICAgbWluVmFsdWU/OiBudW1iZXI7XG4gICAgbWF4VmFsdWU/OiBudW1iZXI7XG4gICAgc2VxdWVuY2VJZD86IG51bWJlcjtcbiAgICBsYXN0TGVkZ2VyU2VxdWVuY2U/OiBudW1iZXI7XG4gICAgbGVkZ2VyU2VxdWVuY2VEZWx0YT86IHN0cmluZztcbiAgICBnYXNQcmljZT86IG51bWJlcjtcbiAgICBub1NwbGl0Q2hhbmdlPzogYm9vbGVhbjtcbiAgICB1bnNwZW50cz86IGFueVtdO1xuICAgIGNoYW5nZUFkZHJlc3M/OiBzdHJpbmc7XG4gICAgdmFsaWRGcm9tQmxvY2s/OiBudW1iZXI7XG4gICAgdmFsaWRUb0Jsb2NrPzogbnVtYmVyO1xuICAgIGluc3RhbnQ/OiBib29sZWFuO1xuICAgIG1lbW8/OiBNZW1vO1xuICAgIGFkZHJlc3NUeXBlPzogc3RyaW5nO1xuICAgIGhvcD86IGJvb2xlYW47XG4gICAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgICByZXNlcnZhdGlvbj86IHtcbiAgICAgIGV4cGlyZVRpbWU/OiBzdHJpbmc7XG4gICAgICBwZW5kaW5nQXBwcm92YWxJZD86IHN0cmluZztcbiAgICB9O1xuICAgIG9mZmxpbmVWZXJpZmljYXRpb24/OiBib29sZWFuO1xuICAgIHdhbGxldENvbnRyYWN0QWRkcmVzcz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmVidWlsZEFuZFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBQcmVidWlsZFRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gICAgcHJlYnVpbGRUeD86IHN0cmluZyB8IFByZWJ1aWxkVHJhbnNhY3Rpb25SZXN1bHQ7XG4gICAgdmVyaWZpY2F0aW9uPzogVmVyaWZpY2F0aW9uT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0IGV4dGVuZHMgVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gICAgd2FsbGV0SWQ6IHN0cmluZztcbiAgICAvLyBDb25zb2xpZGF0ZSBJRCBpcyB1c2VkIGZvciBjb25zb2xpZGF0ZSBhY2NvdW50IHRyYW5zYWN0aW9ucyBhbmQgaW5kaWNhdGVzIGlmIHRoaXMgaXNcbiAgICAvLyBhIGNvbnNvbGlkYXRpb24gYW5kIHdoYXQgY29uc29saWRhdGUgZ3JvdXAgaXQgc2hvdWxkIGJlIHJlZmVyZW5jZWQgYnkuXG4gICAgY29uc29saWRhdGVJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBXYWxsZXRTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgICB0eFByZWJ1aWxkPzogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgICBwcnY/OiBzdHJpbmc7XG4gICAgaXNMYXN0U2lnbmF0dXJlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRVc2VyUHJ2T3B0aW9ucyB7XG4gICAga2V5Y2hhaW4/OiBLZXljaGFpbjtcbiAgICBrZXk/OiBLZXljaGFpbjtcbiAgICBwcnY/OiBzdHJpbmc7XG4gICAgY29sZERlcml2YXRpb25TZWVkPzogc3RyaW5nO1xuICAgIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2FsbGV0Q29pblNwZWNpZmljIHtcbiAgdG9rZW5GbHVzaFRocmVzaG9sZHM/OiBhbnk7XG4gIGFkZHJlc3NWZXJzaW9uPzogbnVtYmVyO1xuICBiYXNlQWRkcmVzcz86IHN0cmluZztcbiAgcm9vdEFkZHJlc3M/OiBzdHJpbmc7XG4gIGN1c3RvbUNoYW5nZVdhbGxldElkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnaW5hdGlvbk9wdGlvbnMge1xuICBwcmV2SWQ/OiBzdHJpbmc7XG4gIGxpbWl0PzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldFRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIFBhZ2luYXRpb25PcHRpb25zIHtcbiAgdHhIYXNoPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zZmVyc09wdGlvbnMgZXh0ZW5kcyBQYWdpbmF0aW9uT3B0aW9ucyB7XG4gIHR4SGFzaD86IHN0cmluZztcbiAgYWxsVG9rZW5zPzogc3RyaW5nO1xuICBzZWFyY2hMYWJlbD86IHN0cmluZztcbiAgYWRkcmVzcz86IHN0cmluZ1tdIHwgc3RyaW5nO1xuICBkYXRlR3RlPzogc3RyaW5nO1xuICBkYXRlTHQ/OiBzdHJpbmc7XG4gIHZhbHVlR3RlPzogc3RyaW5nO1xuICB2YWx1ZUx0Pzogc3RyaW5nO1xuICBpbmNsdWRlSGV4PzogYm9vbGVhbjtcbiAgc3RhdGU/OiBzdHJpbmdbXSB8IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRUcmFuc2Zlck9wdGlvbnMge1xuICBpZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2ZlckJ5U2VxdWVuY2VJZE9wdGlvbnMge1xuICBzZXF1ZW5jZUlkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVuc3BlbnRzT3B0aW9ucyBleHRlbmRzIFBhZ2luYXRpb25PcHRpb25zIHtcbiAgbWluVmFsdWU/OiBudW1iZXI7XG4gIG1heFZhbHVlPzogbnVtYmVyO1xuICBtaW5IZWlnaHQ/OiBudW1iZXI7XG4gIG1pbkNvbmZpcm1zPzogbnVtYmVyO1xuICB0YXJnZXQ/OiBudW1iZXI7XG4gIHNlZ3dpdD86IGJvb2xlYW47XG4gIGNoYWlucz86IG51bWJlcltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnNvbGlkYXRlVW5zcGVudHNPcHRpb25zIHtcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgeHBydj86IHN0cmluZztcbiAgbWluVmFsdWU/OiBudW1iZXI7XG4gIG1heFZhbHVlPzogbnVtYmVyO1xuICBtaW5IZWlnaHQ/OiBudW1iZXJcbiAgbnVtVW5zcGVudHNUb01ha2U/OiBudW1iZXI7XG4gIGZlZVR4Q29uZmlybVRhcmdldD86IG51bWJlcjtcbiAgbGltaXQ/OiBudW1iZXI7XG4gIG1pbkNvbmZpcm1zPzogbnVtYmVyO1xuICBlbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2U/OiBib29sZWFuO1xuICBmZWVSYXRlPzogbnVtYmVyO1xuICBtYXhGZWVSYXRlPzogbnVtYmVyO1xuICBtYXhGZWVQZXJjZW50YWdlPzogbnVtYmVyO1xuICBjb21tZW50Pzogc3RyaW5nO1xuICBvdHA/OiBzdHJpbmc7XG4gIHRhcmdldEFkZHJlc3M/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmFub3V0VW5zcGVudHNPcHRpb25zIHtcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgeHBydj86IHN0cmluZztcbiAgbWluVmFsdWU/OiBudW1iZXI7XG4gIG1heFZhbHVlPzogbnVtYmVyO1xuICBtaW5IZWlnaHQ/OiBudW1iZXJcbiAgbWF4TnVtSW5wdXRzVG9Vc2U/OiBudW1iZXI7XG4gIG51bVVuc3BlbnRzVG9NYWtlPzogbnVtYmVyO1xuICBtaW5Db25maXJtcz86IG51bWJlcjtcbiAgZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlPzogYm9vbGVhbjtcbiAgZmVlUmF0ZT86IG51bWJlcjtcbiAgbWF4RmVlUmF0ZT86IG51bWJlcjtcbiAgbWF4RmVlUGVyY2VudGFnZT86IG51bWJlcjtcbiAgZmVlVHhDb25maXJtVGFyZ2V0PzogbnVtYmVyO1xuICBjb21tZW50Pzogc3RyaW5nO1xuICBvdHA/OiBzdHJpbmc7XG4gIHRhcmdldEFkZHJlc3M/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3dlZXBPcHRpb25zIHtcbiAgYWRkcmVzcz86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgeHBydj86IHN0cmluZztcbiAgb3RwPzogc3RyaW5nO1xuICBmZWVSYXRlPzogbnVtYmVyO1xuICBtYXhGZWVSYXRlPzogbnVtYmVyO1xuICBmZWVUeENvbmZpcm1UYXJnZXQ/OiBudW1iZXI7XG4gIGFsbG93UGFydGlhbFN3ZWVwPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGcmVlemVPcHRpb25zIHtcbiAgZHVyYXRpb24/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmZXJDb21tZW50T3B0aW9ucyB7XG4gIGlkPzogc3RyaW5nO1xuICBjb21tZW50Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkZHJlc3Nlc09wdGlvbnMgZXh0ZW5kcyBQYWdpbmF0aW9uT3B0aW9ucyB7XG4gIG1pbmU/OiBib29sZWFuO1xuICBzb3J0PzogbnVtYmVyO1xuICBsYWJlbENvbnRhaW5zPzogc3RyaW5nO1xuICBzZWd3aXQ/OiBib29sZWFuO1xuICBjaGFpbnM/OiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRBZGRyZXNzT3B0aW9ucyB7XG4gIGFkZHJlc3M/OiBzdHJpbmc7XG4gIGlkPzogc3RyaW5nO1xuICByZXFJZD86IFJlcXVlc3RUcmFjZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlQWRkcmVzc09wdGlvbnMge1xuICBjaGFpbj86IG51bWJlcjtcbiAgZ2FzUHJpY2U/OiBudW1iZXIgfCBzdHJpbmc7XG4gIGNvdW50PzogbnVtYmVyO1xuICBsYWJlbD86IHN0cmluZztcbiAgbG93UHJpb3JpdHk/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZUFkZHJlc3NPcHRpb25zIHtcbiAgbGFiZWw/OiBzdHJpbmc7XG4gIGFkZHJlc3M/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2ltdWxhdGVXZWJob29rT3B0aW9ucyB7XG4gIHdlYmhvb2tJZD86IHN0cmluZztcbiAgdHJhbnNmZXJJZD86IHN0cmluZztcbiAgcGVuZGluZ0FwcHJvdmFsSWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9kaWZ5V2ViaG9va09wdGlvbnMge1xuICB1cmw/OiBzdHJpbmc7XG4gIHR5cGU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0UHJ2T3B0aW9ucyB7XG4gIHBydj86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVTaGFyZU9wdGlvbnMge1xuICB1c2VyPzogc3RyaW5nO1xuICBwZXJtaXNzaW9ucz86IHN0cmluZztcbiAga2V5Y2hhaW4/OiB7XG4gICAgcHViPzogc3RyaW5nO1xuICAgIGVuY3J5cHRlZFBydj86IHN0cmluZztcbiAgICBmcm9tUHViS2V5Pzogc3RyaW5nO1xuICAgIHRvUHViS2V5Pzogc3RyaW5nO1xuICAgIHBhdGg/OiBzdHJpbmc7XG4gIH0sXG4gIHJlc2hhcmU/OiBib29sZWFuO1xuICBtZXNzYWdlPzogc3RyaW5nO1xuICBkaXNhYmxlRW1haWw/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNoYXJlV2FsbGV0T3B0aW9ucyB7XG4gIGVtYWlsPzogc3RyaW5nO1xuICBwZXJtaXNzaW9ucz86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgbWVzc2FnZT86IHN0cmluZztcbiAgcmVzaGFyZT86IGJvb2xlYW47XG4gIHNraXBLZXljaGFpbj86IGJvb2xlYW47XG4gIGRpc2FibGVFbWFpbD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVtb3ZlVXNlck9wdGlvbnMge1xuICB1c2VySWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWNjZWxlcmF0ZVRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIGNwZnBUeElkcz86IHN0cmluZ1tdO1xuICBjcGZwRmVlUmF0ZT86IG51bWJlcjtcbiAgbm9DcGZwRmVlUmF0ZT86IGJvb2xlYW47XG4gIG1heEZlZT86IG51bWJlcjtcbiAgbm9NYXhGZWU/OiBib29sZWFuO1xuICByZWNpcGllbnRzPzoge1xuICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICBhbW91bnQ6IHN0cmluZztcbiAgfVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN1Ym1pdFRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIG90cD86IHN0cmluZztcbiAgdHhIZXg/OiBzdHJpbmc7XG4gIGhhbGZTaWduZWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VuZE9wdGlvbnMge1xuICBhZGRyZXNzPzogc3RyaW5nO1xuICBhbW91bnQ/OiBudW1iZXIgfCBzdHJpbmc7XG4gIGRhdGE/OiBzdHJpbmc7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHBydj86IHN0cmluZztcbiAgbWluQ29uZmlybXM/OiBudW1iZXI7XG4gIGVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZW5kTWFueU9wdGlvbnMge1xuICByZXFJZD86IFJlcXVlc3RUcmFjZXI7XG4gIHJlY2lwaWVudHM/OiB7XG4gICAgYWRkcmVzczogc3RyaW5nO1xuICAgIGFtb3VudDogc3RyaW5nIHwgbnVtYmVyO1xuICAgIGRhdGE/OiBzdHJpbmc7XG4gIH1bXTtcbiAgbnVtQmxvY2tzPzogbnVtYmVyO1xuICBmZWVSYXRlPzogbnVtYmVyO1xuICBtYXhGZWVSYXRlPzogbnVtYmVyO1xuICBtaW5Db25maXJtcz86IG51bWJlcjtcbiAgZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlPzogYm9vbGVhbjtcbiAgdGFyZ2V0V2FsbGV0VW5zcGVudHM/OiBudW1iZXI7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIG1pblZhbHVlPzogbnVtYmVyO1xuICBtYXhWYWx1ZT86IG51bWJlcjtcbiAgc2VxdWVuY2VJZD86IG51bWJlcjtcbiAgbGFzdExlZGdlclNlcXVlbmNlPzogbnVtYmVyO1xuICBsZWRnZXJTZXF1ZW5jZURlbHRhPzogc3RyaW5nO1xuICBnYXNQcmljZT86IG51bWJlcjtcbiAgbm9TcGxpdENoYW5nZT86IGJvb2xlYW47XG4gIHVuc3BlbnRzPzogc3RyaW5nW107XG4gIGNvbW1lbnQ/OiBzdHJpbmc7XG4gIG90cD86IHN0cmluZztcbiAgY2hhbmdlQWRkcmVzcz86IHN0cmluZztcbiAgaW5zdGFudD86IGJvb2xlYW47XG4gIG1lbW8/OiBNZW1vO1xufVxuXG5pbnRlcmZhY2UgV2FsbGV0RGF0YSB7XG4gIGlkOiBzdHJpbmc7XG4gIGFwcHJvdmFsc1JlcXVpcmVkOiBudW1iZXI7XG4gIGJhbGFuY2U6IG51bWJlcjtcbiAgY29uZmlybWVkQmFsYW5jZTogbnVtYmVyO1xuICBzcGVuZGFibGVCYWxhbmNlOiBudW1iZXI7XG4gIGJhbGFuY2VTdHJpbmc6IHN0cmluZztcbiAgY29uZmlybWVkQmFsYW5jZVN0cmluZzogc3RyaW5nO1xuICBzcGVuZGFibGVCYWxhbmNlU3RyaW5nOiBzdHJpbmc7XG4gIGNvaW46IHN0cmluZztcbiAgbGFiZWw6IHN0cmluZztcbiAga2V5czogc3RyaW5nW107XG4gIHJlY2VpdmVBZGRyZXNzOiB7XG4gICAgYWRkcmVzczogc3RyaW5nO1xuICB9O1xuICBtaWdyYXRlZEZyb20/OiBzdHJpbmc7XG4gIGNvaW5TcGVjaWZpYzogV2FsbGV0Q29pblNwZWNpZmljO1xuICBwZW5kaW5nQXBwcm92YWxzOiBQZW5kaW5nQXBwcm92YWxEYXRhW107XG4gIGVudGVycHJpc2U6IHN0cmluZztcbiAgY3VzdG9tQ2hhbmdlS2V5U2lnbmF0dXJlcz86IHtcbiAgICB1c2VyPzogc3RyaW5nO1xuICAgIGJhY2t1cD86IHN0cmluZztcbiAgICBiaXRnbz86IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyVG9rZW5PcHRpb25zIHtcbiAgdG9rZW5Db250cmFjdEFkZHJlc3M/OiBzdHJpbmc7XG4gIHJlY2lwaWVudD86IHN0cmluZztcbiAgYnJvYWRjYXN0PzogYm9vbGVhbjtcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgcHJ2Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoYW5nZUZlZU9wdGlvbnMge1xuICB0eGlkPzogc3RyaW5nO1xuICBmZWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlUG9saWN5UnVsZU9wdGlvbnMge1xuICBpZD86IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbiAgbWVzc2FnZT86IHN0cmluZztcbiAgY29uZGl0aW9uPzogdW5rbm93bjtcbiAgYWN0aW9uPzogdW5rbm93bjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXRQb2xpY3lSdWxlT3B0aW9ucyB7XG4gIGlkPzogc3RyaW5nO1xuICB0eXBlPzogc3RyaW5nO1xuICBtZXNzYWdlPzogc3RyaW5nO1xuICBjb25kaXRpb24/OiB1bmtub3duO1xuICBhY3Rpb24/OiB1bmtub3duO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlbW92ZVBvbGljeVJ1bGVPcHRpb25zIHtcbiAgaWQ/OiBzdHJpbmc7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG93bmxvYWRLZXljYXJkT3B0aW9ucyB7XG4gIGpzUERGPzogYW55O1xuICBRUkNvZGU/OiBhbnk7XG4gIHVzZXJLZXljaGFpbj86IEtleWNoYWluO1xuICBiYWNrdXBLZXljaGFpbj86IEtleWNoYWluO1xuICBiaXRnb0tleWNoYWluPzogS2V5Y2hhaW47XG4gIHBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHBhc3Njb2RlRW5jcnlwdGlvbkNvZGU/OiBzdHJpbmc7XG4gIGFjdGl2YXRpb25Db2RlPzogc3RyaW5nO1xuICB3YWxsZXRLZXlJRD86IHN0cmluZztcbiAgYmFja3VwS2V5SUQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBXYWxsZXQge1xuICBwdWJsaWMgcmVhZG9ubHkgYml0Z286IEJpdEdvO1xuICBwdWJsaWMgcmVhZG9ubHkgYmFzZUNvaW46IEJhc2VDb2luO1xuICBwcml2YXRlIF93YWxsZXQ6IFdhbGxldERhdGE7XG4gIHByaXZhdGUgcmVhZG9ubHkgX3Blcm1pc3Npb25zPzogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvLCBiYXNlQ29pbjogQmFzZUNvaW4sIHdhbGxldERhdGE6IGFueSkge1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgICB0aGlzLmJhc2VDb2luID0gYmFzZUNvaW47XG4gICAgdGhpcy5fd2FsbGV0ID0gd2FsbGV0RGF0YTtcbiAgICBjb25zdCB1c2VySWQgPSBfLmdldChiaXRnbywgJ191c2VyLmlkJyk7XG4gICAgaWYgKF8uaXNTdHJpbmcodXNlcklkKSkge1xuICAgICAgY29uc3QgdXNlckRldGFpbHMgPSBfLmZpbmQod2FsbGV0RGF0YS51c2VycywgeyB1c2VyOiB1c2VySWQgfSk7XG4gICAgICB0aGlzLl9wZXJtaXNzaW9ucyA9IF8uZ2V0KHVzZXJEZXRhaWxzLCAncGVybWlzc2lvbnMnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYSBVUkwgdXNpbmcgdGhpcyB3YWxsZXQncyBpZCB3aGljaCBjYW4gYmUgdXNlZCBmb3IgQml0R28gQVBJIG9wZXJhdGlvbnNcbiAgICogQHBhcmFtIGV4dHJhIEFQSSBzcGVjaWZpYyBzdHJpbmcgdG8gYXBwZW5kIHRvIHRoZSB3YWxsZXQgaWRcbiAgICovXG4gIHVybChleHRyYTogc3RyaW5nID0gJycpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgdGhpcy5pZCgpICsgZXh0cmEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGlzIHdhbGxldCdzIGlkXG4gICAqL1xuICBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQuaWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgYXBwcm92YWxzIHJlcXVpcmVkIGZvciBzcGVuZGluZyBmdW5kcyBmcm9tIHRoaXMgd2FsbGV0XG4gICAqL1xuICBhcHByb3ZhbHNSZXF1aXJlZCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQuYXBwcm92YWxzUmVxdWlyZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGJhbGFuY2Ugb2YgdGhpcyB3YWxsZXRcbiAgICovXG4gIGJhbGFuY2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LmJhbGFuY2U7XG4gIH1cblxuICBwcmVidWlsZFdoaXRlbGlzdGVkUGFyYW1zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ2FkZHJlc3NUeXBlJywgJ2NoYW5nZUFkZHJlc3MnLCAnY29uc29saWRhdGVBZGRyZXNzZXMnLCAnY3BmcEZlZVJhdGUnLCAnY3BmcFR4SWRzJywgJ2VuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZScsXG4gICAgICAnZmVlUmF0ZScsICdnYXNMaW1pdCcsICdnYXNQcmljZScsICdpZGZTaWduZWRUaW1lc3RhbXAnLCAnaWRmVXNlcklkJywgJ2lkZlZlcnNpb24nLCAnaW5zdGFudCcsXG4gICAgICAnbGFzdExlZGdlclNlcXVlbmNlJywgJ2xlZGdlclNlcXVlbmNlRGVsdGEnLCAnbWF4RmVlJywgJ21heEZlZVJhdGUnLCAnbWF4VmFsdWUnLCAnbWVtbycsICdtZXNzYWdlJywgJ21pbkNvbmZpcm1zJyxcbiAgICAgICdtaW5WYWx1ZScsICdub1NwbGl0Q2hhbmdlJywgJ251bUJsb2NrcycsICdyZWNpcGllbnRzJywgJ3Jlc2VydmF0aW9uJywgJ3NlcXVlbmNlSWQnLCAnc3RyYXRlZ3knLFxuICAgICAgJ3RhcmdldFdhbGxldFVuc3BlbnRzJywgJ3RydXN0bGluZXMnLCAndHlwZScsICd1bnNwZW50cycsICd2YWxpZEZyb21CbG9jaycsICd2YWxpZFRvQmxvY2snLFxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIHN0cmljdCBzdWItc2V0IG9mIHByZWJ1aWxkV2hpdGVsaXN0ZWRQYXJhbXNcbiAgICovXG4gIHByZWJ1aWxkQ29uc29saWRhdGVBY2NvdW50UGFyYW1zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ2NvbnNvbGlkYXRlQWRkcmVzc2VzJywgJ2ZlZVJhdGUnLCAnbWF4RmVlUmF0ZScsICdtZW1vJywgJ3ZhbGlkRnJvbUJsb2NrJywgJ3ZhbGlkVG9CbG9jaycsXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbmZpcm1lZCBiYWxhbmNlIG9mIHRoaXMgd2FsbGV0XG4gICAqL1xuICBjb25maXJtZWRCYWxhbmNlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldC5jb25maXJtZWRCYWxhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3BlbmRhYmxlIGJhbGFuY2Ugb2YgdGhpcyB3YWxsZXRcbiAgICovXG4gIHNwZW5kYWJsZUJhbGFuY2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LnNwZW5kYWJsZUJhbGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiYWxhbmNlIG9mIHRoaXMgd2FsbGV0XG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gYmFsYW5jZXMgaGF2ZSB0aGUgcG90ZW50aWFsIHRvIG92ZXJmbG93IHN0YW5kYXJkIGphdmFzY3JpcHQgbnVtYmVyc1xuICAgKi9cbiAgYmFsYW5jZVN0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQuYmFsYW5jZVN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbmZpcm1lZCBiYWxhbmNlIG9mIHRoaXMgd2FsbGV0XG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gYmFsYW5jZXMgaGF2ZSB0aGUgcG90ZW50aWFsIHRvIG92ZXJmbG93IHN0YW5kYXJkIGphdmFzY3JpcHQgbnVtYmVyc1xuICAgKi9cbiAgY29uZmlybWVkQmFsYW5jZVN0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQuY29uZmlybWVkQmFsYW5jZVN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZW5kYWJsZSBiYWxhbmNlIG9mIHRoaXMgd2FsbGV0XG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gYmFsYW5jZXMgaGF2ZSB0aGUgcG90ZW50aWFsIHRvIG92ZXJmbG93IHN0YW5kYXJkIGphdmFzY3JpcHQgbnVtYmVyc1xuICAgKi9cbiAgc3BlbmRhYmxlQmFsYW5jZVN0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQuc3BlbmRhYmxlQmFsYW5jZVN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvaW4gaWRlbnRpZmllciBmb3IgdGhlIHR5cGUgb2YgY29pbiB0aGlzIHdhbGxldCBob2xkc1xuICAgKi9cbiAgY29pbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQuY29pbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxhYmVsIChuYW1lKSBmb3IgdGhpcyB3YWxsZXRcbiAgICovXG4gIHB1YmxpYyBsYWJlbCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQubGFiZWw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwdWJsaWMgb2JqZWN0IGlkcyBmb3IgdGhlIGtleWNoYWlucyBvbiB0aGlzIHdhbGxldC5cbiAgICovXG4gIHB1YmxpYyBrZXlJZHMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQua2V5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSByZWNlaXZlIGFkZHJlc3MgZm9yIHRoaXMgd2FsbGV0XG4gICAqL1xuICBwdWJsaWMgcmVjZWl2ZUFkZHJlc3MoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LnJlY2VpdmVBZGRyZXNzLmFkZHJlc3M7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3YWxsZXQgaWQgb2YgdGhlIHdhbGxldCB0aGF0IHRoaXMgd2FsbGV0IHdhcyBtaWdyYXRlZCBmcm9tLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhpcyBpcyBhIEJDSCB3YWxsZXQgdGhhdCB3YXMgY3JlYXRlZCBmcm9tIGEgQlRDIHdhbGxldCxcbiAgICogdGhlIEJDSCB3YWxsZXQgbWlncmF0ZWQgZnJvbSBmaWVsZCB3b3VsZCBoYXZlIHRoZSBCVEMgd2FsbGV0IGlkLlxuICAgKi9cbiAgcHVibGljIG1pZ3JhdGVkRnJvbSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQubWlncmF0ZWRGcm9tO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdG9rZW4gZmx1c2ggdGhyZXNob2xkcyBmb3IgdGhpcyB3YWxsZXRcbiAgICogQHJldHVybiB7KnxPYmplY3R9IHBhaXJzIG9mIHsgW3Rva2VuTmFtZV06IHRocmVzaG9sZHMgfSBiYXNlIHVuaXRzXG4gICAqL1xuICB0b2tlbkZsdXNoVGhyZXNob2xkcygpOiBhbnkge1xuICAgIGlmICh0aGlzLmJhc2VDb2luLmdldEZhbWlseSgpICE9PSAnZXRoJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Qgc3VwcG9ydGVkIGZvciB0aGlzIHdhbGxldCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0LmNvaW5TcGVjaWZpYy50b2tlbkZsdXNoVGhyZXNob2xkcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2FsbGV0IHByb3BlcnRpZXMgd2hpY2ggYXJlIHNwZWNpZmljIHRvIGNlcnRhaW4gY29pbiBpbXBsZW1lbnRhdGlvbnNcbiAgICovXG4gIGNvaW5TcGVjaWZpYygpOiBXYWxsZXRDb2luU3BlY2lmaWMgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQuY29pblNwZWNpZmljO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgcGVuZGluZyBhcHByb3ZhbHMgb24gdGhpcyB3YWxsZXRcbiAgICovXG4gIHBlbmRpbmdBcHByb3ZhbHMoKTogUGVuZGluZ0FwcHJvdmFsW10ge1xuICAgIHJldHVybiB0aGlzLl93YWxsZXQucGVuZGluZ0FwcHJvdmFscy5tYXAoKGN1cnJlbnRBcHByb3ZhbCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQZW5kaW5nQXBwcm92YWwodGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbiwgY3VycmVudEFwcHJvdmFsLCB0aGlzKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIHRoZSB3YWxsZXQgb2JqZWN0IGJ5IHN5bmNpbmcgd2l0aCB0aGUgYmFjay1lbmRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge1dhbGxldH1cbiAgICovXG4gIHJlZnJlc2gocGFyYW1zOiB7fSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxXYWxsZXQ+KTogQmx1ZWJpcmQ8V2FsbGV0PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFdhbGxldD4oZnVuY3Rpb24gKigpIHtcbiAgICAgIHNlbGYuX3dhbGxldCA9IHlpZWxkIHNlbGYuYml0Z28uZ2V0KHNlbGYudXJsKCkpLnJlc3VsdCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHRoZSB0cmFuc2FjdGlvbnMgZm9yIGEgZ2l2ZW4gd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgdHJhbnNhY3Rpb25zKHBhcmFtczogUGFnaW5hdGlvbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHF1ZXJ5OiBQYWdpbmF0aW9uT3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKHBhcmFtcy5wcmV2SWQpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucHJldklkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJldklkIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5wcmV2SWQgPSBwYXJhbXMucHJldklkO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMubGltaXQpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubGltaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgcXVlcnkubGltaXQgPSBwYXJhbXMubGltaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyB0aGlzLl93YWxsZXQuaWQgKyAnL3R4JykpXG4gICAgICAucXVlcnkocXVlcnkpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHRoZSB0cmFuc2FjdGlvbnMgZm9yIGEgZ2l2ZW4gd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogIC0gdHhIYXNoIHRoZSB0cmFuc2FjdGlvbiBoYXNoIHRvIHNlYXJjaCBmb3JcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb24ocGFyYW1zOiBHZXRUcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndHhIYXNoJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgICBjb25zdCBxdWVyeTogUGFnaW5hdGlvbk9wdGlvbnMgPSB7fTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLnByZXZJZCkpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucHJldklkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJldklkIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5wcmV2SWQgPSBwYXJhbXMucHJldklkO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMubGltaXQpKSB7XG4gICAgICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5saW1pdCkgfHwgcGFyYW1zLmxpbWl0IDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGltaXQgYXJndW1lbnQsIGV4cGVjdGluZyBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5saW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy51cmwoJy90eC8nICsgcGFyYW1zLnR4SGFzaCkpXG4gICAgICAucXVlcnkocXVlcnkpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHRoZSB0cmFuc2ZlcnMgZm9yIGEgZ2l2ZW4gd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgdHJhbnNmZXJzKHBhcmFtczogVHJhbnNmZXJzT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3QgcXVlcnk6IFRyYW5zZmVyc09wdGlvbnMgPSB7fTtcbiAgICBpZiAocGFyYW1zLnByZXZJZCkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcmV2SWQgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnByZXZJZCA9IHBhcmFtcy5wcmV2SWQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5saW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmFsbFRva2Vucykge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuYWxsVG9rZW5zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWxsVG9rZW5zIGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgcXVlcnkuYWxsVG9rZW5zID0gcGFyYW1zLmFsbFRva2VucztcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnNlYXJjaExhYmVsKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnNlYXJjaExhYmVsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2VhcmNoTGFiZWwgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnNlYXJjaExhYmVsID0gcGFyYW1zLnNlYXJjaExhYmVsO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuYWRkcmVzcykge1xuICAgICAgaWYgKCFfLmlzQXJyYXkocGFyYW1zLmFkZHJlc3MpICYmICFfLmlzU3RyaW5nKHBhcmFtcy5hZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWRkcmVzcyBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZyBvciBhcnJheScpO1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNBcnJheShwYXJhbXMuYWRkcmVzcykpIHtcbiAgICAgICAgcGFyYW1zLmFkZHJlc3MuZm9yRWFjaChhZGRyZXNzID0+IHtcbiAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcoYWRkcmVzcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZGRyZXNzIGFyZ3VtZW50LCBleHBlY3RpbmcgYXJyYXkgb2YgYWRkcmVzcyBzdHJpbmdzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmFkZHJlc3MgPSBwYXJhbXMuYWRkcmVzcztcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmRhdGVHdGUpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMuZGF0ZUd0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRhdGVHdGUgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmRhdGVHdGUgPSBwYXJhbXMuZGF0ZUd0ZTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmRhdGVMdCkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5kYXRlTHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkYXRlTHQgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmRhdGVMdCA9IHBhcmFtcy5kYXRlTHQ7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzTmlsKHBhcmFtcy52YWx1ZUd0ZSkpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMudmFsdWVHdGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB2YWx1ZUd0ZSBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgcXVlcnkudmFsdWVHdGUgPSBwYXJhbXMudmFsdWVHdGU7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzTmlsKHBhcmFtcy52YWx1ZUx0KSkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy52YWx1ZUx0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdmFsdWVMdCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgcXVlcnkudmFsdWVMdCA9IHBhcmFtcy52YWx1ZUx0O1xuICAgIH1cblxuICAgIGlmICghXy5pc05pbChwYXJhbXMuaW5jbHVkZUhleCkpIHtcbiAgICAgIGlmICghXy5pc0Jvb2xlYW4ocGFyYW1zLmluY2x1ZGVIZXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNsdWRlSGV4IGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgcXVlcnkuaW5jbHVkZUhleCA9IHBhcmFtcy5pbmNsdWRlSGV4O1xuICAgIH1cblxuICAgIGlmICghXy5pc05pbChwYXJhbXMuc3RhdGUpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLnN0YXRlKSAmJiAhXy5pc1N0cmluZyhwYXJhbXMuc3RhdGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZSBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZyBvciBhcnJheScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMuc3RhdGUpKSB7XG4gICAgICAgIHBhcmFtcy5zdGF0ZS5mb3JFYWNoKHN0YXRlID0+IHtcbiAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcoc3RhdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGUgYXJndW1lbnQsIGV4cGVjdGluZyBhcnJheSBvZiBzdGF0ZSBzdHJpbmdzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnN0YXRlID0gcGFyYW1zLnN0YXRlO1xuICAgIH1cblxuICAgIGlmICghXy5pc05pbChwYXJhbXMudHlwZSkpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMudHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnR5cGUgPSBwYXJhbXMudHlwZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy51cmwoJy90cmFuc2ZlcicpKVxuICAgICAgLnF1ZXJ5KHF1ZXJ5KVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRyYW5zZmVycyBvbiB0aGlzIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZ2V0VHJhbnNmZXIocGFyYW1zOiBHZXRUcmFuc2Zlck9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3RyYW5zZmVyLycgKyBwYXJhbXMuaWQpKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdHJhbnNhY3Rpb24gYnkgc2VxdWVuY2UgaWQgZm9yIGEgZ2l2ZW4gd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICB0cmFuc2ZlckJ5U2VxdWVuY2VJZChwYXJhbXM6IFRyYW5zZmVyQnlTZXF1ZW5jZUlkT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydzZXF1ZW5jZUlkJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy51cmwoJy90cmFuc2Zlci9zZXF1ZW5jZUlkLycgKyBwYXJhbXMuc2VxdWVuY2VJZCkpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1heGltdW0gYW1vdW50IHlvdSBjYW4gc3BlbmQgaW4gYSBzaW5nbGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHBhcmFtZXRlcnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubGltaXQgLSBtYXhpbXVtIG51bWJlciBvZiBzZWxlY3RhYmxlIHVuc3BlbnRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluVmFsdWUgLSB0aGUgbWluaW11bSB2YWx1ZSBvZiB1bnNwZW50cyB0byB1c2UgaW4gc2F0b3NoaXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhWYWx1ZSAtIHRoZSBtYXhpbXVtIHZhbHVlIG9mIHVuc3BlbnRzIHRvIHVzZSBpbiBzYXRvc2hpc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pbkhlaWdodCAtIHRoZSBtaW5pbXVtIGhlaWdodCBvZiB1bnNwZW50cyBvbiB0aGUgYmxvY2sgY2hhaW4gdG8gdXNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluQ29uZmlybXMgLSBhbGwgc2VsZWN0ZWQgdW5zcGVudHMgd2lsbCBoYXZlIGF0IGxlYXN0IHRoaXMgbWFueSBjb25maXJtYXRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLmVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZSAtIEVuZm9yY2VzIG1pbkNvbmZpcm1zIG9uIGNoYW5nZSBpbnB1dHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5mZWVSYXRlIC0gZmVlIHJhdGUgdG8gdXNlIGluIGNhbGN1bGF0aW9uIG9mIG1heGltdW0gc3BlbmRhYmxlIGluIHNhdG9zaGlzL2tCXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4RmVlUmF0ZSAtIHVwcGVyIGxpbWl0IGZvciBmZWVSYXRlIGluIHNhdG9zaGlzL2tCXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMucmVjaXBpZW50QWRkcmVzcyAtIHJlY2lwaWVudCBhZGRyZXNzZXMgZm9yIGEgbW9yZSBhY2N1cmF0ZSBjYWxjdWxhdGlvbiBvZiB0aGUgbWF4aW11bSBhdmFpbGFibGUgdG8gc2VuZFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ttYXhpbXVtU3BlbmRhYmxlOiBOdW1iZXIsIGNvaW46IFN0cmluZ319XG4gICAqIE5PVEUgOiBmZWVUeENvbmZpcm1UYXJnZXQgb21pdHRlZCBvbiBwdXJwb3NlIGJlY2F1c2UgZ2F1Z2luZyB0aGUgbWF4aW11bSBzcGVuZGFibGUgYW1vdW50IHdpdGggZHluYW1pYyBmZWVzIGRvZXMgbm90IG1ha2Ugc2Vuc2VcbiAgICovXG4gIG1heGltdW1TcGVuZGFibGUocGFyYW1zOiBNYXhpbXVtU3BlbmRhYmxlT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxNYXhpbXVtU3BlbmRhYmxlPik6IEJsdWViaXJkPE1heGltdW1TcGVuZGFibGU+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288TWF4aW11bVNwZW5kYWJsZT4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkUGFyYW1zID0gXy5waWNrKHBhcmFtcywgW1xuICAgICAgICAnZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlJywgJ2ZlZVJhdGUnLCAnbGltaXQnLCAnbWF4RmVlUmF0ZScsICdtYXhWYWx1ZScsICdtaW5Db25maXJtcycsICdtaW5IZWlnaHQnLFxuICAgICAgICAnbWluVmFsdWUnLCAncGxhaW5UYXJnZXQnLCAncmVjaXBpZW50QWRkcmVzcycsICd0YXJnZXQnLFxuICAgICAgXSk7XG5cbiAgICAgIHJldHVybiBzZWxmLmJpdGdvLmdldChzZWxmLnVybCgnL21heGltdW1TcGVuZGFibGUnKSlcbiAgICAgICAgLnF1ZXJ5KGZpbHRlcmVkUGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHRoZSB1bnNwZW50cyBmb3IgYSBnaXZlbiB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICB1bnNwZW50cyhwYXJhbXM6IFVuc3BlbnRzT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3QgcXVlcnkgPSBfLnBpY2socGFyYW1zLCBbXG4gICAgICAgICdjaGFpbnMnLCAnbGltaXQnLCAnbWF4VmFsdWUnLCAnbWluQ29uZmlybXMnLCAnbWluSGVpZ2h0JywgJ21pblZhbHVlJywgJ3ByZXZJZCcsICdzZWd3aXQnLCAndGFyZ2V0JyxcbiAgICBdKTtcblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3Vuc3BlbnRzJykpXG4gICAgICAucXVlcnkocXVlcnkpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zb2xpZGF0ZSBvciBmYW5vdXQgdW5zcGVudHMgb24gYSB3YWxsZXRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJvdXRlTmFtZSAtIGVpdGhlciBgY29uc29saWRhdGVgIG9yIGBmYW5vdXRgXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBwYXJhbWV0ZXJzIG9iamVjdFxuICAgKlxuICAgKiBXYWxsZXQgcGFyYW1ldGVyczpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIC0gdGhlIHVzZXJzIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMueHBydiAtIHRoZSBwcml2YXRlIGtleSBpbiBzdHJpbmcgZm9ybSBpZiB0aGUgd2FsbGV0UGFzc3BocmFzZSBpcyBub3QgYXZhaWxhYmxlXG4gICAqXG4gICAqIEZlZSBwYXJhbWV0ZXJzOlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmZlZVJhdGUgLSBUaGUgZmVlIHJhdGUgdG8gdXNlIGZvciB0aGUgY29uc29saWRhdGlvbiBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEZlZVJhdGUgLSB1cHBlciBsaW1pdCBmb3IgZmVlUmF0ZSBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEZlZVBlcmNlbnRhZ2UgLSB0aGUgbWF4aW11bSByZWxhdGl2ZSBwb3J0aW9uIHRoYXQgeW91J3JlIHdpbGxpbmcgdG8gc3BlbmQgdG93YXJkcyBmZWVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0IC0gZXN0aW1hdGUgdGhlIGZlZXMgdG8gYWltIGZvciBmaXJzdCBjb25maXJtYXRpb24gd2l0aCB0aGlzIG51bWJlciBvZiBibG9ja3NcbiAgICpcbiAgICogSW5wdXQgcGFyYW1ldGVyczpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5WYWx1ZSAtIHRoZSBtaW5pbXVtIHZhbHVlIG9mIHVuc3BlbnRzIHRvIHVzZSBpbiBzYXRvc2hpc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heFZhbHVlIC0gdGhlIG1heGltdW0gdmFsdWUgb2YgdW5zcGVudHMgdG8gdXNlIGluIHNhdG9zaGlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluSGVpZ2h0IC0gdGhlIG1pbmltdW0gaGVpZ2h0IG9mIHVuc3BlbnRzIG9uIHRoZSBibG9jayBjaGFpbiB0byB1c2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5Db25maXJtcyAtIGFsbCBzZWxlY3RlZCB1bnNwZW50cyB3aWxsIGhhdmUgYXQgbGVhc3QgdGhpcyBtYW55IGNvbmZpcm1hdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlIC0gaWYgdHJ1ZSwgbWluQ29uZmlybXMgYWxzbyBhcHBsaWVzIHRvIGNoYW5nZSBvdXRwdXRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubGltaXQgICAgICAgICAgICAgICAgZm9yIHJvdXRlTmFtZSA9PT0gJ2NvbnNvbGlkYXRlJ1xuICAgKiAgICAgICAgICAgICAgICAgcGFyYW1zLm1heE51bUlucHV0c1RvVXNlICAgIGZvciByb3V0ZU5hbWUgPT09ICdmYW5vdXQnXG4gICAqICAgICAgICAgICAgICAgICAgLSBtYXhpbXVtIG51bWJlciBvZiB1bnNwZW50cyB5b3Ugd2FudCB0byB1c2UgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqIE91dHB1dCBwYXJhbWV0ZXJzOlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm51bVVuc3BlbnRzVG9NYWtlIC0gdGhlIG51bWJlciBvZiBuZXcgdW5zcGVudHMgdG8gbWFrZVxuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHByaXZhdGUgbWFuYWdlVW5zcGVudHMocm91dGVOYW1lOiBNYW5hZ2VVbnNwZW50cywgcGFyYW1zOiBDb25zb2xpZGF0ZVVuc3BlbnRzT3B0aW9ucyB8IEZhbm91dFVuc3BlbnRzT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWyd3YWxsZXRQYXNzcGhyYXNlJywgJ3hwcnYnXSwgY2FsbGJhY2spO1xuXG4gICAgICBjb25zdCByZXFJZCA9IG5ldyBSZXF1ZXN0VHJhY2VyKCk7XG4gICAgICBjb25zdCBmaWx0ZXJlZFBhcmFtcyA9IF8ucGljayhwYXJhbXMsIFtcbiAgICAgICAgJ2ZlZVJhdGUnLFxuICAgICAgICAnbWF4RmVlUmF0ZScsXG4gICAgICAgICdtYXhGZWVQZXJjZW50YWdlJyxcbiAgICAgICAgJ2ZlZVR4Q29uZmlybVRhcmdldCcsXG5cbiAgICAgICAgJ21pblZhbHVlJyxcbiAgICAgICAgJ21heFZhbHVlJyxcbiAgICAgICAgJ21pbkhlaWdodCcsXG4gICAgICAgICdtaW5Db25maXJtcycsXG4gICAgICAgICdlbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2UnLFxuICAgICAgICAndGFyZ2V0QWRkcmVzcycsXG5cbiAgICAgICAgcm91dGVOYW1lID09PSAnY29uc29saWRhdGUnID8gJ2xpbWl0JyA6ICdtYXhOdW1JbnB1dHNUb1VzZScsXG4gICAgICAgICdudW1VbnNwZW50c1RvTWFrZScsXG4gICAgICBdKTtcbiAgICAgIHNlbGYuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHNlbGYuYml0Z28ucG9zdChzZWxmLnVybChgLyR7cm91dGVOYW1lfVVuc3BlbnRzYCkpXG4gICAgICAgIC5zZW5kKGZpbHRlcmVkUGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG5cbiAgICAgIGNvbnN0IGtleWNoYWluID0geWllbGQgc2VsZi5iYXNlQ29pbi5rZXljaGFpbnMoKS5nZXQoeyBpZDogc2VsZi5fd2FsbGV0LmtleXNbMF0sIHJlcUlkIH0pO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25QYXJhbXMgPSBfLmV4dGVuZCh7fSwgcGFyYW1zLCB7IHR4UHJlYnVpbGQ6IHJlc3BvbnNlLCBrZXljaGFpbiB9KTtcbiAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0geWllbGQgc2VsZi5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25QYXJhbXMpO1xuICAgICAgY29uc3Qgc2VsZWN0UGFyYW1zID0gXy5waWNrKHBhcmFtcywgWydjb21tZW50JywgJ290cCddKTtcbiAgICAgIGNvbnN0IGZpbmFsVHhQYXJhbXMgPSBfLmV4dGVuZCh7fSwgc2lnbmVkVHJhbnNhY3Rpb24sIHNlbGVjdFBhcmFtcyk7XG5cbiAgICAgIHNlbGYuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgICByZXR1cm4gc2VsZi5iaXRnby5wb3N0KHNlbGYuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyBzZWxmLl93YWxsZXQuaWQgKyAnL3R4L3NlbmQnKSlcbiAgICAgICAgLnNlbmQoZmluYWxUeFBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc29saWRhdGUgdW5zcGVudHMgb24gYSB3YWxsZXRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHBhcmFtZXRlcnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSAtIHRoZSB1c2VycyB3YWxsZXQgcGFzc3BocmFzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnhwcnYgLSB0aGUgcHJpdmF0ZSBrZXkgaW4gc3RyaW5nIGZvcm0gaWYgdGhlIHdhbGxldFBhc3NwaHJhc2UgaXMgbm90IGF2YWlsYWJsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmZlZVJhdGUgLSBUaGUgZmVlIHJhdGUgdG8gdXNlIGZvciB0aGUgY29uc29saWRhdGlvbiBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEZlZVJhdGUgLSB1cHBlciBsaW1pdCBmb3IgZmVlUmF0ZSBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEZlZVBlcmNlbnRhZ2UgLSB0aGUgbWF4aW11bSByZWxhdGl2ZSBwb3J0aW9uIHRoYXQgeW91J3JlIHdpbGxpbmcgdG8gc3BlbmQgdG93YXJkcyBmZWVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0IC0gZXN0aW1hdGUgdGhlIGZlZXMgdG8gYWltIGZvciBmaXJzdCBjb25maXJtYXRpb24gd2l0aCB0aGlzIG51bWJlciBvZiBibG9ja3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5WYWx1ZSAtIHRoZSBtaW5pbXVtIHZhbHVlIG9mIHVuc3BlbnRzIHRvIHVzZSBpbiBzYXRvc2hpc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heFZhbHVlIC0gdGhlIG1heGltdW0gdmFsdWUgb2YgdW5zcGVudHMgdG8gdXNlIGluIHNhdG9zaGlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluSGVpZ2h0IC0gdGhlIG1pbmltdW0gaGVpZ2h0IG9mIHVuc3BlbnRzIG9uIHRoZSBibG9jayBjaGFpbiB0byB1c2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5Db25maXJtcyAtIGFsbCBzZWxlY3RlZCB1bnNwZW50cyB3aWxsIGhhdmUgYXQgbGVhc3QgdGhpcyBtYW55IGNvbmZpcm1hdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlIC0gaWYgdHJ1ZSwgbWluQ29uZmlybXMgYWxzbyBhcHBsaWVzIHRvIGNoYW5nZSBvdXRwdXRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubGltaXQgICAgICAgICAgICAgICAgZm9yIHJvdXRlTmFtZSA9PT0gJ2NvbnNvbGlkYXRlJ1xuICAgKiAgICAgICAgICAgICAgICAgcGFyYW1zLm1heE51bUlucHV0c1RvVXNlICAgIGZvciByb3V0ZU5hbWUgPT09ICdmYW5vdXQnXG4gICAqICAgICAgICAgICAgICAgICAgLSBtYXhpbXVtIG51bWJlciBvZiB1bnNwZW50cyB5b3Ugd2FudCB0byB1c2UgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubnVtVW5zcGVudHNUb01ha2UgLSB0aGUgbnVtYmVyIG9mIG5ldyB1bnNwZW50cyB0byBtYWtlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgY29uc29saWRhdGVVbnNwZW50cyhwYXJhbXM6IENvbnNvbGlkYXRlVW5zcGVudHNPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5tYW5hZ2VVbnNwZW50cygnY29uc29saWRhdGUnLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYW5vdXQgdW5zcGVudHMgb24gYSB3YWxsZXRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHBhcmFtZXRlcnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSAtIHRoZSB1c2VycyB3YWxsZXQgcGFzc3BocmFzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnhwcnYgLSB0aGUgcHJpdmF0ZSBrZXkgaW4gc3RyaW5nIGZvcm0gaWYgdGhlIHdhbGxldFBhc3NwaHJhc2UgaXMgbm90IGF2YWlsYWJsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pblZhbHVlIC0gdGhlIG1pbmltdW0gdmFsdWUgb2YgdW5zcGVudHMgdG8gdXNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4VmFsdWUgLSB0aGUgbWF4aW11bSB2YWx1ZSBvZiB1bnNwZW50cyB0byB1c2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5taW5IZWlnaHQgLSB0aGUgbWluaW11bSBoZWlnaHQgb2YgdW5zcGVudHMgb24gdGhlIGJsb2NrIGNoYWluIHRvIHVzZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pbkNvbmZpcm1zIC0gYWxsIHNlbGVjdGVkIHVuc3BlbnRzIHdpbGwgaGF2ZSBhdCBsZWFzdCB0aGlzIG1hbnkgY29uZmlybWF0aW9uc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEZlZVBlcmNlbnRhZ2UgLSB0aGUgbWF4aW11bSBwcm9wb3J0aW9uIG9mIGFuIHVuc3BlbnQgeW91IGFyZSB3aWxsaW5nIHRvIGxvc2UgdG8gZmVlc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmZlZVR4Q29uZmlybVRhcmdldCAtIGVzdGltYXRlIHRoZSBmZWVzIHRvIGFpbSBmb3IgZmlyc3QgY29uZmlybWF0aW9uIHdpdGggdGhpcyBudW1iZXIgb2YgYmxvY2tzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlUmF0ZSAtIFRoZSBkZXNpcmVkIGZlZSByYXRlIGZvciB0aGUgdHJhbnNhY3Rpb24gaW4gc2F0b3NoaXMva0JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5tYXhGZWVSYXRlIC0gVGhlIG1heCBsaW1pdCBmb3IgYSBmZWUgcmF0ZSBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heE51bUlucHV0c1RvVXNlIC0gdGhlIG51bWJlciBvZiB1bnNwZW50cyB5b3Ugd2FudCB0byB1c2UgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubnVtVW5zcGVudHNUb01ha2UgLSB0aGUgbnVtYmVyIG9mIG5ldyB1bnNwZW50cyB0byBtYWtlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZmFub3V0VW5zcGVudHMocGFyYW1zOiBGYW5vdXRVbnNwZW50c09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiB0aGlzLm1hbmFnZVVuc3BlbnRzKCdmYW5vdXQnLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRva2VuIGZsdXNoIHRocmVzaG9sZHMgZm9yIHRoZSB3YWxsZXQuIFVwZGF0ZXMgdGhlIHdhbGxldC5cbiAgICogVG9rZW5zIHdpbGwgb25seSBiZSBmbHVzaGVkIGZyb20gZm9yd2FyZGVyIGNvbnRyYWN0cyBpZiB0aGUgYmFsYW5jZSBpcyBncmVhdGVyIHRoYW4gdGhlIHRocmVzaG9sZCBkZWZpbmVkIGhlcmUuXG4gICAqIEBwYXJhbSB0aHJlc2hvbGRzIHtPYmplY3R9IC0gcGFpcnMgb2YgeyBbdG9rZW5OYW1lXTogdGhyZXNob2xkIH0gKGJhc2UgdW5pdHMpXG4gICAqIEBwYXJhbSBbY2FsbGJhY2tdXG4gICAqL1xuICB1cGRhdGVUb2tlbkZsdXNoVGhyZXNob2xkcyh0aHJlc2hvbGRzOiBhbnkgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKHNlbGYuYmFzZUNvaW4uZ2V0RmFtaWx5KCkgIT09ICdldGgnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IHN1cHBvcnRlZCBmb3IgdGhpcyB3YWxsZXQnKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fd2FsbGV0ID0geWllbGQgc2VsZi5iaXRnby5wdXQoc2VsZi51cmwoKSkuc2VuZCh7XG4gICAgICAgIHRva2VuRmx1c2hUaHJlc2hvbGRzOiB0aHJlc2hvbGRzXG4gICAgICB9KS5yZXN1bHQoKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3ZWVwIGZ1bmRzIGZvciBhIHdhbGxldFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gcGFyYW1ldGVycyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5hZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gc2VuZCBhbGwgdGhlIGZ1bmRzIGluIHRoZSB3YWxsZXQgdG9cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIC0gdGhlIHVzZXJzIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMueHBydiAtIHRoZSBwcml2YXRlIGtleSBpbiBzdHJpbmcgZm9ybSBpZiB0aGUgd2FsbGV0UGFzc3BocmFzZSBpcyBub3QgYXZhaWxhYmxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMub3RwIC0gVHdvIGZhY3RvciBhdXRoIGNvZGUgdG8gZW5hYmxlIHNlbmRpbmcgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0IC0gRXN0aW1hdGUgdGhlIGZlZXMgdG8gYWltIGZvciBmaXJzdCBjb25maXJtYXRpb24gd2l0aGluIHRoaXMgbnVtYmVyIG9mIGJsb2Nrc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmZlZVJhdGUgLSBUaGUgZGVzaXJlZCBmZWUgcmF0ZSBmb3IgdGhlIHRyYW5zYWN0aW9uIGluIHNhdG9zaGlzL2tCXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1heEZlZVJhdGVdIC0gdXBwZXIgbGltaXQgZm9yIGZlZVJhdGUgaW4gc2F0b3NoaXMva0JcbiAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmFsbG93UGFydGlhbFN3ZWVwXSAtIGFsbG93cyBzd2VlcGluZyAyMDAgdW5zcGVudHMgd2hlbiB0aGUgd2FsbGV0IGhhcyBtb3JlIHRoYW4gdGhhdFxuICAgKiBAcGFyYW0gW2NhbGxiYWNrXVxuICAgKiBAcmV0dXJucyB0eEhleCB7U3RyaW5nfSB0aGUgdHhIZXggb2YgdGhlIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgc3dlZXAocGFyYW1zOiBTd2VlcE9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydhZGRyZXNzJ10sIFsnd2FsbGV0UGFzc3BocmFzZScsICd4cHJ2JywgJ290cCddLCBjYWxsYmFjayk7XG5cbiAgICAgIGlmIChbJ2V0aCcsICd4cnAnXS5pbmNsdWRlcyhzZWxmLmJhc2VDb2luLmdldEZhbWlseSgpKSkge1xuICAgICAgICBpZiAoc2VsZi5jb25maXJtZWRCYWxhbmNlU3RyaW5nKCkgIT09IHNlbGYuYmFsYW5jZVN0cmluZygpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3dlZXAgd2hlbiB1bmNvbmZpcm1lZCBmdW5kcyBleGlzdCBvbiB0aGUgd2FsbGV0LCBwbGVhc2Ugd2FpdCB1bnRpbCBhbGwgaW5ib3VuZCB0cmFuc2FjdGlvbnMgY29uZmlybScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBzZWxmLnNwZW5kYWJsZUJhbGFuY2VTdHJpbmcoKTtcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSAnMCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGZ1bmRzIHRvIHN3ZWVwJyk7XG4gICAgICAgIH1cbiAgICAgICAgKHBhcmFtcyBhcyBhbnkpLnJlY2lwaWVudHMgPSBbe1xuICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgIGFtb3VudDogdmFsdWUsXG4gICAgICAgIH1dO1xuXG4gICAgICAgIHJldHVybiBzZWxmLnNlbmRNYW55KHBhcmFtcyk7XG4gICAgICB9XG4gICAgICAvLyB0aGUgZm9sbG93aW5nIGZsb3cgd29ya3MgZm9yIGFsbCBVVFhPIGNvaW5zXG5cbiAgICAgIGNvbnN0IHJlcUlkID0gbmV3IFJlcXVlc3RUcmFjZXIoKTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkUGFyYW1zID0gXy5waWNrKHBhcmFtcywgWydhZGRyZXNzJywgJ2ZlZVJhdGUnLCAnbWF4RmVlUmF0ZScsICdmZWVUeENvbmZpcm1UYXJnZXQnLCAnYWxsb3dQYXJ0aWFsU3dlZXAnXSk7XG4gICAgICBzZWxmLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBzZWxmLmJpdGdvLnBvc3Qoc2VsZi51cmwoJy9zd2VlcFdhbGxldCcpKVxuICAgICAgICAuc2VuZChmaWx0ZXJlZFBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgICAgLy8gVE9ETyhCRy0zNTg4KTogYWRkIHR4SGV4IHZhbGlkYXRpb24gdG8gcHJvdGVjdCBtYW4gaW4gdGhlIG1pZGRsZSBhdHRhY2tzIHJlcGxhY2luZyB0aGUgdHhIZXhcblxuICAgICAgY29uc3Qga2V5Y2hhaW4gPSB5aWVsZCBzZWxmLmJhc2VDb2luLmtleWNoYWlucygpLmdldCh7IGlkOiBzZWxmLl93YWxsZXQua2V5c1swXSwgcmVxSWQgfSk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvblBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBwYXJhbXMsIHsgdHhQcmVidWlsZDogcmVzcG9uc2UsIGtleWNoYWluOiBrZXljaGFpbiwgcHJ2OiBwYXJhbXMueHBydiB9KTtcbiAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0geWllbGQgc2VsZi5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25QYXJhbXMpO1xuXG4gICAgICBjb25zdCBzZWxlY3RQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBbJ290cCddKTtcbiAgICAgIGNvbnN0IGZpbmFsVHhQYXJhbXMgPSBfLmV4dGVuZCh7fSwgc2lnbmVkVHJhbnNhY3Rpb24sIHNlbGVjdFBhcmFtcyk7XG4gICAgICBzZWxmLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuICAgICAgcmV0dXJuIHNlbGYuYml0Z28ucG9zdChzZWxmLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgc2VsZi5fd2FsbGV0LmlkICsgJy90eC9zZW5kJykpXG4gICAgICAgIC5zZW5kKGZpbmFsVHhQYXJhbXMpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyZWV6ZSBhIGdpdmVuIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGZyZWV6ZShwYXJhbXM6IEZyZWV6ZU9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcblxuICAgIGlmIChwYXJhbXMuZHVyYXRpb24pIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMuZHVyYXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkdXJhdGlvbjogc2hvdWxkIGJlIG51bWJlciBvZiBzZWNvbmRzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLnVybCgnL2ZyZWV6ZScpKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGNvbW1lbnQgb2YgYSB0cmFuc2ZlclxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHRyYW5zZmVyQ29tbWVudChwYXJhbXM6IFRyYW5zZmVyQ29tbWVudE9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaWQnXSwgWydjb21tZW50J10sIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzLmJpdGdvLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQvJyArIHRoaXMuX3dhbGxldC5pZCArICcvdHJhbnNmZXIvJyArIHBhcmFtcy5pZCArICcvY29tbWVudCcpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCB0aGUgYWRkcmVzc2VzIGZvciBhIGdpdmVuIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGFkZHJlc3NlcyhwYXJhbXM6IEFkZHJlc3Nlc09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgY29uc3QgcXVlcnk6IEFkZHJlc3Nlc09wdGlvbnMgPSB7fTtcblxuICAgIGlmIChwYXJhbXMubWluZSkge1xuICAgICAgcXVlcnkubWluZSA9ICEhcGFyYW1zLm1pbmU7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnByZXZJZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByZXZJZCBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcXVlcnkucHJldklkID0gcGFyYW1zLnByZXZJZDtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnNvcnQpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMuc29ydCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNvcnQgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnNvcnQgPSBwYXJhbXMuc29ydDtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmxpbWl0KSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLmxpbWl0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGltaXQgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmxpbWl0ID0gcGFyYW1zLmxpbWl0O1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMubGFiZWxDb250YWlucykge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5sYWJlbENvbnRhaW5zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGFiZWxDb250YWlucyBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcXVlcnkubGFiZWxDb250YWlucyA9IHBhcmFtcy5sYWJlbENvbnRhaW5zO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuc2Vnd2l0KSkge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuc2Vnd2l0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2Vnd2l0IGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgcXVlcnkuc2Vnd2l0ID0gcGFyYW1zLnNlZ3dpdDtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmNoYWlucykpIHtcbiAgICAgIGlmICghXy5pc0FycmF5KHBhcmFtcy5jaGFpbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjaGFpbnMgYXJndW1lbnQsIGV4cGVjdGluZyBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5jaGFpbnMgPSBwYXJhbXMuY2hhaW5zO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgdGhpcy5fd2FsbGV0LmlkICsgJy9hZGRyZXNzZXMnKSlcbiAgICAgIC5xdWVyeShxdWVyeSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHNpbmdsZSB3YWxsZXQgYWRkcmVzcyBieSBpdHMgaWRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBnZXRBZGRyZXNzKHBhcmFtczogR2V0QWRkcmVzc09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ2FkZHJlc3MnLCAnaWQnXSwgY2FsbGJhY2spO1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMuYWRkcmVzcykgJiYgXy5pc1VuZGVmaW5lZChwYXJhbXMuaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZHJlc3Mgb3IgaWQgb2YgYWRkcmVzcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmFkZHJlc3MpIHtcbiAgICAgIHF1ZXJ5ID0gcGFyYW1zLmFkZHJlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gcGFyYW1zLmlkO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMucmVxSWQpIHtcbiAgICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihwYXJhbXMucmVxSWQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLmJhc2VDb2luLnVybChgL3dhbGxldC8ke3RoaXMuX3dhbGxldC5pZH0vYWRkcmVzcy8ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9YCkpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgb25lIG9yIG1vcmUgbmV3IGFkZHJlc3MoZXMpIGZvciB1c2Ugd2l0aCB0aGlzIHdhbGxldC5cbiAgICpcbiAgICogSWYgdGhlIGBjb3VudGAgZmllbGQgaXMgZGVmaW5lZCBhbmQgZ3JlYXRlciB0aGFuIDEsIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlXG4gICAqIGFycmF5IHByb3BlcnR5IG5hbWVkIGBhZGRyZXNzZXNgIGNvbnRhaW5pbmcgYGNvdW50YCBhZGRyZXNzIG9iamVjdHNcbiAgICogd2lsbCBiZSByZXR1cm5lZC4gT3RoZXJ3aXNlLCBhIHNpbmdsZSBhZGRyZXNzIG9iamVjdCBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmNoYWluIG9uIHdoaWNoIHRoZSBuZXcgYWRkcmVzcyBzaG91bGQgYmUgY3JlYXRlZFxuICAgKiBAcGFyYW0geyhOdW1iZXJ8U3RyaW5nKX0gcGFyYW1zLmdhc1ByaWNlIGdhcyBwcmljZSBmb3IgbmV3IGFkZHJlc3MgY3JlYXRpb24sIGlmIGFwcGxpY2FibGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5sYWJlbCBsYWJlbCBmb3IgdGhlIG5ldyBhZGRyZXNzKGVzKVxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmNvdW50PTEgbnVtYmVyIG9mIG5ldyBhZGRyZXNzZXMgd2hpY2ggc2hvdWxkIGJlIGNyZWF0ZWQgKG1heGltdW0gMjUwKVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5sb3dQcmlvcml0eSBFdGhlcmV1bS1zcGVjaWZpYyBwYXJhbSB0byBjcmVhdGUgYWRkcmVzcyB1c2luZyBsb3cgcHJpb3JpdHkgZmVlIGFkZHJlc3NcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBjcmVhdGVBZGRyZXNzKHBhcmFtczogQ3JlYXRlQWRkcmVzc09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgYWRkcmVzc1BhcmFtczogQ3JlYXRlQWRkcmVzc09wdGlvbnMgPSB7fTtcbiAgICAgIGNvbnN0IHJlcUlkID0gbmV3IFJlcXVlc3RUcmFjZXIoKTtcblxuICAgICAgY29uc3Qge1xuICAgICAgICBjaGFpbixcbiAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBsb3dQcmlvcml0eSxcbiAgICAgICAgY291bnQgPSAxLFxuICAgICAgfSA9IHBhcmFtcztcblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKGNoYWluKSkge1xuICAgICAgICBpZiAoIV8uaXNJbnRlZ2VyKGNoYWluKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hhaW4gaGFzIHRvIGJlIGFuIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzUGFyYW1zLmNoYWluID0gY2hhaW47XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChnYXNQcmljZSkpIHtcbiAgICAgICAgaWYgKCFfLmlzSW50ZWdlcihnYXNQcmljZSkgJiYgKGlzTmFOKE51bWJlcihnYXNQcmljZSkpIHx8ICFfLmlzU3RyaW5nKGdhc1ByaWNlKSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dhc1ByaWNlIGhhcyB0byBiZSBhbiBpbnRlZ2VyIG9yIG51bWVyaWMgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkcmVzc1BhcmFtcy5nYXNQcmljZSA9IGdhc1ByaWNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQobGFiZWwpKSB7XG4gICAgICAgIGlmICghXy5pc1N0cmluZyhsYWJlbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhYmVsIGhhcyB0byBiZSBhIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGFkZHJlc3NQYXJhbXMubGFiZWwgPSBsYWJlbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzSW50ZWdlcihjb3VudCkgfHwgY291bnQgPD0gMCB8fCBjb3VudCA+IDI1MCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdW50IGhhcyB0byBiZSBhIG51bWJlciBiZXR3ZWVuIDEgYW5kIDI1MCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQobG93UHJpb3JpdHkpKSB7XG4gICAgICAgIGlmICghXy5pc0Jvb2xlYW4obG93UHJpb3JpdHkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb3dQcmlvcml0eSBoYXMgdG8gYmUgYSBib29sZWFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkcmVzc1BhcmFtcy5sb3dQcmlvcml0eSA9IGxvd1ByaW9yaXR5O1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQga2V5Y2hhaW5zIGZvciBhZGRyZXNzIHZlcmlmaWNhdGlvblxuICAgICAgY29uc3Qga2V5Y2hhaW5zID0geWllbGQgQmx1ZWJpcmQubWFwKHNlbGYuX3dhbGxldC5rZXlzIGFzIHN0cmluZ1tdLFxuICAgICAgICBrID0+IHNlbGYuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuZ2V0KHsgaWQ6IGssIHJlcUlkIH0pXG4gICAgICApO1xuICAgICAgY29uc3Qgcm9vdEFkZHJlc3MgPSBfLmdldChzZWxmLl93YWxsZXQsICdyZWNlaXZlQWRkcmVzcy5hZGRyZXNzJyk7XG5cbiAgICAgIGNvbnN0IG5ld0FkZHJlc3NlcyA9IF8udGltZXMoY291bnQsIGNvKGZ1bmN0aW9uICpjcmVhdGVBbmRWZXJpZnlBZGRyZXNzKCkge1xuICAgICAgICBzZWxmLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuICAgICAgICBjb25zdCBuZXdBZGRyZXNzID0geWllbGQgc2VsZi5iaXRnby5wb3N0KHNlbGYuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyBzZWxmLl93YWxsZXQuaWQgKyAnL2FkZHJlc3MnKSlcbiAgICAgICAgICAuc2VuZChhZGRyZXNzUGFyYW1zKVxuICAgICAgICAgIC5yZXN1bHQoKTtcblxuICAgICAgICAvLyBpbmZlciBpdHMgYWRkcmVzcyB0eXBlXG4gICAgICAgIGlmIChfLmlzT2JqZWN0KG5ld0FkZHJlc3MuY29pblNwZWNpZmljKSkge1xuICAgICAgICAgIC8vIG5lZWQgZHluYW1pYyBpbXBvcnQgdG8gYnJlYWsgY2lyY3VsYXIgZGVwZW5kZW5jeSwgdGhpcyBpcyB1Z2x5XG4gICAgICAgICAgY29uc3QgeyBBYnN0cmFjdFV0eG9Db2luIH0gPSByZXF1aXJlKCcuL2NvaW5zL2Fic3RyYWN0VXR4b0NvaW4nKTtcbiAgICAgICAgICBuZXdBZGRyZXNzLmFkZHJlc3NUeXBlID0gQWJzdHJhY3RVdHhvQ29pbi5pbmZlckFkZHJlc3NUeXBlKG5ld0FkZHJlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3QWRkcmVzcy5rZXljaGFpbnMgPSBrZXljaGFpbnM7XG4gICAgICAgIGNvbnN0IHZlcmlmaWNhdGlvbkRhdGE6IFZlcmlmeUFkZHJlc3NPcHRpb25zID0gXy5tZXJnZSh7fSwgbmV3QWRkcmVzcywgeyByb290QWRkcmVzcyB9KTtcblxuICAgICAgICBpZiAodmVyaWZpY2F0aW9uRGF0YS5lcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBBZGRyZXNzR2VuZXJhdGlvbkVycm9yKHZlcmlmaWNhdGlvbkRhdGEuZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZlcmlmaWNhdGlvbkRhdGEuY29pblNwZWNpZmljICYmICF2ZXJpZmljYXRpb25EYXRhLmNvaW5TcGVjaWZpYy5wZW5kaW5nQ2hhaW5Jbml0aWFsaXphdGlvbikge1xuICAgICAgICAgIC8vIGNhbid0IHZlcmlmeSBhZGRyZXNzZXMgd2hpY2ggYXJlIHBlbmRpbmcgY2hhaW4gaW5pdGlhbGl6YXRpb24sIGFzIHRoZSBhZGRyZXNzIGlzIGhpZGRlblxuICAgICAgICAgIHNlbGYuYmFzZUNvaW4udmVyaWZ5QWRkcmVzcyh2ZXJpZmljYXRpb25EYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdBZGRyZXNzO1xuICAgICAgfSkuYmluZCh0aGlzKSk7XG5cbiAgICAgIGlmIChuZXdBZGRyZXNzZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBuZXdBZGRyZXNzZXNbMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3NlczogeWllbGQgUHJvbWlzZS5hbGwobmV3QWRkcmVzc2VzKSxcbiAgICAgIH07XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgcHJvcGVydGllcyBvbiBhbiBhZGRyZXNzXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgdXBkYXRlQWRkcmVzcyhwYXJhbXM6IFVwZGF0ZUFkZHJlc3NPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBwYXJhbXMuYWRkcmVzcztcblxuICAgICAgaWYgKCFfLmlzU3RyaW5nKGFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBzdHJpbmcgcGFyYW1ldGVyIGFkZHJlc3MnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHV0UGFyYW1zID0gXy5waWNrKHBhcmFtcywgWydsYWJlbCddKTtcbiAgICAgIGNvbnN0IHVybCA9IHNlbGYudXJsKCcvYWRkcmVzcy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFkZHJlc3MpKTtcblxuICAgICAgcmV0dXJuIHNlbGYuYml0Z28ucHV0KHVybCkuc2VuZChwdXRQYXJhbXMpLnJlc3VsdCgpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCB3ZWJob29rcyBvbiB0aGlzIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgbGlzdFdlYmhvb2tzKHBhcmFtczogUGFnaW5hdGlvbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHF1ZXJ5OiBQYWdpbmF0aW9uT3B0aW9ucyA9IHt9O1xuICAgIGlmIChwYXJhbXMucHJldklkKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnByZXZJZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByZXZJZCBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcXVlcnkucHJldklkID0gcGFyYW1zLnByZXZJZDtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmxpbWl0KSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLmxpbWl0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGltaXQgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LmxpbWl0ID0gcGFyYW1zLmxpbWl0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3dlYmhvb2tzJykpXG4gICAgICAucXVlcnkocXVlcnkpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZSB3YWxsZXQgd2ViaG9vaywgY3VycmVudGx5IGZvciB3ZWJob29rcyBvZiB0eXBlIHRyYW5zZmVyIGFuZCBwZW5kaW5nIGFwcHJvdmFsXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSB3ZWJob29rSWQgKHJlcXVpcmVkKSBpZCBvZiB0aGUgd2ViaG9vayB0byBiZSBzaW11bGF0ZWRcbiAgICogLSB0cmFuc2ZlcklkIChvcHRpb25hbCBidXQgcmVxdWlyZWQgZm9yIHRyYW5zZmVyIHdlYmhvb2tzKSBpZCBvZiB0aGUgc2ltdWxhdGVkIHRyYW5zZmVyXG4gICAqIC0gcGVuZGluZ0FwcHJvdmFsSWQgKG9wdGlvbmFsIGJ1dCByZXF1aXJlZCBmb3IgcGVuZGluZyBhcHByb3ZhbCB3ZWJob29rcykgaWQgb2YgdGhlIHNpbXVsYXRlZCBwZW5kaW5nIGFwcHJvdmFsXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHNpbXVsYXRlV2ViaG9vayhwYXJhbXM6IFNpbXVsYXRlV2ViaG9va09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnd2ViaG9va0lkJ10sIFsndHJhbnNmZXJJZCcsICdwZW5kaW5nQXBwcm92YWxJZCddLCBjYWxsYmFjayk7XG5cbiAgICBjb25zdCBoYXNUcmFuc2ZlcklkID0gISFwYXJhbXMudHJhbnNmZXJJZDtcbiAgICBjb25zdCBoYXNQZW5kaW5nQXBwcm92YWxJZCA9ICEhcGFyYW1zLnBlbmRpbmdBcHByb3ZhbElkO1xuICAgIGlmICghaGFzVHJhbnNmZXJJZCAmJiAhaGFzUGVuZGluZ0FwcHJvdmFsSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzdXBwbHkgZWl0aGVyIHRyYW5zZmVySWQgb3IgcGVuZGluZ0FwcHJvdmFsSWQnKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVHJhbnNmZXJJZCAmJiBoYXNQZW5kaW5nQXBwcm92YWxJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHN1cHBseSBlaXRoZXIgdHJhbnNmZXJJZCBvciBwZW5kaW5nQXBwcm92YWxJZCwgYnV0IG5vdCBib3RoJyk7XG4gICAgfVxuXG4gICAgLy8gZGVwZW5kaW5nIG9uIHRoZSBjb2luIHR5cGUgb2YgdGhlIHdhbGxldCwgdGhlIHR4SGFzaCBoYXMgdG8gYWRoZXJlIHRvIGl0cyByZXNwZWN0aXZlIGZvcm1hdFxuICAgIC8vIGJ1dCB0aGUgc2VydmVyIHRha2VzIGNhcmUgb2YgdGhhdFxuXG4gICAgLy8gb25seSB0YWtlIHRoZSB0cmFuc2ZlcklkIGFuZCBwZW5kaW5nQXBwcm92YWxJZCBwcm9wZXJ0aWVzXG4gICAgY29uc3QgZmlsdGVyZWRQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBbJ3RyYW5zZmVySWQnLCAncGVuZGluZ0FwcHJvdmFsSWQnXSk7XG5cbiAgICBjb25zdCB3ZWJob29rSWQgPSBwYXJhbXMud2ViaG9va0lkO1xuICAgIHJldHVybiB0aGlzLmJpdGdvLnBvc3QodGhpcy51cmwoJy93ZWJob29rcy8nICsgd2ViaG9va0lkICsgJy9zaW11bGF0ZScpKVxuICAgICAgLnNlbmQoZmlsdGVyZWRQYXJhbXMpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSB3ZWJob29rIHRvIHRoaXMgd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBhZGRXZWJob29rKHBhcmFtczogTW9kaWZ5V2ViaG9va09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndXJsJywgJ3R5cGUnXSwgW10sIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzLmJpdGdvLnBvc3QodGhpcy51cmwoJy93ZWJob29rcycpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgd2ViaG9vayBmcm9tIHRoaXMgd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICByZW1vdmVXZWJob29rKHBhcmFtczogTW9kaWZ5V2ViaG9va09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndXJsJywgJ3R5cGUnXSwgW10sIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmRlbCh0aGlzLnVybCgnL3dlYmhvb2tzJykpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB1c2VyIGtleSBjaGFpbiBmb3IgdGhpcyB3YWxsZXRcbiAgICpcbiAgICogVGhlIHVzZXIga2V5IGNoYWluIGlzIHRoZSBmaXJzdCBrZXljaGFpbiBvZiB0aGUgd2FsbGV0IGFuZCB1c3VhbGx5IGhhcyB0aGUgZW5jcnlwdGVkIHBydiBzdG9yZWQgb24gQml0R28uXG4gICAqIFVzZWZ1bCB3aGVuIHRyeWluZyB0byBnZXQgdGhlIHVzZXJzJyBrZXljaGFpbiBmcm9tIHRoZSBzZXJ2ZXIgYmVmb3JlIGRlY3J5cHRpbmcgdG8gc2lnbiBhIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZ2V0RW5jcnlwdGVkVXNlcktleWNoYWluKHBhcmFtczoge30gPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHRyeUtleUNoYWluID0gY28oZnVuY3Rpb24gKihpbmRleDogbnVtYmVyKSB7XG4gICAgICBpZiAoIXNlbGYuX3dhbGxldC5rZXlzIHx8IGluZGV4ID49IHNlbGYuX3dhbGxldC5rZXlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVuY3J5cHRlZCBrZXljaGFpbnMgb24gdGhpcyB3YWxsZXQuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmFtcyA9IHsgaWQ6IHNlbGYuX3dhbGxldC5rZXlzW2luZGV4XSB9O1xuXG4gICAgICBjb25zdCBrZXljaGFpbiA9IHlpZWxkIHNlbGYuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuZ2V0KHBhcmFtcyk7XG4gICAgICAvLyBJZiB3ZSBmaW5kIHRoZSBwcnYsIHRoZW4gdGhpcyBpcyBwcm9iYWJseSB0aGUgdXNlciBrZXljaGFpbiB3ZSdyZSBsb29raW5nIGZvclxuICAgICAgaWYgKGtleWNoYWluLmVuY3J5cHRlZFBydikge1xuICAgICAgICByZXR1cm4ga2V5Y2hhaW47XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ5S2V5Q2hhaW4oaW5kZXggKyAxKTtcbiAgICB9KS5iaW5kKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRyeUtleUNoYWluKDApLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVuZW5jcnlwdGVkIHByaXZhdGUga2V5IGZvciB0aGlzIHdhbGxldCAoYmUgY2FyZWZ1bCEpXG4gICAqIFJlcXVpcmVzIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBnZXRQcnYocGFyYW1zOiBHZXRQcnZPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ3dhbGxldFBhc3NwaHJhc2UnLCAncHJ2J10sIGNhbGxiYWNrKTtcblxuICAgICAgLy8gUHJlcGFyZSBzaWduaW5nIGtleVxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnBydikgJiYgXy5pc1VuZGVmaW5lZChwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGVpdGhlciBwcm92aWRlIHBydiBvciB3YWxsZXQgcGFzc3BocmFzZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLnBydikgJiYgIV8uaXNTdHJpbmcocGFyYW1zLnBydikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcnYgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLndhbGxldFBhc3NwaHJhc2UpICYmICFfLmlzU3RyaW5nKHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhbGxldFBhc3NwaHJhc2UgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnBydikge1xuICAgICAgICByZXR1cm4gcGFyYW1zLnBydjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXNlcktleWNoYWluID0geWllbGQgc2VsZi5nZXRFbmNyeXB0ZWRVc2VyS2V5Y2hhaW4oKTtcbiAgICAgIGNvbnN0IHVzZXJFbmNyeXB0ZWRQcnYgPSB1c2VyS2V5Y2hhaW4uZW5jcnlwdGVkUHJ2O1xuXG4gICAgICBsZXQgdXNlclBydjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHVzZXJQcnYgPSBzZWxmLmJpdGdvLmRlY3J5cHQoeyBpbnB1dDogdXNlckVuY3J5cHRlZFBydiwgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Vycm9yIGRlY3J5cHRpbmcgd2FsbGV0IHBhc3NwaHJhc2UnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVzZXJQcnY7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGFuIGVuY3J5cHRlZCB3YWxsZXQgc2hhcmUgdG8gQml0R28uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBjcmVhdGVTaGFyZShwYXJhbXM6IENyZWF0ZVNoYXJlT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd1c2VyJywgJ3Blcm1pc3Npb25zJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgICBpZiAocGFyYW1zLmtleWNoYWluICYmICFfLmlzRW1wdHkocGFyYW1zLmtleWNoYWluKSkge1xuICAgICAgaWYgKCFwYXJhbXMua2V5Y2hhaW4ucHViIHx8ICFwYXJhbXMua2V5Y2hhaW4uZW5jcnlwdGVkUHJ2IHx8ICFwYXJhbXMua2V5Y2hhaW4uZnJvbVB1YktleSB8fCAhcGFyYW1zLmtleWNoYWluLnRvUHViS2V5IHx8ICFwYXJhbXMua2V5Y2hhaW4ucGF0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVzIGtleWNoYWluIHBhcmFtZXRlcnMgLSBwdWIsIGVuY3J5cHRlZFBydiwgZnJvbVB1YktleSwgdG9QdWJLZXksIHBhdGgnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMudXJsKCcvc2hhcmUnKSlcbiAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoYXJlIHRoaXMgd2FsbGV0IHdpdGggYW5vdGhlciBCaXRHbyB1c2VyLlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHNoYXJlV2FsbGV0KHBhcmFtczogU2hhcmVXYWxsZXRPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnZW1haWwnLCAncGVybWlzc2lvbnMnXSwgWyd3YWxsZXRQYXNzcGhyYXNlJywgJ21lc3NhZ2UnXSwgY2FsbGJhY2spO1xuXG4gICAgICBpZiAocGFyYW1zLnJlc2hhcmUgIT09IHVuZGVmaW5lZCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLnJlc2hhcmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVzaGFyZSB0byBiZSBhIGJvb2xlYW4uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuc2tpcEtleWNoYWluICE9PSB1bmRlZmluZWQgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5za2lwS2V5Y2hhaW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgc2tpcEtleWNoYWluIHRvIGJlIGEgYm9vbGVhbi4gJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBuZWVkc0tleWNoYWluID0gIXBhcmFtcy5za2lwS2V5Y2hhaW4gJiYgcGFyYW1zLnBlcm1pc3Npb25zICYmIHBhcmFtcy5wZXJtaXNzaW9ucy5pbmRleE9mKCdzcGVuZCcpICE9PSAtMTtcblxuICAgICAgaWYgKHBhcmFtcy5kaXNhYmxlRW1haWwgIT09IHVuZGVmaW5lZCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmRpc2FibGVFbWFpbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBkaXNhYmxlRW1haWwgdG8gYmUgYSBib29sZWFuLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmVtYWlsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgc3RyaW5nIHBhcmFtZXRlciBlbWFpbCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzaGFyaW5nID0geWllbGQgc2VsZi5iaXRnby5nZXRTaGFyaW5nS2V5KHsgZW1haWw6IHBhcmFtcy5lbWFpbC50b0xvd2VyQ2FzZSgpIH0pO1xuICAgICAgbGV0IHNoYXJlZEtleWNoYWluO1xuICAgICAgaWYgKG5lZWRzS2V5Y2hhaW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBrZXljaGFpbiA9IHlpZWxkIHNlbGYuZ2V0RW5jcnlwdGVkVXNlcktleWNoYWluKHt9KTtcbiAgICAgICAgICAvLyBEZWNyeXB0IHRoZSB1c2VyIGtleSB3aXRoIGEgcGFzc3BocmFzZVxuICAgICAgICAgIGlmIChrZXljaGFpbi5lbmNyeXB0ZWRQcnYpIHtcbiAgICAgICAgICAgIGlmICghcGFyYW1zLndhbGxldFBhc3NwaHJhc2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHdhbGxldFBhc3NwaHJhc2UgYXJndW1lbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGtleWNoYWluLnBydiA9IHNlbGYuYml0Z28uZGVjcnlwdCh7IHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSwgaW5wdXQ6IGtleWNoYWluLmVuY3J5cHRlZFBydiB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGVjcnlwdCB1c2VyIGtleWNoYWluJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGVja2V5ID0gbWFrZVJhbmRvbUtleSgpO1xuICAgICAgICAgICAgY29uc3Qgc2VjcmV0ID0gc2VsZi5iaXRnby5nZXRFQ0RIU2VjcmV0KHsgZWNrZXk6IGVja2V5LCBvdGhlclB1YktleUhleDogc2hhcmluZy5wdWJrZXkgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXdFbmNyeXB0ZWRQcnYgPSBzZWxmLmJpdGdvLmVuY3J5cHQoeyBwYXNzd29yZDogc2VjcmV0LCBpbnB1dDoga2V5Y2hhaW4ucHJ2IH0pO1xuXG4gICAgICAgICAgICBzaGFyZWRLZXljaGFpbiA9IHtcbiAgICAgICAgICAgICAgcHViOiBrZXljaGFpbi5wdWIsXG4gICAgICAgICAgICAgIGVuY3J5cHRlZFBydjogbmV3RW5jcnlwdGVkUHJ2LFxuICAgICAgICAgICAgICBmcm9tUHViS2V5OiBlY2tleS5nZXRQdWJsaWNLZXlCdWZmZXIoKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgICAgIHRvUHViS2V5OiBzaGFyaW5nLnB1YmtleSxcbiAgICAgICAgICAgICAgcGF0aDogc2hhcmluZy5wYXRoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZS5tZXNzYWdlID09PSAnTm8gZW5jcnlwdGVkIGtleWNoYWlucyBvbiB0aGlzIHdhbGxldC4nKSB7XG4gICAgICAgICAgICBzaGFyZWRLZXljaGFpbiA9IHt9O1xuICAgICAgICAgICAgLy8gaWdub3JlIHRoaXMgZXJyb3IgYmVjYXVzZSB0aGlzIGxvb2tzIGxpa2UgYSBjb2xkIHdhbGxldFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvcHRpb25zOiBDcmVhdGVTaGFyZU9wdGlvbnMgPSB7XG4gICAgICAgIHVzZXI6IHNoYXJpbmcudXNlcklkLFxuICAgICAgICBwZXJtaXNzaW9uczogcGFyYW1zLnBlcm1pc3Npb25zLFxuICAgICAgICByZXNoYXJlOiBwYXJhbXMucmVzaGFyZSxcbiAgICAgICAgbWVzc2FnZTogcGFyYW1zLm1lc3NhZ2UsXG4gICAgICAgIGRpc2FibGVFbWFpbDogcGFyYW1zLmRpc2FibGVFbWFpbCxcbiAgICAgIH07XG5cbiAgICAgIGlmIChzaGFyZWRLZXljaGFpbikge1xuICAgICAgICBvcHRpb25zLmtleWNoYWluID0gc2hhcmVkS2V5Y2hhaW47XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5za2lwS2V5Y2hhaW4pIHtcbiAgICAgICAgb3B0aW9ucy5rZXljaGFpbiA9IHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5jcmVhdGVTaGFyZShvcHRpb25zKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB1c2VyIGZyb20gd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSB1c2VySWQgSWQgb2YgdGhlIHVzZXIgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgcmVtb3ZlVXNlcihwYXJhbXM6IFJlbW92ZVVzZXJPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3VzZXJJZCddLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZDtcbiAgICByZXR1cm4gdGhpcy5iaXRnby5kZWwodGhpcy51cmwoJy91c2VyLycgKyB1c2VySWQpKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSB0cmFuc2FjdGlvbiBwcmVidWlsZCAodW5zaWduZWQgdHJhbnNhY3Rpb24pIGZyb20gQml0R29cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKiBAcGFyYW0ge3thZGRyZXNzOiBzdHJpbmcsIGFtb3VudDogc3RyaW5nfX0gcGFyYW1zLnJlY2lwaWVudHMgLSBsaXN0IG9mIHJlY2lwaWVudHMgYW5kIG5lY2Vzc2FyeSByZWNpcGllbnQgaW5mb3JtYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5udW1CbG9ja3MgLSBFc3RpbWF0ZXMgdGhlIGFwcHJveGltYXRlIGZlZSBwZXIga2lsb2J5dGUgbmVjZXNzYXJ5IGZvciBhIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiB3aXRoaW4gbnVtQmxvY2tzIGJsb2Nrc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmZlZVJhdGUgLSB0aGUgZGVzaXJlZCBmZWVSYXRlIGZvciB0aGUgdHJhbnNhY3Rpb24gaW4gYmFzZSB1bml0cy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEZlZVJhdGUgLSB1cHBlciBsaW1pdCBmb3IgZmVlUmF0ZSBpbiBiYXNlIHVuaXRzL2tCXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluQ29uZmlybXMgLSBNaW5pbXVtIG51bWJlciBvZiBjb25maXJtYXRpb25zIHVuc3BlbnRzIGdvaW5nIGludG8gdGhpcyB0cmFuc2FjdGlvbiBzaG91bGQgaGF2ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5lbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2UgLSBFbmZvcmNlIG1pbmltdW0gbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgb24gY2hhbmdlIChpbnRlcm5hbCkgaW5wdXRzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLnRhcmdldFdhbGxldFVuc3BlbnRzIC0gVGhlIGRlc2lyZWQgY291bnQgb2YgdW5zcGVudHMgaW4gdGhlIHdhbGxldC4gSWYgdGhlIHdhbGxldOKAmXMgY3VycmVudCB1bnNwZW50IGNvdW50IGlzIGxvd2VyIHRoYW4gdGhlIHRhcmdldCwgdXAgdG8gZm91ciBhZGRpdGlvbmFsIGNoYW5nZSBvdXRwdXRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pblZhbHVlIC0gSWdub3JlIHVuc3BlbnRzIHNtYWxsZXIgdGhhbiB0aGlzIGFtb3VudCBvZiBiYXNlIHVuaXRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4VmFsdWUgLSBJZ25vcmUgdW5zcGVudHMgbGFyZ2VyIHRoYW4gdGhpcyBhbW91bnQgb2YgYmFzZSB1bml0c1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLnNlcXVlbmNlSWQgLSBUaGUgc2VxdWVuY2UgSUQgb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubGFzdExlZGdlclNlcXVlbmNlIC0gQWJzb2x1dGUgbWF4IGxlZGdlciB0aGUgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIGFjY2VwdGVkIGluLCB3aGVyZWFmdGVyIGl0IHdpbGwgYmUgcmVqZWN0ZWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMubGVkZ2VyU2VxdWVuY2VEZWx0YSAtIFJlbGF0aXZlIGxlZGdlciBoZWlnaHQgKGluIHJlbGF0aW9uIHRvIHRoZSBjdXJyZW50IGxlZGdlcikgdGhhdCB0aGUgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIGFjY2VwdGVkIGluLCB3aGVyZWFmdGVyIGl0IHdpbGwgYmUgcmVqZWN0ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZ2FzUHJpY2UgLSBDdXN0b20gZ2FzIHByaWNlIHRvIGJlIHVzZWQgZm9yIHNlbmRpbmcgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZ2FzTGltaXQgLSBDdXN0b20gZ2FzIGxpbWl0IHRvIGJlIHVzZWQgZm9yIHNlbmRpbmcgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLm5vU3BsaXRDaGFuZ2UgLSBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIGF1dG9tYXRpYyBjaGFuZ2Ugc3BsaXR0aW5nIGZvciBwdXJwb3NlcyBvZiB1bnNwZW50IG1hbmFnZW1lbnRcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zLnVuc3BlbnRzIC0gVGhlIHVuc3BlbnRzIHRvIHVzZSBpbiB0aGUgdHJhbnNhY3Rpb24uIEVhY2ggdW5zcGVudCBzaG91bGQgYmUgaW4gdGhlIGZvcm0gcHJldlR4SWQ6bk91dHB1dFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmNoYW5nZUFkZHJlc3MgLSBTcGVjaWZpZXMgdGhlIGRlc3RpbmF0aW9uIG9mIHRoZSBjaGFuZ2Ugb3V0cHV0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMudmFsaWRGcm9tQmxvY2sgLSAoQWxnb3JhbmQpIFRoZSBtaW5pbXVtIHJvdW5kIHRoaXMgd2lsbCBydW4gb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy52YWxpZFRvQmxvY2sgLSAoQWxnb3JhbmQpIFRoZSBtYXhpbXVtIHJvdW5kIHRoaXMgd2lsbCBydW4gb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuaW5zdGFudCAtIEJ1aWxkIHRoaXMgdHJhbnNhY3Rpb24gdG8gY29uZm9ybSB3aXRoIGluc3RhbnQgc2VuZGluZyBjb2luLXNwZWNpZmljIG1ldGhvZCAoaWYgYXZhaWxhYmxlKVxuICAgKiBAcGFyYW0ge3t2YWx1ZTogU3RyaW5nLCB0eXBlOiBTdHJpbmd9fSBwYXJhbXMubWVtbyAtIE1lbW8gdG8gdXNlIGluIHRyYW5zYWN0aW9uIChzdXBwb3J0ZWQgYnkgU3RlbGxhcilcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5hZGRyZXNzVHlwZSAtIFRoZSB0eXBlIG9mIGFkZHJlc3MgdG8gY3JlYXRlIGZvciBjaGFuZ2UuIE9uZSBvZiBgcDJzaGAsIGBwMnNoUDJ3c2hgLCBhbmQgYHAyd3NoYC4gQ2FzZS1zZW5zaXRpdmUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFyYW1zLmhvcCAtIEJ1aWxkIHRoaXMgYXMgYW4gRXRoZXJldW0gaG9wIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucmVzZXJ2YXRpb24gLSBPYmplY3QgdG8gcmVzZXJ2ZSB0aGUgdW5zcGVudHMgdGhhdCB0aGlzIHR4IGJ1aWxkIHVzZXMuIEZvcm1hdCBpcyByZXNlcnZhdGlvbiA9IHsgZXhwaXJlVGltZTogSVNPRGF0ZVN0cmluZywgcGVuZGluZ0FwcHJvdmFsSWQ6IFN0cmluZyB9XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSBUaGUgcGFzc3BocmFzZSB0byB0aGUgd2FsbGV0IHVzZXIga2V5LCB0byBzaWduIGNvbW1pdG1lbnQgZGF0YSBmb3IgRXRoZXJldW0gaG9wIHRyYW5zYWN0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLndhbGxldENvbnRyYWN0QWRkcmVzcyAtIFRoZSBjb250cmFjdCBhZGRyZXNzIHVzZWQgYXMgdGhlIFwidG9cIiBmaWVsZCBvZiBhIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHByZWJ1aWxkVHJhbnNhY3Rpb24ocGFyYW1zOiBQcmVidWlsZFRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0Pik6IEJsdWViaXJkPFByZWJ1aWxkVHJhbnNhY3Rpb25SZXN1bHQ+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288UHJlYnVpbGRUcmFuc2FjdGlvblJlc3VsdD4oZnVuY3Rpb24gKigpIHtcbiAgICAgIC8vIFdoaXRlbGlzdCBwYXJhbXMgdG8gYnVpbGQgdHhcbiAgICAgIGNvbnN0IHdoaXRlbGlzdGVkUGFyYW1zID0gXy5waWNrKHBhcmFtcywgc2VsZi5wcmVidWlsZFdoaXRlbGlzdGVkUGFyYW1zKCkpO1xuICAgICAgZGVidWcoJ3ByZWJ1aWxkaW5nIHRyYW5zYWN0aW9uOiAlTycsIHdoaXRlbGlzdGVkUGFyYW1zKTtcblxuICAgICAgaWYgKHBhcmFtcy5yZXFJZCkge1xuICAgICAgICBzZWxmLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocGFyYW1zLnJlcUlkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0geWllbGQgc2VsZi5iYXNlQ29pbi5nZXRFeHRyYVByZWJ1aWxkUGFyYW1zKE9iamVjdC5hc3NpZ24ocGFyYW1zLCB7IHdhbGxldDogc2VsZiB9KSk7XG4gICAgICBPYmplY3QuYXNzaWduKHdoaXRlbGlzdGVkUGFyYW1zLCBleHRyYVBhcmFtcyk7XG4gICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IHtcbiAgICAgICAgb2ZmbGluZVZlcmlmaWNhdGlvbjogcGFyYW1zLm9mZmxpbmVWZXJpZmljYXRpb24gPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgYnVpbGRRdWVyeSA9IHNlbGYuYml0Z28ucG9zdChzZWxmLmJhc2VDb2luLnVybCgnL3dhbGxldC8nICsgc2VsZi5pZCgpICsgJy90eC9idWlsZCcpKVxuICAgICAgICAucXVlcnkocXVlcnlQYXJhbXMpXG4gICAgICAgIC5zZW5kKHdoaXRlbGlzdGVkUGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgICBjb25zdCB1dHhvQ29pbiA9IHNlbGYuYmFzZUNvaW4gYXMgQWJzdHJhY3RVdHhvQ29pbjtcbiAgICAgIGNvbnN0IGJsb2NrSGVpZ2h0UXVlcnkgPSBfLmlzRnVuY3Rpb24odXR4b0NvaW4uZ2V0TGF0ZXN0QmxvY2tIZWlnaHQpID9cbiAgICAgICAgdXR4b0NvaW4uZ2V0TGF0ZXN0QmxvY2tIZWlnaHQocGFyYW1zLnJlcUlkKSA6XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgY29uc3QgcXVlcmllcyA9IFtidWlsZFF1ZXJ5LCBibG9ja0hlaWdodFF1ZXJ5XTtcbiAgICAgIGNvbnN0IFtidWlsZFJlc3BvbnNlLCBibG9ja0hlaWdodF0gPSB5aWVsZCBQcm9taXNlLmFsbChxdWVyaWVzKTtcbiAgICAgIGRlYnVnKCdwb3N0cHJvY2Vzc2luZyB0cmFuc2FjdGlvbiBwcmVidWlsZDogJU8nLCBidWlsZFJlc3BvbnNlKTtcbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChibG9ja0hlaWdodCkpIHtcbiAgICAgICAgYnVpbGRSZXNwb25zZS5ibG9ja0hlaWdodCA9IGJsb2NrSGVpZ2h0O1xuICAgICAgfVxuICAgICAgbGV0IHByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkID0geWllbGQgc2VsZi5iYXNlQ29pbi5wb3N0UHJvY2Vzc1ByZWJ1aWxkKFxuICAgICAgICBPYmplY3QuYXNzaWduKGJ1aWxkUmVzcG9uc2UsIHsgd2FsbGV0OiBzZWxmLCBidWlsZFBhcmFtczogd2hpdGVsaXN0ZWRQYXJhbXMgfSlcbiAgICAgICk7XG4gICAgICBkZWxldGUgcHJlYnVpbGQud2FsbGV0O1xuICAgICAgZGVsZXRlIHByZWJ1aWxkLmJ1aWxkUGFyYW1zO1xuICAgICAgcHJlYnVpbGQgPSBfLmV4dGVuZCh7fSwgcHJlYnVpbGQsIHsgd2FsbGV0SWQ6IHNlbGYuaWQoKSB9KTtcbiAgICAgIGlmIChzZWxmLl93YWxsZXQgJiYgc2VsZi5fd2FsbGV0LmNvaW5TcGVjaWZpYyAmJiAhcGFyYW1zLndhbGxldENvbnRyYWN0QWRkcmVzcykge1xuICAgICAgICBwcmVidWlsZCA9IF8uZXh0ZW5kKHt9LCBwcmVidWlsZCwgeyB3YWxsZXRDb250cmFjdEFkZHJlc3M6IHNlbGYuX3dhbGxldC5jb2luU3BlY2lmaWMuYmFzZUFkZHJlc3MgfSk7XG4gICAgICB9XG4gICAgICBkZWJ1ZygnZmluYWwgdHJhbnNhY3Rpb24gcHJlYnVpbGQ6ICVPJywgcHJlYnVpbGQpO1xuICAgICAgcmV0dXJuIHByZWJ1aWxkIGFzIFByZWJ1aWxkVHJhbnNhY3Rpb25SZXN1bHQ7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIGEgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHR4UHJlYnVpbGRcbiAgICogLSBba2V5Y2hhaW4gLyBrZXldIChvYmplY3QpIG9yIHBydiAoc3RyaW5nKVxuICAgKiAtIHdhbGxldFBhc3NwaHJhc2VcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBzaWduVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBXYWxsZXRTaWduVHJhbnNhY3Rpb25PcHRpb25zID0ge30sXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8U2lnbmVkVHJhbnNhY3Rpb24+XG4gICk6IEJsdWViaXJkPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFNpZ25lZFRyYW5zYWN0aW9uPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgdHhQcmVidWlsZCA9IHBhcmFtcy50eFByZWJ1aWxkO1xuICAgICAgaWYgKCF0eFByZWJ1aWxkIHx8IHR5cGVvZiB0eFByZWJ1aWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4UHJlYnVpbGQgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXNpZ24gPSB5aWVsZCBzZWxmLmJhc2VDb2luLnByZXNpZ25UcmFuc2FjdGlvbihwYXJhbXMpO1xuICAgICAgY29uc3QgdXNlclBydiA9IHNlbGYuZ2V0VXNlclBydihwcmVzaWduKTtcbiAgICAgIGNvbnN0IHNpZ25pbmdQYXJhbXMgPSBfLmV4dGVuZCh7fSwgcHJlc2lnbiwgeyB0eFByZWJ1aWxkOiB0eFByZWJ1aWxkLCBwcnY6IHVzZXJQcnYgfSk7XG4gICAgICByZXR1cm4gc2VsZi5iYXNlQ29pbi5zaWduVHJhbnNhY3Rpb24oc2lnbmluZ1BhcmFtcyk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIgcHJpdmF0ZSBrZXkgZnJvbSBlaXRoZXIgYSBkZXJpdmF0aW9uIG9yIGFuIGVuY3J5cHRlZCBrZXljaGFpblxuICAgKiBAcGFyYW0gW3BhcmFtcy5rZXljaGFpbiAvIHBhcmFtcy5rZXldIChvYmplY3QpIG9yIHBhcmFtcy5wcnYgKHN0cmluZylcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIChzdHJpbmcpXG4gICAqL1xuICBnZXRVc2VyUHJ2KHBhcmFtczogR2V0VXNlclBydk9wdGlvbnMgPSB7fSk6IHN0cmluZyB7XG4gICAgY29uc3QgdXNlcktleWNoYWluID0gcGFyYW1zLmtleWNoYWluIHx8IHBhcmFtcy5rZXk7XG4gICAgbGV0IHVzZXJQcnYgPSBwYXJhbXMucHJ2O1xuICAgIGlmICh1c2VyUHJ2ICYmIHR5cGVvZiB1c2VyUHJ2ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcnYgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAodXNlclBydiAmJiBwYXJhbXMuY29sZERlcml2YXRpb25TZWVkKSB7XG4gICAgICAvLyB0aGUgZGVyaXZhdGlvbiBvbmx5IG1ha2VzIHNlbnNlIHdoZW4gYSBrZXkgYWxyZWFkeSBleGlzdHNcbiAgICAgIGNvbnN0IGRlcml2YXRpb24gPSB0aGlzLmJhc2VDb2luLmRlcml2ZUtleVdpdGhTZWVkKHsga2V5OiB1c2VyUHJ2LCBzZWVkOiBwYXJhbXMuY29sZERlcml2YXRpb25TZWVkIH0pO1xuICAgICAgdXNlclBydiA9IGRlcml2YXRpb24ua2V5O1xuICAgIH0gZWxzZSBpZiAoIXVzZXJQcnYpIHtcbiAgICAgIGlmICghdXNlcktleWNoYWluIHx8IHR5cGVvZiB1c2VyS2V5Y2hhaW4gIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5Y2hhaW4gbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVzZXJFbmNyeXB0ZWRQcnYgPSB1c2VyS2V5Y2hhaW4uZW5jcnlwdGVkUHJ2O1xuICAgICAgaWYgKCF1c2VyRW5jcnlwdGVkUHJ2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5Y2hhaW4gZG9lcyBub3QgaGF2ZSBwcm9wZXJ0eSBlbmNyeXB0ZWRQcnYnKTtcbiAgICAgIH1cbiAgICAgIGlmICghcGFyYW1zLndhbGxldFBhc3NwaHJhc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3YWxsZXRQYXNzcGhyYXNlIHByb3BlcnR5IG1pc3NpbmcnKTtcbiAgICAgIH1cblxuICAgICAgdXNlclBydiA9IHRoaXMuYml0Z28uZGVjcnlwdCh7IGlucHV0OiB1c2VyRW5jcnlwdGVkUHJ2LCBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgfSk7XG4gICAgfVxuICAgIHJldHVybiB1c2VyUHJ2O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHRyYW5zYWN0aW9uIHByZWJ1aWxkIGZyb20gQml0R28sIHZhbGlkYXRlIGl0LCBhbmQgdGhlbiBkZWNyeXB0IHRoZSB1c2VyIGtleSBhbmQgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHByZWJ1aWxkQW5kU2lnblRyYW5zYWN0aW9uKHBhcmFtczogUHJlYnVpbGRBbmRTaWduVHJhbnNhY3Rpb25PcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFNpZ25lZFRyYW5zYWN0aW9uPik6IEJsdWViaXJkPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFNpZ25lZFRyYW5zYWN0aW9uPihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKHBhcmFtcy5wcmVidWlsZFR4ICYmIHBhcmFtcy5yZWNpcGllbnRzKSB7XG4gICAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoJ09ubHkgb25lIG9mIHByZWJ1aWxkVHggYW5kIHJlY2lwaWVudHMgbWF5IGJlIHNwZWNpZmllZCcpO1xuICAgICAgICBlcnJvci5jb2RlID0gJ2JvdGhfcHJlYnVpbGR0eF9hbmRfcmVjaXBpZW50c19zcGVjaWZpZWQnO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5yZWNpcGllbnRzICYmICFBcnJheS5pc0FycmF5KHBhcmFtcy5yZWNpcGllbnRzKSkge1xuICAgICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKCdleHBlY3RpbmcgcmVjaXBpZW50cyBhcnJheScpO1xuICAgICAgICBlcnJvci5jb2RlID0gJ3JlY2lwaWVudHNfbm90X2FycmF5JztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzQXJyYXkoc2VsZi5fcGVybWlzc2lvbnMpICYmICFzZWxmLl9wZXJtaXNzaW9ucy5pbmNsdWRlcygnc3BlbmQnKSkge1xuICAgICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKCdubyBzcGVuZCBwZXJtaXNzaW9uIG9uIHRoaXMgd2FsbGV0Jyk7XG4gICAgICAgIGVycm9yLmNvZGUgPSAndXNlcl9ub3RfYWxsb3dlZF90b19zcGVuZF9mcm9tX3dhbGxldCc7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuXG4gICAgICAvLyBjYWxsIHByZWJ1aWxkVHJhbnNhY3Rpb24gYW5kIGtleWNoYWlucy1nZXQgaW4gcGFyYWxsZWxcbiAgICAgIC8vIHRoZSBwcmVidWlsZCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBwcm92aWRpbmcgYW4gZXhwbGljaXQgdHhcbiAgICAgIGNvbnN0IHR4UHJlYnVpbGRRdWVyeSA9IHBhcmFtcy5wcmVidWlsZFR4ID8gUHJvbWlzZS5yZXNvbHZlKHBhcmFtcy5wcmVidWlsZFR4KSA6IHNlbGYucHJlYnVpbGRUcmFuc2FjdGlvbihwYXJhbXMpO1xuXG4gICAgICAvLyByZXRyaWV2ZSBvdXIga2V5Y2hhaW5zIG5lZWRlZCB0byBydW4gdGhlIHByZWJ1aWxkIC0gc29tZSBjb2lucyB1c2UgYWxsIHB1YnNcbiAgICAgIGNvbnN0IGtleWNoYWlucyA9IHlpZWxkIHNlbGYuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuZ2V0S2V5c0ZvclNpZ25pbmcoeyB3YWxsZXQ6IHNlbGYsIHJlcUlkOiBwYXJhbXMucmVxSWQgfSk7XG5cbiAgICAgIGNvbnN0IHR4UHJlYnVpbGQgPSB5aWVsZCB0eFByZWJ1aWxkUXVlcnk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHZlcmlmaWNhdGlvblBhcmFtcyA9IF8ucGljayhwYXJhbXMudmVyaWZpY2F0aW9uIHx8IHt9LCBbJ2Rpc2FibGVOZXR3b3JraW5nJywgJ2tleWNoYWlucycsICdhZGRyZXNzZXMnXSk7XG4gICAgICAgIHlpZWxkIHNlbGYuYmFzZUNvaW4udmVyaWZ5VHJhbnNhY3Rpb24oe1xuICAgICAgICAgIHR4UGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgdHhQcmVidWlsZCxcbiAgICAgICAgICB3YWxsZXQ6IHNlbGYsXG4gICAgICAgICAgdmVyaWZpY2F0aW9uOiB2ZXJpZmljYXRpb25QYXJhbXMsXG4gICAgICAgICAgcmVxSWQ6IHBhcmFtcy5yZXFJZCxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRlYnVnKCdUcmFuc2FjdGlvbiBwcmVidWlsZCBmYWlsdXJlOicsIGUpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCd0cmFuc2FjdGlvbiBwcmVidWlsZCBmYWlsZWQgbG9jYWwgdmFsaWRhdGlvbjonKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cblxuICAgICAgLy8gcGFzcyBvdXIgdGhyZWUga2V5c1xuICAgICAgY29uc3Qgc2lnbmluZ1BhcmFtcyA9IF8uZXh0ZW5kKHt9LCBwYXJhbXMsIHtcbiAgICAgICAgdHhQcmVidWlsZDogdHhQcmVidWlsZCxcbiAgICAgICAgd2FsbGV0OiB7XG4gICAgICAgICAgLy8gdGhpcyBpcyB0aGUgdmVyc2lvbiBvZiB0aGUgbXVsdGlzaWcgYWRkcmVzcyBhdCB3YWxsZXQgY3JlYXRpb24gdGltZVxuICAgICAgICAgIGFkZHJlc3NWZXJzaW9uOiBzZWxmLl93YWxsZXQuY29pblNwZWNpZmljLmFkZHJlc3NWZXJzaW9uXG4gICAgICAgIH0sXG4gICAgICAgIGtleWNoYWluOiBrZXljaGFpbnNbMF0sXG4gICAgICAgIGJhY2t1cEtleWNoYWluOiAoa2V5Y2hhaW5zLmxlbmd0aCA+IDEpID8ga2V5Y2hhaW5zWzFdIDogbnVsbCxcbiAgICAgICAgYml0Z29LZXljaGFpbjogKGtleWNoYWlucy5sZW5ndGggPiAyKSA/IGtleWNoYWluc1syXSA6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHlpZWxkIHNlbGYuc2lnblRyYW5zYWN0aW9uKHNpZ25pbmdQYXJhbXMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2luc3VmZmljaWVudCBmdW5kcycpKSB7XG4gICAgICAgICAgZXJyb3IuY29kZSA9ICdpbnN1ZmZpY2llbnRfZnVuZHMnO1xuICAgICAgICAgIGVycm9yLndhbGxldEJhbGFuY2VzID0ge1xuICAgICAgICAgICAgYmFsYW5jZVN0cmluZzogc2VsZi5iYWxhbmNlU3RyaW5nKCksXG4gICAgICAgICAgICBjb25maXJtZWRCYWxhbmNlU3RyaW5nOiBzZWxmLmNvbmZpcm1lZEJhbGFuY2VTdHJpbmcoKSxcbiAgICAgICAgICAgIHNwZW5kYWJsZUJhbGFuY2VTdHJpbmc6IHNlbGYuc3BlbmRhYmxlQmFsYW5jZVN0cmluZygpLFxuICAgICAgICAgICAgYmFsYW5jZTogc2VsZi5iYWxhbmNlKCksXG4gICAgICAgICAgICBjb25maXJtZWRCYWxhbmNlOiBzZWxmLmNvbmZpcm1lZEJhbGFuY2UoKSxcbiAgICAgICAgICAgIHNwZW5kYWJsZUJhbGFuY2U6IHNlbGYuc3BlbmRhYmxlQmFsYW5jZSgpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBlcnJvci50eFBhcmFtcyA9IF8ub21pdChwYXJhbXMsIFsna2V5Y2hhaW4nLCAncHJ2JywgJ3Bhc3NwaHJhc2UnLCAnd2FsbGV0UGFzc3BocmFzZScsICdrZXknXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlbGVyYXRlIGEgdHJhbnNhY3Rpb24ncyBjb25maXJtYXRpb24gdXNpbmcgQ2hpbGQtUGF5cy1Gb3ItUGFyZW50IChDUEZQKVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgYWNjZWxlcmF0ZVRyYW5zYWN0aW9uKHBhcmFtczogQWNjZWxlcmF0ZVRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICAvLyBUT0RPKEJHLTkzNDkpOiBjaGFuZ2UgdGhlIGxhc3QgY2hlY2sgdG8gPiAwIGFuZCB0aGUgZXJyb3IgbWVzc2FnZSBvbmNlIHBsYXRmb3JtIGFsbG93cyBtdWx0aXBsZSB0cmFuc2FjdGlvbnMgdG9cbiAgICAgIC8vICAgICAgICAgICAgICAgIGJlIGJ1bXBlZCBpbiB0aGUgc2FtZSBDUEZQIHRyYW5zYWN0aW9uXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMuY3BmcFR4SWRzKSB8fCAhQXJyYXkuaXNBcnJheShwYXJhbXMuY3BmcFR4SWRzKSB8fCBwYXJhbXMuY3BmcFR4SWRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKCdleHBlY3RpbmcgY3BmcFR4SWRzIHRvIGJlIGFuIGFycmF5IG9mIGxlbmd0aCAxJyk7XG4gICAgICAgIGVycm9yLmNvZGUgPSAnY3BmcHR4aWRzX25vdF9hcnJheSc7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMuY3BmcEZlZVJhdGUpKSB7XG4gICAgICAgIGlmIChwYXJhbXMubm9DcGZwRmVlUmF0ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoJ2NwZnBGZWVSYXRlIG11c3QgYmUgc2V0IHVubGVzcyBub0NwZnBGZWVSYXRlIGlzIHNldCcpO1xuICAgICAgICAgIGVycm9yLmNvZGUgPSAnY3BmcGZlZXJhdGVfbm90X3NldCc7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghXy5pc0ludGVnZXIocGFyYW1zLmNwZnBGZWVSYXRlKSB8fCBwYXJhbXMuY3BmcEZlZVJhdGUgPCAwKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcignY3BmcEZlZVJhdGUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICAgICAgZXJyb3IuY29kZSA9ICdjcGZwZmVlcmF0ZV9ub3Rfbm9ubmVnYXRpdmVfaW50ZWdlcic7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLm1heEZlZSkpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5ub01heEZlZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoJ21heEZlZSBtdXN0IGJlIHNldCB1bmxlc3Mgbm9NYXhGZWUgaXMgc2V0Jyk7XG4gICAgICAgICAgZXJyb3IuY29kZSA9ICdtYXhmZWVfbm90X3NldCc7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghXy5pc0ludGVnZXIocGFyYW1zLm1heEZlZSkgfHwgcGFyYW1zLm1heEZlZSA8IDApIHtcbiAgICAgICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKCdtYXhGZWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICAgICAgZXJyb3IuY29kZSA9ICdtYXhmZWVfbm90X25vbm5lZ2F0aXZlX2ludGVnZXInO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMucmVjaXBpZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMucmVjaXBpZW50cykgfHwgcGFyYW1zLnJlY2lwaWVudHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHZhbHVlIGZvciAncmVjaXBpZW50cyc6IG11c3QgYmUgZW1wdHkgYXJyYXkgd2hlbiBzZXRgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwYXJhbXMucmVjaXBpZW50cyA9IFtdO1xuXG4gICAgICAvLyBXZSBtdXN0IHBhc3MgdGhlIGJ1aWxkIHBhcmFtcyB0aHJvdWdoIHRvIHN1Ym1pdCBpbiBjYXNlIHRoZSBDUEZQIHR4IGV2ZXIgaGFzIHRvIGJlIHJlYnVpbHQuXG4gICAgICBjb25zdCBzdWJtaXRQYXJhbXMgPSBPYmplY3QuYXNzaWduKHBhcmFtcywgeWllbGQgc2VsZi5wcmVidWlsZEFuZFNpZ25UcmFuc2FjdGlvbihwYXJhbXMpKTtcbiAgICAgIGRlbGV0ZSBzdWJtaXRQYXJhbXMud2FsbGV0O1xuICAgICAgcmV0dXJuIHlpZWxkIHNlbGYuc3VibWl0VHJhbnNhY3Rpb24oc3VibWl0UGFyYW1zKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1Ym1pdCBhIGhhbGYtc2lnbmVkIHRyYW5zYWN0aW9uIHRvIEJpdEdvXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSB0eEhleDogdHJhbnNhY3Rpb24gaGV4IHRvIHN1Ym1pdFxuICAgKiAtIGhhbGZTaWduZWQ6IG9iamVjdCBjb250YWluaW5nIHRyYW5zYWN0aW9uICh0eEhleCBvciB0eEJhc2U2NCkgdG8gc3VibWl0XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgc3VibWl0VHJhbnNhY3Rpb24ocGFyYW1zOiBTdWJtaXRUcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ290cCcsICd0eEhleCddLCBjYWxsYmFjayk7XG4gICAgY29uc3QgaGFzVHhIZXggPSAhIXBhcmFtcy50eEhleDtcbiAgICBjb25zdCBoYXNIYWxmU2lnbmVkID0gISFwYXJhbXMuaGFsZlNpZ25lZDtcblxuICAgIGlmICgoaGFzVHhIZXggJiYgaGFzSGFsZlNpZ25lZCkgfHwgKCFoYXNUeEhleCAmJiAhaGFzSGFsZlNpZ25lZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzdXBwbHkgZWl0aGVyIHR4SGV4IG9yIGhhbGZTaWduZWQsIGJ1dCBub3QgYm90aCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyB0aGlzLmlkKCkgKyAnL3R4L3NlbmQnKSlcbiAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgY29pbnMgdG8gYSByZWNpcGllbnRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmFkZHJlc3MgLSB0aGUgZGVzdGluYXRpb24gYWRkcmVzc1xuICAgKiBAcGFyYW0gcGFyYW1zLmFtb3VudCAtIHRoZSBhbW91bnQgaW4gc2F0b3NoaXMvd2VpL2Jhc2UgdmFsdWUgdG8gYmUgc2VudFxuICAgKiBAcGFyYW0gcGFyYW1zLm1lc3NhZ2UgLSBvcHRpb25hbCBtZXNzYWdlIHRvIGF0dGFjaCB0byB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEgLSBbRXRoZXJldW0gU3BlY2lmaWNdIG9wdGlvbmFsIGRhdGEgdG8gcGFzcyB0byB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgLSB0aGUgcGFzc3BocmFzZSB0byBiZSB1c2VkIHRvIGRlY3J5cHQgdGhlIHVzZXIga2V5IG9uIHRoaXMgd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2IC0gdGhlIHByaXZhdGUga2V5IGluIHN0cmluZyBmb3JtLCBpZiB3YWxsZXRQYXNzcGhyYXNlIGlzIG5vdCBhdmFpbGFibGVcbiAgICogQHBhcmFtIHBhcmFtcy5taW5Db25maXJtcyAtIHRoZSBtaW5pbXVtIGNvbmZpcm1hdGlvbiB0aHJlc2hvbGQgZm9yIGlucHV0c1xuICAgKiBAcGFyYW0gcGFyYW1zLmVuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZSAtIHdoZXRoZXIgdG8gZW5mb3JjZSBtaW5Db25maXJtcyBmb3IgY2hhbmdlIGlucHV0c1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBzZW5kKHBhcmFtczogU2VuZE9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnYWRkcmVzcyddLCBbJ21lc3NhZ2UnLCAnZGF0YSddLCBjYWxsYmFjayk7XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMuYW1vdW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBhbW91bnQnKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMuYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgYW1vdW50Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgY29pbiA9IHRoaXMuYmFzZUNvaW47XG5cbiAgICBjb25zdCBhbW91bnQgPSBuZXcgQmlnTnVtYmVyKHBhcmFtcy5hbW91bnQpO1xuICAgIGlmIChhbW91bnQuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGFtb3VudCAtIHBvc2l0aXZlIG51bWJlciBncmVhdGVyIHRoYW4gemVybyBvciBudW1lcmljIHN0cmluZyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGlmICghY29pbi52YWx1ZWxlc3NUcmFuc2ZlckFsbG93ZWQoKSAmJiBhbW91bnQuaXNaZXJvKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgYW1vdW50IC0gcG9zaXRpdmUgbnVtYmVyIGdyZWF0ZXIgdGhhbiB6ZXJvIG9yIG51bWVyaWMgc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVjaXBpZW50czogU2VuZE1hbnlPcHRpb25zWydyZWNpcGllbnRzJ10gPSBbe1xuICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICBhbW91bnQ6IHBhcmFtcy5hbW91bnQsXG4gICAgfV07XG5cbiAgICBpZiAocGFyYW1zLmRhdGEgJiYgY29pbi50cmFuc2FjdGlvbkRhdGFBbGxvd2VkKCkpIHtcbiAgICAgIHJlY2lwaWVudHNbMF0uZGF0YSA9IHBhcmFtcy5kYXRhO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbmRNYW55T3B0aW9uczogU2VuZE1hbnlPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLCB7IHJlY2lwaWVudHMgfSk7XG4gICAgcmV0dXJuIHRoaXMuc2VuZE1hbnkoc2VuZE1hbnlPcHRpb25zKS5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIG1vbmV5IHRvIG11bHRpcGxlIHJlY2lwaWVudHNcbiAgICogMS4gR2V0cyB0aGUgdXNlciBrZXljaGFpbiBieSBjaGVja2luZyB0aGUgd2FsbGV0IGZvciBhIGtleSB3aGljaCBoYXMgYW4gZW5jcnlwdGVkIHBydlxuICAgKiAyLiBEZWNyeXB0cyB1c2VyIGtleVxuICAgKiAzLiBDcmVhdGVzIHRoZSB0cmFuc2FjdGlvbiB3aXRoIGRlZmF1bHQgZmVlXG4gICAqIDQuIFNpZ25zIHRyYW5zYWN0aW9uIHdpdGggZGVjcnlwdGVkIHVzZXIga2V5XG4gICAqIDUuIFNlbmRzIHRoZSB0cmFuc2FjdGlvbiB0byBCaXRHb1xuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAqIEBwYXJhbSB7e2FkZHJlc3M6IHN0cmluZywgYW1vdW50OiBzdHJpbmd9fSBwYXJhbXMucmVjaXBpZW50cyAtIGxpc3Qgb2YgcmVjaXBpZW50cyBhbmQgbmVjZXNzYXJ5IHJlY2lwaWVudCBpbmZvcm1hdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm51bUJsb2NrcyAtIEVzdGltYXRlcyB0aGUgYXBwcm94aW1hdGUgZmVlIHBlciBraWxvYnl0ZSBuZWNlc3NhcnkgZm9yIGEgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHdpdGhpbiBudW1CbG9ja3MgYmxvY2tzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMuZmVlUmF0ZSAtIHRoZSBkZXNpcmVkIGZlZVJhdGUgZm9yIHRoZSB0cmFuc2FjdGlvbiBpbiBzYXRvdGhpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1heEZlZVJhdGUgLSB1cHBlciBsaW1pdCBmb3IgZmVlUmF0ZSBpbiBzYXRvc2hpcy9rQlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLm1pbkNvbmZpcm1zIC0gYWxsIHNlbGVjdGVkIHVuc3BlbnRzIHdpbGwgaGF2ZSBhdCBsZWFzdCB0aGlzIG1hbnkgY29uZmlybWF0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5lbmZvcmNlTWluQ29uZmlybXNGb3JDaGFuZ2UgLSBFbmZvcmNlcyBtaW5Db25maXJtcyBvbiBjaGFuZ2UgaW5wdXRzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMudGFyZ2V0V2FsbGV0VW5zcGVudHMgLSBUaGUgZGVzaXJlZCBjb3VudCBvZiB1bnNwZW50cyBpbiB0aGUgd2FsbGV0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMubWVzc2FnZSAtIG9wdGlvbmFsIG1lc3NhZ2UgdG8gYXR0YWNoIHRvIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWluVmFsdWUgLSBJZ25vcmUgdW5zcGVudHMgc21hbGxlciB0aGFuIHRoaXMgYW1vdW50IG9mIHNhdG9zaGlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4VmFsdWUgLSBJZ25vcmUgdW5zcGVudHMgbGFyZ2VyIHRoYW4gdGhpcyBhbW91bnQgb2Ygc2F0b3NoaXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5zZXF1ZW5jZUlkIC0gVGhlIHNlcXVlbmNlIElEIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmxhc3RMZWRnZXJTZXF1ZW5jZSAtIEFic29sdXRlIG1heCBsZWRnZXIgdGhlIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhY2NlcHRlZCBpbiwgd2hlcmVhZnRlciBpdCB3aWxsIGJlIHJlamVjdGVkLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmxlZGdlclNlcXVlbmNlRGVsdGEgLSBSZWxhdGl2ZSBsZWRnZXIgaGVpZ2h0IChpbiByZWxhdGlvbiB0byB0aGUgY3VycmVudCBsZWRnZXIpIHRoYXQgdGhlIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhY2NlcHRlZCBpbiwgd2hlcmVhZnRlciBpdCB3aWxsIGJlIHJlamVjdGVkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFyYW1zLmdhc1ByaWNlIC0gQ3VzdG9tIGdhcyBwcmljZSB0byBiZSB1c2VkIGZvciBzZW5kaW5nIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBhcmFtcy5ub1NwbGl0Q2hhbmdlIC0gU2V0IHRvIHRydWUgdG8gZGlzYWJsZSBhdXRvbWF0aWMgY2hhbmdlIHNwbGl0dGluZyBmb3IgcHVycG9zZXMgb2YgdW5zcGVudCBtYW5hZ2VtZW50XG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcy51bnNwZW50cyAtIFRoZSB1bnNwZW50cyB0byB1c2UgaW4gdGhlIHRyYW5zYWN0aW9uLiBFYWNoIHVuc3BlbnQgc2hvdWxkIGJlIGluIHRoZSBmb3JtIHByZXZUeElkOm5PdXRwdXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5jb21tZW50IC0gQW55IGFkZGl0aW9uYWwgY29tbWVudCB0byBhdHRhY2ggdG8gdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMub3RwIC0gVHdvIGZhY3RvciBhdXRoIGNvZGUgdG8gZW5hYmxlIHNlbmRpbmcgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMuY2hhbmdlQWRkcmVzcyAtIFNwZWNpZmllcyB0aGUgZGVzdGluYXRpb24gb2YgdGhlIGNoYW5nZSBvdXRwdXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBwYXJhbXMuaW5zdGFudCAtIFNlbmQgdGhpcyB0cmFuc2FjdGlvbiB1c2luZyBjb2luLXNwZWNpZmljIGluc3RhbnQgc2VuZGluZyBtZXRob2QgKGlmIGF2YWlsYWJsZSlcbiAgICogQHBhcmFtIHt7dmFsdWU6IFN0cmluZywgdHlwZTogU3RyaW5nfX0gcGFyYW1zLm1lbW8gLSBNZW1vIHRvIHVzZSBpbiB0cmFuc2FjdGlvbiAoc3VwcG9ydGVkIGJ5IFN0ZWxsYXIpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMudHlwZSAtIFR5cGUgb2YgdGhlIHRyYW5zYWN0aW9uIChlLmcuIHRydXN0bGluZSlcbiAgICogQHBhcmFtIHt7dG9rZW46IHBhcmFtcywgYWN0aW9uOiBTdHJpbmcsIGxpbWl0OiBTdHJpbmd9W119IG9wdGlvbnMudHJ1c3RsaW5lcyAtIEFycmF5IG9mIHRydXN0bGluZXMgdG8gbWFuYWdlIChzdXBwb3J0ZWQgYnkgU3RlbGxhcilcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgc2VuZE1hbnkocGFyYW1zOiBTZW5kTWFueU9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsnY29tbWVudCcsICdvdHAnXSwgY2FsbGJhY2spO1xuICAgICAgZGVidWcoJ3NlbmRNYW55IGNhbGxlZCcpO1xuICAgICAgY29uc3QgcmVxSWQgPSBwYXJhbXMucmVxSWQgfHwgbmV3IFJlcXVlc3RUcmFjZXIoKTtcbiAgICAgIHBhcmFtcy5yZXFJZCA9IHJlcUlkO1xuICAgICAgY29uc3QgY29pbiA9IHNlbGYuYmFzZUNvaW47XG4gICAgICBpZiAoXy5pc09iamVjdChwYXJhbXMucmVjaXBpZW50cykpIHtcbiAgICAgICAgcGFyYW1zLnJlY2lwaWVudHMubWFwKGZ1bmN0aW9uKHJlY2lwaWVudCkge1xuICAgICAgICAgIGNvbnN0IGFtb3VudCA9IG5ldyBCaWdOdW1iZXIocmVjaXBpZW50LmFtb3VudCk7XG4gICAgICAgICAgaWYgKGFtb3VudC5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgYW1vdW50IC0gcG9zaXRpdmUgbnVtYmVyIGdyZWF0ZXIgdGhhbiB6ZXJvIG9yIG51bWVyaWMgc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY29pbi52YWx1ZWxlc3NUcmFuc2ZlckFsbG93ZWQoKSAmJiBhbW91bnQuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgYW1vdW50IC0gcG9zaXRpdmUgbnVtYmVyIGdyZWF0ZXIgdGhhbiB6ZXJvIG9yIG51bWVyaWMgc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGFsZlNpZ25lZFRyYW5zYWN0aW9uID0geWllbGQgc2VsZi5wcmVidWlsZEFuZFNpZ25UcmFuc2FjdGlvbihwYXJhbXMpO1xuICAgICAgY29uc3Qgc2VsZWN0UGFyYW1zID0gXy5waWNrKHBhcmFtcywgW1xuICAgICAgICAncmVjaXBpZW50cycsICdudW1CbG9ja3MnLCAnZmVlUmF0ZScsICdtYXhGZWVSYXRlJywgJ21pbkNvbmZpcm1zJyxcbiAgICAgICAgJ2VuZm9yY2VNaW5Db25maXJtc0ZvckNoYW5nZScsICd0YXJnZXRXYWxsZXRVbnNwZW50cycsXG4gICAgICAgICdtZXNzYWdlJywgJ21pblZhbHVlJywgJ21heFZhbHVlJywgJ3NlcXVlbmNlSWQnLFxuICAgICAgICAnbGFzdExlZGdlclNlcXVlbmNlJywgJ2xlZGdlclNlcXVlbmNlRGVsdGEnLCAnZ2FzUHJpY2UnLFxuICAgICAgICAnbm9TcGxpdENoYW5nZScsICd1bnNwZW50cycsICdjb21tZW50JywgJ290cCcsICdjaGFuZ2VBZGRyZXNzJyxcbiAgICAgICAgJ2luc3RhbnQnLCAnbWVtbycsICd0eXBlJywgJ3RydXN0bGluZXMnLFxuICAgICAgXSk7XG4gICAgICBjb25zdCBmaW5hbFR4UGFyYW1zID0gXy5leHRlbmQoe30sIGhhbGZTaWduZWRUcmFuc2FjdGlvbiwgc2VsZWN0UGFyYW1zKTtcbiAgICAgIHNlbGYuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgICByZXR1cm4gc2VsZi5iaXRnby5wb3N0KHNlbGYudXJsKCcvdHgvc2VuZCcpKVxuICAgICAgICAuc2VuZChmaW5hbFR4UGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvdmVyIGFuIHVuc3VwcG9ydGVkIHRva2VuIGZyb20gYSBCaXRHbyBtdWx0aXNpZyB3YWxsZXRcbiAgICogcGFyYW1zIGFyZSB2YWxpZGF0ZWQgaW4gRXRoLnByb3RvdHlwZS5yZWNvdmVyVG9rZW5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzIHRoZSBjb250cmFjdCBhZGRyZXNzIG9mIHRoZSB1bnN1cHBvcnRlZCB0b2tlblxuICAgKiBAcGFyYW0gcGFyYW1zLnJlY2lwaWVudCB0aGUgZGVzdGluYXRpb24gYWRkcmVzcyByZWNvdmVyZWQgdG9rZW5zIHNob3VsZCBiZSBzZW50IHRvXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSB0aGUgd2FsbGV0IHBhc3NwaHJhc2VcbiAgICogQHBhcmFtIHBhcmFtcy5wcnYgdGhlIHhwcnZcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICByZWNvdmVyVG9rZW4ocGFyYW1zOiBSZWNvdmVyVG9rZW5PcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGlmIChzZWxmLmJhc2VDb2luLmdldEZhbWlseSgpICE9PSAnZXRoJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rva2VuIHJlY292ZXJ5IG9ubHkgc3VwcG9ydGVkIGZvciBldGggd2FsbGV0cycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHRva2VuQ29udHJhY3RBZGRyZXNzLFxuICAgICAgICByZWNpcGllbnQsXG4gICAgICB9ID0gcGFyYW1zO1xuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh0b2tlbkNvbnRyYWN0QWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHN0cmluZyBwYXJhbWV0ZXIgdG9rZW5Db250cmFjdEFkZHJlc3MnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocmVjaXBpZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgc3RyaW5nIHBhcmFtZXRlciByZWNpcGllbnQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVjb3ZlclRva2VuT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyB0b2tlbkNvbnRyYWN0QWRkcmVzcywgcmVjaXBpZW50IH0sIHBhcmFtcywgeyB3YWxsZXQ6IHNlbGYgfSk7XG4gICAgICByZXR1cm4gKHNlbGYuYmFzZUNvaW4gYXMgRXRoKS5yZWNvdmVyVG9rZW4ocmVjb3ZlclRva2VuT3B0aW9ucyk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdHJhbnNhY3Rpb24gbWV0YWRhdGEgZm9yIHRoZSBvbGRlc3QgdHJhbnNhY3Rpb24gdGhhdCBpcyBzdGlsbCBwZW5kaW5nIG9yIGF0dGVtcHRlZFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3Qgd2l0aCB0eGlkLCB3YWxsZXRJZCwgdHgsIGFuZCBmZWUgKGlmIHN1cHBvcnRlZCBmb3IgY29pbilcbiAgICovXG4gIGdldEZpcnN0UGVuZGluZ1RyYW5zYWN0aW9uKHBhcmFtczoge30gPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiBpbnRlcm5hbC5nZXRGaXJzdFBlbmRpbmdUcmFuc2FjdGlvbih7IHdhbGxldElkOiB0aGlzLmlkKCkgfSwgdGhpcy5iYXNlQ29pbiwgdGhpcy5iaXRnbykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBmZWUgb24gdGhlIHBlbmRpbmcgdHJhbnNhY3Rpb24gdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gdHhpZCB0byB0aGUgZ2l2ZW4gbmV3IGZlZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMudHhpZCBUaGUgdHJhbnNhY3Rpb24gSWQgY29ycmVzcG9uZGluZyB0byB0aGUgdHJhbnNhY3Rpb24gd2hvc2UgZmVlIGlzIHRvIGJlIGNoYW5nZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5mZWUgVGhlIG5ldyBmZWUgdG8gYXBwbHkgdG8gdGhlIGRlbm90ZWQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0cmFuc2FjdGlvbiBJRCBvZiB0aGUgbmV3IHRyYW5zYWN0aW9uIHRoYXQgY29udGFpbnMgdGhlIG5ldyBmZWUgcmF0ZVxuICAgKi9cbiAgY2hhbmdlRmVlKHBhcmFtczogQ2hhbmdlRmVlT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3R4aWQnLCAnZmVlJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgICAgIHJldHVybiBzZWxmLmJpdGdvLnBvc3Qoc2VsZi5iYXNlQ29pbi51cmwoJy93YWxsZXQvJyArIHNlbGYuaWQoKSArICcvdHgvY2hhbmdlRmVlJykpXG4gICAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggaW5mbyBmcm9tIG1lcmNoYW50IHNlcnZlclxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoZSBwYXJhbXMgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMudXJsIFRoZSBVcmwgdG8gcmV0cmlldmUgaW5mbyBmcm9tXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgaW5mbyByZXR1cm5lZCBmcm9tIHRoZSBtZXJjaGFudCBzZXJ2ZXJcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGdldFBheW1lbnRJbmZvKHBhcmFtczogeyB1cmw/OiBzdHJpbmc7IH0gPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqY29HZXRQYXltZW50SW5mbygpIHtcbiAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndXJsJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgICAgIHJldHVybiBzZWxmLmJpdGdvLmdldChzZWxmLnVybCgnL3BheW1lbnRJbmZvJykpXG4gICAgICAgIC5xdWVyeShwYXJhbXMpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQganNvbiBwYXltZW50IHJlc3BvbnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhlIHBhcmFtcyBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5wYXltZW50VXJsIC0gVGhlIHVybCB0byBzZW5kIHRoZSBmdWxseSBzaWduZWQgdHJhbnNhY3Rpb24gdG9cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy50eEhleCAtIFRoZSB0cmFuc2FjdGlvbiBoZXggb2YgdGhlIHBheW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5tZW1vIHtTdHJpbmd9IC0gQSBtZW1vIHN1cHBsaWVkIGJ5IHRoZSBtZXJjaGFudCwgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgdHJhbnNmZXIgYXMgdGhlIGNvbW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5leHBpcmVzIHtTdHJpbmd9IC0gSVNPIERhdGUgZm9ybWF0IG9mIHdoZW4gdGhlIHBheW1lbnQgcmVxdWVzdCBleHBpcmVzXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgaW5mbyByZXR1cm5lZCBmcm9tIHRoZSBtZXJjaGFudCBzZXJ2ZXIgUGF5bWVudCBBY2tcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHNlbmRQYXltZW50UmVzcG9uc2UocGFyYW1zOiB7fSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLnVybCgnL3NlbmRQYXltZW50JykpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwb2xpY3kgcnVsZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMuY29uZGl0aW9uIGNvbmRpdGlvbiBvYmplY3RcbiAgICogQHBhcmFtIHBhcmFtcy5hY3Rpb24gYWN0aW9uIG9iamVjdFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBjcmVhdGVQb2xpY3lSdWxlKHBhcmFtczogQ3JlYXRlUG9saWN5UnVsZU9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCcsICd0eXBlJ10sIFsnbWVzc2FnZSddLCBjYWxsYmFjayk7XG5cbiAgICAgIGlmICghXy5pc09iamVjdChwYXJhbXMuY29uZGl0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcGFyYW1ldGVyOiBjb25kaXRpb25zIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zLmFjdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBhcmFtZXRlcjogYWN0aW9uIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5iaXRnby5wb3N0KHNlbGYudXJsKCcvcG9saWN5L3J1bGUnKSlcbiAgICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBwb2xpY3kgcnVsZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMuY29uZGl0aW9uIGNvbmRpdGlvbiBvYmplY3RcbiAgICogQHBhcmFtIHBhcmFtcy5hY3Rpb24gYWN0aW9uIG9iamVjdFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBzZXRQb2xpY3lSdWxlKHBhcmFtczogYW55ID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaWQnLCAndHlwZSddLCBbJ21lc3NhZ2UnXSwgY2FsbGJhY2spO1xuXG4gICAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zLmNvbmRpdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBhcmFtZXRlcjogY29uZGl0aW9ucyBvYmplY3QnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcy5hY3Rpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwYXJhbWV0ZXI6IGFjdGlvbiBvYmplY3QnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuYml0Z28ucHV0KHNlbGYudXJsKCcvcG9saWN5L3J1bGUnKSlcbiAgICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgUG9saWN5IFJ1bGVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICByZW1vdmVQb2xpY3lSdWxlKHBhcmFtczogUmVtb3ZlUG9saWN5UnVsZU9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCddLCBbJ21lc3NhZ2UnXSwgY2FsbGJhY2spO1xuXG4gICAgICByZXR1cm4gc2VsZi5iaXRnby5kZWwoc2VsZi51cmwoJy9wb2xpY3kvcnVsZScpKVxuICAgICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGlzIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHJlbW92ZShwYXJhbXM6IHt9ID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5iaXRnby5kZWwodGhpcy51cmwoKSkucmVzdWx0KCkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdHJhZGluZyBhY2NvdW50IGZyb20gdGhpcyB3YWxsZXRcbiAgICovXG4gIHRvVHJhZGluZ0FjY291bnQoKTogVHJhZGluZ0FjY291bnQge1xuICAgIGlmICh0aGlzLmJhc2VDb2luLmdldEZhbWlseSgpICE9PSAnb2ZjJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gb25seSBjb252ZXJ0IGFuIE9mZmNoYWluIChPRkMpIHdhbGxldCB0byBhIHRyYWRpbmcgYWNjb3VudCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYWRpbmdBY2NvdW50KHRoaXMuX3dhbGxldC5lbnRlcnByaXNlLCB0aGlzLCB0aGlzLmJpdGdvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBkb3dubG9hZHMgUERGIGtleWNhcmQgZm9yIHdhbGxldCAocmVxdWlyZXMgcmVzcG9uc2UgZnJvbSB3YWxsZXRzLmdlbmVyYXRlV2FsbGV0KVxuICAgKlxuICAgKiBOb3RlOiB0aGlzIGlzIGV4YW1wbGUgY29kZSBhbmQgaXMgbm90IHRoZSB2ZXJzaW9uIHVzZWQgb24gYml0Z28uY29tXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogICAqIGpzUERGIC0gYW4gaW5zdGFuY2Ugb2YgdGhlIGpzUERGIGxpYnJhcnlcbiAgICogICAqIFFSQ29kZSAtIGFuIGluc3RhbmNlIG9mIHRoZSBRUmlvdXMgbGlicmFyeVxuICAgKiAgICogdXNlcktleWNoYWluIC0gYSB3YWxsZXQncyBwcml2YXRlIHVzZXIga2V5Y2hhaW5cbiAgICogICAqIGJhY2t1cEtleWNoYWluIC0gYSB3YWxsZXQncyBwcml2YXRlIGJhY2t1cCBrZXljaGFpblxuICAgKiAgICogYml0Z29LZXljaGFpbiAtIGEgd2FsbGV0J3MgcHJpdmF0ZSBiaXRnbyBrZXljaGFpblxuICAgKiAgICogcGFzc3BocmFzZSAtIHRoZSB3YWxsZXQgcGFzc3BocmFzZVxuICAgKiAgICogcGFzc2NvZGVFbmNyeXB0aW9uQ29kZSAtIHRoZSBlbmNyeXB0aW9uIHNlY3JldCB1c2VkIGZvciBCb3ggRFxuICAgKiAgICogYWN0aXZhdGlvbkNvZGUgLSBhIHJhbmRvbWx5IGdlbmVyYXRlZCBzaXgtZGlnaXQgYWN0aXZhdGlvbiBjb2RlXG4gICAqICAgKiB3YWxsZXRLZXlJRCAtIHRoZSBLZXkgSUQgdXNlZCBmb3IgZGVyaXZpbmcgYSBjb2xkIHdhbGxldCdzIHNpZ25pbmcga2V5XG4gICAqICAgKiBiYWNrdXBLZXlJRCAtIHRoZSBLZXkgSUQgdXNlZCBmb3IgZGVyaXZpbmcgYSBjb2xkIHdhbGxldCdzIGJhY2t1cCBrZXlcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBkb3dubG9hZEtleWNhcmQocGFyYW1zOiBEb3dubG9hZEtleWNhcmRPcHRpb25zID0ge30pOiB2b2lkIHtcbiAgICBpZiAoIXdpbmRvdyB8fCAhd2luZG93LmxvY2F0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkb3dubG9hZEtleWNhcmQgZnVuY3Rpb24gaXMgb25seSBjYWxsYWJsZSB3aXRoaW4gYSBicm93c2VyLicpO1xuICAgIH1cblxuICAgIC8vIEdyYWIgcGFyYW1ldGVycyB3aXRoIGRlZmF1bHQgZm9yIGFjdGl2YXRpb25Db2RlXG4gICAgY29uc3Qge1xuICAgICAganNQREYsXG4gICAgICBRUkNvZGUsXG4gICAgICB1c2VyS2V5Y2hhaW4sXG4gICAgICBiYWNrdXBLZXljaGFpbixcbiAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgICBwYXNzcGhyYXNlLFxuICAgICAgcGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICAgIHdhbGxldEtleUlELFxuICAgICAgYmFja3VwS2V5SUQsXG4gICAgICBhY3RpdmF0aW9uQ29kZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDkwMDAwMCArIDEwMDAwMCkudG9TdHJpbmcoKSxcbiAgICB9ID0gcGFyYW1zO1xuXG4gICAgaWYgKCFqc1BERiB8fCB0eXBlb2YganNQREYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHBhc3MgaW4gYSB2YWxpZCBqc1BERiBpbnN0YW5jZScpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGtleWNoYWluc1xuICAgIGlmICghdXNlcktleWNoYWluIHx8IHR5cGVvZiB1c2VyS2V5Y2hhaW4gIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFdhbGxldCBrZXljaGFpbiBtdXN0IGhhdmUgYSAndXNlcicgcHJvcGVydHlgKTtcbiAgICB9XG5cbiAgICBpZiAoIWJhY2t1cEtleWNoYWluIHx8IHR5cGVvZiBiYWNrdXBLZXljaGFpbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmFja3VwIGtleWNoYWluIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cblxuICAgIGlmICghYml0Z29LZXljaGFpbiB8fCB0eXBlb2YgYml0Z29LZXljaGFpbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQml0Z28ga2V5Y2hhaW4gaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKHdhbGxldEtleUlEICYmIHR5cGVvZiB3YWxsZXRLZXlJRCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd2FsbGV0S2V5SUQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmIChiYWNrdXBLZXlJRCAmJiB0eXBlb2YgYmFja3VwS2V5SUQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhY2t1cEtleUlEIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBhY3RpdmF0aW9uIGNvZGUgaWYgcHJvdmlkZWRcbiAgICBpZiAodHlwZW9mIGFjdGl2YXRpb25Db2RlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3RpdmF0aW9uIENvZGUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmIChhY3RpdmF0aW9uQ29kZS5sZW5ndGggIT09IDYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aXZhdGlvbiBjb2RlIG11c3QgYmUgc2l4IGNoYXJhY3RlcnMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb2luU2hvcnROYW1lID0gdGhpcy5iYXNlQ29pbi50eXBlO1xuICAgIGNvbnN0IGNvaW5OYW1lID0gdGhpcy5iYXNlQ29pbi5nZXRGdWxsTmFtZSgpO1xuICAgIGNvbnN0IHdhbGxldExhYmVsID0gdGhpcy5fd2FsbGV0LmxhYmVsO1xuXG4gICAgY29uc3QgZG9jID0gZHJhd0tleWNhcmQoe1xuICAgICAganNQREYsXG4gICAgICBRUkNvZGUsXG4gICAgICBlbmNyeXB0OiB0aGlzLmJpdGdvLmVuY3J5cHQsXG4gICAgICBjb2luU2hvcnROYW1lLFxuICAgICAgY29pbk5hbWUsXG4gICAgICBhY3RpdmF0aW9uQ29kZSxcbiAgICAgIHdhbGxldExhYmVsLFxuICAgICAgcGFzc3BocmFzZSxcbiAgICAgIHBhc3Njb2RlRW5jcnlwdGlvbkNvZGUsXG4gICAgICB1c2VyS2V5Y2hhaW4sXG4gICAgICBiYWNrdXBLZXljaGFpbixcbiAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgICB3YWxsZXRLZXlJRCxcbiAgICAgIGJhY2t1cEtleUlELFxuICAgIH0pO1xuXG4gICAgLy8gU2F2ZSB0aGUgUERGIG9uIHRoZSB1c2VyJ3MgYnJvd3NlclxuICAgIGRvYy5zYXZlKGBCaXRHbyBLZXljYXJkIGZvciAke3dhbGxldExhYmVsfS5wZGZgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBzZXQgb2YgY29uc29saWRhdGlvbiB0cmFuc2FjdGlvbnMgZm9yIGEgd2FsbGV0LlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqICAgICBmcm9tQWRkcmVzc2VzIC0gdGhlc2UgYXJlIHRoZSBvbi1jaGFpbiByZWNlaXZlIGFkZHJlc3NlcyB3ZSB3YW50IHRvIHBpY2sgYSBjb25zb2xpZGF0aW9uIGFtb3VudCBmcm9tXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgYnVpbGRBY2NvdW50Q29uc29saWRhdGlvbnMocGFyYW1zOiBCdWlsZENvbnNvbGlkYXRpb25UcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8UHJlYnVpbGRUcmFuc2FjdGlvblJlc3VsdFtdPik6IEJsdWViaXJkPFByZWJ1aWxkVHJhbnNhY3Rpb25SZXN1bHRbXT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxQcmVidWlsZFRyYW5zYWN0aW9uUmVzdWx0W10+KGZ1bmN0aW9uICooKSB7XG4gICAgICBpZiAoIXNlbGYuYmFzZUNvaW4uYWxsb3dzQWNjb3VudENvbnNvbGlkYXRpb25zKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3NlbGYuYmFzZUNvaW4uZ2V0RnVsbE5hbWUoKX0gZG9lcyBub3QgYWxsb3cgYWNjb3VudCBjb25zb2xpZGF0aW9ucy5gKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2hpdGVsaXN0IHBhcmFtcyB0byBidWlsZCB0eFxuICAgICAgY29uc3Qgd2hpdGVsaXN0ZWRQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBzZWxmLnByZWJ1aWxkQ29uc29saWRhdGVBY2NvdW50UGFyYW1zKCkpO1xuICAgICAgZGVidWcoJ3ByZWJ1aWxkaW5nIGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb246ICVPJywgd2hpdGVsaXN0ZWRQYXJhbXMpO1xuXG4gICAgICBpZiAocGFyYW1zLnJlcUlkKSB7XG4gICAgICAgIHNlbGYuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihwYXJhbXMucmVxSWQpO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGlzIGNvdWxkIHJldHVybiAxMDAgYnVpbGQgdHJhbnNhY3Rpb25zXG4gICAgICBjb25zdCBidWlsZFJlc3BvbnNlID0geWllbGQgc2VsZi5iaXRnby5wb3N0KHNlbGYuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyBzZWxmLmlkKCkgKyAnL2NvbnNvbGlkYXRlQWNjb3VudC9idWlsZCcpKVxuICAgICAgICAuc2VuZCh3aGl0ZWxpc3RlZFBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuXG4gICAgICAvLyB3ZSBuZWVkIHRvIHN0ZXAgb3ZlciBlYWNoIHByZWJ1aWxkIG5vdyAtIHNob3VsZCBiZSBpbiBhbiBhcnJheSBpbiB0aGUgYm9keVxuICAgICAgY29uc3QgY29uc29saWRhdGlvbnM6VHJhbnNhY3Rpb25QcmVidWlsZFtdID0gW107XG4gICAgICBmb3IgKGNvbnN0IGNvbnNvbGlkYXRlQWNjb3VudEJ1aWxkIG9mIGJ1aWxkUmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IHByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkID0geWllbGQgc2VsZi5iYXNlQ29pbi5wb3N0UHJvY2Vzc1ByZWJ1aWxkKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29uc29saWRhdGVBY2NvdW50QnVpbGQsIHsgd2FsbGV0OiBzZWxmLCBidWlsZFBhcmFtczogd2hpdGVsaXN0ZWRQYXJhbXMgfSlcbiAgICAgICAgKTtcblxuICAgICAgICBkZWxldGUgcHJlYnVpbGQud2FsbGV0O1xuICAgICAgICBkZWxldGUgcHJlYnVpbGQuYnVpbGRQYXJhbXM7XG5cbiAgICAgICAgcHJlYnVpbGQgPSBfLmV4dGVuZCh7fSwgcHJlYnVpbGQsIHsgd2FsbGV0SWQ6IHNlbGYuaWQoKSB9KTtcbiAgICAgICAgZGVidWcoJ2ZpbmFsIGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb24gcHJlYnVpbGQ6ICVPJywgcHJlYnVpbGQpO1xuXG4gICAgICAgIGNvbnNvbGlkYXRpb25zLnB1c2gocHJlYnVpbGQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uc29saWRhdGlvbnM7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYW5kIHNlbmRzIGEgc2V0IG9mIGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb25zIGZvciBhIHdhbGxldC5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAgICAgcHJlYnVpbGRUeCAgIC0gdGhpcyBpcyB0aGUgcHJlLWJ1aWxkIGNvbnNvbGlkYXRpb24gdHguIHRoaXMgaXMgYSBub3JtYWxseSBidWlsdCB0eCB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICBhbiBhZGRpdGlvbmFsIHBhcmFtZXRlciBvZiBjb25zb2xpZGF0ZUlkLlxuICAgKiAgICAgdmVyaWZpY2F0aW9uIC0gbm9ybWFsIGtleWNoYWlucywgZXRjLiBmb3IgdmVyaWZpY2F0aW9uXG4gICAqL1xuICBzZW5kQWNjb3VudENvbnNvbGlkYXRpb24ocGFyYW1zOiBQcmVidWlsZEFuZFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxhbnk+KGZ1bmN0aW9uICooKSB7XG4gICAgICBpZiAoIXNlbGYuYmFzZUNvaW4uYWxsb3dzQWNjb3VudENvbnNvbGlkYXRpb25zKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3NlbGYuYmFzZUNvaW4uZ2V0RnVsbE5hbWUoKX0gZG9lcyBub3QgYWxsb3cgYWNjb3VudCBjb25zb2xpZGF0aW9ucy5gKTtcbiAgICAgIH1cblxuICAgICAgLy8gb25lIG9mIGEgc2V0IG9mIGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb25zXG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy5wcmVidWlsZFR4ID09PSAnc3RyaW5nJyB8fCBwYXJhbXMucHJlYnVpbGRUeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBidWlsZCBvZiBhY2NvdW50IGNvbnNvbGlkYXRpb24uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyYW1zLnByZWJ1aWxkVHguY29uc29saWRhdGVJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGNvbnNvbGlkYXRpb24gaWQgb24gY29uc29saWRhdGlvbiB0cmFuc2FjdGlvbi4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2lnbmVkUHJlYnVpbGQgPSB5aWVsZCBzZWxmLnByZWJ1aWxkQW5kU2lnblRyYW5zYWN0aW9uKHBhcmFtcyk7XG5cbiAgICAgIC8vIGRlY29yYXRlIHdpdGggb3VyIGNvbnNvbGlkYXRpb24gaWRcbiAgICAgIHNpZ25lZFByZWJ1aWxkLmNvbnNvbGlkYXRlSWQgPSBwYXJhbXMucHJlYnVpbGRUeC5jb25zb2xpZGF0ZUlkO1xuXG4gICAgICBkZWxldGUgc2lnbmVkUHJlYnVpbGQud2FsbGV0O1xuXG4gICAgICByZXR1cm4geWllbGQgc2VsZi5zdWJtaXRUcmFuc2FjdGlvbihzaWduZWRQcmVidWlsZCk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYW5kIHNlbmRzIGEgc2V0IG9mIGFjY291bnQgY29uc29saWRhdGlvbnMuIFRoaXMgaXMgaW50ZW5kZWQgdG8gZmx1c2ggbWFueSBiYWxhbmNlcyB0byB0aGUgcm9vdCB3YWxsZXQgYmFsYW5jZS5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHNlbmRBY2NvdW50Q29uc29saWRhdGlvbnMocGFyYW1zOiBCdWlsZENvbnNvbGlkYXRpb25UcmFuc2FjdGlvbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxhbnk+KGZ1bmN0aW9uICooKSB7XG4gICAgICBpZiAoIXNlbGYuYmFzZUNvaW4uYWxsb3dzQWNjb3VudENvbnNvbGlkYXRpb25zKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3NlbGYuYmFzZUNvaW4uZ2V0RnVsbE5hbWUoKX0gZG9lcyBub3QgYWxsb3cgYWNjb3VudCBjb25zb2xpZGF0aW9ucy5gKTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhpcyBnaXZlcyB1cyBhIHNldCBvZiBhY2NvdW50IGNvbnNvbGlkYXRpb24gdHJhbnNhY3Rpb25zXG4gICAgICBjb25zdCB1bnNpZ25lZEJ1aWxkcyA9IHlpZWxkIHNlbGYuYnVpbGRBY2NvdW50Q29uc29saWRhdGlvbnMocGFyYW1zKTtcbiAgICAgIGlmICh1bnNpZ25lZEJ1aWxkcyAmJiB1bnNpZ25lZEJ1aWxkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NmdWxUeHM6IGFueVtdID0gW107XG4gICAgICAgIGNvbnN0IGZhaWxlZFR4cyA9IG5ldyBBcnJheTxFcnJvcj4oKTtcbiAgICAgICAgZm9yIChjb25zdCB1bnNpZ25lZEJ1aWxkIG9mIHVuc2lnbmVkQnVpbGRzKSB7XG4gICAgICAgICAgLy8gZm9sZCBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgd2UgdXNlZCB0byBidWlsZCB0aGlzIHRyYW5zYWN0aW9uIGludG8gdGhlIHVuc2lnbmVkQnVpbGRcbiAgICAgICAgICBjb25zdCB1bnNpZ25lZEJ1aWxkV2l0aE9wdGlvbnM6IFByZWJ1aWxkQW5kU2lnblRyYW5zYWN0aW9uT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyk7XG4gICAgICAgICAgdW5zaWduZWRCdWlsZFdpdGhPcHRpb25zLnByZWJ1aWxkVHggPSB1bnNpZ25lZEJ1aWxkO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzZW5kVHggPSB5aWVsZCBzZWxmLnNlbmRBY2NvdW50Q29uc29saWRhdGlvbih1bnNpZ25lZEJ1aWxkV2l0aE9wdGlvbnMpO1xuICAgICAgICAgICAgc3VjY2Vzc2Z1bFR4cy5wdXNoKHNlbmRUeCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZmFpbGVkVHhzLnB1c2goZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzZnVsVHhzLFxuICAgICAgICAgIGZhaWx1cmU6IGZhaWxlZFR4cyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG59XG4iXX0=