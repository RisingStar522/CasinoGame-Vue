"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var Bluebird = require("bluebird");
var statics_1 = require("@bitgo/statics");
var co = Bluebird.coroutine;
var bitgoAccountLib = require("@bitgo/account-lib");
var baseCoin_1 = require("../baseCoin");
var errors_1 = require("../../errors");
var stellar = require("stellar-sdk");
var seedValidator_1 = require("../internal/seedValidator");
var Hbar = /** @class */ (function (_super) {
    __extends(Hbar, _super);
    function Hbar(bitgo, staticsCoin) {
        var _this = _super.call(this, bitgo) || this;
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        _this._staticsCoin = staticsCoin;
        return _this;
    }
    Hbar.prototype.getChain = function () {
        return this._staticsCoin.name;
    };
    Hbar.prototype.getFamily = function () {
        return this._staticsCoin.family;
    };
    Hbar.prototype.getFullName = function () {
        return this._staticsCoin.fullName;
    };
    Hbar.prototype.getBaseFactor = function () {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    };
    Hbar.createInstance = function (bitgo, staticsCoin) {
        return new Hbar(bitgo, staticsCoin);
    };
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    Hbar.prototype.valuelessTransferAllowed = function () {
        return false;
    };
    /**
     * Checks if this is a valid base58 or hex address
     * @param address
     */
    Hbar.prototype.isValidAddress = function (address) {
        try {
            var addressDetails = this.getAddressDetails(address);
            if (typeof addressDetails.memoId === 'undefined' || addressDetails.memoId === '') {
                // we want addresses to normalize without a memoId
                address = address.replace('?memoId=', '');
            }
            return address === this.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Generate Hedera Hashgraph key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    Hbar.prototype.generateKeyPair = function (seed) {
        var keyPair = seed ? new bitgoAccountLib.Hbar.KeyPair({ seed: seed }) : new bitgoAccountLib.Hbar.KeyPair();
        var keys = keyPair.getKeys();
        if (!keys.prv) {
            throw new Error('Keypair generation failed to generate a prv');
        }
        return {
            pub: keys.pub,
            prv: keys.prv,
        };
    };
    Hbar.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    Hbar.prototype.verifyAddress = function (params) {
        return true;
    };
    Hbar.prototype.verifyTransaction = function (params, callback) {
        return Bluebird.resolve(true).asCallback(callback);
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param params.wallet.addressVersion {String} this is the version of the Algorand multisig address generation format
     * @param callback
     * @returns Bluebird<SignedTransaction>
     */
    Hbar.prototype.signTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var factory, txBuilder, transaction, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        factory = bitgoAccountLib.register(self.getChain(), bitgoAccountLib.Hbar.TransactionBuilderFactory);
                        txBuilder = factory.from(params.txPrebuild.txHex);
                        txBuilder.sign({ key: params.prv });
                        return [4 /*yield*/, txBuilder.build()];
                    case 1:
                        transaction = _a.sent();
                        if (!transaction) {
                            throw new Error('Invalid messaged passed to signMessage');
                        }
                        response = {
                            txHex: transaction.toBroadcastFormat(),
                        };
                        return [2 /*return*/, transaction.signature.length >= 2 ? response : { halfSigned: response }];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     * @return {Buffer} A signature over the given message using the given key
     */
    Hbar.prototype.signMessage = function (key, message, callback) {
        return co(function cosignMessage() {
            var msg;
            return __generator(this, function (_a) {
                msg = Buffer.isBuffer(message) ? message.toString('utf8') : message;
                // reconstitute keys and sign
                return [2 /*return*/, new bitgoAccountLib.Hbar.KeyPair({ prv: key.prv }).signMessage(msg)];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Builds a funds recovery transaction without BitGo.
     * We need to do three queries during this:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     * @param params
     * @param callback
     */
    Hbar.prototype.recover = function (params, callback) {
        throw new errors_1.MethodNotImplementedError();
    };
    /**
     * Explain a Hedera transaction from txHex
     * @param params
     * @param callback
     */
    Hbar.prototype.explainTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txHex, factory, txBuilder, tx, txJson, displayOrder, memo, outputs, explanationResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
                        if (!txHex) {
                            throw new Error('missing explain tx parameters');
                        }
                        if (!params.feeInfo) {
                            throw new Error('missing fee information');
                        }
                        factory = bitgoAccountLib.register(self.getChain(), bitgoAccountLib.Hbar.TransactionBuilderFactory);
                        txBuilder = factory.from(txHex);
                        return [4 /*yield*/, txBuilder.build()];
                    case 1:
                        tx = _a.sent();
                        txJson = tx.toJson();
                        if (tx._txBody.data !== 'cryptoTransfer') {
                            // don't explain this
                            throw new Error('Transaction format outside of cryptoTransfer not supported for explanation.');
                        }
                        displayOrder = [
                            'id',
                            'outputAmount',
                            'changeAmount',
                            'outputs',
                            'changeOutputs',
                            'fee',
                            'timestamp',
                            'expiration',
                            'memo',
                        ];
                        memo = '';
                        if (params.memo) {
                            memo = params.memo.value;
                        }
                        outputs = [
                            {
                                amount: txJson.amount.toString(),
                                address: txJson.to,
                                memo: memo,
                            },
                        ];
                        explanationResult = {
                            displayOrder: displayOrder,
                            id: txJson.id,
                            outputs: outputs,
                            outputAmount: outputs[0].amount,
                            changeOutputs: [],
                            changeAmount: '0',
                            fee: params.feeInfo,
                            timestamp: txJson.startTime,
                            expiration: txJson.validDuration,
                        };
                        return [2 /*return*/, explanationResult];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Process address into address and memo id
     *
     * @param address the address
     * @returns object containing address and memo id
     */
    Hbar.prototype.getAddressDetails = function (rawAddress) {
        var memoId = undefined;
        var address = rawAddress;
        if (rawAddress.includes('?memoId=')) {
            address = rawAddress.substr(0, rawAddress.indexOf('?'));
        }
        // failed to parse OR bad address
        if (!address || !bitgoAccountLib.Hbar.Utils.isValidAddress(address)) {
            throw new errors_1.InvalidAddressError("invalid address: " + rawAddress);
        }
        // address doesn't have a memo id - this is ok
        if (rawAddress === address) {
            return { address: address, memoId: memoId };
        }
        memoId = rawAddress.substr(rawAddress.indexOf('?memoId=') + 8);
        // undefined is valid as in has not been specified
        if (typeof memoId !== 'undefined' && !this.isValidMemoId(memoId)) {
            throw new errors_1.InvalidMemoIdError("invalid address: '" + address + "', memoId is not valid");
        }
        return { address: address, memoId: memoId };
    };
    /**
     * Validate and return address with appended memo id
     *
     * @param address
     * @param memoId
     */
    Hbar.prototype.normalizeAddress = function (_a) {
        var address = _a.address, memoId = _a.memoId;
        if (memoId && this.isValidMemoId(memoId)) {
            return address + "?memoId=" + memoId;
        }
        return address;
    };
    /**
     * Validates whether a memo is potentially correct in hedera.
     *
     * @param memoId
     */
    Hbar.prototype.isValidMemoId = function (memoId) {
        // TODO: change this to account-lib helper once its published
        if (typeof memoId !== 'undefined' && Buffer.from(memoId).length > 100) {
            return false;
        }
        return true;
    };
    Hbar.prototype.isStellarSeed = function (seed) {
        return seedValidator_1.SeedValidator.isValidEd25519SeedForCoin(seed, statics_1.CoinFamily.XLM);
    };
    Hbar.prototype.convertFromStellarSeed = function (seed) {
        // assume this is a trust custodial seed if its a valid ed25519 prv
        if (!this.isStellarSeed(seed) || seedValidator_1.SeedValidator.hasCompetingSeedFormats(seed)) {
            return null;
        }
        if (seedValidator_1.SeedValidator.isValidEd25519SeedForCoin(seed, statics_1.CoinFamily.XLM)) {
            var keyFromSeed = new bitgoAccountLib.Hbar.KeyPair({ seed: stellar.StrKey.decodeEd25519SecretSeed(seed) });
            var keys = keyFromSeed.getKeys();
            if (keys !== undefined && keys.prv) {
                return keys.prv;
            }
        }
        return null;
    };
    Hbar.prototype.isValidPub = function (pub) {
        return bitgoAccountLib.Hbar.Utils.isValidPublicKey(pub);
    };
    return Hbar;
}(baseCoin_1.BaseCoin));
exports.Hbar = Hbar;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGJhci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy92Mi9jb2lucy9oYmFyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0gsbUNBQXFDO0FBQ3JDLDBDQUF5RTtBQUN6RSxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBQzlCLG9EQUFzRDtBQUV0RCx3Q0FhcUI7QUFJckIsdUNBQWtHO0FBQ2xHLHFDQUF1QztBQUN2QywyREFBMEQ7QUFzQzFEO0lBQTBCLHdCQUFRO0lBR2hDLGNBQVksS0FBWSxFQUFFLFdBQXVDO1FBQWpFLFlBQ0Usa0JBQU0sS0FBSyxDQUFDLFNBT2I7UUFMQyxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztTQUN2RTtRQUVELEtBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDOztJQUNsQyxDQUFDO0lBRUQsdUJBQVEsR0FBUjtRQUNFLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7SUFDaEMsQ0FBQztJQUVELHdCQUFTLEdBQVQ7UUFDRSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDO0lBQ2xDLENBQUM7SUFFRCwwQkFBVyxHQUFYO1FBQ0UsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQztJQUNwQyxDQUFDO0lBRUQsNEJBQWEsR0FBYjtRQUNFLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRU0sbUJBQWMsR0FBckIsVUFBc0IsS0FBWSxFQUFFLFdBQXVDO1FBQ3pFLE9BQU8sSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQ3RDLENB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SSw2QkFBYSxDQUFDLHlCQUF5QixDQUFDLElBQUksRUFBRSxvQkFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ2pFLElBQU0sV0FBVyxHQUFHLElBQUksZUFBZSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDN0csSUFBTSxJQUFJLEdBQUcsV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ25DLElBQUksSUFBSSxLQUFLLFNBQVMsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUNsQyxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUM7YUFDakI7U0FDRjtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELHlCQUFVLEdBQVYsVUFBVyxHQUFXO1FBQ3BCLE9BQU8sZUFBZSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUNILFdBQUM7QUFBRCxDQUFDLEFBM1RELENBQTBCLG1CQUFRLEdBMlRqQztBQTNUWSxvQkFBSSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IENvaW5GYW1pbHksIEJhc2VDb2luIGFzIFN0YXRpY3NCYXNlQ29pbiB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuaW1wb3J0ICogYXMgYml0Z29BY2NvdW50TGliIGZyb20gJ0BiaXRnby9hY2NvdW50LWxpYic7XG5cbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBLZXlQYWlyLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvbkZlZSxcbiAgVHJhbnNhY3Rpb25SZWNpcGllbnQgYXMgUmVjaXBpZW50LFxuICBUcmFuc2FjdGlvblByZWJ1aWxkIGFzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxufSBmcm9tICcuLi9iYXNlQ29pbic7XG5cbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vYml0Z28nO1xuaW1wb3J0IHsgTm9kZUNhbGxiYWNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgSW52YWxpZEFkZHJlc3NFcnJvciwgSW52YWxpZE1lbW9JZEVycm9yLCBNZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCAqIGFzIHN0ZWxsYXIgZnJvbSAnc3RlbGxhci1zZGsnO1xuaW1wb3J0IHsgU2VlZFZhbGlkYXRvciB9IGZyb20gJy4uL2ludGVybmFsL3NlZWRWYWxpZGF0b3InO1xuXG5leHBvcnQgaW50ZXJmYWNlIEhiYXJTaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHBydjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFR4SW5mbyB7XG4gIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xuICBmcm9tOiBzdHJpbmc7XG4gIHR4aWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvblByZWJ1aWxkIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uUHJlYnVpbGQge1xuICB0eEhleDogc3RyaW5nO1xuICB0eEluZm86IFR4SW5mbztcbiAgZmVlSW5mbzogVHJhbnNhY3Rpb25GZWU7XG4gIHNvdXJjZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEhleD86IHN0cmluZztcbiAgaGFsZlNpZ25lZD86IHtcbiAgICB0eEhleDogc3RyaW5nO1xuICB9O1xuICBmZWVJbmZvOiBUcmFuc2FjdGlvbkZlZTtcbiAgLy8gVE9ETyhCRy0yNDgwOSk6IGdldCB0aGUgbWVtbyBmcm9tIHRoZSB0b0pzb25cbiAgbWVtbz86IHtcbiAgICB0eXBlOiBzdHJpbmc7XG4gICAgdmFsdWU6IHN0cmluZztcbiAgfTtcbn1cblxuaW50ZXJmYWNlIEFkZHJlc3NEZXRhaWxzIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBtZW1vSWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBIYmFyIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3N0YXRpY3NDb2luOiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+O1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHbywgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KSB7XG4gICAgc3VwZXIoYml0Z28pO1xuXG4gICAgaWYgKCFzdGF0aWNzQ29pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBzdGF0aWNzQ29pbicpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRpY3NDb2luID0gc3RhdGljc0NvaW47XG4gIH1cblxuICBnZXRDaGFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4ubmFtZTtcbiAgfVxuXG4gIGdldEZhbWlseSgpOiBDb2luRmFtaWx5IHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZmFtaWx5O1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZ1bGxOYW1lO1xuICB9XG5cbiAgZ2V0QmFzZUZhY3RvcigpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXRpY3NDb2luLmRlY2ltYWxQbGFjZXMpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHbywgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgSGJhcihiaXRnbywgc3RhdGljc0NvaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgdmFsdWUgb2YgMFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgMCB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB2YWx1ZWxlc3NUcmFuc2ZlckFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGlzIGEgdmFsaWQgYmFzZTU4IG9yIGhleCBhZGRyZXNzXG4gICAqIEBwYXJhbSBhZGRyZXNzXG4gICAqL1xuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3MpO1xuICAgICAgaWYgKHR5cGVvZiBhZGRyZXNzRGV0YWlscy5tZW1vSWQgPT09ICd1bmRlZmluZWQnIHx8IGFkZHJlc3NEZXRhaWxzLm1lbW9JZCA9PT0gJycpIHtcbiAgICAgICAgLy8gd2Ugd2FudCBhZGRyZXNzZXMgdG8gbm9ybWFsaXplIHdpdGhvdXQgYSBtZW1vSWRcbiAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MucmVwbGFjZSgnP21lbW9JZD0nLCAnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWRkcmVzcyA9PT0gdGhpcy5ub3JtYWxpemVBZGRyZXNzKGFkZHJlc3NEZXRhaWxzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIEhlZGVyYSBIYXNoZ3JhcGgga2V5IHBhaXJcbiAgICpcbiAgICogQHBhcmFtIHNlZWRcbiAgICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IHdpdGggZ2VuZXJhdGVkIHB1YiwgcHJ2XG4gICAqL1xuICBnZW5lcmF0ZUtleVBhaXIoc2VlZD86IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIGNvbnN0IGtleVBhaXIgPSBzZWVkID8gbmV3IGJpdGdvQWNjb3VudExpYi5IYmFyLktleVBhaXIoeyBzZWVkIH0pIDogbmV3IGJpdGdvQWNjb3VudExpYi5IYmFyLktleVBhaXIoKTtcbiAgICBjb25zdCBrZXlzID0ga2V5UGFpci5nZXRLZXlzKCk7XG5cbiAgICBpZiAoIWtleXMucHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXBhaXIgZ2VuZXJhdGlvbiBmYWlsZWQgdG8gZ2VuZXJhdGUgYSBwcnYnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHViOiBrZXlzLnB1YixcbiAgICAgIHBydjoga2V5cy5wcnYsXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQYXJzZWRUcmFuc2FjdGlvbj5cbiAgKTogQmx1ZWJpcmQ8UGFyc2VkVHJhbnNhY3Rpb24+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSh7fSkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICB2ZXJpZnlBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZlcmlmeVRyYW5zYWN0aW9uKHBhcmFtczogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxib29sZWFuPik6IEJsdWViaXJkPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSh0cnVlKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50eFByZWJ1aWxkIHtPYmplY3R9IHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBwbGF0Zm9ybVxuICAgKiBAcGFyYW0gcGFyYW1zLnBydiB7U3RyaW5nfSB1c2VyIHBydlxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldC5hZGRyZXNzVmVyc2lvbiB7U3RyaW5nfSB0aGlzIGlzIHRoZSB2ZXJzaW9uIG9mIHRoZSBBbGdvcmFuZCBtdWx0aXNpZyBhZGRyZXNzIGdlbmVyYXRpb24gZm9ybWF0XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyBCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj5cbiAgICovXG4gIHNpZ25UcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IEhiYXJTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFNpZ25lZFRyYW5zYWN0aW9uPlxuICApOiBCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxTaWduZWRUcmFuc2FjdGlvbj4oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3QgZmFjdG9yeSA9IGJpdGdvQWNjb3VudExpYi5yZWdpc3RlcihzZWxmLmdldENoYWluKCksIGJpdGdvQWNjb3VudExpYi5IYmFyLlRyYW5zYWN0aW9uQnVpbGRlckZhY3RvcnkpO1xuICAgICAgY29uc3QgdHhCdWlsZGVyID0gZmFjdG9yeS5mcm9tKHBhcmFtcy50eFByZWJ1aWxkLnR4SGV4KTtcbiAgICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiBwYXJhbXMucHJ2IH0pO1xuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbjogYW55ID0geWllbGQgdHhCdWlsZGVyLmJ1aWxkKCk7XG5cbiAgICAgIGlmICghdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2VkIHBhc3NlZCB0byBzaWduTWVzc2FnZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgdHhIZXg6IHRyYW5zYWN0aW9uLnRvQnJvYWRjYXN0Rm9ybWF0KCksXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uLnNpZ25hdHVyZS5sZW5ndGggPj0gMiA/IHJlc3BvbnNlIDogeyBoYWxmU2lnbmVkOiByZXNwb25zZSB9O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gbWVzc2FnZSB3aXRoIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICogQHJldHVybiB7QnVmZmVyfSBBIHNpZ25hdHVyZSBvdmVyIHRoZSBnaXZlbiBtZXNzYWdlIHVzaW5nIHRoZSBnaXZlbiBrZXlcbiAgICovXG4gIHNpZ25NZXNzYWdlKGtleTogS2V5UGFpciwgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxCdWZmZXI+KTogQmx1ZWJpcmQ8QnVmZmVyPiB7XG4gICAgcmV0dXJuIGNvPEJ1ZmZlcj4oZnVuY3Rpb24qIGNvc2lnbk1lc3NhZ2UoKSB7XG4gICAgICBjb25zdCBtc2cgPSBCdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkgPyBtZXNzYWdlLnRvU3RyaW5nKCd1dGY4JykgOiBtZXNzYWdlO1xuICAgICAgLy8gcmVjb25zdGl0dXRlIGtleXMgYW5kIHNpZ25cbiAgICAgIHJldHVybiBuZXcgYml0Z29BY2NvdW50TGliLkhiYXIuS2V5UGFpcih7IHBydjoga2V5LnBydiB9KS5zaWduTWVzc2FnZShtc2cpO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R28uXG4gICAqIFdlIG5lZWQgdG8gZG8gdGhyZWUgcXVlcmllcyBkdXJpbmcgdGhpczpcbiAgICogMSkgTm9kZSBxdWVyeSAtIGhvdyBtdWNoIG1vbmV5IGlzIGluIHRoZSBhY2NvdW50XG4gICAqIDIpIEJ1aWxkIHRyYW5zYWN0aW9uIC0gYnVpbGQgb3VyIHRyYW5zYWN0aW9uIGZvciB0aGUgYW1vdW50XG4gICAqIDMpIFNlbmQgc2lnbmVkIGJ1aWxkIC0gc2VuZCBvdXIgc2lnbmVkIGJ1aWxkIHRvIGEgcHVibGljIG5vZGVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHJlY292ZXIocGFyYW1zOiBhbnksIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICB0aHJvdyBuZXcgTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGxhaW4gYSBIZWRlcmEgdHJhbnNhY3Rpb24gZnJvbSB0eEhleFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZXhwbGFpblRyYW5zYWN0aW9uKFxuICAgIHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPlxuICApOiBCbHVlYmlyZDxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbnN0IHR4SGV4ID0gcGFyYW1zLnR4SGV4IHx8IChwYXJhbXMuaGFsZlNpZ25lZCAmJiBwYXJhbXMuaGFsZlNpZ25lZC50eEhleCk7XG4gICAgICBpZiAoIXR4SGV4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBleHBsYWluIHR4IHBhcmFtZXRlcnMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXJhbXMuZmVlSW5mbykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgZmVlIGluZm9ybWF0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZhY3RvcnkgPSBiaXRnb0FjY291bnRMaWIucmVnaXN0ZXIoc2VsZi5nZXRDaGFpbigpLCBiaXRnb0FjY291bnRMaWIuSGJhci5UcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5KTtcbiAgICAgIGNvbnN0IHR4QnVpbGRlciA9IGZhY3RvcnkuZnJvbSh0eEhleCk7XG4gICAgICBjb25zdCB0eCA9IHlpZWxkIHR4QnVpbGRlci5idWlsZCgpO1xuICAgICAgY29uc3QgdHhKc29uID0gdHgudG9Kc29uKCk7XG5cbiAgICAgIGlmICh0eC5fdHhCb2R5LmRhdGEgIT09ICdjcnlwdG9UcmFuc2ZlcicpIHtcbiAgICAgICAgLy8gZG9uJ3QgZXhwbGFpbiB0aGlzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gZm9ybWF0IG91dHNpZGUgb2YgY3J5cHRvVHJhbnNmZXIgbm90IHN1cHBvcnRlZCBmb3IgZXhwbGFuYXRpb24uJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRpc3BsYXlPcmRlciA9IFtcbiAgICAgICAgJ2lkJyxcbiAgICAgICAgJ291dHB1dEFtb3VudCcsXG4gICAgICAgICdjaGFuZ2VBbW91bnQnLFxuICAgICAgICAnb3V0cHV0cycsXG4gICAgICAgICdjaGFuZ2VPdXRwdXRzJyxcbiAgICAgICAgJ2ZlZScsXG4gICAgICAgICd0aW1lc3RhbXAnLFxuICAgICAgICAnZXhwaXJhdGlvbicsXG4gICAgICAgICdtZW1vJyxcbiAgICAgIF07XG5cbiAgICAgIC8vIFRPRE8oQkctMjQ4MDkpOiBnZXQgdGhlIG1lbW8gZnJvbSB0aGUgdG9Kc29uXG4gICAgICBsZXQgbWVtbyA9ICcnO1xuICAgICAgaWYgKHBhcmFtcy5tZW1vKSB7XG4gICAgICAgIG1lbW8gPSBwYXJhbXMubWVtby52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0cHV0cyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGFtb3VudDogdHhKc29uLmFtb3VudC50b1N0cmluZygpLFxuICAgICAgICAgIGFkZHJlc3M6IHR4SnNvbi50byxcbiAgICAgICAgICBtZW1vLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgY29uc3QgZXhwbGFuYXRpb25SZXN1bHQ6IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgIGRpc3BsYXlPcmRlcixcbiAgICAgICAgaWQ6IHR4SnNvbi5pZCxcbiAgICAgICAgb3V0cHV0cyxcbiAgICAgICAgb3V0cHV0QW1vdW50OiBvdXRwdXRzWzBdLmFtb3VudCxcbiAgICAgICAgY2hhbmdlT3V0cHV0czogW10sIC8vIGFjY291bnQgYmFzZWQgZG9lcyBub3QgdXNlIGNoYW5nZSBvdXRwdXRzXG4gICAgICAgIGNoYW5nZUFtb3VudDogJzAnLCAvLyBhY2NvdW50IGJhc2UgZG9lcyBub3QgbWFrZSBjaGFuZ2VcbiAgICAgICAgZmVlOiBwYXJhbXMuZmVlSW5mbyxcbiAgICAgICAgdGltZXN0YW1wOiB0eEpzb24uc3RhcnRUaW1lLFxuICAgICAgICBleHBpcmF0aW9uOiB0eEpzb24udmFsaWREdXJhdGlvbixcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBleHBsYW5hdGlvblJlc3VsdDtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGFkZHJlc3MgaW50byBhZGRyZXNzIGFuZCBtZW1vIGlkXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHRoZSBhZGRyZXNzXG4gICAqIEByZXR1cm5zIG9iamVjdCBjb250YWluaW5nIGFkZHJlc3MgYW5kIG1lbW8gaWRcbiAgICovXG4gIGdldEFkZHJlc3NEZXRhaWxzKHJhd0FkZHJlc3M6IHN0cmluZyk6IEFkZHJlc3NEZXRhaWxzIHtcbiAgICBsZXQgbWVtb0lkOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgbGV0IGFkZHJlc3MgPSByYXdBZGRyZXNzO1xuXG4gICAgaWYgKHJhd0FkZHJlc3MuaW5jbHVkZXMoJz9tZW1vSWQ9JykpIHtcbiAgICAgIGFkZHJlc3MgPSByYXdBZGRyZXNzLnN1YnN0cigwLCByYXdBZGRyZXNzLmluZGV4T2YoJz8nKSk7XG4gICAgfVxuXG4gICAgLy8gZmFpbGVkIHRvIHBhcnNlIE9SIGJhZCBhZGRyZXNzXG4gICAgaWYgKCFhZGRyZXNzIHx8ICFiaXRnb0FjY291bnRMaWIuSGJhci5VdGlscy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHtyYXdBZGRyZXNzfWApO1xuICAgIH1cblxuICAgIC8vIGFkZHJlc3MgZG9lc24ndCBoYXZlIGEgbWVtbyBpZCAtIHRoaXMgaXMgb2tcbiAgICBpZiAocmF3QWRkcmVzcyA9PT0gYWRkcmVzcykge1xuICAgICAgcmV0dXJuIHsgYWRkcmVzcywgbWVtb0lkIH07XG4gICAgfVxuXG4gICAgbWVtb0lkID0gcmF3QWRkcmVzcy5zdWJzdHIocmF3QWRkcmVzcy5pbmRleE9mKCc/bWVtb0lkPScpICsgOCk7XG4gICAgLy8gdW5kZWZpbmVkIGlzIHZhbGlkIGFzIGluIGhhcyBub3QgYmVlbiBzcGVjaWZpZWRcbiAgICBpZiAodHlwZW9mIG1lbW9JZCAhPT0gJ3VuZGVmaW5lZCcgJiYgIXRoaXMuaXNWYWxpZE1lbW9JZChtZW1vSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZE1lbW9JZEVycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICcke2FkZHJlc3N9JywgbWVtb0lkIGlzIG5vdCB2YWxpZGApO1xuICAgIH1cblxuICAgIHJldHVybiB7IGFkZHJlc3MsIG1lbW9JZCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGFuZCByZXR1cm4gYWRkcmVzcyB3aXRoIGFwcGVuZGVkIG1lbW8gaWRcbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICogQHBhcmFtIG1lbW9JZFxuICAgKi9cbiAgbm9ybWFsaXplQWRkcmVzcyh7IGFkZHJlc3MsIG1lbW9JZCB9OiBBZGRyZXNzRGV0YWlscyk6IHN0cmluZyB7XG4gICAgaWYgKG1lbW9JZCAmJiB0aGlzLmlzVmFsaWRNZW1vSWQobWVtb0lkKSkge1xuICAgICAgcmV0dXJuIGAke2FkZHJlc3N9P21lbW9JZD0ke21lbW9JZH1gO1xuICAgIH1cbiAgICByZXR1cm4gYWRkcmVzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgd2hldGhlciBhIG1lbW8gaXMgcG90ZW50aWFsbHkgY29ycmVjdCBpbiBoZWRlcmEuXG4gICAqXG4gICAqIEBwYXJhbSBtZW1vSWRcbiAgICovXG4gIGlzVmFsaWRNZW1vSWQobWVtb0lkOiBzdHJpbmcpIHtcbiAgICAvLyBUT0RPOiBjaGFuZ2UgdGhpcyB0byBhY2NvdW50LWxpYiBoZWxwZXIgb25jZSBpdHMgcHVibGlzaGVkXG4gICAgaWYgKHR5cGVvZiBtZW1vSWQgIT09ICd1bmRlZmluZWQnICYmIEJ1ZmZlci5mcm9tKG1lbW9JZCkubGVuZ3RoID4gMTAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaXNTdGVsbGFyU2VlZChzZWVkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gU2VlZFZhbGlkYXRvci5pc1ZhbGlkRWQyNTUxOVNlZWRGb3JDb2luKHNlZWQsIENvaW5GYW1pbHkuWExNKTtcbiAgfVxuXG4gIGNvbnZlcnRGcm9tU3RlbGxhclNlZWQoc2VlZDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgLy8gYXNzdW1lIHRoaXMgaXMgYSB0cnVzdCBjdXN0b2RpYWwgc2VlZCBpZiBpdHMgYSB2YWxpZCBlZDI1NTE5IHBydlxuICAgIGlmICghdGhpcy5pc1N0ZWxsYXJTZWVkKHNlZWQpIHx8IFNlZWRWYWxpZGF0b3IuaGFzQ29tcGV0aW5nU2VlZEZvcm1hdHMoc2VlZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChTZWVkVmFsaWRhdG9yLmlzVmFsaWRFZDI1NTE5U2VlZEZvckNvaW4oc2VlZCwgQ29pbkZhbWlseS5YTE0pKSB7XG4gICAgICBjb25zdCBrZXlGcm9tU2VlZCA9IG5ldyBiaXRnb0FjY291bnRMaWIuSGJhci5LZXlQYWlyKHsgc2VlZDogc3RlbGxhci5TdHJLZXkuZGVjb2RlRWQyNTUxOVNlY3JldFNlZWQoc2VlZCkgfSk7XG4gICAgICBjb25zdCBrZXlzID0ga2V5RnJvbVNlZWQuZ2V0S2V5cygpO1xuICAgICAgaWYgKGtleXMgIT09IHVuZGVmaW5lZCAmJiBrZXlzLnBydikge1xuICAgICAgICByZXR1cm4ga2V5cy5wcnY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGJpdGdvQWNjb3VudExpYi5IYmFyLlV0aWxzLmlzVmFsaWRQdWJsaWNLZXkocHViKTtcbiAgfVxufVxuIl19