"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var bitgoAccountLib = require("@bitgo/account-lib");
var baseCoin_1 = require("../baseCoin");
var bignumber_js_1 = require("bignumber.js");
var errors_1 = require("../../errors");
var Xtz = /** @class */ (function (_super) {
    __extends(Xtz, _super);
    function Xtz(bitgo, staticsCoin) {
        var _this = _super.call(this, bitgo) || this;
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        _this._staticsCoin = staticsCoin;
        return _this;
    }
    Xtz.prototype.getChain = function () {
        return this._staticsCoin.name;
    };
    Xtz.prototype.getFamily = function () {
        return this._staticsCoin.family;
    };
    Xtz.prototype.getFullName = function () {
        return this._staticsCoin.fullName;
    };
    Xtz.prototype.getBaseFactor = function () {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    };
    Xtz.createInstance = function (bitgo, staticsCoin) {
        return new Xtz(bitgo, staticsCoin);
    };
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    Xtz.prototype.valuelessTransferAllowed = function () {
        return true;
    };
    /**
     * Checks if this is a valid base58 or hex address
     * @param address
     */
    Xtz.prototype.isValidAddress = function (address) {
        if (!address) {
            return false;
        }
        return bitgoAccountLib.Xtz.Utils.isValidAddress(address);
    };
    /**
     * Generate Tezos key pair - BitGo xpub format
     *
     * @param seed
     * @returns {Object} object with generated xpub, xprv
     */
    Xtz.prototype.generateKeyPair = function (seed) {
        var keyPair = seed ? new bitgoAccountLib.Xtz.KeyPair({ seed: seed }) : new bitgoAccountLib.Xtz.KeyPair();
        var keys = keyPair.getExtendedKeys();
        if (!keys.xprv) {
            throw new Error('Missing xprv in key generation.');
        }
        return {
            pub: keys.xpub,
            prv: keys.xprv,
        };
    };
    Xtz.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    Xtz.prototype.verifyAddress = function (params) {
        return true;
    };
    Xtz.prototype.verifyTransaction = function (params, callback) {
        return Bluebird.resolve(true).asCallback(callback);
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param params.wallet.addressVersion {String} this is the version of the Algorand multisig address generation format
     * @param callback
     * @returns Bluebird<SignedTransaction>
     */
    Xtz.prototype.signTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txBuilder, transaction, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txBuilder = bitgoAccountLib.getBuilder(self.getChain());
                        txBuilder.from(params.txPrebuild.txHex);
                        txBuilder.source(params.txPrebuild.source);
                        if (params.txPrebuild.dataToSign) {
                            txBuilder.overrideDataToSign({ dataToSign: params.txPrebuild.dataToSign });
                        }
                        txBuilder.sign({ key: params.prv });
                        return [4 /*yield*/, txBuilder.build()];
                    case 1:
                        transaction = _a.sent();
                        if (!transaction) {
                            throw new Error('Invalid messaged passed to signMessage');
                        }
                        response = {
                            txHex: transaction.toBroadcastFormat(),
                        };
                        return [2 /*return*/, transaction.signature.length >= 2 ? response : { halfSigned: response }];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    Xtz.prototype.signMessage = function (key, message, callback) {
        return co(function cosignMessage() {
            var keyPair, messageHex, signatureData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyPair = new bitgoAccountLib.Xtz.KeyPair({ prv: key.prv });
                        messageHex = message instanceof Buffer ? message.toString('hex') : Buffer.from(message).toString('hex');
                        return [4 /*yield*/, bitgoAccountLib.Xtz.Utils.sign(keyPair, messageHex)];
                    case 1:
                        signatureData = _a.sent();
                        return [2 /*return*/, Buffer.from(signatureData.sig).toString('hex')];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Builds a funds recovery transaction without BitGo.
     * We need to do three queries during this:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     * @param params
     * @param callback
     */
    Xtz.prototype.recover = function (params, callback) {
        throw new errors_1.MethodNotImplementedError();
    };
    /**
     * Explain a Tezos transaction from txHex
     * @param params
     * @param callback
     */
    Xtz.prototype.explainTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txHex, txBuilder, tx, displayOrder;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
                        if (!txHex || !params.feeInfo) {
                            throw new Error('missing explain tx parameters');
                        }
                        txBuilder = bitgoAccountLib.getBuilder(self.getChain());
                        // Newer coins can return BaseTransactionBuilderFactory instead of BaseTransactionBuilder
                        if (!(txBuilder instanceof bitgoAccountLib.BaseCoin.BaseTransactionBuilder)) {
                            throw new Error('getBuilder() did not return an BaseTransactionBuilder object. Has it been updated?');
                        }
                        txBuilder.from(txHex);
                        return [4 /*yield*/, txBuilder.build()];
                    case 1:
                        tx = _a.sent();
                        displayOrder = ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee'];
                        return [2 /*return*/, {
                                displayOrder: displayOrder,
                                id: tx.id,
                                outputs: tx.outputs,
                                outputAmount: tx.outputs
                                    .reduce(function (accumulator, output) { return accumulator.plus(output.value); }, new bignumber_js_1.default('0'))
                                    .toFixed(0),
                                changeOutputs: [],
                                changeAmount: '0',
                                fee: params.feeInfo,
                            }];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    Xtz.prototype.isValidPub = function (pub) {
        return bitgoAccountLib.Xtz.Utils.isValidPublicKey(pub);
    };
    return Xtz;
}(baseCoin_1.BaseCoin));
exports.Xtz = Xtz;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieHR6LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3h0ei50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILG1DQUFxQztBQUVyQyxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBQzlCLG9EQUFzRDtBQUV0RCx3Q0FhcUI7QUFJckIsNkNBQXFDO0FBQ3JDLHVDQUF5RDtBQW1DekQ7SUFBeUIsdUJBQVE7SUFHL0IsYUFBWSxLQUFZLEVBQUUsV0FBdUM7UUFBakUsWUFDRSxrQkFBTSxLQUFLLENBQUMsU0FPYjtRQUxDLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvREFBb0QsQ0FBQyxDQUFDO1NBQ3ZFO1FBRUQsS0FBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7O0lBQ2xDLENBQUM7SUFFRCxzQkFBUSxHQUFSO1FBQ0UsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQztJQUNoQyxDQUFDO0lBRUQsdUJBQVMsR0FBVDtRQUNFLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUM7SUFDbEMsQ0FBQztJQUVELHlCQUFXLEdBQVg7UUFDRSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDO0lBQ3BDLENBQUM7SUFFRCwyQkFBYSxHQUFiO1FBQ0UsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFTSxrQkFBYyxHQUFyQixVQUFzQixLQUFZLEVBQUUsV0FBdUM7UUFDekUsT0FBTyxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7T0FHRztJQUNILHNDQUF3QixH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LEVBQUM7OztTQUNILENBQUM7YUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ1YsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRCx3QkFBVSxHQUFWLFVBQVcsR0FBVztRQUNwQixPQUFPLGVBQWUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFDSCxVQUFDO0FBQUQsQ0FBQyxBQXRNRCxDQUF5QixtQkFBUSxHQXNNaEM7QUF0TVksa0JBQUciLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBDb2luRmFtaWx5LCBCYXNlQ29pbiBhcyBTdGF0aWNzQmFzZUNvaW4gfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5jb25zdCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcbmltcG9ydCAqIGFzIGJpdGdvQWNjb3VudExpYiBmcm9tICdAYml0Z28vYWNjb3VudC1saWInO1xuXG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgS2V5UGFpcixcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBTaWduZWRUcmFuc2FjdGlvbixcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25GZWUsXG4gIFRyYW5zYWN0aW9uUmVjaXBpZW50IGFzIFJlY2lwaWVudCxcbiAgVHJhbnNhY3Rpb25QcmVidWlsZCBhcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbixcbn0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuXG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uLy4uL2JpdGdvJztcbmltcG9ydCB7IE5vZGVDYWxsYmFjayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFh0elNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcHJ2OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHhJbmZvIHtcbiAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gIGZyb206IHN0cmluZztcbiAgdHhpZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHR4SGV4OiBzdHJpbmc7XG4gIHR4SW5mbzogVHhJbmZvO1xuICBmZWVJbmZvOiBYdHpUcmFuc2FjdGlvbkZlZTtcbiAgc291cmNlOiBzdHJpbmc7XG4gIGRhdGFUb1NpZ246IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBYdHpUcmFuc2FjdGlvbkZlZSB7XG4gIGZlZTogc3RyaW5nO1xuICBnYXNMaW1pdD86IHN0cmluZztcbiAgc3RvcmFnZUxpbWl0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEhleD86IHN0cmluZztcbiAgaGFsZlNpZ25lZD86IHtcbiAgICB0eEhleDogc3RyaW5nO1xuICB9O1xuICBmZWVJbmZvOiBUcmFuc2FjdGlvbkZlZTtcbn1cblxuZXhwb3J0IGNsYXNzIFh0eiBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9zdGF0aWNzQ29pbjogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPjtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28sIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPikge1xuICAgIHN1cGVyKGJpdGdvKTtcblxuICAgIGlmICghc3RhdGljc0NvaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgc3RhdGljc0NvaW4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0aWNzQ29pbiA9IHN0YXRpY3NDb2luO1xuICB9XG5cbiAgZ2V0Q2hhaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLm5hbWU7XG4gIH1cblxuICBnZXRGYW1pbHkoKTogQ29pbkZhbWlseSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZhbWlseTtcbiAgfVxuXG4gIGdldEZ1bGxOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5mdWxsTmFtZTtcbiAgfVxuXG4gIGdldEJhc2VGYWN0b3IoKSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGF0aWNzQ29pbi5kZWNpbWFsUGxhY2VzKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R28sIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPik6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IFh0eihiaXRnbywgc3RhdGljc0NvaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgdmFsdWUgb2YgMFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgMCB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB2YWx1ZWxlc3NUcmFuc2ZlckFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgaXMgYSB2YWxpZCBiYXNlNTggb3IgaGV4IGFkZHJlc3NcbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghYWRkcmVzcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYml0Z29BY2NvdW50TGliLlh0ei5VdGlscy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBUZXpvcyBrZXkgcGFpciAtIEJpdEdvIHhwdWIgZm9ybWF0XG4gICAqXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGdlbmVyYXRlZCB4cHViLCB4cHJ2XG4gICAqL1xuICBnZW5lcmF0ZUtleVBhaXIoc2VlZD86IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIGNvbnN0IGtleVBhaXIgPSBzZWVkID8gbmV3IGJpdGdvQWNjb3VudExpYi5YdHouS2V5UGFpcih7IHNlZWQgfSkgOiBuZXcgYml0Z29BY2NvdW50TGliLlh0ei5LZXlQYWlyKCk7XG4gICAgY29uc3Qga2V5cyA9IGtleVBhaXIuZ2V0RXh0ZW5kZWRLZXlzKCk7XG5cbiAgICBpZiAoIWtleXMueHBydikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHhwcnYgaW4ga2V5IGdlbmVyYXRpb24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHB1Yjoga2V5cy54cHViLFxuICAgICAgcHJ2OiBrZXlzLnhwcnYsXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQYXJzZWRUcmFuc2FjdGlvbj5cbiAgKTogQmx1ZWJpcmQ8UGFyc2VkVHJhbnNhY3Rpb24+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSh7fSkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICB2ZXJpZnlBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZlcmlmeVRyYW5zYWN0aW9uKHBhcmFtczogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxib29sZWFuPik6IEJsdWViaXJkPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSh0cnVlKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50eFByZWJ1aWxkIHtPYmplY3R9IHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBwbGF0Zm9ybVxuICAgKiBAcGFyYW0gcGFyYW1zLnBydiB7U3RyaW5nfSB1c2VyIHBydlxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldC5hZGRyZXNzVmVyc2lvbiB7U3RyaW5nfSB0aGlzIGlzIHRoZSB2ZXJzaW9uIG9mIHRoZSBBbGdvcmFuZCBtdWx0aXNpZyBhZGRyZXNzIGdlbmVyYXRpb24gZm9ybWF0XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyBCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj5cbiAgICovXG4gIHNpZ25UcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IFh0elNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8U2lnbmVkVHJhbnNhY3Rpb24+XG4gICk6IEJsdWViaXJkPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFNpZ25lZFRyYW5zYWN0aW9uPihmdW5jdGlvbiooKSB7XG4gICAgICBjb25zdCB0eEJ1aWxkZXI6IGFueSA9IGJpdGdvQWNjb3VudExpYi5nZXRCdWlsZGVyKHNlbGYuZ2V0Q2hhaW4oKSk7XG4gICAgICB0eEJ1aWxkZXIuZnJvbShwYXJhbXMudHhQcmVidWlsZC50eEhleCk7XG4gICAgICB0eEJ1aWxkZXIuc291cmNlKHBhcmFtcy50eFByZWJ1aWxkLnNvdXJjZSk7XG4gICAgICBpZiAocGFyYW1zLnR4UHJlYnVpbGQuZGF0YVRvU2lnbikge1xuICAgICAgICB0eEJ1aWxkZXIub3ZlcnJpZGVEYXRhVG9TaWduKHsgZGF0YVRvU2lnbjogcGFyYW1zLnR4UHJlYnVpbGQuZGF0YVRvU2lnbiB9KTtcbiAgICAgIH1cbiAgICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiBwYXJhbXMucHJ2IH0pO1xuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbjogYW55ID0geWllbGQgdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgICBpZiAoIXRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlZCBwYXNzZWQgdG8gc2lnbk1lc3NhZ2UnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICB0eEhleDogdHJhbnNhY3Rpb24udG9Ccm9hZGNhc3RGb3JtYXQoKSxcbiAgICAgIH07XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb24uc2lnbmF0dXJlLmxlbmd0aCA+PSAyID8gcmVzcG9uc2UgOiB7IGhhbGZTaWduZWQ6IHJlc3BvbnNlIH07XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBtZXNzYWdlIHdpdGggcHJpdmF0ZSBrZXlcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKi9cbiAgc2lnbk1lc3NhZ2Uoa2V5OiBLZXlQYWlyLCBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPEJ1ZmZlcj4pOiBCbHVlYmlyZDxCdWZmZXI+IHtcbiAgICByZXR1cm4gY288QnVmZmVyPihmdW5jdGlvbiogY29zaWduTWVzc2FnZSgpIHtcbiAgICAgIGNvbnN0IGtleVBhaXIgPSBuZXcgYml0Z29BY2NvdW50TGliLlh0ei5LZXlQYWlyKHsgcHJ2OiBrZXkucHJ2IH0pO1xuICAgICAgY29uc3QgbWVzc2FnZUhleCA9IG1lc3NhZ2UgaW5zdGFuY2VvZiBCdWZmZXIgPyBtZXNzYWdlLnRvU3RyaW5nKCdoZXgnKSA6IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZURhdGEgPSB5aWVsZCBiaXRnb0FjY291bnRMaWIuWHR6LlV0aWxzLnNpZ24oa2V5UGFpciwgbWVzc2FnZUhleCk7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oc2lnbmF0dXJlRGF0YS5zaWcpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBmdW5kcyByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRob3V0IEJpdEdvLlxuICAgKiBXZSBuZWVkIHRvIGRvIHRocmVlIHF1ZXJpZXMgZHVyaW5nIHRoaXM6XG4gICAqIDEpIE5vZGUgcXVlcnkgLSBob3cgbXVjaCBtb25leSBpcyBpbiB0aGUgYWNjb3VudFxuICAgKiAyKSBCdWlsZCB0cmFuc2FjdGlvbiAtIGJ1aWxkIG91ciB0cmFuc2FjdGlvbiBmb3IgdGhlIGFtb3VudFxuICAgKiAzKSBTZW5kIHNpZ25lZCBidWlsZCAtIHNlbmQgb3VyIHNpZ25lZCBidWlsZCB0byBhIHB1YmxpYyBub2RlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICByZWNvdmVyKHBhcmFtczogYW55LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluIGEgVGV6b3MgdHJhbnNhY3Rpb24gZnJvbSB0eEhleFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZXhwbGFpblRyYW5zYWN0aW9uKFxuICAgIHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPlxuICApOiBCbHVlYmlyZDxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbnN0IHR4SGV4ID0gcGFyYW1zLnR4SGV4IHx8IChwYXJhbXMuaGFsZlNpZ25lZCAmJiBwYXJhbXMuaGFsZlNpZ25lZC50eEhleCk7XG4gICAgICBpZiAoIXR4SGV4IHx8ICFwYXJhbXMuZmVlSW5mbykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgZXhwbGFpbiB0eCBwYXJhbWV0ZXJzJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0eEJ1aWxkZXIgPSBiaXRnb0FjY291bnRMaWIuZ2V0QnVpbGRlcihzZWxmLmdldENoYWluKCkpO1xuICAgICAgLy8gTmV3ZXIgY29pbnMgY2FuIHJldHVybiBCYXNlVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeSBpbnN0ZWFkIG9mIEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXJcbiAgICAgIGlmICghKHR4QnVpbGRlciBpbnN0YW5jZW9mIGJpdGdvQWNjb3VudExpYi5CYXNlQ29pbi5CYXNlVHJhbnNhY3Rpb25CdWlsZGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldEJ1aWxkZXIoKSBkaWQgbm90IHJldHVybiBhbiBCYXNlVHJhbnNhY3Rpb25CdWlsZGVyIG9iamVjdC4gSGFzIGl0IGJlZW4gdXBkYXRlZD8nKTtcbiAgICAgIH1cbiAgICAgIHR4QnVpbGRlci5mcm9tKHR4SGV4KTtcbiAgICAgIGNvbnN0IHR4OiBhbnkgPSB5aWVsZCB0eEJ1aWxkZXIuYnVpbGQoKTtcblxuICAgICAgY29uc3QgZGlzcGxheU9yZGVyID0gWydpZCcsICdvdXRwdXRBbW91bnQnLCAnY2hhbmdlQW1vdW50JywgJ291dHB1dHMnLCAnY2hhbmdlT3V0cHV0cycsICdmZWUnXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheU9yZGVyLFxuICAgICAgICBpZDogdHguaWQsXG4gICAgICAgIG91dHB1dHM6IHR4Lm91dHB1dHMsXG4gICAgICAgIG91dHB1dEFtb3VudDogdHgub3V0cHV0c1xuICAgICAgICAgIC5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBvdXRwdXQpID0+IGFjY3VtdWxhdG9yLnBsdXMob3V0cHV0LnZhbHVlKSwgbmV3IEJpZ051bWJlcignMCcpKVxuICAgICAgICAgIC50b0ZpeGVkKDApLFxuICAgICAgICBjaGFuZ2VPdXRwdXRzOiBbXSwgLy8gYWNjb3VudCBiYXNlZCBkb2VzIG5vdCB1c2UgY2hhbmdlIG91dHB1dHNcbiAgICAgICAgY2hhbmdlQW1vdW50OiAnMCcsIC8vIGFjY291bnQgYmFzZSBkb2VzIG5vdCBtYWtlIGNoYW5nZVxuICAgICAgICBmZWU6IHBhcmFtcy5mZWVJbmZvLFxuICAgICAgfTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gYml0Z29BY2NvdW50TGliLlh0ei5VdGlscy5pc1ZhbGlkUHVibGljS2V5KHB1Yik7XG4gIH1cbn1cbiJdfQ==