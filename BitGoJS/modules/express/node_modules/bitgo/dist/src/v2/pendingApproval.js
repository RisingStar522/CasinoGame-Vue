"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("../common");
var Bluebird = require("bluebird");
var _ = require("lodash");
var util_1 = require("./internal/util");
var co = Bluebird.coroutine;
var OwnerType;
(function (OwnerType) {
    OwnerType["WALLET"] = "wallet";
    OwnerType["ENTERPRISE"] = "enterprise";
})(OwnerType = exports.OwnerType || (exports.OwnerType = {}));
var State;
(function (State) {
    State["PENDING"] = "pending";
    State["AWAITING_SIGNATURE"] = "awaitingSignature";
    State["PENDING_BITGO_ADMIN_APPROVAL"] = "pendingBitGoAdminApproval";
    State["PENDING_ID_VERIFICATION"] = "pendingIdVerification";
    State["PENDING_CUSTODIAN_APPROVAL"] = "pendingCustodianApproval";
    State["PENDING_FINAL_APPROVAL"] = "pendingFinalApproval";
    State["APPROVED"] = "approved";
    State["PROCESSING"] = "processing";
    State["REJECTED"] = "rejected";
})(State = exports.State || (exports.State = {}));
var Type;
(function (Type) {
    Type["USER_CHANGE_REQUEST"] = "userChangeRequest";
    Type["TRANSACTION_REQUEST"] = "transactionRequest";
    Type["POLICY_RULE_REQUEST"] = "policyRuleRequest";
    Type["UPDATE_APPROVALS_REQUIRED_REQUEST"] = "updateApprovalsRequiredRequest";
})(Type = exports.Type || (exports.Type = {}));
var PendingApproval = /** @class */ (function () {
    function PendingApproval(bitgo, baseCoin, pendingApprovalData, wallet) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
        this.wallet = wallet;
        this._pendingApproval = pendingApprovalData;
    }
    /**
     * Get the id for this PendingApproval
     */
    PendingApproval.prototype.id = function () {
        return this._pendingApproval.id;
    };
    /**
     * Get the owner type (wallet or enterprise)
     * Pending approvals can be approved or modified by different scopes (depending on how they were created)
     * If a pending approval is owned by a wallet, then it can be approved by administrators of the wallet
     * If a pending approval is owned by an enterprise, then it can be approved by administrators of the enterprise
     */
    PendingApproval.prototype.ownerType = function () {
        if (this._pendingApproval.wallet) {
            return OwnerType.WALLET;
        }
        else if (this._pendingApproval.enterprise) {
            return OwnerType.ENTERPRISE;
        }
        else {
            throw new Error('unexpected pending approval owner: neither wallet nor enterprise was present');
        }
    };
    /**
     * Get the id of the wallet which is associated with this PendingApproval
     */
    PendingApproval.prototype.walletId = function () {
        return this._pendingApproval.wallet;
    };
    /**
     * Get the enterprise ID that is associated with this PendingApproval
     */
    PendingApproval.prototype.enterpriseId = function () {
        return this._pendingApproval.enterprise;
    };
    /**
     * Get the state of this PendingApproval
     */
    PendingApproval.prototype.state = function () {
        return this._pendingApproval.state;
    };
    /**
     * Get the id of the user that performed the action resulting in this PendingApproval
     */
    PendingApproval.prototype.creator = function () {
        return this._pendingApproval.creator;
    };
    /**
     * Get the type of the pending approval (what it approves)
     */
    PendingApproval.prototype.type = function () {
        if (!this._pendingApproval.info) {
            throw new Error('pending approval info is not available');
        }
        return this._pendingApproval.info.type;
    };
    /**
     * Get information about this PendingApproval
     */
    PendingApproval.prototype.info = function () {
        return this._pendingApproval.info;
    };
    /**
     * Get the number of approvals that are required for this PendingApproval to be approved.
     * Defaults to 1 if approvalsRequired doesn't exist on the object
     */
    PendingApproval.prototype.approvalsRequired = function () {
        return this._pendingApproval.approvalsRequired || 1;
    };
    /**
     * Generate a url for this PendingApproval for making requests to the server.
     * @param extra
     */
    PendingApproval.prototype.url = function (extra) {
        if (extra === void 0) { extra = ''; }
        return this.baseCoin.url('/pendingapprovals/' + this.id() + extra);
    };
    /**
     * Refetches this PendingApproval from the server and returns it.
     *
     * Note that this mutates the PendingApproval object in place.
     * @param params
     * @param callback
     */
    PendingApproval.prototype.get = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = self;
                        return [4 /*yield*/, self.bitgo.get(self.url()).result()];
                    case 1:
                        _a._pendingApproval = _b.sent();
                        return [2 /*return*/, self];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Helper function to ensure that self.wallet is set
     */
    PendingApproval.prototype.populateWallet = function () {
        var self = this;
        return co(function () {
            var transactionRequest, updatedWallet;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        transactionRequest = self.info().transactionRequest;
                        if (_.isUndefined(transactionRequest)) {
                            throw new Error('missing required object property transactionRequest');
                        }
                        if (!_.isUndefined(self.wallet)) return [3 /*break*/, 2];
                        return [4 /*yield*/, self.baseCoin.wallets().get({ id: transactionRequest.sourceWallet })];
                    case 1:
                        updatedWallet = _a.sent();
                        if (_.isUndefined(updatedWallet)) {
                            throw new Error('unexpected - unable to get wallet using sourcewallet');
                        }
                        self.wallet = updatedWallet;
                        _a.label = 2;
                    case 2:
                        if (self.wallet.id() !== transactionRequest.sourceWallet) {
                            throw new Error('unexpected source wallet for pending approval');
                        }
                        return [2 /*return*/];
                }
            });
        }).call(this);
    };
    /**
     * Sets this PendingApproval to an approved state
     */
    PendingApproval.prototype.approve = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            /*
             * Internal helper function to get the serialized transaction which is being approved
             */
            function getApprovalTransaction() {
                return co(function () {
                    var transaction;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!(self.type() === 'transactionRequest')) return [3 /*break*/, 3];
                                /*
                                 * If this is a request for approving a transaction, depending on whether this user has a private key to the wallet
                                 * (some admins may not have the spend permission), the transaction could either be rebroadcast as is, or it could
                                 * be reconstructed. It is preferable to reconstruct a tx in order to adhere to the latest network conditions
                                 * such as newer unspents, different fees, or a higher sequence id
                                 */
                                if (params.tx) {
                                    // the approval tx was reconstructed and explicitly specified - pass it through
                                    return [2 /*return*/, {
                                            txHex: params.tx,
                                        }];
                                }
                                transaction = _.get(self.info(), "transactionRequest.coinSpecific." + self.baseCoin.type);
                                // this user may not have spending privileges or a passphrase may not have been passed in
                                if (!canRecreateTransaction) {
                                    if (!_.isObject(transaction)) {
                                        throw new Error('there is neither an original transaction object nor can a new one be recreated');
                                    }
                                    return [2 /*return*/, transaction];
                                }
                                self.bitgo.setRequestTracer(reqId);
                                return [4 /*yield*/, self.populateWallet()];
                            case 1:
                                _a.sent();
                                return [4 /*yield*/, self.recreateAndSignTransaction(params)];
                            case 2: return [2 /*return*/, _a.sent()];
                            case 3: return [2 /*return*/];
                        }
                    });
                }).call(this);
            }
            /*
             * Internal helper function to prepare the approval payload and send it to bitgo
             */
            function sendApproval(transaction) {
                return co(function () {
                    var approvalParams;
                    return __generator(this, function (_a) {
                        approvalParams = { state: 'approved', otp: params.otp };
                        if (transaction) {
                            // if the transaction already has a half signed property, we take that directly
                            approvalParams.halfSigned = transaction.halfSigned || transaction;
                        }
                        self.bitgo.setRequestTracer(reqId);
                        return [2 /*return*/, self.bitgo
                                .put(self.url())
                                .send(approvalParams)
                                .result()
                                .nodeify(callback)];
                    });
                }).call(this);
            }
            var canRecreateTransaction, isColdWallet, isOFCWallet, reqId, approvalTransaction, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common_1.validateParams(params, [], ['walletPassphrase', 'otp'], callback);
                        canRecreateTransaction = true;
                        isColdWallet = !!_.get(self.wallet, '_wallet.isCold');
                        isOFCWallet = self.baseCoin.getFamily() === 'ofc';
                        if (!params.xprv && !(params.walletPassphrase && !isColdWallet && !isOFCWallet)) {
                            canRecreateTransaction = false;
                        }
                        reqId = new util_1.RequestTracer();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, getApprovalTransaction()];
                    case 2:
                        approvalTransaction = _a.sent();
                        self.bitgo.setRequestTracer(reqId);
                        return [4 /*yield*/, sendApproval(approvalTransaction)];
                    case 3: return [2 /*return*/, _a.sent()];
                    case 4:
                        e_1 = _a.sent();
                        if (!canRecreateTransaction &&
                            (e_1.message.indexOf('could not find unspent output for input') !== -1 ||
                                e_1.message.indexOf('transaction conflicts with an existing transaction in the send queue') !== -1)) {
                            throw new Error('unspents expired, wallet passphrase or xprv required to recreate transaction');
                        }
                        throw e_1;
                    case 5: return [2 /*return*/];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Sets this PendingApproval to a rejected state
     * @param params
     * @param callback
     */
    PendingApproval.prototype.reject = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.bitgo
            .put(this.url())
            .send({ state: 'rejected' })
            .result()
            .nodeify(callback);
    };
    /**
     * Alias for PendingApproval.reject()
     *
     * @deprecated
     * @param params
     * @param callback
     */
    PendingApproval.prototype.cancel = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.reject(params, callback);
    };
    /**
     * Recreate a transaction for a pending approval to respond to updated network conditions
     * @param params
     * @param callback
     */
    PendingApproval.prototype.recreateAndSignTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var transactionRequest, originalPrebuild, recipients, prebuildParams, _a, signedTransaction, originalParsedTransaction, recreatedParsedTransaction;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        transactionRequest = self.info().transactionRequest;
                        if (_.isUndefined(transactionRequest)) {
                            throw new Error('cannot recreate transaction without transaction request');
                        }
                        if (_.isUndefined(self.wallet)) {
                            throw new Error('cannot recreate transaction without wallet');
                        }
                        originalPrebuild = transactionRequest.coinSpecific[self.baseCoin.type];
                        recipients = transactionRequest.recipients;
                        prebuildParams = _.extend({}, params, { recipients: recipients }, transactionRequest.buildParams);
                        if (!_.isUndefined(originalPrebuild.hopTransaction)) {
                            prebuildParams.hop = true;
                        }
                        if (!!recipients.length) return [3 /*break*/, 2];
                        // no recipients - this is a consolidation transaction
                        _a = prebuildParams;
                        return [4 /*yield*/, self.bitgo
                                .post(self.wallet.url("/consolidateUnspents"))
                                .send(params)
                                .result()];
                    case 1:
                        // no recipients - this is a consolidation transaction
                        _a.prebuildTx = _b.sent();
                        delete prebuildParams.recipients;
                        _b.label = 2;
                    case 2: return [4 /*yield*/, self.wallet.prebuildAndSignTransaction(prebuildParams)];
                    case 3:
                        signedTransaction = _b.sent();
                        return [4 /*yield*/, self.baseCoin.parseTransaction({
                                txParams: prebuildParams,
                                wallet: self.wallet,
                                txPrebuild: originalPrebuild,
                            })];
                    case 4:
                        originalParsedTransaction = _b.sent();
                        return [4 /*yield*/, self.baseCoin.parseTransaction({
                                txParams: prebuildParams,
                                wallet: self.wallet,
                                txPrebuild: signedTransaction,
                            })];
                    case 5:
                        recreatedParsedTransaction = _b.sent();
                        if (_.isUndefined(recreatedParsedTransaction.implicitExternalSpendAmount)) {
                            return [2 /*return*/, signedTransaction];
                        }
                        if (!_.isFinite(recreatedParsedTransaction.implicitExternalSpendAmount)) {
                            throw new Error('implicit external spend amount could not be determined');
                        }
                        if (!_.isUndefined(originalParsedTransaction.implicitExternalSpendAmount) &&
                            recreatedParsedTransaction.implicitExternalSpendAmount > originalParsedTransaction.implicitExternalSpendAmount) {
                            throw new Error('recreated transaction is using a higher pay-as-you-go-fee');
                        }
                        return [2 /*return*/, signedTransaction];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    return PendingApproval;
}());
exports.PendingApproval = PendingApproval;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVuZGluZ0FwcHJvdmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3YyL3BlbmRpbmdBcHByb3ZhbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlBLG9DQUEyQztBQUMzQyxtQ0FBcUM7QUFDckMsMEJBQTRCO0FBQzVCLHdDQUFnRDtBQU1oRCxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBc0I5QixJQUFZLFNBR1g7QUFIRCxXQUFZLFNBQVM7SUFDbkIsOEJBQWlCLENBQUE7SUFDakIsc0NBQXlCLENBQUE7QUFDM0IsQ0FBQyxFQUhXLFNBQVMsR0FBVCxpQkFBUyxLQUFULGlCQUFTLFFBR3BCO0FBRUQsSUFBWSxLQVVYO0FBVkQsV0FBWSxLQUFLO0lBQ2YsNEJBQW1CLENBQUE7SUFDbkIsaURBQXdDLENBQUE7SUFDeEMsbUVBQTBELENBQUE7SUFDMUQsMERBQWlELENBQUE7SUFDakQsZ0VBQXVELENBQUE7SUFDdkQsd0RBQStDLENBQUE7SUFDL0MsOEJBQXFCLENBQUE7SUFDckIsa0NBQXlCLENBQUE7SUFDekIsOEJBQXFCLENBQUE7QUFDdkIsQ0FBQyxFQVZXLEtBQUssR0FBTCxhQUFLLEtBQUwsYUFBSyxRQVVoQjtBQUVELElBQVksSUFLWDtBQUxELFdBQVksSUFBSTtJQUNkLGlEQUF5QyxDQUFBO0lBQ3pDLGtEQUEwQyxDQUFBO0lBQzFDLGlEQUF5QyxDQUFBO0lBQ3pDLDRFQUFvRSxDQUFBO0FBQ3RFLENBQUMsRUFMVyxJQUFJLEdBQUosWUFBSSxLQUFKLFlBQUksUUFLZjtBQVNEO0lBTUUseUJBQVksS0FBWSxFQUFFLFFBQWtCLEVBQUUsbUJBQXdDLEVBQUUsTUFBZTtRQUNyRyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsTUFBTSxH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eUJBQXlCLEdBQUcsU0FJaEM7d0JBQ2lDLHFCQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUM7Z0NBQ3RFLFFBQVEsRUFBRSxjQUFjO2dDQUN4QixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07Z0NBQ25CLFVBQVUsRUFBRSxpQkFBaUI7NkJBQzlCLENBQUMsRUFBQTs7d0JBSkksMEJBQTBCLEdBQUcsU0FJakM7d0JBRUYsSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDLDBCQUEwQixDQUFDLDJCQUEyQixDQUFDLEVBQUU7NEJBQ3pFLHNCQUFPLGlCQUFpQixFQUFDO3lCQUMxQjt3QkFFRCxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQywwQkFBMEIsQ0FBQywyQkFBMkIsQ0FBQyxFQUFFOzRCQUN2RSxNQUFNLElBQUksS0FBSyxDQUFDLHdEQUF3RCxDQUFDLENBQUM7eUJBQzNFO3dCQUNELElBQ0UsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLHlCQUF5QixDQUFDLDJCQUEyQixDQUFDOzRCQUNyRSwwQkFBMEIsQ0FBQywyQkFBMkIsR0FBRyx5QkFBeUIsQ0FBQywyQkFBMkIsRUFDOUc7NEJBQ0EsTUFBTSxJQUFJLEtBQUssQ0FBQywyREFBMkQsQ0FBQyxDQUFDO3lCQUM5RTt3QkFDRCxzQkFBTyxpQkFBaUIsRUFBQzs7O1NBQzFCLENBQUM7YUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ1YsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFDSCxzQkFBQztBQUFELENBQUMsQUFoVkQsSUFnVkM7QUFoVlksMENBQWUiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgeyBCaXRHbyB9IGZyb20gJy4uL2JpdGdvJztcbmltcG9ydCB7IHZhbGlkYXRlUGFyYW1zIH0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFJlcXVlc3RUcmFjZXIgfSBmcm9tICcuL2ludGVybmFsL3V0aWwnO1xuXG5pbXBvcnQgeyBOb2RlQ2FsbGJhY2sgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFdhbGxldCB9IGZyb20gJy4vd2FsbGV0JztcbmltcG9ydCB7IEJhc2VDb2luIH0gZnJvbSAnLi9iYXNlQ29pbic7XG5cbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBlbmRpbmdBcHByb3ZhbEluZm8ge1xuICB0eXBlOiBUeXBlO1xuICB0cmFuc2FjdGlvblJlcXVlc3Q/OiB7XG4gICAgY29pblNwZWNpZmljOiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuICAgIHJlY2lwaWVudHM6IGFueTtcbiAgICBidWlsZFBhcmFtczogYW55O1xuICAgIHNvdXJjZVdhbGxldD86IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQZW5kaW5nQXBwcm92YWxEYXRhIHtcbiAgaWQ6IHN0cmluZztcbiAgd2FsbGV0Pzogc3RyaW5nO1xuICBlbnRlcnByaXNlPzogc3RyaW5nO1xuICBzdGF0ZTogU3RhdGU7XG4gIGNyZWF0b3I6IHN0cmluZztcbiAgaW5mbzogUGVuZGluZ0FwcHJvdmFsSW5mbztcbiAgYXBwcm92YWxzUmVxdWlyZWQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBlbnVtIE93bmVyVHlwZSB7XG4gIFdBTExFVCA9ICd3YWxsZXQnLFxuICBFTlRFUlBSSVNFID0gJ2VudGVycHJpc2UnLFxufVxuXG5leHBvcnQgZW51bSBTdGF0ZSB7XG4gIFBFTkRJTkcgPSAncGVuZGluZycsXG4gIEFXQUlUSU5HX1NJR05BVFVSRSA9ICdhd2FpdGluZ1NpZ25hdHVyZScsXG4gIFBFTkRJTkdfQklUR09fQURNSU5fQVBQUk9WQUwgPSAncGVuZGluZ0JpdEdvQWRtaW5BcHByb3ZhbCcsXG4gIFBFTkRJTkdfSURfVkVSSUZJQ0FUSU9OID0gJ3BlbmRpbmdJZFZlcmlmaWNhdGlvbicsXG4gIFBFTkRJTkdfQ1VTVE9ESUFOX0FQUFJPVkFMID0gJ3BlbmRpbmdDdXN0b2RpYW5BcHByb3ZhbCcsXG4gIFBFTkRJTkdfRklOQUxfQVBQUk9WQUwgPSAncGVuZGluZ0ZpbmFsQXBwcm92YWwnLFxuICBBUFBST1ZFRCA9ICdhcHByb3ZlZCcsXG4gIFBST0NFU1NJTkcgPSAncHJvY2Vzc2luZycsXG4gIFJFSkVDVEVEID0gJ3JlamVjdGVkJyxcbn1cblxuZXhwb3J0IGVudW0gVHlwZSB7XG4gIFVTRVJfQ0hBTkdFX1JFUVVFU1QgPSAndXNlckNoYW5nZVJlcXVlc3QnLFxuICBUUkFOU0FDVElPTl9SRVFVRVNUID0gJ3RyYW5zYWN0aW9uUmVxdWVzdCcsXG4gIFBPTElDWV9SVUxFX1JFUVVFU1QgPSAncG9saWN5UnVsZVJlcXVlc3QnLFxuICBVUERBVEVfQVBQUk9WQUxTX1JFUVVJUkVEX1JFUVVFU1QgPSAndXBkYXRlQXBwcm92YWxzUmVxdWlyZWRSZXF1ZXN0Jyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcHByb3ZlT3B0aW9ucyB7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIG90cD86IHN0cmluZztcbiAgdHg/OiBzdHJpbmc7XG4gIHhwcnY/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBQZW5kaW5nQXBwcm92YWwge1xuICBwcml2YXRlIHJlYWRvbmx5IGJpdGdvOiBCaXRHbztcbiAgcHJpdmF0ZSByZWFkb25seSBiYXNlQ29pbjogQmFzZUNvaW47XG4gIHByaXZhdGUgd2FsbGV0PzogV2FsbGV0O1xuICBwcml2YXRlIF9wZW5kaW5nQXBwcm92YWw6IFBlbmRpbmdBcHByb3ZhbERhdGE7XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvLCBiYXNlQ29pbjogQmFzZUNvaW4sIHBlbmRpbmdBcHByb3ZhbERhdGE6IFBlbmRpbmdBcHByb3ZhbERhdGEsIHdhbGxldD86IFdhbGxldCkge1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgICB0aGlzLmJhc2VDb2luID0gYmFzZUNvaW47XG4gICAgdGhpcy53YWxsZXQgPSB3YWxsZXQ7XG4gICAgdGhpcy5fcGVuZGluZ0FwcHJvdmFsID0gcGVuZGluZ0FwcHJvdmFsRGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGlkIGZvciB0aGlzIFBlbmRpbmdBcHByb3ZhbFxuICAgKi9cbiAgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3duZXIgdHlwZSAod2FsbGV0IG9yIGVudGVycHJpc2UpXG4gICAqIFBlbmRpbmcgYXBwcm92YWxzIGNhbiBiZSBhcHByb3ZlZCBvciBtb2RpZmllZCBieSBkaWZmZXJlbnQgc2NvcGVzIChkZXBlbmRpbmcgb24gaG93IHRoZXkgd2VyZSBjcmVhdGVkKVxuICAgKiBJZiBhIHBlbmRpbmcgYXBwcm92YWwgaXMgb3duZWQgYnkgYSB3YWxsZXQsIHRoZW4gaXQgY2FuIGJlIGFwcHJvdmVkIGJ5IGFkbWluaXN0cmF0b3JzIG9mIHRoZSB3YWxsZXRcbiAgICogSWYgYSBwZW5kaW5nIGFwcHJvdmFsIGlzIG93bmVkIGJ5IGFuIGVudGVycHJpc2UsIHRoZW4gaXQgY2FuIGJlIGFwcHJvdmVkIGJ5IGFkbWluaXN0cmF0b3JzIG9mIHRoZSBlbnRlcnByaXNlXG4gICAqL1xuICBvd25lclR5cGUoKTogT3duZXJUeXBlIHtcbiAgICBpZiAodGhpcy5fcGVuZGluZ0FwcHJvdmFsLndhbGxldCkge1xuICAgICAgcmV0dXJuIE93bmVyVHlwZS5XQUxMRVQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wZW5kaW5nQXBwcm92YWwuZW50ZXJwcmlzZSkge1xuICAgICAgcmV0dXJuIE93bmVyVHlwZS5FTlRFUlBSSVNFO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgcGVuZGluZyBhcHByb3ZhbCBvd25lcjogbmVpdGhlciB3YWxsZXQgbm9yIGVudGVycHJpc2Ugd2FzIHByZXNlbnQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpZCBvZiB0aGUgd2FsbGV0IHdoaWNoIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFBlbmRpbmdBcHByb3ZhbFxuICAgKi9cbiAgd2FsbGV0SWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLndhbGxldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVudGVycHJpc2UgSUQgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBQZW5kaW5nQXBwcm92YWxcbiAgICovXG4gIGVudGVycHJpc2VJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwuZW50ZXJwcmlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YXRlIG9mIHRoaXMgUGVuZGluZ0FwcHJvdmFsXG4gICAqL1xuICBzdGF0ZSgpOiBTdGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbC5zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGlkIG9mIHRoZSB1c2VyIHRoYXQgcGVyZm9ybWVkIHRoZSBhY3Rpb24gcmVzdWx0aW5nIGluIHRoaXMgUGVuZGluZ0FwcHJvdmFsXG4gICAqL1xuICBjcmVhdG9yKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbC5jcmVhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHlwZSBvZiB0aGUgcGVuZGluZyBhcHByb3ZhbCAod2hhdCBpdCBhcHByb3ZlcylcbiAgICovXG4gIHR5cGUoKTogVHlwZSB7XG4gICAgaWYgKCF0aGlzLl9wZW5kaW5nQXBwcm92YWwuaW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwZW5kaW5nIGFwcHJvdmFsIGluZm8gaXMgbm90IGF2YWlsYWJsZScpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwuaW5mby50eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIFBlbmRpbmdBcHByb3ZhbFxuICAgKi9cbiAgaW5mbygpOiBQZW5kaW5nQXBwcm92YWxJbmZvIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLmluZm87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgYXBwcm92YWxzIHRoYXQgYXJlIHJlcXVpcmVkIGZvciB0aGlzIFBlbmRpbmdBcHByb3ZhbCB0byBiZSBhcHByb3ZlZC5cbiAgICogRGVmYXVsdHMgdG8gMSBpZiBhcHByb3ZhbHNSZXF1aXJlZCBkb2Vzbid0IGV4aXN0IG9uIHRoZSBvYmplY3RcbiAgICovXG4gIGFwcHJvdmFsc1JlcXVpcmVkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbC5hcHByb3ZhbHNSZXF1aXJlZCB8fCAxO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdXJsIGZvciB0aGlzIFBlbmRpbmdBcHByb3ZhbCBmb3IgbWFraW5nIHJlcXVlc3RzIHRvIHRoZSBzZXJ2ZXIuXG4gICAqIEBwYXJhbSBleHRyYVxuICAgKi9cbiAgdXJsKGV4dHJhOiBzdHJpbmcgPSAnJyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZUNvaW4udXJsKCcvcGVuZGluZ2FwcHJvdmFscy8nICsgdGhpcy5pZCgpICsgZXh0cmEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZmV0Y2hlcyB0aGlzIFBlbmRpbmdBcHByb3ZhbCBmcm9tIHRoZSBzZXJ2ZXIgYW5kIHJldHVybnMgaXQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG11dGF0ZXMgdGhlIFBlbmRpbmdBcHByb3ZhbCBvYmplY3QgaW4gcGxhY2UuXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBnZXQocGFyYW1zOiB7fSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQZW5kaW5nQXBwcm92YWw+KTogQmx1ZWJpcmQ8UGVuZGluZ0FwcHJvdmFsPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFBlbmRpbmdBcHByb3ZhbD4oZnVuY3Rpb24qKCkge1xuICAgICAgc2VsZi5fcGVuZGluZ0FwcHJvdmFsID0geWllbGQgc2VsZi5iaXRnby5nZXQoc2VsZi51cmwoKSkucmVzdWx0KCk7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZW5zdXJlIHRoYXQgc2VsZi53YWxsZXQgaXMgc2V0XG4gICAqL1xuICBwcml2YXRlIHBvcHVsYXRlV2FsbGV0KCk6IEJsdWViaXJkPHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzx1bmRlZmluZWQ+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uUmVxdWVzdCA9IHNlbGYuaW5mbygpLnRyYW5zYWN0aW9uUmVxdWVzdDtcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHRyYW5zYWN0aW9uUmVxdWVzdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIG9iamVjdCBwcm9wZXJ0eSB0cmFuc2FjdGlvblJlcXVlc3QnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoc2VsZi53YWxsZXQpKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRXYWxsZXQ6IFdhbGxldCA9IHlpZWxkIHNlbGYuYmFzZUNvaW4ud2FsbGV0cygpLmdldCh7IGlkOiB0cmFuc2FjdGlvblJlcXVlc3Quc291cmNlV2FsbGV0IH0pO1xuXG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHVwZGF0ZWRXYWxsZXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIC0gdW5hYmxlIHRvIGdldCB3YWxsZXQgdXNpbmcgc291cmNld2FsbGV0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLndhbGxldCA9IHVwZGF0ZWRXYWxsZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLndhbGxldC5pZCgpICE9PSB0cmFuc2FjdGlvblJlcXVlc3Quc291cmNlV2FsbGV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBzb3VyY2Ugd2FsbGV0IGZvciBwZW5kaW5nIGFwcHJvdmFsJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIG90aGVyd2lzZSByZXR1cm5zIHVuZGVmaW5lZFxuICAgIH0pLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIFBlbmRpbmdBcHByb3ZhbCB0byBhbiBhcHByb3ZlZCBzdGF0ZVxuICAgKi9cbiAgYXBwcm92ZShwYXJhbXM6IEFwcHJvdmVPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24qKCkge1xuICAgICAgdmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWyd3YWxsZXRQYXNzcGhyYXNlJywgJ290cCddLCBjYWxsYmFjayk7XG5cbiAgICAgIGxldCBjYW5SZWNyZWF0ZVRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgIC8qXG4gICAgICAgKiBDb2xkIHdhbGxldHMgY2Fubm90IHJlY3JlYXRlIHRyYW5zYWN0aW9ucyBpZiB0aGUgb25seSB0aGluZyBwcm92aWRlZCBpcyB0aGUgd2FsbGV0IHBhc3NwaHJhc2VcbiAgICAgICAqXG4gICAgICAgKiBUaGUgdHJhbnNhY3Rpb24gY2FuIGJlIHJlY3JlYXRlZCBpZiBlaXRoZXJcbiAgICAgICAqIOKAkyB0aGVyZSBpcyBhbiB4cHJ2XG4gICAgICAgKiDigJMgdGhlcmUgaXMgYSB3YWxsZXRQYXNzcGhyYXNlIGFuZCB0aGUgd2FsbGV0IGlzIG5vdCBjb2xkIChiZWNhdXNlIGlmIGl0J3MgY29sZCwgdGhlIHBhc3NwaHJhc2UgaXMgb2YgbGl0dGxlIHVzZSlcbiAgICAgICAqXG4gICAgICAgKiBUaGVyZWZvcmUsIGlmIG5laXRoZXIgb2YgdGhlc2UgaXMgdHJ1ZSwgdGhlIHRyYW5zYWN0aW9uIGNhbm5vdCBiZSByZWNyZWF0ZWQsIHdoaWNoIGlzIHJlZmxlY3RlZCBpbiB0aGUgaWZcbiAgICAgICAqIHN0YXRlbWVudCBiZWxvdy5cbiAgICAgICAqL1xuICAgICAgY29uc3QgaXNDb2xkV2FsbGV0ID0gISFfLmdldChzZWxmLndhbGxldCwgJ193YWxsZXQuaXNDb2xkJyk7XG4gICAgICBjb25zdCBpc09GQ1dhbGxldCA9IHNlbGYuYmFzZUNvaW4uZ2V0RmFtaWx5KCkgPT09ICdvZmMnOyAvLyBPZmYtY2hhaW4gdHJhbnNhY3Rpb25zIGRvbid0IG5lZWQgdG8gYmUgcmVidWlsdFxuICAgICAgaWYgKCFwYXJhbXMueHBydiAmJiAhKHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlICYmICFpc0NvbGRXYWxsZXQgJiYgIWlzT0ZDV2FsbGV0KSkge1xuICAgICAgICBjYW5SZWNyZWF0ZVRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcUlkID0gbmV3IFJlcXVlc3RUcmFjZXIoKTtcblxuICAgICAgLypcbiAgICAgICAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gd2hpY2ggaXMgYmVpbmcgYXBwcm92ZWRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZ2V0QXBwcm92YWxUcmFuc2FjdGlvbigpOiBCbHVlYmlyZDx7IHR4SGV4OiBzdHJpbmcgfT4ge1xuICAgICAgICByZXR1cm4gY288eyB0eEhleDogc3RyaW5nIH0+KGZ1bmN0aW9uKigpIHtcbiAgICAgICAgICBpZiAoc2VsZi50eXBlKCkgPT09ICd0cmFuc2FjdGlvblJlcXVlc3QnKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhIHJlcXVlc3QgZm9yIGFwcHJvdmluZyBhIHRyYW5zYWN0aW9uLCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGlzIHVzZXIgaGFzIGEgcHJpdmF0ZSBrZXkgdG8gdGhlIHdhbGxldFxuICAgICAgICAgICAgICogKHNvbWUgYWRtaW5zIG1heSBub3QgaGF2ZSB0aGUgc3BlbmQgcGVybWlzc2lvbiksIHRoZSB0cmFuc2FjdGlvbiBjb3VsZCBlaXRoZXIgYmUgcmVicm9hZGNhc3QgYXMgaXMsIG9yIGl0IGNvdWxkXG4gICAgICAgICAgICAgKiBiZSByZWNvbnN0cnVjdGVkLiBJdCBpcyBwcmVmZXJhYmxlIHRvIHJlY29uc3RydWN0IGEgdHggaW4gb3JkZXIgdG8gYWRoZXJlIHRvIHRoZSBsYXRlc3QgbmV0d29yayBjb25kaXRpb25zXG4gICAgICAgICAgICAgKiBzdWNoIGFzIG5ld2VyIHVuc3BlbnRzLCBkaWZmZXJlbnQgZmVlcywgb3IgYSBoaWdoZXIgc2VxdWVuY2UgaWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHBhcmFtcy50eCkge1xuICAgICAgICAgICAgICAvLyB0aGUgYXBwcm92YWwgdHggd2FzIHJlY29uc3RydWN0ZWQgYW5kIGV4cGxpY2l0bHkgc3BlY2lmaWVkIC0gcGFzcyBpdCB0aHJvdWdoXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHhIZXg6IHBhcmFtcy50eCxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBfLmdldChzZWxmLmluZm8oKSwgYHRyYW5zYWN0aW9uUmVxdWVzdC5jb2luU3BlY2lmaWMuJHtzZWxmLmJhc2VDb2luLnR5cGV9YCk7XG5cbiAgICAgICAgICAgIC8vIHRoaXMgdXNlciBtYXkgbm90IGhhdmUgc3BlbmRpbmcgcHJpdmlsZWdlcyBvciBhIHBhc3NwaHJhc2UgbWF5IG5vdCBoYXZlIGJlZW4gcGFzc2VkIGluXG4gICAgICAgICAgICBpZiAoIWNhblJlY3JlYXRlVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgaWYgKCFfLmlzT2JqZWN0KHRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGhlcmUgaXMgbmVpdGhlciBhbiBvcmlnaW5hbCB0cmFuc2FjdGlvbiBvYmplY3Qgbm9yIGNhbiBhIG5ldyBvbmUgYmUgcmVjcmVhdGVkJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuICAgICAgICAgICAgeWllbGQgc2VsZi5wb3B1bGF0ZVdhbGxldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHNlbGYucmVjcmVhdGVBbmRTaWduVHJhbnNhY3Rpb24ocGFyYW1zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gcHJlcGFyZSB0aGUgYXBwcm92YWwgcGF5bG9hZCBhbmQgc2VuZCBpdCB0byBiaXRnb1xuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBzZW5kQXBwcm92YWwodHJhbnNhY3Rpb246IHsgdHhIZXg6IHN0cmluZzsgaGFsZlNpZ25lZD86IHN0cmluZyB9KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgICAgIHJldHVybiBjbyhmdW5jdGlvbiooKSB7XG4gICAgICAgICAgY29uc3QgYXBwcm92YWxQYXJhbXM6IGFueSA9IHsgc3RhdGU6ICdhcHByb3ZlZCcsIG90cDogcGFyYW1zLm90cCB9O1xuICAgICAgICAgIGlmICh0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHRyYW5zYWN0aW9uIGFscmVhZHkgaGFzIGEgaGFsZiBzaWduZWQgcHJvcGVydHksIHdlIHRha2UgdGhhdCBkaXJlY3RseVxuICAgICAgICAgICAgYXBwcm92YWxQYXJhbXMuaGFsZlNpZ25lZCA9IHRyYW5zYWN0aW9uLmhhbGZTaWduZWQgfHwgdHJhbnNhY3Rpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuYml0Z29cbiAgICAgICAgICAgIC5wdXQoc2VsZi51cmwoKSlcbiAgICAgICAgICAgIC5zZW5kKGFwcHJvdmFsUGFyYW1zKVxuICAgICAgICAgICAgLnJlc3VsdCgpXG4gICAgICAgICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFwcHJvdmFsVHJhbnNhY3Rpb24gPSB5aWVsZCBnZXRBcHByb3ZhbFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIHNlbGYuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgICAgIHJldHVybiB5aWVsZCBzZW5kQXBwcm92YWwoYXBwcm92YWxUcmFuc2FjdGlvbik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhY2FuUmVjcmVhdGVUcmFuc2FjdGlvbiAmJlxuICAgICAgICAgIChlLm1lc3NhZ2UuaW5kZXhPZignY291bGQgbm90IGZpbmQgdW5zcGVudCBvdXRwdXQgZm9yIGlucHV0JykgIT09IC0xIHx8XG4gICAgICAgICAgICBlLm1lc3NhZ2UuaW5kZXhPZigndHJhbnNhY3Rpb24gY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgdHJhbnNhY3Rpb24gaW4gdGhlIHNlbmQgcXVldWUnKSAhPT0gLTEpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zcGVudHMgZXhwaXJlZCwgd2FsbGV0IHBhc3NwaHJhc2Ugb3IgeHBydiByZXF1aXJlZCB0byByZWNyZWF0ZSB0cmFuc2FjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIFBlbmRpbmdBcHByb3ZhbCB0byBhIHJlamVjdGVkIHN0YXRlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICByZWplY3QocGFyYW1zOiB7fSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYml0Z29cbiAgICAgIC5wdXQodGhpcy51cmwoKSlcbiAgICAgIC5zZW5kKHsgc3RhdGU6ICdyZWplY3RlZCcgfSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciBQZW5kaW5nQXBwcm92YWwucmVqZWN0KClcbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGNhbmNlbChwYXJhbXM6IHt9ID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3QocGFyYW1zLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmVjcmVhdGUgYSB0cmFuc2FjdGlvbiBmb3IgYSBwZW5kaW5nIGFwcHJvdmFsIHRvIHJlc3BvbmQgdG8gdXBkYXRlZCBuZXR3b3JrIGNvbmRpdGlvbnNcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHJlY3JlYXRlQW5kU2lnblRyYW5zYWN0aW9uKHBhcmFtczogYW55ID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24qKCkge1xuICAgICAgLy8gdGhpcyBtZXRob2Qgb25seSBtYWtlcyBzZW5zZSB3aXRoIGV4aXN0aW5nIHRyYW5zYWN0aW9uIHJlcXVlc3RzXG4gICAgICBjb25zdCB0cmFuc2FjdGlvblJlcXVlc3QgPSBzZWxmLmluZm8oKS50cmFuc2FjdGlvblJlcXVlc3Q7XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh0cmFuc2FjdGlvblJlcXVlc3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHJlY3JlYXRlIHRyYW5zYWN0aW9uIHdpdGhvdXQgdHJhbnNhY3Rpb24gcmVxdWVzdCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChzZWxmLndhbGxldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcmVjcmVhdGUgdHJhbnNhY3Rpb24gd2l0aG91dCB3YWxsZXQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3JpZ2luYWxQcmVidWlsZCA9IHRyYW5zYWN0aW9uUmVxdWVzdC5jb2luU3BlY2lmaWNbc2VsZi5iYXNlQ29pbi50eXBlXTtcblxuICAgICAgY29uc3QgcmVjaXBpZW50cyA9IHRyYW5zYWN0aW9uUmVxdWVzdC5yZWNpcGllbnRzO1xuICAgICAgY29uc3QgcHJlYnVpbGRQYXJhbXMgPSBfLmV4dGVuZCh7fSwgcGFyYW1zLCB7IHJlY2lwaWVudHM6IHJlY2lwaWVudHMgfSwgdHJhbnNhY3Rpb25SZXF1ZXN0LmJ1aWxkUGFyYW1zKTtcblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKG9yaWdpbmFsUHJlYnVpbGQuaG9wVHJhbnNhY3Rpb24pKSB7XG4gICAgICAgIHByZWJ1aWxkUGFyYW1zLmhvcCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVjaXBpZW50cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gbm8gcmVjaXBpZW50cyAtIHRoaXMgaXMgYSBjb25zb2xpZGF0aW9uIHRyYW5zYWN0aW9uXG4gICAgICAgIHByZWJ1aWxkUGFyYW1zLnByZWJ1aWxkVHggPSB5aWVsZCBzZWxmLmJpdGdvXG4gICAgICAgICAgLnBvc3Qoc2VsZi53YWxsZXQudXJsKGAvY29uc29saWRhdGVVbnNwZW50c2ApKVxuICAgICAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgICAgICAucmVzdWx0KCk7XG4gICAgICAgIGRlbGV0ZSBwcmVidWlsZFBhcmFtcy5yZWNpcGllbnRzO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbiA9IHlpZWxkIHNlbGYud2FsbGV0LnByZWJ1aWxkQW5kU2lnblRyYW5zYWN0aW9uKHByZWJ1aWxkUGFyYW1zKTtcbiAgICAgIC8vIGNvbXBhcmUgUEFZR28gZmVlc1xuICAgICAgY29uc3Qgb3JpZ2luYWxQYXJzZWRUcmFuc2FjdGlvbiA9IHlpZWxkIHNlbGYuYmFzZUNvaW4ucGFyc2VUcmFuc2FjdGlvbih7XG4gICAgICAgIHR4UGFyYW1zOiBwcmVidWlsZFBhcmFtcyxcbiAgICAgICAgd2FsbGV0OiBzZWxmLndhbGxldCxcbiAgICAgICAgdHhQcmVidWlsZDogb3JpZ2luYWxQcmVidWlsZCxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVjcmVhdGVkUGFyc2VkVHJhbnNhY3Rpb24gPSB5aWVsZCBzZWxmLmJhc2VDb2luLnBhcnNlVHJhbnNhY3Rpb24oe1xuICAgICAgICB0eFBhcmFtczogcHJlYnVpbGRQYXJhbXMsXG4gICAgICAgIHdhbGxldDogc2VsZi53YWxsZXQsXG4gICAgICAgIHR4UHJlYnVpbGQ6IHNpZ25lZFRyYW5zYWN0aW9uLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHJlY3JlYXRlZFBhcnNlZFRyYW5zYWN0aW9uLmltcGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudCkpIHtcbiAgICAgICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNGaW5pdGUocmVjcmVhdGVkUGFyc2VkVHJhbnNhY3Rpb24uaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ltcGxpY2l0IGV4dGVybmFsIHNwZW5kIGFtb3VudCBjb3VsZCBub3QgYmUgZGV0ZXJtaW5lZCcpO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICAhXy5pc1VuZGVmaW5lZChvcmlnaW5hbFBhcnNlZFRyYW5zYWN0aW9uLmltcGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudCkgJiZcbiAgICAgICAgcmVjcmVhdGVkUGFyc2VkVHJhbnNhY3Rpb24uaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50ID4gb3JpZ2luYWxQYXJzZWRUcmFuc2FjdGlvbi5pbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnRcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY3JlYXRlZCB0cmFuc2FjdGlvbiBpcyB1c2luZyBhIGhpZ2hlciBwYXktYXMteW91LWdvLWZlZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9uO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG59XG4iXX0=