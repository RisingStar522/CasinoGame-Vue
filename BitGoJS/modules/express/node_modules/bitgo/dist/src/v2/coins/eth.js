"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var bignumber_js_1 = require("bignumber.js");
var utxoLib = require("@bitgo/utxo-lib");
var Bluebird = require("bluebird");
var crypto_1 = require("crypto");
var debugLib = require("debug");
var Keccak = require("keccak");
var _ = require("lodash");
var secp256k1 = require("secp256k1");
var request = require("superagent");
var baseCoin_1 = require("../baseCoin");
var erc20Token_1 = require("./erc20Token");
var wallet_1 = require("../wallet");
var common = require("../../common");
var config = require("../../config");
var util_1 = require("../internal/util");
var errors_1 = require("../../errors");
var co = Bluebird.coroutine;
var debug = debugLib('bitgo:v2:eth');
exports.optionalDeps = {
    get ethAbi() {
        try {
            return require('ethereumjs-abi');
        }
        catch (e) {
            debug('unable to load ethereumjs-abi:');
            debug(e.stack);
            throw new errors_1.EthereumLibraryUnavailableError("ethereumjs-abi");
        }
    },
    get ethUtil() {
        try {
            return require('ethereumjs-util');
        }
        catch (e) {
            debug('unable to load ethereumjs-util:');
            debug(e.stack);
            throw new errors_1.EthereumLibraryUnavailableError("ethereumjs-util");
        }
    },
    get EthTx() {
        try {
            return require('ethereumjs-tx');
        }
        catch (e) {
            debug('unable to load ethereumjs-tx:');
            debug(e.stack);
            throw new errors_1.EthereumLibraryUnavailableError("ethereumjs-tx");
        }
    },
};
var Eth = /** @class */ (function (_super) {
    __extends(Eth, _super);
    function Eth() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Eth.createInstance = function (bitgo) {
        return new Eth(bitgo);
    };
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    Eth.prototype.getBaseFactor = function () {
        // 10^18
        return '1000000000000000000';
    };
    Eth.prototype.getChain = function () {
        return 'eth';
    };
    Eth.prototype.getFamily = function () {
        return 'eth';
    };
    Eth.prototype.getFullName = function () {
        return 'Ethereum';
    };
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    Eth.prototype.valuelessTransferAllowed = function () {
        return true;
    };
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    Eth.prototype.transactionDataAllowed = function () {
        return true;
    };
    /**
     * Evaluates whether an address string is valid for this coin
     * @param address
     */
    Eth.prototype.isValidAddress = function (address) {
        return exports.optionalDeps.ethUtil.isValidAddress(exports.optionalDeps.ethUtil.addHexPrefix(address));
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Eth.prototype.isValidPub = function (pub) {
        try {
            utxoLib.HDNode.fromBase58(pub);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Default gas price from platform
     * @returns {BigNumber}
     */
    Eth.prototype.getRecoveryGasPrice = function () {
        return new exports.optionalDeps.ethUtil.BN('20000000000');
    };
    /**
     * Default gas limit from platform
     * @returns {BigNumber}
     */
    Eth.prototype.getRecoveryGasLimit = function () {
        return new exports.optionalDeps.ethUtil.BN('500000');
    };
    /**
     * Default expire time for a contract call (1 week)
     * @returns {number} Time in seconds
     */
    Eth.prototype.getDefaultExpireTime = function () {
        return Math.floor(new Date().getTime() / 1000) + 60 * 60 * 24 * 7;
    };
    /**
     * Query Etherscan for the balance of an address
     * @param address {String} the ETH address
     * @param callback
     * @returns {BigNumber} address balance
     */
    Eth.prototype.queryAddressBalance = function (address, callback) {
        var self = this;
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.recoveryBlockchainExplorerQuery({
                            module: 'account',
                            action: 'balance',
                            address: address,
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new exports.optionalDeps.ethUtil.BN(result.result, 10)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Query Etherscan for the balance of an address for a token
     * @param tokenContractAddress {String} address where the token smart contract is hosted
     * @param walletContractAddress {String} address of the wallet
     * @param callback
     * @returns {BigNumber} token balaance in base units
     */
    Eth.prototype.queryAddressTokenBalance = function (tokenContractAddress, walletContractAddress, callback) {
        var self = this;
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!exports.optionalDeps.ethUtil.isValidAddress(tokenContractAddress)) {
                            throw new Error('cannot get balance for invalid token address');
                        }
                        if (!exports.optionalDeps.ethUtil.isValidAddress(walletContractAddress)) {
                            throw new Error('cannot get token balance for invalid wallet address');
                        }
                        return [4 /*yield*/, self.recoveryBlockchainExplorerQuery({
                                module: 'account',
                                action: 'tokenbalance',
                                contractaddress: tokenContractAddress,
                                address: walletContractAddress,
                                tag: 'latest',
                            })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new exports.optionalDeps.ethUtil.BN(result.result, 10)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Get transfer operation for coin
     * @param recipient recipient info
     * @param expireTime expiry time
     * @param contractSequenceId sequence id
     * @returns {Array} operation array
     */
    Eth.prototype.getOperation = function (recipient, expireTime, contractSequenceId) {
        return [
            ['string', 'address', 'uint', 'bytes', 'uint', 'uint'],
            [
                'ETHER',
                new exports.optionalDeps.ethUtil.BN(exports.optionalDeps.ethUtil.stripHexPrefix(recipient.address), 16),
                recipient.amount,
                Buffer.from(exports.optionalDeps.ethUtil.stripHexPrefix(recipient.data) || '', 'hex'),
                expireTime,
                contractSequenceId,
            ],
        ];
    };
    Eth.prototype.getOperationSha3ForExecuteAndConfirm = function (recipients, expireTime, contractSequenceId) {
        var _a;
        if (!recipients || !Array.isArray(recipients)) {
            throw new Error('expecting array of recipients');
        }
        // Right now we only support 1 recipient
        if (recipients.length !== 1) {
            throw new Error('must send to exactly 1 recipient');
        }
        if (!_.isNumber(expireTime)) {
            throw new Error('expireTime must be number of seconds since epoch');
        }
        if (!_.isNumber(contractSequenceId)) {
            throw new Error('contractSequenceId must be number');
        }
        // Check inputs
        recipients.forEach(function (recipient) {
            if (!_.isString(recipient.address) ||
                !exports.optionalDeps.ethUtil.isValidAddress(exports.optionalDeps.ethUtil.addHexPrefix(recipient.address))) {
                throw new Error('Invalid address: ' + recipient.address);
            }
            var amount;
            try {
                amount = new bignumber_js_1.BigNumber(recipient.amount);
            }
            catch (e) {
                throw new Error('Invalid amount for: ' + recipient.address + ' - should be numeric');
            }
            recipient.amount = amount.toFixed(0);
            if (recipient.data && !_.isString(recipient.data)) {
                throw new Error('Data for recipient ' + recipient.address + ' - should be of type hex string');
            }
        });
        var recipient = recipients[0];
        return exports.optionalDeps.ethUtil.bufferToHex((_a = exports.optionalDeps.ethAbi).soliditySHA3.apply(_a, this.getOperation(recipient, expireTime, contractSequenceId)));
    };
    /**
     * Queries the contract (via Etherscan) for the next sequence ID
     * @param address {String} address of the contract
     * @param callback
     * @returns {Number} sequence ID
     */
    Eth.prototype.querySequenceId = function (address, callback) {
        var self = this;
        return co(function () {
            var sequenceIdMethodSignature, sequenceIdArgs, sequenceIdData, result, sequenceIdHex;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sequenceIdMethodSignature = exports.optionalDeps.ethAbi.methodID('getNextSequenceId', []);
                        sequenceIdArgs = exports.optionalDeps.ethAbi.rawEncode([], []);
                        sequenceIdData = Buffer.concat([sequenceIdMethodSignature, sequenceIdArgs]).toString('hex');
                        return [4 /*yield*/, self.recoveryBlockchainExplorerQuery({
                                module: 'proxy',
                                action: 'eth_call',
                                to: address,
                                data: sequenceIdData,
                                tag: 'latest',
                            })];
                    case 1:
                        result = _a.sent();
                        sequenceIdHex = result.result;
                        return [2 /*return*/, new exports.optionalDeps.ethUtil.BN(sequenceIdHex.slice(2), 16).toNumber()];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Helper function for signTransaction for the rare case that SDK is doing the second signature
     * Note: we are expecting this to be called from the offline vault
     * @param params.txPrebuild
     * @param params.signingKeyNonce
     * @param params.walletContractAddress
     * @param params.prv
     * @returns {{txHex: *}}
     */
    Eth.prototype.signFinal = function (params) {
        var txPrebuild = params.txPrebuild;
        if (!_.isNumber(params.signingKeyNonce) && !_.isNumber(params.txPrebuild.halfSigned.backupKeyNonce)) {
            throw new Error('must have at least one of signingKeyNonce and backupKeyNonce as a parameter, and it must be a number');
        }
        if (_.isUndefined(params.walletContractAddress)) {
            throw new Error('params must include walletContractAddress, but got undefined');
        }
        var signingNode = utxoLib.HDNode.fromBase58(params.prv);
        var signingKey = signingNode.getKey().getPrivateKeyBuffer();
        var txInfo = {
            recipient: txPrebuild.recipients[0],
            expireTime: txPrebuild.halfSigned.expireTime,
            contractSequenceId: txPrebuild.halfSigned.contractSequenceId,
            signature: txPrebuild.halfSigned.signature,
        };
        var sendMethodArgs = this.getSendMethodArgs(txInfo);
        var methodSignature = exports.optionalDeps.ethAbi.methodID('sendMultiSig', _.map(sendMethodArgs, 'type'));
        var encodedArgs = exports.optionalDeps.ethAbi.rawEncode(_.map(sendMethodArgs, 'type'), _.map(sendMethodArgs, 'value'));
        var sendData = Buffer.concat([methodSignature, encodedArgs]);
        var ethTxParams = {
            to: params.walletContractAddress,
            nonce: params.signingKeyNonce || params.txPrebuild.halfSigned.backupKeyNonce,
            value: 0,
            gasPrice: new exports.optionalDeps.ethUtil.BN(txPrebuild.gasPrice),
            gasLimit: new exports.optionalDeps.ethUtil.BN(txPrebuild.gasLimit),
            data: sendData,
            spendAmount: params.recipients[0].amount,
        };
        var ethTx = new exports.optionalDeps.EthTx(ethTxParams);
        ethTx.sign(signingKey);
        return { txHex: ethTx.serialize().toString('hex') };
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @param callback
     * @returns {Bluebird<SignedTransaction>}
     */
    Eth.prototype.signTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txPrebuild, userPrv, EXPIRETIME_DEFAULT, secondsSinceEpoch, expireTime, sequenceId, operationHash, signature, txParams;
            return __generator(this, function (_a) {
                txPrebuild = params.txPrebuild;
                userPrv = params.prv;
                EXPIRETIME_DEFAULT = 60 * 60 * 24 * 7;
                if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
                    if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                        throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
                    }
                    throw new Error('missing txPrebuild parameter');
                }
                if (_.isUndefined(userPrv) || !_.isString(userPrv)) {
                    if (!_.isUndefined(userPrv) && !_.isString(userPrv)) {
                        throw new Error("prv must be a string, got type " + typeof userPrv);
                    }
                    throw new Error('missing prv parameter to sign transaction');
                }
                params.recipients = txPrebuild.recipients || params.recipients;
                // if no recipients in either params or txPrebuild, then throw an error
                if (!params.recipients || !Array.isArray(params.recipients)) {
                    throw new Error('recipients missing or not array');
                }
                // Normally the SDK provides the first signature for an ETH tx, but occasionally it provides the second and final one.
                if (params.isLastSignature) {
                    // In this case when we're doing the second (final) signature, the logic is different.
                    return [2 /*return*/, self.signFinal(params)];
                }
                secondsSinceEpoch = Math.floor(new Date().getTime() / 1000);
                expireTime = params.expireTime || secondsSinceEpoch + EXPIRETIME_DEFAULT;
                sequenceId = txPrebuild.nextContractSequenceId;
                if (_.isUndefined(sequenceId)) {
                    throw new Error('transaction prebuild missing required property nextContractSequenceId');
                }
                operationHash = self.getOperationSha3ForExecuteAndConfirm(params.recipients, expireTime, sequenceId);
                signature = util_1.Util.ethSignMsgHash(operationHash, util_1.Util.xprvToEthPrivateKey(userPrv));
                txParams = {
                    recipients: params.recipients,
                    expireTime: expireTime,
                    contractSequenceId: sequenceId,
                    sequenceId: params.sequenceId,
                    operationHash: operationHash,
                    signature: signature,
                    gasLimit: params.gasLimit,
                    gasPrice: params.gasPrice,
                    hopTransaction: txPrebuild.hopTransaction,
                    backupKeyNonce: txPrebuild.backupKeyNonce,
                };
                return [2 /*return*/, { halfSigned: txParams }];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Ensure either enterprise or newFeeAddress is passed, to know whether to create new key or use enterprise key
     * @param params
     * @param params.enterprise {String} the enterprise id to associate with this key
     * @param params.newFeeAddress {Boolean} create a new fee address (enterprise not needed in this case)
     */
    Eth.prototype.preCreateBitGo = function (params) {
        // We always need params object, since either enterprise or newFeeAddress is required
        if (!_.isObject(params)) {
            throw new Error("preCreateBitGo must be passed a params object. Got " + params + " (type " + typeof params + ")");
        }
        if (_.isUndefined(params.enterprise) && _.isUndefined(params.newFeeAddress)) {
            throw new Error('expecting enterprise when adding BitGo key. If you want to create a new ETH bitgo key, set the newFeeAddress parameter to true.');
        }
        // Check whether key should be an enterprise key or a BitGo key for a new fee address
        if (!_.isUndefined(params.enterprise) && !_.isUndefined(params.newFeeAddress)) {
            throw new Error("Incompatible arguments - cannot pass both enterprise and newFeeAddress parameter.");
        }
        if (!_.isUndefined(params.enterprise) && !_.isString(params.enterprise)) {
            throw new Error("enterprise should be a string - got " + params.enterprise + " (type " + typeof params.enterprise + ")");
        }
        if (!_.isUndefined(params.newFeeAddress) && !_.isBoolean(params.newFeeAddress)) {
            throw new Error("newFeeAddress should be a boolean - got " + params.newFeeAddress + " (type " + typeof params.newFeeAddress + ")");
        }
    };
    /**
     * Queries public block explorer to get the next ETH nonce that should be used for the given ETH address
     * @param address
     * @param callback
     * @returns {*}
     */
    Eth.prototype.getAddressNonce = function (address, callback) {
        var self = this;
        return co(function () {
            var nonce, result, backupKeyTxList, outgoingTxs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nonce = 0;
                        return [4 /*yield*/, self.recoveryBlockchainExplorerQuery({
                                module: 'account',
                                action: 'txlist',
                                address: address,
                            })];
                    case 1:
                        result = _a.sent();
                        backupKeyTxList = result.result;
                        if (backupKeyTxList.length > 0) {
                            outgoingTxs = backupKeyTxList.filter(function (tx) { return tx.from === address; });
                            nonce = outgoingTxs.length;
                        }
                        return [2 /*return*/, nonce];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Helper function for recover()
     * This transforms the unsigned transaction information into a format the BitGo offline vault expects
     * @param txInfo
     * @param ethTx
     * @param userKey
     * @param backupKey
     * @param gasPrice
     * @param gasLimit
     * @param callback
     * @returns {{tx: *, userKey: *, backupKey: *, coin: string, amount: string, gasPrice: string, gasLimit: string, recipients: ({address, amount}|{address: ({address, amount}|string), amount: string}|string)[]}}
     */
    Eth.prototype.formatForOfflineVault = function (txInfo, ethTx, userKey, backupKey, gasPrice, gasLimit, callback) {
        var self = this;
        return co(function () {
            var backupHDNode, backupSigningKey, response, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        backupHDNode = utxoLib.HDNode.fromBase58(backupKey);
                        backupSigningKey = backupHDNode.getKey().getPublicKeyBuffer();
                        _a = {
                            tx: ethTx.serialize().toString('hex'),
                            userKey: userKey,
                            backupKey: backupKey,
                            coin: self.getChain(),
                            gasPrice: exports.optionalDeps.ethUtil.bufferToInt(gasPrice).toFixed(),
                            gasLimit: gasLimit,
                            recipients: [txInfo.recipient],
                            walletContractAddress: '0x' + ethTx.to.toString('hex'),
                            amount: txInfo.recipient.amount
                        };
                        return [4 /*yield*/, self.getAddressNonce("0x" + exports.optionalDeps.ethUtil.publicToAddress(backupSigningKey, true).toString('hex'))];
                    case 1:
                        response = (_a.backupKeyNonce = _b.sent(),
                            _a);
                        _.extend(response, txInfo);
                        response.nextContractSequenceId = response.contractSequenceId;
                        return [2 /*return*/, response];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * @param params.userKey {String} [encrypted] xprv
     * @param params.backupKey {String} [encrypted] xprv or xpub if the xprv is held by a KRS provider
     * @param params.walletPassphrase {String} used to decrypt userKey and backupKey
     * @param params.walletContractAddress {String} the ETH address of the wallet contract
     * @param params.krsProvider {String} necessary if backup key is held by KRS
     * @param params.recoveryDestination {String} target address to send recovered funds to
     * @param callback
     */
    Eth.prototype.recover = function (params, callback) {
        var self = this;
        return co(function recover() {
            var isKrsRecovery, isUnsignedSweep, userKey, backupKey, gasPrice, gasLimit, backupKeyAddress, backupSigningKey, backupHDNode, backupPrv, backupHDNode, backupKeyNonce, backupKeyBalance, txAmount, recipients, sequenceId, operationHash, signature, txInfo, sendMethodArgs, methodSignature, encodedArgs, sendData, tx, signedTx;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (_.isUndefined(params.userKey)) {
                            throw new Error('missing userKey');
                        }
                        if (_.isUndefined(params.backupKey)) {
                            throw new Error('missing backupKey');
                        }
                        if (_.isUndefined(params.walletPassphrase) && !params.userKey.startsWith('xpub')) {
                            throw new Error('missing wallet passphrase');
                        }
                        if (_.isUndefined(params.walletContractAddress) || !self.isValidAddress(params.walletContractAddress)) {
                            throw new Error('invalid walletContractAddress');
                        }
                        if (_.isUndefined(params.recoveryDestination) || !self.isValidAddress(params.recoveryDestination)) {
                            throw new Error('invalid recoveryDestination');
                        }
                        isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
                        isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
                        if (isKrsRecovery && params.krsProvider && _.isUndefined(config.krsProviders[params.krsProvider])) {
                            throw new Error('unknown key recovery service provider');
                        }
                        userKey = params.userKey.replace(/\s/g, '');
                        backupKey = params.backupKey.replace(/\s/g, '');
                        gasPrice = self.getRecoveryGasPrice();
                        gasLimit = self.getRecoveryGasLimit();
                        // Decrypt private keys from KeyCard values if necessary
                        if (!userKey.startsWith('xpub') && !userKey.startsWith('xprv')) {
                            try {
                                userKey = self.bitgo.decrypt({
                                    input: userKey,
                                    password: params.walletPassphrase,
                                });
                            }
                            catch (e) {
                                throw new Error("Error decrypting user keychain: " + e.message);
                            }
                        }
                        if (isKrsRecovery || isUnsignedSweep) {
                            backupHDNode = utxoLib.HDNode.fromBase58(backupKey);
                            backupSigningKey = backupHDNode.getKey().getPublicKeyBuffer();
                            backupKeyAddress = "0x" + exports.optionalDeps.ethUtil.publicToAddress(backupSigningKey, true).toString('hex');
                        }
                        else {
                            backupPrv = void 0;
                            try {
                                backupPrv = self.bitgo.decrypt({
                                    input: backupKey,
                                    password: params.walletPassphrase,
                                });
                            }
                            catch (e) {
                                throw new Error("Error decrypting backup keychain: " + e.message);
                            }
                            backupHDNode = utxoLib.HDNode.fromBase58(backupPrv);
                            backupSigningKey = backupHDNode.getKey().getPrivateKeyBuffer();
                            backupKeyAddress = "0x" + exports.optionalDeps.ethUtil.privateToAddress(backupSigningKey).toString('hex');
                        }
                        return [4 /*yield*/, self.getAddressNonce(backupKeyAddress)];
                    case 1:
                        backupKeyNonce = _a.sent();
                        return [4 /*yield*/, self.queryAddressBalance(backupKeyAddress)];
                    case 2:
                        backupKeyBalance = _a.sent();
                        if (backupKeyBalance.lt(gasPrice.mul(gasLimit))) {
                            throw new Error("Backup key address " + backupKeyAddress + " has balance " + backupKeyBalance.toString(10) + ". This address must have a balance of at least 0.01 ETH to perform recoveries. Try sending some ETH to this address then retry.");
                        }
                        return [4 /*yield*/, self.queryAddressBalance(params.walletContractAddress)];
                    case 3:
                        txAmount = _a.sent();
                        recipients = [
                            {
                                address: params.recoveryDestination,
                                amount: txAmount.toString(10),
                            },
                        ];
                        return [4 /*yield*/, self.querySequenceId(params.walletContractAddress)];
                    case 4:
                        sequenceId = _a.sent();
                        // Get operation hash and sign it
                        if (!isUnsignedSweep) {
                            operationHash = self.getOperationSha3ForExecuteAndConfirm(recipients, self.getDefaultExpireTime(), sequenceId);
                            signature = util_1.Util.ethSignMsgHash(operationHash, util_1.Util.xprvToEthPrivateKey(userKey));
                            try {
                                util_1.Util.ecRecoverEthAddress(operationHash, signature);
                            }
                            catch (e) {
                                throw new Error('Invalid signature');
                            }
                        }
                        txInfo = {
                            recipient: recipients[0],
                            expireTime: self.getDefaultExpireTime(),
                            contractSequenceId: sequenceId,
                            operationHash: operationHash,
                            signature: signature,
                            gasLimit: gasLimit.toString(10),
                        };
                        sendMethodArgs = self.getSendMethodArgs(txInfo);
                        methodSignature = exports.optionalDeps.ethAbi.methodID('sendMultiSig', _.map(sendMethodArgs, 'type'));
                        encodedArgs = exports.optionalDeps.ethAbi.rawEncode(_.map(sendMethodArgs, 'type'), _.map(sendMethodArgs, 'value'));
                        sendData = Buffer.concat([methodSignature, encodedArgs]);
                        tx = new exports.optionalDeps.EthTx({
                            to: params.walletContractAddress,
                            nonce: backupKeyNonce,
                            value: 0,
                            gasPrice: gasPrice,
                            gasLimit: gasLimit,
                            data: sendData,
                            spendAmount: txAmount,
                        });
                        if (isUnsignedSweep) {
                            return [2 /*return*/, self.formatForOfflineVault(txInfo, tx, userKey, backupKey, gasPrice, gasLimit)];
                        }
                        if (!isKrsRecovery) {
                            tx.sign(backupSigningKey);
                        }
                        signedTx = {
                            id: exports.optionalDeps.ethUtil.bufferToHex(tx.hash(true)),
                            tx: tx.serialize().toString('hex'),
                        };
                        if (isKrsRecovery) {
                            signedTx.backupKey = backupKey;
                            signedTx.coin = self.getChain();
                        }
                        return [2 /*return*/, signedTx];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Recover an unsupported token from a BitGo multisig wallet
     * This builds a half-signed transaction, for which there will be an admin route to co-sign and broadcast. Optionally
     * the user can set params.broadcast = true and the half-signed tx will be sent to BitGo for cosigning and broadcasting
     * @param params
     * @param params.wallet the wallet to recover the token from
     * @param params.tokenContractAddress the contract address of the unsupported token
     * @param params.recipient the destination address recovered tokens should be sent to
     * @param params.walletPassphrase the wallet passphrase
     * @param params.prv the xprv
     * @param params.broadcast if true, we will automatically submit the half-signed tx to BitGo for cosigning and broadcasting
     * @param callback
     */
    Eth.prototype.recoverToken = function (params, callback) {
        var self = this;
        return co(function () {
            var coinSpecific, recoveryAmount, sendMethodArgs, methodSignature, encodedArgs, sendData, broadcastParams, recipient, expireTime, _a, nextContractSequenceId, gasPrice, gasLimit, safeSequenceId, operationTypes, operationArgs, operationHash, userPrv, signature, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!_.isObject(params)) {
                            throw new Error("recoverToken must be passed a params object. Got " + params + " (type " + typeof params + ")");
                        }
                        if (_.isUndefined(params.tokenContractAddress) || !_.isString(params.tokenContractAddress)) {
                            throw new Error("tokenContractAddress must be a string, got " + params.tokenContractAddress + " (type " + typeof params.tokenContractAddress + ")");
                        }
                        if (!self.isValidAddress(params.tokenContractAddress)) {
                            throw new Error('tokenContractAddress not a valid address');
                        }
                        if (_.isUndefined(params.wallet) || !(params.wallet instanceof wallet_1.Wallet)) {
                            throw new Error("wallet must be a wallet instance, got " + params.wallet + " (type " + typeof params.wallet + ")");
                        }
                        if (_.isUndefined(params.recipient) || !_.isString(params.recipient)) {
                            throw new Error("recipient must be a string, got " + params.recipient + " (type " + typeof params.recipient + ")");
                        }
                        if (!self.isValidAddress(params.recipient)) {
                            throw new Error('recipient not a valid address');
                        }
                        if (!exports.optionalDeps.ethUtil.bufferToHex || !exports.optionalDeps.ethAbi.soliditySHA3) {
                            throw new Error('ethereum not fully supported in this environment');
                        }
                        coinSpecific = params.wallet.coinSpecific();
                        if (!coinSpecific || !_.isString(coinSpecific.baseAddress)) {
                            throw new Error('missing required coin specific property baseAddress');
                        }
                        return [4 /*yield*/, self.queryAddressTokenBalance(params.tokenContractAddress, coinSpecific.baseAddress)];
                    case 1:
                        recoveryAmount = _b.sent();
                        if (!params.broadcast) return [3 /*break*/, 3];
                        sendMethodArgs = [
                            {
                                name: '_to',
                                type: 'address',
                                value: params.recipient,
                            },
                            {
                                name: '_value',
                                type: 'uint256',
                                value: recoveryAmount.toString(10),
                            },
                        ];
                        methodSignature = exports.optionalDeps.ethAbi.methodID('transfer', _.map(sendMethodArgs, 'type'));
                        encodedArgs = exports.optionalDeps.ethAbi.rawEncode(_.map(sendMethodArgs, 'type'), _.map(sendMethodArgs, 'value'));
                        sendData = Buffer.concat([methodSignature, encodedArgs]);
                        broadcastParams = {
                            address: params.tokenContractAddress,
                            amount: '0',
                            data: sendData.toString('hex'),
                        };
                        if (params.walletPassphrase) {
                            broadcastParams.walletPassphrase = params.walletPassphrase;
                        }
                        else if (params.prv) {
                            broadcastParams.prv = params.prv;
                        }
                        return [4 /*yield*/, params.wallet.send(broadcastParams)];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        recipient = {
                            address: params.recipient,
                            amount: recoveryAmount.toString(10),
                        };
                        expireTime = Math.floor(new Date().getTime() / 1000) + 60 * 60 * 24 * 7;
                        return [4 /*yield*/, params.wallet.prebuildTransaction({
                                recipients: [
                                    {
                                        address: params.recipient,
                                        amount: '1',
                                    },
                                ],
                            })];
                    case 4:
                        _a = _b.sent(), nextContractSequenceId = _a.nextContractSequenceId, gasPrice = _a.gasPrice, gasLimit = _a.gasLimit;
                        safeSequenceId = nextContractSequenceId + 1000;
                        operationTypes = ['string', 'address', 'uint', 'address', 'uint', 'uint'];
                        operationArgs = [
                            // "ERC20" has been added here so that ether operation hashes, signatures cannot be re-used for tokenSending
                            'ERC20',
                            new exports.optionalDeps.ethUtil.BN(exports.optionalDeps.ethUtil.stripHexPrefix(recipient.address), 16),
                            recipient.amount,
                            new exports.optionalDeps.ethUtil.BN(exports.optionalDeps.ethUtil.stripHexPrefix(params.tokenContractAddress), 16),
                            expireTime,
                            safeSequenceId,
                        ];
                        operationHash = exports.optionalDeps.ethUtil.bufferToHex(exports.optionalDeps.ethAbi.soliditySHA3(operationTypes, operationArgs));
                        return [4 /*yield*/, params.wallet.getPrv({
                                prv: params.prv,
                                walletPassphrase: params.walletPassphrase,
                            })];
                    case 5:
                        userPrv = _b.sent();
                        signature = util_1.Util.ethSignMsgHash(operationHash, util_1.Util.xprvToEthPrivateKey(userPrv));
                        result = {
                            halfSigned: {
                                recipient: recipient,
                                expireTime: expireTime,
                                contractSequenceId: safeSequenceId,
                                operationHash: operationHash,
                                signature: signature,
                                gasLimit: gasLimit,
                                gasPrice: gasPrice,
                                tokenContractAddress: params.tokenContractAddress,
                                walletId: params.wallet.id(),
                            },
                        };
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Build arguments to call the send method on the wallet contract
     * @param txInfo
     */
    Eth.prototype.getSendMethodArgs = function (txInfo) {
        // Method signature is
        // sendMultiSig(address toAddress, uint value, bytes data, uint expireTime, uint sequenceId, bytes signature)
        return [
            {
                name: 'toAddress',
                type: 'address',
                value: txInfo.recipient.address,
            },
            {
                name: 'value',
                type: 'uint',
                value: txInfo.recipient.amount,
            },
            {
                name: 'data',
                type: 'bytes',
                value: exports.optionalDeps.ethUtil.toBuffer(txInfo.recipient.data || ''),
            },
            {
                name: 'expireTime',
                type: 'uint',
                value: txInfo.expireTime,
            },
            {
                name: 'sequenceId',
                type: 'uint',
                value: txInfo.contractSequenceId,
            },
            {
                name: 'signature',
                type: 'bytes',
                value: exports.optionalDeps.ethUtil.toBuffer(txInfo.signature),
            },
        ];
    };
    /**
     * Make a query to Etherscan for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @param callback
     * @returns {Object} response from Etherscan
     */
    Eth.prototype.recoveryBlockchainExplorerQuery = function (query, callback) {
        var self = this;
        return co(function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (common.Environments[self.bitgo.getEnv()].etherscanApiToken) {
                            query.apikey = common.Environments[self.bitgo.getEnv()].etherscanApiToken;
                        }
                        return [4 /*yield*/, request
                                .get(common.Environments[self.bitgo.getEnv()].etherscanBaseUrl + '/api')
                                .query(query)];
                    case 1:
                        response = _a.sent();
                        if (!response.ok) {
                            throw new Error('could not reach Etherscan');
                        }
                        return [2 /*return*/, response.body];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Creates the extra parameters needed to build a hop transaction
     * @param buildParams The original build parameters
     * @param callback
     * @returns extra parameters object to merge with the original build parameters object and send to the platform
     */
    Eth.prototype.createHopTransactionParams = function (buildParams, callback) {
        var self = this;
        return co(function () {
            var wallet, recipients, walletPassphrase, userKeychain, userPrv, userPrvBuffer, recipientAddress, recipientAmount, feeEstimateParams, feeEstimate, gasLimit, gasPrice, gasPriceMax, paymentId, hopDigest, userReqSig, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        wallet = buildParams.wallet;
                        recipients = buildParams.recipients;
                        walletPassphrase = buildParams.walletPassphrase;
                        return [4 /*yield*/, self.keychains().get({ id: wallet.keyIds()[0] })];
                    case 1:
                        userKeychain = _a.sent();
                        userPrv = wallet.getUserPrv({ keychain: userKeychain, walletPassphrase: walletPassphrase });
                        userPrvBuffer = utxoLib.HDNode.fromBase58(userPrv)
                            .getKey()
                            .getPrivateKeyBuffer();
                        if (!recipients || !Array.isArray(recipients)) {
                            throw new Error('expecting array of recipients');
                        }
                        // Right now we only support 1 recipient
                        if (recipients.length !== 1) {
                            throw new Error('must send to exactly 1 recipient');
                        }
                        recipientAddress = recipients[0].address;
                        recipientAmount = recipients[0].amount;
                        feeEstimateParams = {
                            recipient: recipientAddress,
                            amount: recipientAmount,
                            hop: true,
                        };
                        return [4 /*yield*/, self.feeEstimate(feeEstimateParams)];
                    case 2:
                        feeEstimate = _a.sent();
                        gasLimit = feeEstimate.gasLimitEstimate;
                        gasPrice = Math.round(feeEstimate.feeEstimate / gasLimit);
                        gasPriceMax = gasPrice * 5;
                        paymentId = Math.floor(Math.random() * 10000000000).toString();
                        hopDigest = Eth.getHopDigest([
                            recipientAddress,
                            recipientAmount,
                            gasPriceMax.toString(),
                            gasLimit.toString(),
                            paymentId,
                        ]);
                        userReqSig = exports.optionalDeps.ethUtil.addHexPrefix(secp256k1.sign(hopDigest, userPrvBuffer).signature.toString('hex'));
                        result = {
                            hopParams: {
                                gasPriceMax: gasPriceMax,
                                userReqSig: userReqSig,
                                paymentId: paymentId,
                            },
                            gasLimit: gasLimit,
                        };
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Validates that the hop prebuild from the HSM is valid and correct
     * @param wallet The wallet that the prebuild is for
     * @param hopPrebuild The prebuild to validate
     * @param originalParams The original parameters passed to prebuildTransaction
     * @param callback
     * @returns void
     * @throws Error if The prebuild is invalid
     */
    Eth.prototype.validateHopPrebuild = function (wallet, hopPrebuild, originalParams, callback) {
        var self = this;
        return co(function () {
            var tx, id, signature, serverXpub, serverPubkeyBuffer, signatureBuffer, messageBuffer, isValidSignature, builtHopTx, recipients, originalAmount, originalDestination, hopAmount, hopDestination;
            return __generator(this, function (_a) {
                tx = hopPrebuild.tx, id = hopPrebuild.id, signature = hopPrebuild.signature;
                serverXpub = common.Environments[self.bitgo.getEnv()].hsmXpub;
                serverPubkeyBuffer = utxoLib.HDNode.fromBase58(serverXpub).getPublicKeyBuffer();
                signatureBuffer = Buffer.from(exports.optionalDeps.ethUtil.stripHexPrefix(signature), 'hex');
                messageBuffer = Buffer.from(exports.optionalDeps.ethUtil.stripHexPrefix(id), 'hex');
                isValidSignature = secp256k1.verify(messageBuffer, signatureBuffer.slice(1), serverPubkeyBuffer);
                if (!isValidSignature) {
                    throw new Error("Hop txid signature invalid");
                }
                builtHopTx = new exports.optionalDeps.EthTx(tx);
                // If original params are given, we can check them against the transaction prebuild params
                if (!_.isNil(originalParams)) {
                    recipients = originalParams.recipients;
                    originalAmount = new bignumber_js_1.BigNumber(recipients[0].amount);
                    originalDestination = recipients[0].address;
                    hopAmount = new bignumber_js_1.BigNumber(exports.optionalDeps.ethUtil.bufferToHex(builtHopTx.value));
                    hopDestination = exports.optionalDeps.ethUtil.bufferToHex(builtHopTx.to);
                    if (!hopAmount.eq(originalAmount)) {
                        throw new Error("Hop amount: " + hopAmount + " does not equal original amount: " + originalAmount);
                    }
                    if (hopDestination.toLowerCase() !== originalDestination.toLowerCase()) {
                        throw new Error("Hop destination: " + hopDestination + " does not equal original recipient: " + hopDestination);
                    }
                }
                if (!builtHopTx.verifySignature()) {
                    // We dont want to continue at all in this case, at risk of ETH being stuck on the hop address
                    throw new Error("Invalid hop transaction signature, txid: " + id);
                }
                if (exports.optionalDeps.ethUtil.addHexPrefix(builtHopTx.hash().toString('hex')) !== id) {
                    throw new Error("Signed hop txid does not equal actual txid");
                }
                return [2 /*return*/];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Gets the hop digest for the user to sign. This is validated in the HSM to prove that the user requested this tx
     * @param paramsArr The parameters to hash together for the digest
     */
    Eth.getHopDigest = function (paramsArr) {
        var hash = new Keccak('keccak256');
        hash.update([Eth.hopTransactionSalt].concat(paramsArr).join('$'));
        return hash.digest();
    };
    /**
     * Modify prebuild before sending it to the server. Add things like hop transaction params
     * @param buildParams The whitelisted parameters for this prebuild
     * @param buildParams.hop True if this should prebuild a hop tx, else false
     * @param buildParams.recipients The recipients array of this transaction
     * @param buildParams.wallet The wallet sending this tx
     * @param buildParams.walletPassphrase the passphrase for this wallet
     * @param callback
     */
    Eth.prototype.getExtraPrebuildParams = function (buildParams, callback) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!_.isUndefined(buildParams.hop) &&
                            buildParams.hop &&
                            !_.isUndefined(buildParams.wallet) &&
                            !_.isUndefined(buildParams.recipients) &&
                            !_.isUndefined(buildParams.walletPassphrase))) return [3 /*break*/, 2];
                        if (this instanceof erc20Token_1.Erc20Token) {
                            throw new Error("Hop transactions are not enabled for ERC-20 tokens, nor are they necessary. Please remove the 'hop' parameter and try again.");
                        }
                        return [4 /*yield*/, self.createHopTransactionParams({
                                wallet: buildParams.wallet,
                                recipients: buildParams.recipients,
                                walletPassphrase: buildParams.walletPassphrase,
                            })];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [2 /*return*/, {}];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    Eth.prototype.postProcessPrebuild = function (params, callback) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!_.isUndefined(params.hopTransaction) &&
                            !_.isUndefined(params.wallet) &&
                            !_.isUndefined(params.buildParams))) return [3 /*break*/, 2];
                        return [4 /*yield*/, self.validateHopPrebuild(params.wallet, params.hopTransaction, params.buildParams)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, params];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     * @param params
     * @param callback
     */
    Eth.prototype.presignTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!_.isUndefined(params.hopTransaction) &&
                            !_.isUndefined(params.wallet) &&
                            !_.isUndefined(params.buildParams))) return [3 /*break*/, 2];
                        return [4 /*yield*/, self.validateHopPrebuild(params.wallet, params.hopTransaction)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, params];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Boolean} [params.hop] True if we should estimate fee for a hop transaction
     * @param {String} [params.recipient] The recipient of the transaction to estimate a send to
     * @param {String} [params.data] The ETH tx data to estimate a send for
     * @param callback
     * @returns {Object} The fee info returned from the server
     */
    Eth.prototype.feeEstimate = function (params, callback) {
        var self = this;
        return co(function coFeeEstimate() {
            var query;
            return __generator(this, function (_a) {
                query = {};
                if (params && params.hop) {
                    query.hop = params.hop;
                }
                if (params && params.recipient) {
                    query.recipient = params.recipient;
                }
                if (params && params.data) {
                    query.data = params.data;
                }
                if (params && params.amount) {
                    query.amount = params.amount;
                }
                return [2 /*return*/, self.bitgo
                        .get(self.url('/tx/fee'))
                        .query(query)
                        .result()];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Generate secp256k1 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    Eth.prototype.generateKeyPair = function (seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto_1.randomBytes(512 / 8);
        }
        var extendedKey = utxoLib.HDNode.fromSeedBuffer(seed);
        var xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58(),
        };
    };
    Eth.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    Eth.prototype.verifyAddress = function (params) {
        return true;
    };
    Eth.prototype.verifyTransaction = function (params, callback) {
        return Bluebird.resolve(true).asCallback(callback);
    };
    Eth.hopTransactionSalt = 'bitgoHopAddressRequestSalt';
    return Eth;
}(baseCoin_1.BaseCoin));
exports.Eth = Eth;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXRoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL2V0aC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILDZDQUF5QztBQUN6Qyx5Q0FBMkM7QUFDM0MsbUNBQXFDO0FBQ3JDLGlDQUFxQztBQUNyQyxnQ0FBa0M7QUFDbEMsK0JBQWlDO0FBQ2pDLDBCQUE0QjtBQUM1QixxQ0FBdUM7QUFDdkMsb0NBQXNDO0FBRXRDLHdDQVVxQjtBQUNyQiwyQ0FBMEM7QUFHMUMsb0NBQW1DO0FBQ25DLHFDQUF1QztBQUN2QyxxQ0FBdUM7QUFDdkMseUNBQXdDO0FBQ3hDLHVDQUErRDtBQUUvRCxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBQzlCLElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUUxQixRQUFBLFlBQVksR0FBRztJQUMxQixJQUFJLE1BQU07UUFDUixJQUFJO1lBQ0YsT0FBTyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztTQUNsQztRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsS0FBSyxDQUFDLGdDQUFnQyxDQUFDLENBQUM7WUFDeEMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNmLE1BQU0sSUFBSSx3Q0FBK0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1NBQzdEO0lBQ0gsQ0FBQztJQUVELElBQUksT0FBTztRQUNULElBQUk7WUFDRixPQUFPLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1NBQ25DO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztZQUN6QyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ2YsTUFBTSxJQUFJLHdDQUErQixDQUFDLGlCQUFpQixD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QTVwQ0QsQ0FBeUIsbUJBQVEsR0E0cENoQztBQTVwQ1ksa0JBQUciLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0ICogYXMgdXR4b0xpYiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgZGVidWdMaWIgZnJvbSAnZGVidWcnO1xuaW1wb3J0ICogYXMgS2VjY2FrIGZyb20gJ2tlY2Nhayc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBzZWNwMjU2azEgZnJvbSAnc2VjcDI1NmsxJztcbmltcG9ydCAqIGFzIHJlcXVlc3QgZnJvbSAnc3VwZXJhZ2VudCc7XG5cbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBGZWVFc3RpbWF0ZU9wdGlvbnMsXG4gIEtleVBhaXIsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25QcmVidWlsZCBhcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgSGFsZlNpZ25lZFRyYW5zYWN0aW9uIGFzIEJhc2VIYWxmU2lnbmVkVHJhbnNhY3Rpb24sXG59IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IEVyYzIwVG9rZW4gfSBmcm9tICcuL2VyYzIwVG9rZW4nO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi8uLi9iaXRnbyc7XG5pbXBvcnQgeyBOb2RlQ2FsbGJhY2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBXYWxsZXQgfSBmcm9tICcuLi93YWxsZXQnO1xuaW1wb3J0ICogYXMgY29tbW9uIGZyb20gJy4uLy4uL2NvbW1vbic7XG5pbXBvcnQgKiBhcyBjb25maWcgZnJvbSAnLi4vLi4vY29uZmlnJztcbmltcG9ydCB7IFV0aWwgfSBmcm9tICcuLi9pbnRlcm5hbC91dGlsJztcbmltcG9ydCB7IEV0aGVyZXVtTGlicmFyeVVuYXZhaWxhYmxlRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuXG5jb25zdCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcbmNvbnN0IGRlYnVnID0gZGVidWdMaWIoJ2JpdGdvOnYyOmV0aCcpO1xuXG5leHBvcnQgY29uc3Qgb3B0aW9uYWxEZXBzID0ge1xuICBnZXQgZXRoQWJpKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVxdWlyZSgnZXRoZXJldW1qcy1hYmknKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygndW5hYmxlIHRvIGxvYWQgZXRoZXJldW1qcy1hYmk6Jyk7XG4gICAgICBkZWJ1ZyhlLnN0YWNrKTtcbiAgICAgIHRocm93IG5ldyBFdGhlcmV1bUxpYnJhcnlVbmF2YWlsYWJsZUVycm9yKGBldGhlcmV1bWpzLWFiaWApO1xuICAgIH1cbiAgfSxcblxuICBnZXQgZXRoVXRpbCgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCd1bmFibGUgdG8gbG9hZCBldGhlcmV1bWpzLXV0aWw6Jyk7XG4gICAgICBkZWJ1ZyhlLnN0YWNrKTtcbiAgICAgIHRocm93IG5ldyBFdGhlcmV1bUxpYnJhcnlVbmF2YWlsYWJsZUVycm9yKGBldGhlcmV1bWpzLXV0aWxgKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0IEV0aFR4KCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVxdWlyZSgnZXRoZXJldW1qcy10eCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCd1bmFibGUgdG8gbG9hZCBldGhlcmV1bWpzLXR4OicpO1xuICAgICAgZGVidWcoZS5zdGFjayk7XG4gICAgICB0aHJvdyBuZXcgRXRoZXJldW1MaWJyYXJ5VW5hdmFpbGFibGVFcnJvcihgZXRoZXJldW1qcy10eGApO1xuICAgIH1cbiAgfSxcbn07XG5cbi8qKlxuICogVGhlIGV4dHJhIHBhcmFtZXRlcnMgdG8gc2VuZCB0byBwbGF0Zm9ybSBidWlsZCByb3V0ZSBmb3IgaG9wIHRyYW5zYWN0aW9uc1xuICovXG5pbnRlcmZhY2UgSG9wUGFyYW1zIHtcbiAgaG9wUGFyYW1zOiB7XG4gICAgZ2FzUHJpY2VNYXg6IG51bWJlcjtcbiAgICB1c2VyUmVxU2lnOiBzdHJpbmc7XG4gICAgcGF5bWVudElkOiBzdHJpbmc7XG4gIH07XG4gIGdhc0xpbWl0OiBudW1iZXI7XG59XG5cbi8qKlxuICogVGhlIHByZWJ1aWx0IGhvcCB0cmFuc2FjdGlvbiByZXR1cm5lZCBmcm9tIHRoZSBIU01cbiAqL1xuaW50ZXJmYWNlIEhvcFByZWJ1aWxkIHtcbiAgdHg6IHN0cmluZztcbiAgaWQ6IHN0cmluZztcbiAgc2lnbmF0dXJlOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBSZWNpcGllbnQge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGFtb3VudDogc3RyaW5nO1xuICBkYXRhPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgU2lnbkZpbmFsT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IHtcbiAgICBnYXNQcmljZTogc3RyaW5nO1xuICAgIGdhc0xpbWl0OiBzdHJpbmc7XG4gICAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gICAgaGFsZlNpZ25lZDoge1xuICAgICAgZXhwaXJlVGltZTogbnVtYmVyO1xuICAgICAgY29udHJhY3RTZXF1ZW5jZUlkOiBudW1iZXI7XG4gICAgICBiYWNrdXBLZXlOb25jZT86IG51bWJlcjtcbiAgICAgIHNpZ25hdHVyZTogc3RyaW5nO1xuICAgIH07XG4gICAgbmV4dENvbnRyYWN0U2VxdWVuY2VJZD86IG51bWJlcjtcbiAgICBob3BUcmFuc2FjdGlvbj86IHN0cmluZztcbiAgICBiYWNrdXBLZXlOb25jZT86IG51bWJlcjtcbiAgfTtcbiAgc2lnbmluZ0tleU5vbmNlOiBudW1iZXI7XG4gIHdhbGxldENvbnRyYWN0QWRkcmVzczogc3RyaW5nO1xuICBwcnY6IHN0cmluZztcbiAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIFNpZ25GaW5hbE9wdGlvbnMge1xuICBpc0xhc3RTaWduYXR1cmU/OiBib29sZWFuO1xuICBleHBpcmVUaW1lOiBudW1iZXI7XG4gIHNlcXVlbmNlSWQ6IG51bWJlcjtcbiAgZ2FzTGltaXQ6IG51bWJlcjtcbiAgZ2FzUHJpY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYWxmU2lnbmVkVHJhbnNhY3Rpb24gZXh0ZW5kcyBCYXNlSGFsZlNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgaGFsZlNpZ25lZDoge1xuICAgIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xuICAgIGV4cGlyZVRpbWU6IG51bWJlcjtcbiAgICBjb250cmFjdFNlcXVlbmNlSWQ6IG51bWJlcjtcbiAgICBzZXF1ZW5jZUlkOiBudW1iZXI7XG4gICAgdHhIZXg/OiBuZXZlcjtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdWxseVNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgdHhIZXg6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgU2lnbmVkVHJhbnNhY3Rpb24gPSBIYWxmU2lnbmVkVHJhbnNhY3Rpb24gfCBGdWxseVNpZ25lZFRyYW5zYWN0aW9uO1xuXG5pbnRlcmZhY2UgUHJlY3JlYXRlQml0R29PcHRpb25zIHtcbiAgZW50ZXJwcmlzZT86IHN0cmluZztcbiAgbmV3RmVlQWRkcmVzcz86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIE9mZmxpbmVWYXVsdFR4SW5mbyB7XG4gIG5leHRDb250cmFjdFNlcXVlbmNlSWQ/OiBzdHJpbmc7XG4gIGNvbnRyYWN0U2VxdWVuY2VJZD86IHN0cmluZztcbiAgdHg6IHN0cmluZztcbiAgdXNlcktleTogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgY29pbjogc3RyaW5nO1xuICBnYXNQcmljZTogbnVtYmVyO1xuICBnYXNMaW1pdDogbnVtYmVyO1xuICByZWNpcGllbnRzOiBSZWNpcGllbnRbXTtcbiAgd2FsbGV0Q29udHJhY3RBZGRyZXNzOiBzdHJpbmc7XG4gIGFtb3VudDogc3RyaW5nO1xuICBiYWNrdXBLZXlOb25jZTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgVW5mb3JtYXR0ZWRUeEluZm8ge1xuICByZWNpcGllbnQ6IFJlY2lwaWVudDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyT3B0aW9ucyB7XG4gIHVzZXJLZXk6IHN0cmluZztcbiAgYmFja3VwS2V5OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHdhbGxldENvbnRyYWN0QWRkcmVzczogc3RyaW5nO1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7XG4gIGtyc1Byb3ZpZGVyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJ5SW5mbyB7XG4gIGlkOiBzdHJpbmc7XG4gIHR4OiBzdHJpbmc7XG4gIGJhY2t1cEtleT86IHN0cmluZztcbiAgY29pbj86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlY292ZXJUb2tlbk9wdGlvbnMge1xuICB0b2tlbkNvbnRyYWN0QWRkcmVzczogc3RyaW5nO1xuICB3YWxsZXQ6IFdhbGxldDtcbiAgcmVjaXBpZW50OiBzdHJpbmc7XG4gIGJyb2FkY2FzdD86IGJvb2xlYW47XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHBydj86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEdldFNlbmRNZXRob2RBcmdzT3B0aW9ucyB7XG4gIHJlY2lwaWVudDogUmVjaXBpZW50O1xuICBleHBpcmVUaW1lOiBudW1iZXI7XG4gIGNvbnRyYWN0U2VxdWVuY2VJZDogbnVtYmVyO1xuICBzaWduYXR1cmU6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFNlbmRNZXRob2RBcmdzIHtcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlOiBzdHJpbmc7XG4gIHZhbHVlOiBhbnk7XG59XG5cbmludGVyZmFjZSBIb3BUcmFuc2FjdGlvbkJ1aWxkT3B0aW9ucyB7XG4gIHdhbGxldDogV2FsbGV0O1xuICByZWNpcGllbnRzOiBSZWNpcGllbnRbXTtcbiAgd2FsbGV0UGFzc3BocmFzZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgQnVpbGRPcHRpb25zIHtcbiAgaG9wPzogYm9vbGVhbjtcbiAgd2FsbGV0PzogV2FsbGV0O1xuICByZWNpcGllbnRzPzogUmVjaXBpZW50W107XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBGZWVFc3RpbWF0ZSB7XG4gIGdhc0xpbWl0RXN0aW1hdGU6IG51bWJlcjtcbiAgZmVlRXN0aW1hdGU6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIGhvcFRyYW5zYWN0aW9uPzogSG9wUHJlYnVpbGQ7XG4gIGJ1aWxkUGFyYW1zOiB7XG4gICAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gIH07XG59XG5cbmludGVyZmFjZSBSZWNvdmVyVG9rZW5UcmFuc2FjdGlvbiB7XG4gIGhhbGZTaWduZWQ6IHtcbiAgICByZWNpcGllbnQ6IFJlY2lwaWVudDtcbiAgICBleHBpcmVUaW1lOiBudW1iZXI7XG4gICAgY29udHJhY3RTZXF1ZW5jZUlkOiBudW1iZXI7XG4gICAgb3BlcmF0aW9uSGFzaDogc3RyaW5nO1xuICAgIHNpZ25hdHVyZTogc3RyaW5nO1xuICAgIGdhc0xpbWl0OiBudW1iZXI7XG4gICAgZ2FzUHJpY2U6IG51bWJlcjtcbiAgICB0b2tlbkNvbnRyYWN0QWRkcmVzczogc3RyaW5nO1xuICAgIHdhbGxldElkOiBzdHJpbmc7XG4gIH07XG59XG5cbmV4cG9ydCBjbGFzcyBFdGggZXh0ZW5kcyBCYXNlQ29pbiB7XG4gIHN0YXRpYyBob3BUcmFuc2FjdGlvblNhbHQgPSAnYml0Z29Ib3BBZGRyZXNzUmVxdWVzdFNhbHQnO1xuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R28pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBFdGgoYml0Z28pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZhY3RvciBiZXR3ZWVuIHRoZSBiYXNlIHVuaXQgYW5kIGl0cyBzbWFsbGVzdCBzdWJkaXZpc29uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldEJhc2VGYWN0b3IoKTogc3RyaW5nIHtcbiAgICAvLyAxMF4xOFxuICAgIHJldHVybiAnMTAwMDAwMDAwMDAwMDAwMDAwMCc7XG4gIH1cblxuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnZXRoJztcbiAgfVxuXG4gIGdldEZhbWlseSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnZXRoJztcbiAgfVxuXG4gIGdldEZ1bGxOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdFdGhlcmV1bSc7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBmb3Igc2VuZGluZyB2YWx1ZSBvZiAwXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gc2VuZCAwIHZhbHVlLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHZhbHVlbGVzc1RyYW5zZmVyQWxsb3dlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBzZW5kaW5nIGRhdGEgYWxvbmcgd2l0aCB0cmFuc2FjdGlvbnNcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIHR4IGRhdGEgKEVUSCksIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgdHJhbnNhY3Rpb25EYXRhQWxsb3dlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZXMgd2hldGhlciBhbiBhZGRyZXNzIHN0cmluZyBpcyB2YWxpZCBmb3IgdGhpcyBjb2luXG4gICAqIEBwYXJhbSBhZGRyZXNzXG4gICAqL1xuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gb3B0aW9uYWxEZXBzLmV0aFV0aWwuaXNWYWxpZEFkZHJlc3Mob3B0aW9uYWxEZXBzLmV0aFV0aWwuYWRkSGV4UHJlZml4KGFkZHJlc3MpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwdWIgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgdXR4b0xpYi5IRE5vZGUuZnJvbUJhc2U1OChwdWIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGdhcyBwcmljZSBmcm9tIHBsYXRmb3JtXG4gICAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9XG4gICAqL1xuICBnZXRSZWNvdmVyeUdhc1ByaWNlKCk6IGFueSB7XG4gICAgcmV0dXJuIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTignMjAwMDAwMDAwMDAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGdhcyBsaW1pdCBmcm9tIHBsYXRmb3JtXG4gICAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9XG4gICAqL1xuICBnZXRSZWNvdmVyeUdhc0xpbWl0KCk6IGFueSB7XG4gICAgcmV0dXJuIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTignNTAwMDAwJyk7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBleHBpcmUgdGltZSBmb3IgYSBjb250cmFjdCBjYWxsICgxIHdlZWspXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRpbWUgaW4gc2Vjb25kc1xuICAgKi9cbiAgZ2V0RGVmYXVsdEV4cGlyZVRpbWUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApICsgNjAgKiA2MCAqIDI0ICogNztcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyeSBFdGhlcnNjYW4gZm9yIHRoZSBiYWxhbmNlIG9mIGFuIGFkZHJlc3NcbiAgICogQHBhcmFtIGFkZHJlc3Mge1N0cmluZ30gdGhlIEVUSCBhZGRyZXNzXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBhZGRyZXNzIGJhbGFuY2VcbiAgICovXG4gIHF1ZXJ5QWRkcmVzc0JhbGFuY2UoYWRkcmVzczogc3RyaW5nLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHNlbGYucmVjb3ZlcnlCbG9ja2NoYWluRXhwbG9yZXJRdWVyeSh7XG4gICAgICAgIG1vZHVsZTogJ2FjY291bnQnLFxuICAgICAgICBhY3Rpb246ICdiYWxhbmNlJyxcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTihyZXN1bHQucmVzdWx0LCAxMCk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUXVlcnkgRXRoZXJzY2FuIGZvciB0aGUgYmFsYW5jZSBvZiBhbiBhZGRyZXNzIGZvciBhIHRva2VuXG4gICAqIEBwYXJhbSB0b2tlbkNvbnRyYWN0QWRkcmVzcyB7U3RyaW5nfSBhZGRyZXNzIHdoZXJlIHRoZSB0b2tlbiBzbWFydCBjb250cmFjdCBpcyBob3N0ZWRcbiAgICogQHBhcmFtIHdhbGxldENvbnRyYWN0QWRkcmVzcyB7U3RyaW5nfSBhZGRyZXNzIG9mIHRoZSB3YWxsZXRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IHRva2VuIGJhbGFhbmNlIGluIGJhc2UgdW5pdHNcbiAgICovXG4gIHF1ZXJ5QWRkcmVzc1Rva2VuQmFsYW5jZShcbiAgICB0b2tlbkNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgIHdhbGxldENvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT5cbiAgKTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uKigpIHtcbiAgICAgIGlmICghb3B0aW9uYWxEZXBzLmV0aFV0aWwuaXNWYWxpZEFkZHJlc3ModG9rZW5Db250cmFjdEFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdldCBiYWxhbmNlIGZvciBpbnZhbGlkIHRva2VuIGFkZHJlc3MnKTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9uYWxEZXBzLmV0aFV0aWwuaXNWYWxpZEFkZHJlc3Mod2FsbGV0Q29udHJhY3RBZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBnZXQgdG9rZW4gYmFsYW5jZSBmb3IgaW52YWxpZCB3YWxsZXQgYWRkcmVzcycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBzZWxmLnJlY292ZXJ5QmxvY2tjaGFpbkV4cGxvcmVyUXVlcnkoe1xuICAgICAgICBtb2R1bGU6ICdhY2NvdW50JyxcbiAgICAgICAgYWN0aW9uOiAndG9rZW5iYWxhbmNlJyxcbiAgICAgICAgY29udHJhY3RhZGRyZXNzOiB0b2tlbkNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgYWRkcmVzczogd2FsbGV0Q29udHJhY3RBZGRyZXNzLFxuICAgICAgICB0YWc6ICdsYXRlc3QnLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4ocmVzdWx0LnJlc3VsdCwgMTApO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0cmFuc2ZlciBvcGVyYXRpb24gZm9yIGNvaW5cbiAgICogQHBhcmFtIHJlY2lwaWVudCByZWNpcGllbnQgaW5mb1xuICAgKiBAcGFyYW0gZXhwaXJlVGltZSBleHBpcnkgdGltZVxuICAgKiBAcGFyYW0gY29udHJhY3RTZXF1ZW5jZUlkIHNlcXVlbmNlIGlkXG4gICAqIEByZXR1cm5zIHtBcnJheX0gb3BlcmF0aW9uIGFycmF5XG4gICAqL1xuICBnZXRPcGVyYXRpb24ocmVjaXBpZW50OiBSZWNpcGllbnQsIGV4cGlyZVRpbWU6IG51bWJlciwgY29udHJhY3RTZXF1ZW5jZUlkOiBudW1iZXIpOiAoc3RyaW5nIHwgQnVmZmVyKVtdW10ge1xuICAgIHJldHVybiBbXG4gICAgICBbJ3N0cmluZycsICdhZGRyZXNzJywgJ3VpbnQnLCAnYnl0ZXMnLCAndWludCcsICd1aW50J10sXG4gICAgICBbXG4gICAgICAgICdFVEhFUicsXG4gICAgICAgIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTihvcHRpb25hbERlcHMuZXRoVXRpbC5zdHJpcEhleFByZWZpeChyZWNpcGllbnQuYWRkcmVzcyksIDE2KSxcbiAgICAgICAgcmVjaXBpZW50LmFtb3VudCxcbiAgICAgICAgQnVmZmVyLmZyb20ob3B0aW9uYWxEZXBzLmV0aFV0aWwuc3RyaXBIZXhQcmVmaXgocmVjaXBpZW50LmRhdGEpIHx8ICcnLCAnaGV4JyksXG4gICAgICAgIGV4cGlyZVRpbWUsXG4gICAgICAgIGNvbnRyYWN0U2VxdWVuY2VJZCxcbiAgICAgIF0sXG4gICAgXTtcbiAgfVxuXG4gIGdldE9wZXJhdGlvblNoYTNGb3JFeGVjdXRlQW5kQ29uZmlybShcbiAgICByZWNpcGllbnRzOiBSZWNpcGllbnRbXSxcbiAgICBleHBpcmVUaW1lOiBudW1iZXIsXG4gICAgY29udHJhY3RTZXF1ZW5jZUlkOiBudW1iZXJcbiAgKTogc3RyaW5nIHtcbiAgICBpZiAoIXJlY2lwaWVudHMgfHwgIUFycmF5LmlzQXJyYXkocmVjaXBpZW50cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIGFycmF5IG9mIHJlY2lwaWVudHMnKTtcbiAgICB9XG5cbiAgICAvLyBSaWdodCBub3cgd2Ugb25seSBzdXBwb3J0IDEgcmVjaXBpZW50XG4gICAgaWYgKHJlY2lwaWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc2VuZCB0byBleGFjdGx5IDEgcmVjaXBpZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzTnVtYmVyKGV4cGlyZVRpbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGlyZVRpbWUgbXVzdCBiZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSBlcG9jaCcpO1xuICAgIH1cblxuICAgIGlmICghXy5pc051bWJlcihjb250cmFjdFNlcXVlbmNlSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnRyYWN0U2VxdWVuY2VJZCBtdXN0IGJlIG51bWJlcicpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlucHV0c1xuICAgIHJlY2lwaWVudHMuZm9yRWFjaChmdW5jdGlvbihyZWNpcGllbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIV8uaXNTdHJpbmcocmVjaXBpZW50LmFkZHJlc3MpIHx8XG4gICAgICAgICFvcHRpb25hbERlcHMuZXRoVXRpbC5pc1ZhbGlkQWRkcmVzcyhvcHRpb25hbERlcHMuZXRoVXRpbC5hZGRIZXhQcmVmaXgocmVjaXBpZW50LmFkZHJlc3MpKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzOiAnICsgcmVjaXBpZW50LmFkZHJlc3MpO1xuICAgICAgfVxuXG4gICAgICBsZXQgYW1vdW50O1xuICAgICAgdHJ5IHtcbiAgICAgICAgYW1vdW50ID0gbmV3IEJpZ051bWJlcihyZWNpcGllbnQuYW1vdW50KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFtb3VudCBmb3I6ICcgKyByZWNpcGllbnQuYWRkcmVzcyArICcgLSBzaG91bGQgYmUgbnVtZXJpYycpO1xuICAgICAgfVxuXG4gICAgICByZWNpcGllbnQuYW1vdW50ID0gYW1vdW50LnRvRml4ZWQoMCk7XG5cbiAgICAgIGlmIChyZWNpcGllbnQuZGF0YSAmJiAhXy5pc1N0cmluZyhyZWNpcGllbnQuZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGZvciByZWNpcGllbnQgJyArIHJlY2lwaWVudC5hZGRyZXNzICsgJyAtIHNob3VsZCBiZSBvZiB0eXBlIGhleCBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHJlY2lwaWVudCA9IHJlY2lwaWVudHNbMF07XG4gICAgcmV0dXJuIG9wdGlvbmFsRGVwcy5ldGhVdGlsLmJ1ZmZlclRvSGV4KFxuICAgICAgb3B0aW9uYWxEZXBzLmV0aEFiaS5zb2xpZGl0eVNIQTMoLi4udGhpcy5nZXRPcGVyYXRpb24ocmVjaXBpZW50LCBleHBpcmVUaW1lLCBjb250cmFjdFNlcXVlbmNlSWQpKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUXVlcmllcyB0aGUgY29udHJhY3QgKHZpYSBFdGhlcnNjYW4pIGZvciB0aGUgbmV4dCBzZXF1ZW5jZSBJRFxuICAgKiBAcGFyYW0gYWRkcmVzcyB7U3RyaW5nfSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge051bWJlcn0gc2VxdWVuY2UgSURcbiAgICovXG4gIHF1ZXJ5U2VxdWVuY2VJZChhZGRyZXNzOiBzdHJpbmcsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPG51bWJlcj4pOiBCbHVlYmlyZDxudW1iZXI+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288bnVtYmVyPihmdW5jdGlvbiooKSB7XG4gICAgICAvLyBHZXQgc2VxdWVuY2UgSUQgdXNpbmcgY29udHJhY3QgY2FsbFxuICAgICAgY29uc3Qgc2VxdWVuY2VJZE1ldGhvZFNpZ25hdHVyZSA9IG9wdGlvbmFsRGVwcy5ldGhBYmkubWV0aG9kSUQoJ2dldE5leHRTZXF1ZW5jZUlkJywgW10pO1xuICAgICAgY29uc3Qgc2VxdWVuY2VJZEFyZ3MgPSBvcHRpb25hbERlcHMuZXRoQWJpLnJhd0VuY29kZShbXSwgW10pO1xuICAgICAgY29uc3Qgc2VxdWVuY2VJZERhdGEgPSBCdWZmZXIuY29uY2F0KFtzZXF1ZW5jZUlkTWV0aG9kU2lnbmF0dXJlLCBzZXF1ZW5jZUlkQXJnc10pLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHNlbGYucmVjb3ZlcnlCbG9ja2NoYWluRXhwbG9yZXJRdWVyeSh7XG4gICAgICAgIG1vZHVsZTogJ3Byb3h5JyxcbiAgICAgICAgYWN0aW9uOiAnZXRoX2NhbGwnLFxuICAgICAgICB0bzogYWRkcmVzcyxcbiAgICAgICAgZGF0YTogc2VxdWVuY2VJZERhdGEsXG4gICAgICAgIHRhZzogJ2xhdGVzdCcsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNlcXVlbmNlSWRIZXggPSByZXN1bHQucmVzdWx0O1xuICAgICAgcmV0dXJuIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTihzZXF1ZW5jZUlkSGV4LnNsaWNlKDIpLCAxNikudG9OdW1iZXIoKTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHNpZ25UcmFuc2FjdGlvbiBmb3IgdGhlIHJhcmUgY2FzZSB0aGF0IFNESyBpcyBkb2luZyB0aGUgc2Vjb25kIHNpZ25hdHVyZVxuICAgKiBOb3RlOiB3ZSBhcmUgZXhwZWN0aW5nIHRoaXMgdG8gYmUgY2FsbGVkIGZyb20gdGhlIG9mZmxpbmUgdmF1bHRcbiAgICogQHBhcmFtIHBhcmFtcy50eFByZWJ1aWxkXG4gICAqIEBwYXJhbSBwYXJhbXMuc2lnbmluZ0tleU5vbmNlXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzXG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2XG4gICAqIEByZXR1cm5zIHt7dHhIZXg6ICp9fVxuICAgKi9cbiAgc2lnbkZpbmFsKHBhcmFtczogU2lnbkZpbmFsT3B0aW9ucyk6IEZ1bGx5U2lnbmVkVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0IHR4UHJlYnVpbGQgPSBwYXJhbXMudHhQcmVidWlsZDtcblxuICAgIGlmICghXy5pc051bWJlcihwYXJhbXMuc2lnbmluZ0tleU5vbmNlKSAmJiAhXy5pc051bWJlcihwYXJhbXMudHhQcmVidWlsZC5oYWxmU2lnbmVkLmJhY2t1cEtleU5vbmNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBvZiBzaWduaW5nS2V5Tm9uY2UgYW5kIGJhY2t1cEtleU5vbmNlIGFzIGEgcGFyYW1ldGVyLCBhbmQgaXQgbXVzdCBiZSBhIG51bWJlcidcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcmFtcyBtdXN0IGluY2x1ZGUgd2FsbGV0Q29udHJhY3RBZGRyZXNzLCBidXQgZ290IHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHNpZ25pbmdOb2RlID0gdXR4b0xpYi5IRE5vZGUuZnJvbUJhc2U1OChwYXJhbXMucHJ2KTtcbiAgICBjb25zdCBzaWduaW5nS2V5ID0gc2lnbmluZ05vZGUuZ2V0S2V5KCkuZ2V0UHJpdmF0ZUtleUJ1ZmZlcigpO1xuXG4gICAgY29uc3QgdHhJbmZvID0ge1xuICAgICAgcmVjaXBpZW50OiB0eFByZWJ1aWxkLnJlY2lwaWVudHNbMF0sXG4gICAgICBleHBpcmVUaW1lOiB0eFByZWJ1aWxkLmhhbGZTaWduZWQuZXhwaXJlVGltZSxcbiAgICAgIGNvbnRyYWN0U2VxdWVuY2VJZDogdHhQcmVidWlsZC5oYWxmU2lnbmVkLmNvbnRyYWN0U2VxdWVuY2VJZCxcbiAgICAgIHNpZ25hdHVyZTogdHhQcmVidWlsZC5oYWxmU2lnbmVkLnNpZ25hdHVyZSxcbiAgICB9O1xuXG4gICAgY29uc3Qgc2VuZE1ldGhvZEFyZ3MgPSB0aGlzLmdldFNlbmRNZXRob2RBcmdzKHR4SW5mbyk7XG4gICAgY29uc3QgbWV0aG9kU2lnbmF0dXJlID0gb3B0aW9uYWxEZXBzLmV0aEFiaS5tZXRob2RJRCgnc2VuZE11bHRpU2lnJywgXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd0eXBlJykpO1xuICAgIGNvbnN0IGVuY29kZWRBcmdzID0gb3B0aW9uYWxEZXBzLmV0aEFiaS5yYXdFbmNvZGUoXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd0eXBlJyksIF8ubWFwKHNlbmRNZXRob2RBcmdzLCAndmFsdWUnKSk7XG4gICAgY29uc3Qgc2VuZERhdGEgPSBCdWZmZXIuY29uY2F0KFttZXRob2RTaWduYXR1cmUsIGVuY29kZWRBcmdzXSk7XG5cbiAgICBjb25zdCBldGhUeFBhcmFtcyA9IHtcbiAgICAgIHRvOiBwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzLFxuICAgICAgbm9uY2U6IHBhcmFtcy5zaWduaW5nS2V5Tm9uY2UgfHwgcGFyYW1zLnR4UHJlYnVpbGQuaGFsZlNpZ25lZC5iYWNrdXBLZXlOb25jZSxcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgZ2FzUHJpY2U6IG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTih0eFByZWJ1aWxkLmdhc1ByaWNlKSxcbiAgICAgIGdhc0xpbWl0OiBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4odHhQcmVidWlsZC5nYXNMaW1pdCksXG4gICAgICBkYXRhOiBzZW5kRGF0YSxcbiAgICAgIHNwZW5kQW1vdW50OiBwYXJhbXMucmVjaXBpZW50c1swXS5hbW91bnQsXG4gICAgfTtcblxuICAgIGNvbnN0IGV0aFR4ID0gbmV3IG9wdGlvbmFsRGVwcy5FdGhUeChldGhUeFBhcmFtcyk7XG4gICAgZXRoVHguc2lnbihzaWduaW5nS2V5KTtcbiAgICByZXR1cm4geyB0eEhleDogZXRoVHguc2VyaWFsaXplKCkudG9TdHJpbmcoJ2hleCcpIH07XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gdHhQcmVidWlsZFxuICAgKiAtIHBydlxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge0JsdWViaXJkPFNpZ25lZFRyYW5zYWN0aW9uPn1cbiAgICovXG4gIHNpZ25UcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8U2lnbmVkVHJhbnNhY3Rpb24+XG4gICk6IEJsdWViaXJkPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFNpZ25lZFRyYW5zYWN0aW9uPihmdW5jdGlvbiooKSB7XG4gICAgICBjb25zdCB0eFByZWJ1aWxkID0gcGFyYW1zLnR4UHJlYnVpbGQ7XG4gICAgICBjb25zdCB1c2VyUHJ2ID0gcGFyYW1zLnBydjtcbiAgICAgIGNvbnN0IEVYUElSRVRJTUVfREVGQVVMVCA9IDYwICogNjAgKiAyNCAqIDc7IC8vIFRoaXMgc2lnbmF0dXJlIHdpbGwgYmUgdmFsaWQgZm9yIDEgd2Vla1xuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh0eFByZWJ1aWxkKSB8fCAhXy5pc09iamVjdCh0eFByZWJ1aWxkKSkge1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQodHhQcmVidWlsZCkgJiYgIV8uaXNPYmplY3QodHhQcmVidWlsZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHR4UHJlYnVpbGQgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCB0eXBlICR7dHlwZW9mIHR4UHJlYnVpbGR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHR4UHJlYnVpbGQgcGFyYW1ldGVyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHVzZXJQcnYpIHx8ICFfLmlzU3RyaW5nKHVzZXJQcnYpKSB7XG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh1c2VyUHJ2KSAmJiAhXy5pc1N0cmluZyh1c2VyUHJ2KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJ2IG11c3QgYmUgYSBzdHJpbmcsIGdvdCB0eXBlICR7dHlwZW9mIHVzZXJQcnZ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBydiBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBwYXJhbXMucmVjaXBpZW50cyA9IHR4UHJlYnVpbGQucmVjaXBpZW50cyB8fCBwYXJhbXMucmVjaXBpZW50cztcblxuICAgICAgLy8gaWYgbm8gcmVjaXBpZW50cyBpbiBlaXRoZXIgcGFyYW1zIG9yIHR4UHJlYnVpbGQsIHRoZW4gdGhyb3cgYW4gZXJyb3JcbiAgICAgIGlmICghcGFyYW1zLnJlY2lwaWVudHMgfHwgIUFycmF5LmlzQXJyYXkocGFyYW1zLnJlY2lwaWVudHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjaXBpZW50cyBtaXNzaW5nIG9yIG5vdCBhcnJheScpO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWxseSB0aGUgU0RLIHByb3ZpZGVzIHRoZSBmaXJzdCBzaWduYXR1cmUgZm9yIGFuIEVUSCB0eCwgYnV0IG9jY2FzaW9uYWxseSBpdCBwcm92aWRlcyB0aGUgc2Vjb25kIGFuZCBmaW5hbCBvbmUuXG4gICAgICBpZiAocGFyYW1zLmlzTGFzdFNpZ25hdHVyZSkge1xuICAgICAgICAvLyBJbiB0aGlzIGNhc2Ugd2hlbiB3ZSdyZSBkb2luZyB0aGUgc2Vjb25kIChmaW5hbCkgc2lnbmF0dXJlLCB0aGUgbG9naWMgaXMgZGlmZmVyZW50LlxuICAgICAgICByZXR1cm4gc2VsZi5zaWduRmluYWwocGFyYW1zKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2Vjb25kc1NpbmNlRXBvY2ggPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgICBjb25zdCBleHBpcmVUaW1lID0gcGFyYW1zLmV4cGlyZVRpbWUgfHwgc2Vjb25kc1NpbmNlRXBvY2ggKyBFWFBJUkVUSU1FX0RFRkFVTFQ7XG4gICAgICBjb25zdCBzZXF1ZW5jZUlkID0gdHhQcmVidWlsZC5uZXh0Q29udHJhY3RTZXF1ZW5jZUlkO1xuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChzZXF1ZW5jZUlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIG1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgbmV4dENvbnRyYWN0U2VxdWVuY2VJZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcGVyYXRpb25IYXNoID0gc2VsZi5nZXRPcGVyYXRpb25TaGEzRm9yRXhlY3V0ZUFuZENvbmZpcm0ocGFyYW1zLnJlY2lwaWVudHMsIGV4cGlyZVRpbWUsIHNlcXVlbmNlSWQpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gVXRpbC5ldGhTaWduTXNnSGFzaChvcGVyYXRpb25IYXNoLCBVdGlsLnhwcnZUb0V0aFByaXZhdGVLZXkodXNlclBydikpO1xuXG4gICAgICBjb25zdCB0eFBhcmFtcyA9IHtcbiAgICAgICAgcmVjaXBpZW50czogcGFyYW1zLnJlY2lwaWVudHMsXG4gICAgICAgIGV4cGlyZVRpbWU6IGV4cGlyZVRpbWUsXG4gICAgICAgIGNvbnRyYWN0U2VxdWVuY2VJZDogc2VxdWVuY2VJZCxcbiAgICAgICAgc2VxdWVuY2VJZDogcGFyYW1zLnNlcXVlbmNlSWQsXG4gICAgICAgIG9wZXJhdGlvbkhhc2g6IG9wZXJhdGlvbkhhc2gsXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgICBnYXNMaW1pdDogcGFyYW1zLmdhc0xpbWl0LFxuICAgICAgICBnYXNQcmljZTogcGFyYW1zLmdhc1ByaWNlLFxuICAgICAgICBob3BUcmFuc2FjdGlvbjogdHhQcmVidWlsZC5ob3BUcmFuc2FjdGlvbixcbiAgICAgICAgYmFja3VwS2V5Tm9uY2U6IHR4UHJlYnVpbGQuYmFja3VwS2V5Tm9uY2UsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHsgaGFsZlNpZ25lZDogdHhQYXJhbXMgfTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgZWl0aGVyIGVudGVycHJpc2Ugb3IgbmV3RmVlQWRkcmVzcyBpcyBwYXNzZWQsIHRvIGtub3cgd2hldGhlciB0byBjcmVhdGUgbmV3IGtleSBvciB1c2UgZW50ZXJwcmlzZSBrZXlcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmVudGVycHJpc2Uge1N0cmluZ30gdGhlIGVudGVycHJpc2UgaWQgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBrZXlcbiAgICogQHBhcmFtIHBhcmFtcy5uZXdGZWVBZGRyZXNzIHtCb29sZWFufSBjcmVhdGUgYSBuZXcgZmVlIGFkZHJlc3MgKGVudGVycHJpc2Ugbm90IG5lZWRlZCBpbiB0aGlzIGNhc2UpXG4gICAqL1xuICBwcmVDcmVhdGVCaXRHbyhwYXJhbXM6IFByZWNyZWF0ZUJpdEdvT3B0aW9ucyk6IHZvaWQge1xuICAgIC8vIFdlIGFsd2F5cyBuZWVkIHBhcmFtcyBvYmplY3QsIHNpbmNlIGVpdGhlciBlbnRlcnByaXNlIG9yIG5ld0ZlZUFkZHJlc3MgaXMgcmVxdWlyZWRcbiAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcmVDcmVhdGVCaXRHbyBtdXN0IGJlIHBhc3NlZCBhIHBhcmFtcyBvYmplY3QuIEdvdCAke3BhcmFtc30gKHR5cGUgJHt0eXBlb2YgcGFyYW1zfSlgKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMuZW50ZXJwcmlzZSkgJiYgXy5pc1VuZGVmaW5lZChwYXJhbXMubmV3RmVlQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2V4cGVjdGluZyBlbnRlcnByaXNlIHdoZW4gYWRkaW5nIEJpdEdvIGtleS4gSWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgbmV3IEVUSCBiaXRnbyBrZXksIHNldCB0aGUgbmV3RmVlQWRkcmVzcyBwYXJhbWV0ZXIgdG8gdHJ1ZS4nXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHdoZXRoZXIga2V5IHNob3VsZCBiZSBhbiBlbnRlcnByaXNlIGtleSBvciBhIEJpdEdvIGtleSBmb3IgYSBuZXcgZmVlIGFkZHJlc3NcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmVudGVycHJpc2UpICYmICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5uZXdGZWVBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvbXBhdGlibGUgYXJndW1lbnRzIC0gY2Fubm90IHBhc3MgYm90aCBlbnRlcnByaXNlIGFuZCBuZXdGZWVBZGRyZXNzIHBhcmFtZXRlci5gKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmVudGVycHJpc2UpICYmICFfLmlzU3RyaW5nKHBhcmFtcy5lbnRlcnByaXNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbnRlcnByaXNlIHNob3VsZCBiZSBhIHN0cmluZyAtIGdvdCAke3BhcmFtcy5lbnRlcnByaXNlfSAodHlwZSAke3R5cGVvZiBwYXJhbXMuZW50ZXJwcmlzZX0pYCk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5uZXdGZWVBZGRyZXNzKSAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLm5ld0ZlZUFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBuZXdGZWVBZGRyZXNzIHNob3VsZCBiZSBhIGJvb2xlYW4gLSBnb3QgJHtwYXJhbXMubmV3RmVlQWRkcmVzc30gKHR5cGUgJHt0eXBlb2YgcGFyYW1zLm5ld0ZlZUFkZHJlc3N9KWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJpZXMgcHVibGljIGJsb2NrIGV4cGxvcmVyIHRvIGdldCB0aGUgbmV4dCBFVEggbm9uY2UgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIGdpdmVuIEVUSCBhZGRyZXNzXG4gICAqIEBwYXJhbSBhZGRyZXNzXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGdldEFkZHJlc3NOb25jZShhZGRyZXNzOiBzdHJpbmcsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPG51bWJlcj4pOiBCbHVlYmlyZDxudW1iZXI+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288bnVtYmVyPihmdW5jdGlvbiooKSB7XG4gICAgICAvLyBHZXQgbm9uY2UgZm9yIGJhY2t1cCBrZXkgKHNob3VsZCBiZSAwKVxuICAgICAgbGV0IG5vbmNlID0gMDtcblxuICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgc2VsZi5yZWNvdmVyeUJsb2NrY2hhaW5FeHBsb3JlclF1ZXJ5KHtcbiAgICAgICAgbW9kdWxlOiAnYWNjb3VudCcsXG4gICAgICAgIGFjdGlvbjogJ3R4bGlzdCcsXG4gICAgICAgIGFkZHJlc3MsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJhY2t1cEtleVR4TGlzdCA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgICBpZiAoYmFja3VwS2V5VHhMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGxhc3Qgbm9uY2UgdXNlZFxuICAgICAgICBjb25zdCBvdXRnb2luZ1R4cyA9IGJhY2t1cEtleVR4TGlzdC5maWx0ZXIodHggPT4gdHguZnJvbSA9PT0gYWRkcmVzcyk7XG4gICAgICAgIG5vbmNlID0gb3V0Z29pbmdUeHMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vbmNlO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgcmVjb3ZlcigpXG4gICAqIFRoaXMgdHJhbnNmb3JtcyB0aGUgdW5zaWduZWQgdHJhbnNhY3Rpb24gaW5mb3JtYXRpb24gaW50byBhIGZvcm1hdCB0aGUgQml0R28gb2ZmbGluZSB2YXVsdCBleHBlY3RzXG4gICAqIEBwYXJhbSB0eEluZm9cbiAgICogQHBhcmFtIGV0aFR4XG4gICAqIEBwYXJhbSB1c2VyS2V5XG4gICAqIEBwYXJhbSBiYWNrdXBLZXlcbiAgICogQHBhcmFtIGdhc1ByaWNlXG4gICAqIEBwYXJhbSBnYXNMaW1pdFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3t0eDogKiwgdXNlcktleTogKiwgYmFja3VwS2V5OiAqLCBjb2luOiBzdHJpbmcsIGFtb3VudDogc3RyaW5nLCBnYXNQcmljZTogc3RyaW5nLCBnYXNMaW1pdDogc3RyaW5nLCByZWNpcGllbnRzOiAoe2FkZHJlc3MsIGFtb3VudH18e2FkZHJlc3M6ICh7YWRkcmVzcywgYW1vdW50fXxzdHJpbmcpLCBhbW91bnQ6IHN0cmluZ318c3RyaW5nKVtdfX1cbiAgICovXG4gIGZvcm1hdEZvck9mZmxpbmVWYXVsdChcbiAgICB0eEluZm86IFVuZm9ybWF0dGVkVHhJbmZvLFxuICAgIGV0aFR4OiBhbnksXG4gICAgdXNlcktleTogc3RyaW5nLFxuICAgIGJhY2t1cEtleTogc3RyaW5nLFxuICAgIGdhc1ByaWNlOiBCdWZmZXIsXG4gICAgZ2FzTGltaXQ6IG51bWJlcixcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxPZmZsaW5lVmF1bHRUeEluZm8+XG4gICk6IEJsdWViaXJkPE9mZmxpbmVWYXVsdFR4SW5mbz4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxPZmZsaW5lVmF1bHRUeEluZm8+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbnN0IGJhY2t1cEhETm9kZSA9IHV0eG9MaWIuSEROb2RlLmZyb21CYXNlNTgoYmFja3VwS2V5KTtcbiAgICAgIGNvbnN0IGJhY2t1cFNpZ25pbmdLZXkgPSBiYWNrdXBIRE5vZGUuZ2V0S2V5KCkuZ2V0UHVibGljS2V5QnVmZmVyKCk7XG4gICAgICBjb25zdCByZXNwb25zZTogT2ZmbGluZVZhdWx0VHhJbmZvID0ge1xuICAgICAgICB0eDogZXRoVHguc2VyaWFsaXplKCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICB1c2VyS2V5LFxuICAgICAgICBiYWNrdXBLZXksXG4gICAgICAgIGNvaW46IHNlbGYuZ2V0Q2hhaW4oKSxcbiAgICAgICAgZ2FzUHJpY2U6IG9wdGlvbmFsRGVwcy5ldGhVdGlsLmJ1ZmZlclRvSW50KGdhc1ByaWNlKS50b0ZpeGVkKCksXG4gICAgICAgIGdhc0xpbWl0LFxuICAgICAgICByZWNpcGllbnRzOiBbdHhJbmZvLnJlY2lwaWVudF0sXG4gICAgICAgIHdhbGxldENvbnRyYWN0QWRkcmVzczogJzB4JyArIGV0aFR4LnRvLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgYW1vdW50OiB0eEluZm8ucmVjaXBpZW50LmFtb3VudCxcbiAgICAgICAgYmFja3VwS2V5Tm9uY2U6IHlpZWxkIHNlbGYuZ2V0QWRkcmVzc05vbmNlKFxuICAgICAgICAgIGAweCR7b3B0aW9uYWxEZXBzLmV0aFV0aWwucHVibGljVG9BZGRyZXNzKGJhY2t1cFNpZ25pbmdLZXksIHRydWUpLnRvU3RyaW5nKCdoZXgnKX1gXG4gICAgICAgICksXG4gICAgICB9O1xuICAgICAgXy5leHRlbmQocmVzcG9uc2UsIHR4SW5mbyk7XG4gICAgICByZXNwb25zZS5uZXh0Q29udHJhY3RTZXF1ZW5jZUlkID0gcmVzcG9uc2UuY29udHJhY3RTZXF1ZW5jZUlkO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R29cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJLZXkge1N0cmluZ30gW2VuY3J5cHRlZF0geHBydlxuICAgKiBAcGFyYW0gcGFyYW1zLmJhY2t1cEtleSB7U3RyaW5nfSBbZW5jcnlwdGVkXSB4cHJ2IG9yIHhwdWIgaWYgdGhlIHhwcnYgaXMgaGVsZCBieSBhIEtSUyBwcm92aWRlclxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFBhc3NwaHJhc2Uge1N0cmluZ30gdXNlZCB0byBkZWNyeXB0IHVzZXJLZXkgYW5kIGJhY2t1cEtleVxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldENvbnRyYWN0QWRkcmVzcyB7U3RyaW5nfSB0aGUgRVRIIGFkZHJlc3Mgb2YgdGhlIHdhbGxldCBjb250cmFjdFxuICAgKiBAcGFyYW0gcGFyYW1zLmtyc1Byb3ZpZGVyIHtTdHJpbmd9IG5lY2Vzc2FyeSBpZiBiYWNrdXAga2V5IGlzIGhlbGQgYnkgS1JTXG4gICAqIEBwYXJhbSBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbiB7U3RyaW5nfSB0YXJnZXQgYWRkcmVzcyB0byBzZW5kIHJlY292ZXJlZCBmdW5kcyB0b1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHJlY292ZXIoXG4gICAgcGFyYW1zOiBSZWNvdmVyT3B0aW9ucyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxSZWNvdmVyeUluZm8gfCBPZmZsaW5lVmF1bHRUeEluZm8+XG4gICk6IEJsdWViaXJkPFJlY292ZXJ5SW5mbyB8IE9mZmxpbmVWYXVsdFR4SW5mbz4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxSZWNvdmVyeUluZm8gfCBPZmZsaW5lVmF1bHRUeEluZm8+KGZ1bmN0aW9uKiByZWNvdmVyKCkge1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnVzZXJLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB1c2VyS2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5iYWNrdXBLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBiYWNrdXBLZXknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLndhbGxldFBhc3NwaHJhc2UpICYmICFwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCd4cHViJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHdhbGxldCBwYXNzcGhyYXNlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3MpIHx8ICFzZWxmLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB3YWxsZXRDb250cmFjdEFkZHJlc3MnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pIHx8ICFzZWxmLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVjb3ZlcnlEZXN0aW5hdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0tyc1JlY292ZXJ5ID0gcGFyYW1zLmJhY2t1cEtleS5zdGFydHNXaXRoKCd4cHViJykgJiYgIXBhcmFtcy51c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKTtcbiAgICAgIGNvbnN0IGlzVW5zaWduZWRTd2VlcCA9IHBhcmFtcy5iYWNrdXBLZXkuc3RhcnRzV2l0aCgneHB1YicpICYmIHBhcmFtcy51c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKTtcblxuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkgJiYgcGFyYW1zLmtyc1Byb3ZpZGVyICYmIF8uaXNVbmRlZmluZWQoY29uZmlnLmtyc1Byb3ZpZGVyc1twYXJhbXMua3JzUHJvdmlkZXJdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHJlY292ZXJ5IHNlcnZpY2UgcHJvdmlkZXInKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYW4gdXAgd2hpdGVzcGFjZSBmcm9tIGVudGVyZWQgdmFsdWVzXG4gICAgICBsZXQgdXNlcktleSA9IHBhcmFtcy51c2VyS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICBjb25zdCBiYWNrdXBLZXkgPSBwYXJhbXMuYmFja3VwS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cbiAgICAgIC8vIFNldCBuZXcgZXRoIHR4IGZlZXMgKHVzaW5nIGRlZmF1bHQgY29uZmlnIHZhbHVlcyBmcm9tIHBsYXRmb3JtKVxuICAgICAgY29uc3QgZ2FzUHJpY2UgPSBzZWxmLmdldFJlY292ZXJ5R2FzUHJpY2UoKTtcbiAgICAgIGNvbnN0IGdhc0xpbWl0ID0gc2VsZi5nZXRSZWNvdmVyeUdhc0xpbWl0KCk7XG5cbiAgICAgIC8vIERlY3J5cHQgcHJpdmF0ZSBrZXlzIGZyb20gS2V5Q2FyZCB2YWx1ZXMgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAoIXVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpICYmICF1c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwcnYnKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVzZXJLZXkgPSBzZWxmLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICAgICAgaW5wdXQ6IHVzZXJLZXksXG4gICAgICAgICAgICBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY3J5cHRpbmcgdXNlciBrZXljaGFpbjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IGJhY2t1cEtleUFkZHJlc3M7XG4gICAgICBsZXQgYmFja3VwU2lnbmluZ0tleTtcblxuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkgfHwgaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAgIGNvbnN0IGJhY2t1cEhETm9kZSA9IHV0eG9MaWIuSEROb2RlLmZyb21CYXNlNTgoYmFja3VwS2V5KTtcbiAgICAgICAgYmFja3VwU2lnbmluZ0tleSA9IGJhY2t1cEhETm9kZS5nZXRLZXkoKS5nZXRQdWJsaWNLZXlCdWZmZXIoKTtcbiAgICAgICAgYmFja3VwS2V5QWRkcmVzcyA9IGAweCR7b3B0aW9uYWxEZXBzLmV0aFV0aWwucHVibGljVG9BZGRyZXNzKGJhY2t1cFNpZ25pbmdLZXksIHRydWUpLnRvU3RyaW5nKCdoZXgnKX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGVjcnlwdCBiYWNrdXAgcHJpdmF0ZSBrZXkgYW5kIGdldCBhZGRyZXNzXG4gICAgICAgIGxldCBiYWNrdXBQcnY7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBiYWNrdXBQcnYgPSBzZWxmLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICAgICAgaW5wdXQ6IGJhY2t1cEtleSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGVjcnlwdGluZyBiYWNrdXAga2V5Y2hhaW46ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmFja3VwSEROb2RlID0gdXR4b0xpYi5IRE5vZGUuZnJvbUJhc2U1OChiYWNrdXBQcnYpO1xuICAgICAgICBiYWNrdXBTaWduaW5nS2V5ID0gYmFja3VwSEROb2RlLmdldEtleSgpLmdldFByaXZhdGVLZXlCdWZmZXIoKTtcbiAgICAgICAgYmFja3VwS2V5QWRkcmVzcyA9IGAweCR7b3B0aW9uYWxEZXBzLmV0aFV0aWwucHJpdmF0ZVRvQWRkcmVzcyhiYWNrdXBTaWduaW5nS2V5KS50b1N0cmluZygnaGV4Jyl9YDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmFja3VwS2V5Tm9uY2UgPSB5aWVsZCBzZWxmLmdldEFkZHJlc3NOb25jZShiYWNrdXBLZXlBZGRyZXNzKTtcblxuICAgICAgLy8gZ2V0IGJhbGFuY2Ugb2YgYmFja3VwS2V5IHRvIGVuc3VyZSBmdW5kcyBhcmUgYXZhaWxhYmxlIHRvIHBheSBmZWVzXG4gICAgICBjb25zdCBiYWNrdXBLZXlCYWxhbmNlID0geWllbGQgc2VsZi5xdWVyeUFkZHJlc3NCYWxhbmNlKGJhY2t1cEtleUFkZHJlc3MpO1xuXG4gICAgICBpZiAoYmFja3VwS2V5QmFsYW5jZS5sdChnYXNQcmljZS5tdWwoZ2FzTGltaXQpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEJhY2t1cCBrZXkgYWRkcmVzcyAke2JhY2t1cEtleUFkZHJlc3N9IGhhcyBiYWxhbmNlICR7YmFja3VwS2V5QmFsYW5jZS50b1N0cmluZyhcbiAgICAgICAgICAgIDEwXG4gICAgICAgICAgKX0uIFRoaXMgYWRkcmVzcyBtdXN0IGhhdmUgYSBiYWxhbmNlIG9mIGF0IGxlYXN0IDAuMDEgRVRIIHRvIHBlcmZvcm0gcmVjb3Zlcmllcy4gVHJ5IHNlbmRpbmcgc29tZSBFVEggdG8gdGhpcyBhZGRyZXNzIHRoZW4gcmV0cnkuYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgYmFsYW5jZSBvZiB3YWxsZXQgYW5kIGRlZHVjdCBmZWVzIHRvIGdldCB0cmFuc2FjdGlvbiBhbW91bnRcbiAgICAgIGNvbnN0IHR4QW1vdW50ID0geWllbGQgc2VsZi5xdWVyeUFkZHJlc3NCYWxhbmNlKHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3MpO1xuXG4gICAgICAvLyBidWlsZCByZWNpcGllbnRzIG9iamVjdFxuICAgICAgY29uc3QgcmVjaXBpZW50cyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uLFxuICAgICAgICAgIGFtb3VudDogdHhBbW91bnQudG9TdHJpbmcoMTApLFxuICAgICAgICB9LFxuICAgICAgXTtcblxuICAgICAgLy8gR2V0IHNlcXVlbmNlIElEIHVzaW5nIGNvbnRyYWN0IGNhbGxcbiAgICAgIGNvbnN0IHNlcXVlbmNlSWQgPSB5aWVsZCBzZWxmLnF1ZXJ5U2VxdWVuY2VJZChwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzKTtcblxuICAgICAgbGV0IG9wZXJhdGlvbkhhc2gsIHNpZ25hdHVyZTtcbiAgICAgIC8vIEdldCBvcGVyYXRpb24gaGFzaCBhbmQgc2lnbiBpdFxuICAgICAgaWYgKCFpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgICAgb3BlcmF0aW9uSGFzaCA9IHNlbGYuZ2V0T3BlcmF0aW9uU2hhM0ZvckV4ZWN1dGVBbmRDb25maXJtKHJlY2lwaWVudHMsIHNlbGYuZ2V0RGVmYXVsdEV4cGlyZVRpbWUoKSwgc2VxdWVuY2VJZCk7XG4gICAgICAgIHNpZ25hdHVyZSA9IFV0aWwuZXRoU2lnbk1zZ0hhc2gob3BlcmF0aW9uSGFzaCwgVXRpbC54cHJ2VG9FdGhQcml2YXRlS2V5KHVzZXJLZXkpKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIFV0aWwuZWNSZWNvdmVyRXRoQWRkcmVzcyhvcGVyYXRpb25IYXNoLCBzaWduYXR1cmUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR4SW5mbyA9IHtcbiAgICAgICAgcmVjaXBpZW50OiByZWNpcGllbnRzWzBdLFxuICAgICAgICBleHBpcmVUaW1lOiBzZWxmLmdldERlZmF1bHRFeHBpcmVUaW1lKCksXG4gICAgICAgIGNvbnRyYWN0U2VxdWVuY2VJZDogc2VxdWVuY2VJZCxcbiAgICAgICAgb3BlcmF0aW9uSGFzaDogb3BlcmF0aW9uSGFzaCxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICAgIGdhc0xpbWl0OiBnYXNMaW1pdC50b1N0cmluZygxMCksXG4gICAgICB9O1xuXG4gICAgICAvLyBjYWxjdWxhdGUgc2VuZCBkYXRhXG4gICAgICBjb25zdCBzZW5kTWV0aG9kQXJncyA9IHNlbGYuZ2V0U2VuZE1ldGhvZEFyZ3ModHhJbmZvKTtcbiAgICAgIGNvbnN0IG1ldGhvZFNpZ25hdHVyZSA9IG9wdGlvbmFsRGVwcy5ldGhBYmkubWV0aG9kSUQoJ3NlbmRNdWx0aVNpZycsIF8ubWFwKHNlbmRNZXRob2RBcmdzLCAndHlwZScpKTtcbiAgICAgIGNvbnN0IGVuY29kZWRBcmdzID0gb3B0aW9uYWxEZXBzLmV0aEFiaS5yYXdFbmNvZGUoXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd0eXBlJyksIF8ubWFwKHNlbmRNZXRob2RBcmdzLCAndmFsdWUnKSk7XG4gICAgICBjb25zdCBzZW5kRGF0YSA9IEJ1ZmZlci5jb25jYXQoW21ldGhvZFNpZ25hdHVyZSwgZW5jb2RlZEFyZ3NdKTtcblxuICAgICAgLy8gQnVpbGQgY29udHJhY3QgY2FsbCBhbmQgc2lnbiBpdFxuICAgICAgY29uc3QgdHggPSBuZXcgb3B0aW9uYWxEZXBzLkV0aFR4KHtcbiAgICAgICAgdG86IHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3MsXG4gICAgICAgIG5vbmNlOiBiYWNrdXBLZXlOb25jZSxcbiAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgIGdhc1ByaWNlOiBnYXNQcmljZSxcbiAgICAgICAgZ2FzTGltaXQ6IGdhc0xpbWl0LFxuICAgICAgICBkYXRhOiBzZW5kRGF0YSxcbiAgICAgICAgc3BlbmRBbW91bnQ6IHR4QW1vdW50LFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0Rm9yT2ZmbGluZVZhdWx0KHR4SW5mbywgdHgsIHVzZXJLZXksIGJhY2t1cEtleSwgZ2FzUHJpY2UsIGdhc0xpbWl0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0tyc1JlY292ZXJ5KSB7XG4gICAgICAgIHR4LnNpZ24oYmFja3VwU2lnbmluZ0tleSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpZ25lZFR4OiBSZWNvdmVyeUluZm8gPSB7XG4gICAgICAgIGlkOiBvcHRpb25hbERlcHMuZXRoVXRpbC5idWZmZXJUb0hleCh0eC5oYXNoKHRydWUpKSxcbiAgICAgICAgdHg6IHR4LnNlcmlhbGl6ZSgpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIH07XG5cbiAgICAgIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgICAgIHNpZ25lZFR4LmJhY2t1cEtleSA9IGJhY2t1cEtleTtcbiAgICAgICAgc2lnbmVkVHguY29pbiA9IHNlbGYuZ2V0Q2hhaW4oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNpZ25lZFR4O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY292ZXIgYW4gdW5zdXBwb3J0ZWQgdG9rZW4gZnJvbSBhIEJpdEdvIG11bHRpc2lnIHdhbGxldFxuICAgKiBUaGlzIGJ1aWxkcyBhIGhhbGYtc2lnbmVkIHRyYW5zYWN0aW9uLCBmb3Igd2hpY2ggdGhlcmUgd2lsbCBiZSBhbiBhZG1pbiByb3V0ZSB0byBjby1zaWduIGFuZCBicm9hZGNhc3QuIE9wdGlvbmFsbHlcbiAgICogdGhlIHVzZXIgY2FuIHNldCBwYXJhbXMuYnJvYWRjYXN0ID0gdHJ1ZSBhbmQgdGhlIGhhbGYtc2lnbmVkIHR4IHdpbGwgYmUgc2VudCB0byBCaXRHbyBmb3IgY29zaWduaW5nIGFuZCBicm9hZGNhc3RpbmdcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldCB0aGUgd2FsbGV0IHRvIHJlY292ZXIgdGhlIHRva2VuIGZyb21cbiAgICogQHBhcmFtIHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzcyB0aGUgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgdW5zdXBwb3J0ZWQgdG9rZW5cbiAgICogQHBhcmFtIHBhcmFtcy5yZWNpcGllbnQgdGhlIGRlc3RpbmF0aW9uIGFkZHJlc3MgcmVjb3ZlcmVkIHRva2VucyBzaG91bGQgYmUgc2VudCB0b1xuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgdGhlIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2IHRoZSB4cHJ2XG4gICAqIEBwYXJhbSBwYXJhbXMuYnJvYWRjYXN0IGlmIHRydWUsIHdlIHdpbGwgYXV0b21hdGljYWxseSBzdWJtaXQgdGhlIGhhbGYtc2lnbmVkIHR4IHRvIEJpdEdvIGZvciBjb3NpZ25pbmcgYW5kIGJyb2FkY2FzdGluZ1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHJlY292ZXJUb2tlbihcbiAgICBwYXJhbXM6IFJlY292ZXJUb2tlbk9wdGlvbnMsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8UmVjb3ZlclRva2VuVHJhbnNhY3Rpb24+XG4gICk6IEJsdWViaXJkPFJlY292ZXJUb2tlblRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFJlY292ZXJUb2tlblRyYW5zYWN0aW9uPihmdW5jdGlvbiooKSB7XG4gICAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlY292ZXJUb2tlbiBtdXN0IGJlIHBhc3NlZCBhIHBhcmFtcyBvYmplY3QuIEdvdCAke3BhcmFtc30gKHR5cGUgJHt0eXBlb2YgcGFyYW1zfSlgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzKSB8fCAhXy5pc1N0cmluZyhwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgdG9rZW5Db250cmFjdEFkZHJlc3MgbXVzdCBiZSBhIHN0cmluZywgZ290ICR7XG4gICAgICAgICAgICBwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3NcbiAgICAgICAgICB9ICh0eXBlICR7dHlwZW9mIHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzc30pYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGYuaXNWYWxpZEFkZHJlc3MocGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rva2VuQ29udHJhY3RBZGRyZXNzIG5vdCBhIHZhbGlkIGFkZHJlc3MnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLndhbGxldCkgfHwgIShwYXJhbXMud2FsbGV0IGluc3RhbmNlb2YgV2FsbGV0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHdhbGxldCBtdXN0IGJlIGEgd2FsbGV0IGluc3RhbmNlLCBnb3QgJHtwYXJhbXMud2FsbGV0fSAodHlwZSAke3R5cGVvZiBwYXJhbXMud2FsbGV0fSlgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnJlY2lwaWVudCkgfHwgIV8uaXNTdHJpbmcocGFyYW1zLnJlY2lwaWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZWNpcGllbnQgbXVzdCBiZSBhIHN0cmluZywgZ290ICR7cGFyYW1zLnJlY2lwaWVudH0gKHR5cGUgJHt0eXBlb2YgcGFyYW1zLnJlY2lwaWVudH0pYCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjaXBpZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY2lwaWVudCBub3QgYSB2YWxpZCBhZGRyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9uYWxEZXBzLmV0aFV0aWwuYnVmZmVyVG9IZXggfHwgIW9wdGlvbmFsRGVwcy5ldGhBYmkuc29saWRpdHlTSEEzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXRoZXJldW0gbm90IGZ1bGx5IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0b2tlbiBiYWxhbmNlIGZyb20gZXh0ZXJuYWwgQVBJXG4gICAgICBjb25zdCBjb2luU3BlY2lmaWMgPSBwYXJhbXMud2FsbGV0LmNvaW5TcGVjaWZpYygpO1xuICAgICAgaWYgKCFjb2luU3BlY2lmaWMgfHwgIV8uaXNTdHJpbmcoY29pblNwZWNpZmljLmJhc2VBZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgY29pbiBzcGVjaWZpYyBwcm9wZXJ0eSBiYXNlQWRkcmVzcycpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVjb3ZlcnlBbW91bnQgPSB5aWVsZCBzZWxmLnF1ZXJ5QWRkcmVzc1Rva2VuQmFsYW5jZShwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MsIGNvaW5TcGVjaWZpYy5iYXNlQWRkcmVzcyk7XG5cbiAgICAgIGlmIChwYXJhbXMuYnJvYWRjYXN0KSB7XG4gICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGNyZWF0ZSBhIG5vcm1hbCBFVEggdHJhbnNhY3Rpb24gdGhhdCBzZW5kcyBhbiBhbW91bnQgb2YgMCBFVEggdG8gdGhlXG4gICAgICAgIC8vIHRva2VuQ29udHJhY3RBZGRyZXNzIGFuZCBlbmNvZGUgdGhlIHVuc3VwcG9ydGVkLXRva2VuLXNlbmQgZGF0YSBpbiB0aGUgZGF0YSBmaWVsZFxuICAgICAgICAvLyAjdHJpY2tzeVxuICAgICAgICBjb25zdCBzZW5kTWV0aG9kQXJncyA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnX3RvJyxcbiAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJhbXMucmVjaXBpZW50LFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ192YWx1ZScsXG4gICAgICAgICAgICB0eXBlOiAndWludDI1NicsXG4gICAgICAgICAgICB2YWx1ZTogcmVjb3ZlcnlBbW91bnQudG9TdHJpbmcoMTApLFxuICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IG1ldGhvZFNpZ25hdHVyZSA9IG9wdGlvbmFsRGVwcy5ldGhBYmkubWV0aG9kSUQoJ3RyYW5zZmVyJywgXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd0eXBlJykpO1xuICAgICAgICBjb25zdCBlbmNvZGVkQXJncyA9IG9wdGlvbmFsRGVwcy5ldGhBYmkucmF3RW5jb2RlKFxuICAgICAgICAgIF8ubWFwKHNlbmRNZXRob2RBcmdzLCAndHlwZScpLFxuICAgICAgICAgIF8ubWFwKHNlbmRNZXRob2RBcmdzLCAndmFsdWUnKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBzZW5kRGF0YSA9IEJ1ZmZlci5jb25jYXQoW21ldGhvZFNpZ25hdHVyZSwgZW5jb2RlZEFyZ3NdKTtcblxuICAgICAgICBjb25zdCBicm9hZGNhc3RQYXJhbXM6IGFueSA9IHtcbiAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgYW1vdW50OiAnMCcsXG4gICAgICAgICAgZGF0YTogc2VuZERhdGEudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkge1xuICAgICAgICAgIGJyb2FkY2FzdFBhcmFtcy53YWxsZXRQYXNzcGhyYXNlID0gcGFyYW1zLndhbGxldFBhc3NwaHJhc2U7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLnBydikge1xuICAgICAgICAgIGJyb2FkY2FzdFBhcmFtcy5wcnYgPSBwYXJhbXMucHJ2O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHlpZWxkIHBhcmFtcy53YWxsZXQuc2VuZChicm9hZGNhc3RQYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWNpcGllbnQgPSB7XG4gICAgICAgIGFkZHJlc3M6IHBhcmFtcy5yZWNpcGllbnQsXG4gICAgICAgIGFtb3VudDogcmVjb3ZlcnlBbW91bnQudG9TdHJpbmcoMTApLFxuICAgICAgfTtcblxuICAgICAgLy8gVGhpcyBzaWduYXR1cmUgd2lsbCBiZSB2YWxpZCBmb3Igb25lIHdlZWtcbiAgICAgIGNvbnN0IGV4cGlyZVRpbWUgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCkgKyA2MCAqIDYwICogMjQgKiA3O1xuXG4gICAgICAvLyBHZXQgc2VxdWVuY2UgSUQuIFdlIGRvIHRoaXMgYnkgYnVpbGRpbmcgYSAnZmFrZScgZXRoIHRyYW5zYWN0aW9uLCBzbyB0aGUgcGxhdGZvcm0gd2lsbCBpbmNyZW1lbnQgYW5kIHJldHVybiB1cyB0aGUgbmV3IHNlcXVlbmNlIGlkXG4gICAgICAvLyBUaGlzIF9kb2VzXyByZXF1aXJlIHRoZSB1c2VyIHRvIGhhdmUgYSBub24temVybyB3YWxsZXQgYmFsYW5jZVxuICAgICAgY29uc3QgeyBuZXh0Q29udHJhY3RTZXF1ZW5jZUlkLCBnYXNQcmljZSwgZ2FzTGltaXQgfSA9IHlpZWxkIHBhcmFtcy53YWxsZXQucHJlYnVpbGRUcmFuc2FjdGlvbih7XG4gICAgICAgIHJlY2lwaWVudHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMucmVjaXBpZW50LFxuICAgICAgICAgICAgYW1vdW50OiAnMScsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGVzZSByZWNvdmVyaWVzIG5lZWQgdG8gYmUgcHJvY2Vzc2VkIGJ5IHN1cHBvcnQsIGJ1dCBpZiB0aGUgY3VzdG9tZXIgc2VuZHMgYW55IHRyYW5zYWN0aW9ucyBiZWZvcmUgcmVjb3ZlcnkgaXNcbiAgICAgIC8vIGNvbXBsZXRlIHRoZSBzZXF1ZW5jZSBJRCB3aWxsIGJlIGludmFsaWQuIGFydGlmaWNpYWxseSBpbmZsYXRlIHRoZSBzZXF1ZW5jZSBJRCB0byBhbGxvdyBtb3JlIHRpbWUgZm9yIHByb2Nlc3NpbmdcbiAgICAgIGNvbnN0IHNhZmVTZXF1ZW5jZUlkID0gbmV4dENvbnRyYWN0U2VxdWVuY2VJZCArIDEwMDA7XG5cbiAgICAgIC8vIEJ1aWxkIHNlbmREYXRhIGZvciBldGhlcmV1bSB0eFxuICAgICAgY29uc3Qgb3BlcmF0aW9uVHlwZXMgPSBbJ3N0cmluZycsICdhZGRyZXNzJywgJ3VpbnQnLCAnYWRkcmVzcycsICd1aW50JywgJ3VpbnQnXTtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbkFyZ3MgPSBbXG4gICAgICAgIC8vIFwiRVJDMjBcIiBoYXMgYmVlbiBhZGRlZCBoZXJlIHNvIHRoYXQgZXRoZXIgb3BlcmF0aW9uIGhhc2hlcywgc2lnbmF0dXJlcyBjYW5ub3QgYmUgcmUtdXNlZCBmb3IgdG9rZW5TZW5kaW5nXG4gICAgICAgICdFUkMyMCcsXG4gICAgICAgIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTihvcHRpb25hbERlcHMuZXRoVXRpbC5zdHJpcEhleFByZWZpeChyZWNpcGllbnQuYWRkcmVzcyksIDE2KSxcbiAgICAgICAgcmVjaXBpZW50LmFtb3VudCxcbiAgICAgICAgbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKG9wdGlvbmFsRGVwcy5ldGhVdGlsLnN0cmlwSGV4UHJlZml4KHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzcyksIDE2KSxcbiAgICAgICAgZXhwaXJlVGltZSxcbiAgICAgICAgc2FmZVNlcXVlbmNlSWQsXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBvcGVyYXRpb25IYXNoID0gb3B0aW9uYWxEZXBzLmV0aFV0aWwuYnVmZmVyVG9IZXgoXG4gICAgICAgIG9wdGlvbmFsRGVwcy5ldGhBYmkuc29saWRpdHlTSEEzKG9wZXJhdGlvblR5cGVzLCBvcGVyYXRpb25BcmdzKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgdXNlclBydiA9IHlpZWxkIHBhcmFtcy53YWxsZXQuZ2V0UHJ2KHtcbiAgICAgICAgcHJ2OiBwYXJhbXMucHJ2LFxuICAgICAgICB3YWxsZXRQYXNzcGhyYXNlOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBVdGlsLmV0aFNpZ25Nc2dIYXNoKG9wZXJhdGlvbkhhc2gsIFV0aWwueHBydlRvRXRoUHJpdmF0ZUtleSh1c2VyUHJ2KSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdDogUmVjb3ZlclRva2VuVHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIGhhbGZTaWduZWQ6IHtcbiAgICAgICAgICByZWNpcGllbnQ6IHJlY2lwaWVudCxcbiAgICAgICAgICBleHBpcmVUaW1lOiBleHBpcmVUaW1lLFxuICAgICAgICAgIGNvbnRyYWN0U2VxdWVuY2VJZDogc2FmZVNlcXVlbmNlSWQsXG4gICAgICAgICAgb3BlcmF0aW9uSGFzaDogb3BlcmF0aW9uSGFzaCxcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgICAgICBnYXNMaW1pdDogZ2FzTGltaXQsXG4gICAgICAgICAgZ2FzUHJpY2U6IGdhc1ByaWNlLFxuICAgICAgICAgIHRva2VuQ29udHJhY3RBZGRyZXNzOiBwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgd2FsbGV0SWQ6IHBhcmFtcy53YWxsZXQuaWQoKSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYXJndW1lbnRzIHRvIGNhbGwgdGhlIHNlbmQgbWV0aG9kIG9uIHRoZSB3YWxsZXQgY29udHJhY3RcbiAgICogQHBhcmFtIHR4SW5mb1xuICAgKi9cbiAgZ2V0U2VuZE1ldGhvZEFyZ3ModHhJbmZvOiBHZXRTZW5kTWV0aG9kQXJnc09wdGlvbnMpOiBTZW5kTWV0aG9kQXJnc1tdIHtcbiAgICAvLyBNZXRob2Qgc2lnbmF0dXJlIGlzXG4gICAgLy8gc2VuZE11bHRpU2lnKGFkZHJlc3MgdG9BZGRyZXNzLCB1aW50IHZhbHVlLCBieXRlcyBkYXRhLCB1aW50IGV4cGlyZVRpbWUsIHVpbnQgc2VxdWVuY2VJZCwgYnl0ZXMgc2lnbmF0dXJlKVxuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd0b0FkZHJlc3MnLFxuICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgIHZhbHVlOiB0eEluZm8ucmVjaXBpZW50LmFkZHJlc3MsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAndmFsdWUnLFxuICAgICAgICB0eXBlOiAndWludCcsXG4gICAgICAgIHZhbHVlOiB0eEluZm8ucmVjaXBpZW50LmFtb3VudCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdkYXRhJyxcbiAgICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgICAgdmFsdWU6IG9wdGlvbmFsRGVwcy5ldGhVdGlsLnRvQnVmZmVyKHR4SW5mby5yZWNpcGllbnQuZGF0YSB8fCAnJyksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnZXhwaXJlVGltZScsXG4gICAgICAgIHR5cGU6ICd1aW50JyxcbiAgICAgICAgdmFsdWU6IHR4SW5mby5leHBpcmVUaW1lLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3NlcXVlbmNlSWQnLFxuICAgICAgICB0eXBlOiAndWludCcsXG4gICAgICAgIHZhbHVlOiB0eEluZm8uY29udHJhY3RTZXF1ZW5jZUlkLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3NpZ25hdHVyZScsXG4gICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgIHZhbHVlOiBvcHRpb25hbERlcHMuZXRoVXRpbC50b0J1ZmZlcih0eEluZm8uc2lnbmF0dXJlKSxcbiAgICAgIH0sXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgcXVlcnkgdG8gRXRoZXJzY2FuIGZvciBpbmZvcm1hdGlvbiBzdWNoIGFzIGJhbGFuY2UsIHRva2VuIGJhbGFuY2UsIHNvbGlkaXR5IGNhbGxzXG4gICAqIEBwYXJhbSBxdWVyeSB7T2JqZWN0fSBrZXktdmFsdWUgcGFpcnMgb2YgcGFyYW1ldGVycyB0byBhcHBlbmQgYWZ0ZXIgL2FwaVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge09iamVjdH0gcmVzcG9uc2UgZnJvbSBFdGhlcnNjYW5cbiAgICovXG4gIHJlY292ZXJ5QmxvY2tjaGFpbkV4cGxvcmVyUXVlcnkocXVlcnk6IGFueSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiooKSB7XG4gICAgICBpZiAoY29tbW9uLkVudmlyb25tZW50c1tzZWxmLmJpdGdvLmdldEVudigpXS5ldGhlcnNjYW5BcGlUb2tlbikge1xuICAgICAgICBxdWVyeS5hcGlrZXkgPSBjb21tb24uRW52aXJvbm1lbnRzW3NlbGYuYml0Z28uZ2V0RW52KCldLmV0aGVyc2NhbkFwaVRva2VuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0XG4gICAgICAgIC5nZXQoY29tbW9uLkVudmlyb25tZW50c1tzZWxmLmJpdGdvLmdldEVudigpXS5ldGhlcnNjYW5CYXNlVXJsICsgJy9hcGknKVxuICAgICAgICAucXVlcnkocXVlcnkpO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWNoIEV0aGVyc2NhbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmJvZHk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgZXh0cmEgcGFyYW1ldGVycyBuZWVkZWQgdG8gYnVpbGQgYSBob3AgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIGJ1aWxkUGFyYW1zIFRoZSBvcmlnaW5hbCBidWlsZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyBleHRyYSBwYXJhbWV0ZXJzIG9iamVjdCB0byBtZXJnZSB3aXRoIHRoZSBvcmlnaW5hbCBidWlsZCBwYXJhbWV0ZXJzIG9iamVjdCBhbmQgc2VuZCB0byB0aGUgcGxhdGZvcm1cbiAgICovXG4gIGNyZWF0ZUhvcFRyYW5zYWN0aW9uUGFyYW1zKFxuICAgIGJ1aWxkUGFyYW1zOiBIb3BUcmFuc2FjdGlvbkJ1aWxkT3B0aW9ucyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxIb3BQYXJhbXM+XG4gICk6IEJsdWViaXJkPEhvcFBhcmFtcz4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxIb3BQYXJhbXM+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbnN0IHdhbGxldCA9IGJ1aWxkUGFyYW1zLndhbGxldDtcbiAgICAgIGNvbnN0IHJlY2lwaWVudHMgPSBidWlsZFBhcmFtcy5yZWNpcGllbnRzO1xuICAgICAgY29uc3Qgd2FsbGV0UGFzc3BocmFzZSA9IGJ1aWxkUGFyYW1zLndhbGxldFBhc3NwaHJhc2U7XG5cbiAgICAgIGNvbnN0IHVzZXJLZXljaGFpbiA9IHlpZWxkIHNlbGYua2V5Y2hhaW5zKCkuZ2V0KHsgaWQ6IHdhbGxldC5rZXlJZHMoKVswXSB9KTtcbiAgICAgIGNvbnN0IHVzZXJQcnYgPSB3YWxsZXQuZ2V0VXNlclBydih7IGtleWNoYWluOiB1c2VyS2V5Y2hhaW4sIHdhbGxldFBhc3NwaHJhc2UgfSk7XG4gICAgICBjb25zdCB1c2VyUHJ2QnVmZmVyID0gdXR4b0xpYi5IRE5vZGUuZnJvbUJhc2U1OCh1c2VyUHJ2KVxuICAgICAgICAuZ2V0S2V5KClcbiAgICAgICAgLmdldFByaXZhdGVLZXlCdWZmZXIoKTtcbiAgICAgIGlmICghcmVjaXBpZW50cyB8fCAhQXJyYXkuaXNBcnJheShyZWNpcGllbnRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyBhcnJheSBvZiByZWNpcGllbnRzJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJpZ2h0IG5vdyB3ZSBvbmx5IHN1cHBvcnQgMSByZWNpcGllbnRcbiAgICAgIGlmIChyZWNpcGllbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc2VuZCB0byBleGFjdGx5IDEgcmVjaXBpZW50Jyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWNpcGllbnRBZGRyZXNzID0gcmVjaXBpZW50c1swXS5hZGRyZXNzO1xuICAgICAgY29uc3QgcmVjaXBpZW50QW1vdW50ID0gcmVjaXBpZW50c1swXS5hbW91bnQ7XG4gICAgICBjb25zdCBmZWVFc3RpbWF0ZVBhcmFtcyA9IHtcbiAgICAgICAgcmVjaXBpZW50OiByZWNpcGllbnRBZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IHJlY2lwaWVudEFtb3VudCxcbiAgICAgICAgaG9wOiB0cnVlLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZlZUVzdGltYXRlOiBGZWVFc3RpbWF0ZSA9IHlpZWxkIHNlbGYuZmVlRXN0aW1hdGUoZmVlRXN0aW1hdGVQYXJhbXMpO1xuXG4gICAgICBjb25zdCBnYXNMaW1pdCA9IGZlZUVzdGltYXRlLmdhc0xpbWl0RXN0aW1hdGU7XG4gICAgICBjb25zdCBnYXNQcmljZSA9IE1hdGgucm91bmQoZmVlRXN0aW1hdGUuZmVlRXN0aW1hdGUgLyBnYXNMaW1pdCk7XG4gICAgICBjb25zdCBnYXNQcmljZU1heCA9IGdhc1ByaWNlICogNTtcbiAgICAgIC8vIFBheW1lbnQgaWQgYSByYW5kb20gbnVtYmVyIHNvIGl0cyBkaWZmZXJlbnQgZm9yIGV2ZXJ5IHR4XG4gICAgICBjb25zdCBwYXltZW50SWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDAwMCkudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IGhvcERpZ2VzdDogQnVmZmVyID0gRXRoLmdldEhvcERpZ2VzdChbXG4gICAgICAgIHJlY2lwaWVudEFkZHJlc3MsXG4gICAgICAgIHJlY2lwaWVudEFtb3VudCxcbiAgICAgICAgZ2FzUHJpY2VNYXgudG9TdHJpbmcoKSxcbiAgICAgICAgZ2FzTGltaXQudG9TdHJpbmcoKSxcbiAgICAgICAgcGF5bWVudElkLFxuICAgICAgXSk7XG5cbiAgICAgIGNvbnN0IHVzZXJSZXFTaWcgPSBvcHRpb25hbERlcHMuZXRoVXRpbC5hZGRIZXhQcmVmaXgoXG4gICAgICAgIHNlY3AyNTZrMS5zaWduKGhvcERpZ2VzdCwgdXNlclBydkJ1ZmZlcikuc2lnbmF0dXJlLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzdWx0OiBIb3BQYXJhbXMgPSB7XG4gICAgICAgIGhvcFBhcmFtczoge1xuICAgICAgICAgIGdhc1ByaWNlTWF4LFxuICAgICAgICAgIHVzZXJSZXFTaWcsXG4gICAgICAgICAgcGF5bWVudElkLFxuICAgICAgICB9LFxuICAgICAgICBnYXNMaW1pdCxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIGhvcCBwcmVidWlsZCBmcm9tIHRoZSBIU00gaXMgdmFsaWQgYW5kIGNvcnJlY3RcbiAgICogQHBhcmFtIHdhbGxldCBUaGUgd2FsbGV0IHRoYXQgdGhlIHByZWJ1aWxkIGlzIGZvclxuICAgKiBAcGFyYW0gaG9wUHJlYnVpbGQgVGhlIHByZWJ1aWxkIHRvIHZhbGlkYXRlXG4gICAqIEBwYXJhbSBvcmlnaW5hbFBhcmFtcyBUaGUgb3JpZ2luYWwgcGFyYW1ldGVycyBwYXNzZWQgdG8gcHJlYnVpbGRUcmFuc2FjdGlvblxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgdm9pZFxuICAgKiBAdGhyb3dzIEVycm9yIGlmIFRoZSBwcmVidWlsZCBpcyBpbnZhbGlkXG4gICAqL1xuICB2YWxpZGF0ZUhvcFByZWJ1aWxkKFxuICAgIHdhbGxldDogV2FsbGV0LFxuICAgIGhvcFByZWJ1aWxkOiBIb3BQcmVidWlsZCxcbiAgICBvcmlnaW5hbFBhcmFtcz86IHsgcmVjaXBpZW50czogUmVjaXBpZW50W10gfSxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazx2b2lkPlxuICApOiBCbHVlYmlyZDx2b2lkPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPHZvaWQ+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbnN0IHsgdHgsIGlkLCBzaWduYXR1cmUgfSA9IGhvcFByZWJ1aWxkO1xuXG4gICAgICAvLyBmaXJzdCwgdmFsaWRhdGUgdGhlIEhTTSBzaWduYXR1cmVcbiAgICAgIGNvbnN0IHNlcnZlclhwdWIgPSBjb21tb24uRW52aXJvbm1lbnRzW3NlbGYuYml0Z28uZ2V0RW52KCldLmhzbVhwdWI7XG4gICAgICBjb25zdCBzZXJ2ZXJQdWJrZXlCdWZmZXI6IEJ1ZmZlciA9IHV0eG9MaWIuSEROb2RlLmZyb21CYXNlNTgoc2VydmVyWHB1YikuZ2V0UHVibGljS2V5QnVmZmVyKCk7XG4gICAgICBjb25zdCBzaWduYXR1cmVCdWZmZXI6IEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKG9wdGlvbmFsRGVwcy5ldGhVdGlsLnN0cmlwSGV4UHJlZml4KHNpZ25hdHVyZSksICdoZXgnKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VCdWZmZXI6IEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKG9wdGlvbmFsRGVwcy5ldGhVdGlsLnN0cmlwSGV4UHJlZml4KGlkKSwgJ2hleCcpO1xuXG4gICAgICBjb25zdCBpc1ZhbGlkU2lnbmF0dXJlOiBib29sZWFuID0gc2VjcDI1NmsxLnZlcmlmeShtZXNzYWdlQnVmZmVyLCBzaWduYXR1cmVCdWZmZXIuc2xpY2UoMSksIHNlcnZlclB1YmtleUJ1ZmZlcik7XG4gICAgICBpZiAoIWlzVmFsaWRTaWduYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIb3AgdHhpZCBzaWduYXR1cmUgaW52YWxpZGApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBidWlsdEhvcFR4ID0gbmV3IG9wdGlvbmFsRGVwcy5FdGhUeCh0eCk7XG4gICAgICAvLyBJZiBvcmlnaW5hbCBwYXJhbXMgYXJlIGdpdmVuLCB3ZSBjYW4gY2hlY2sgdGhlbSBhZ2FpbnN0IHRoZSB0cmFuc2FjdGlvbiBwcmVidWlsZCBwYXJhbXNcbiAgICAgIGlmICghXy5pc05pbChvcmlnaW5hbFBhcmFtcykpIHtcbiAgICAgICAgY29uc3QgeyByZWNpcGllbnRzIH0gPSBvcmlnaW5hbFBhcmFtcztcblxuICAgICAgICAvLyBUaGVuIHZhbGlkYXRlIHRoYXQgdGhlIHR4IHBhcmFtcyBhY3R1YWxseSBlcXVhbCB0aGUgcmVxdWVzdGVkIHBhcmFtc1xuICAgICAgICBjb25zdCBvcmlnaW5hbEFtb3VudCA9IG5ldyBCaWdOdW1iZXIocmVjaXBpZW50c1swXS5hbW91bnQpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbERlc3RpbmF0aW9uOiBzdHJpbmcgPSByZWNpcGllbnRzWzBdLmFkZHJlc3M7XG5cbiAgICAgICAgY29uc3QgaG9wQW1vdW50ID0gbmV3IEJpZ051bWJlcihvcHRpb25hbERlcHMuZXRoVXRpbC5idWZmZXJUb0hleChidWlsdEhvcFR4LnZhbHVlKSk7XG4gICAgICAgIGNvbnN0IGhvcERlc3RpbmF0aW9uOiBzdHJpbmcgPSBvcHRpb25hbERlcHMuZXRoVXRpbC5idWZmZXJUb0hleChidWlsdEhvcFR4LnRvKTtcbiAgICAgICAgaWYgKCFob3BBbW91bnQuZXEob3JpZ2luYWxBbW91bnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIb3AgYW1vdW50OiAke2hvcEFtb3VudH0gZG9lcyBub3QgZXF1YWwgb3JpZ2luYWwgYW1vdW50OiAke29yaWdpbmFsQW1vdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob3BEZXN0aW5hdGlvbi50b0xvd2VyQ2FzZSgpICE9PSBvcmlnaW5hbERlc3RpbmF0aW9uLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhvcCBkZXN0aW5hdGlvbjogJHtob3BEZXN0aW5hdGlvbn0gZG9lcyBub3QgZXF1YWwgb3JpZ2luYWwgcmVjaXBpZW50OiAke2hvcERlc3RpbmF0aW9ufWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYnVpbHRIb3BUeC52ZXJpZnlTaWduYXR1cmUoKSkge1xuICAgICAgICAvLyBXZSBkb250IHdhbnQgdG8gY29udGludWUgYXQgYWxsIGluIHRoaXMgY2FzZSwgYXQgcmlzayBvZiBFVEggYmVpbmcgc3R1Y2sgb24gdGhlIGhvcCBhZGRyZXNzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBob3AgdHJhbnNhY3Rpb24gc2lnbmF0dXJlLCB0eGlkOiAke2lkfWApO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbmFsRGVwcy5ldGhVdGlsLmFkZEhleFByZWZpeChidWlsdEhvcFR4Lmhhc2goKS50b1N0cmluZygnaGV4JykpICE9PSBpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpZ25lZCBob3AgdHhpZCBkb2VzIG5vdCBlcXVhbCBhY3R1YWwgdHhpZGApO1xuICAgICAgfVxuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGhvcCBkaWdlc3QgZm9yIHRoZSB1c2VyIHRvIHNpZ24uIFRoaXMgaXMgdmFsaWRhdGVkIGluIHRoZSBIU00gdG8gcHJvdmUgdGhhdCB0aGUgdXNlciByZXF1ZXN0ZWQgdGhpcyB0eFxuICAgKiBAcGFyYW0gcGFyYW1zQXJyIFRoZSBwYXJhbWV0ZXJzIHRvIGhhc2ggdG9nZXRoZXIgZm9yIHRoZSBkaWdlc3RcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGdldEhvcERpZ2VzdChwYXJhbXNBcnI6IHN0cmluZ1tdKTogQnVmZmVyIHtcbiAgICBjb25zdCBoYXNoID0gbmV3IEtlY2Nhaygna2VjY2FrMjU2Jyk7XG4gICAgaGFzaC51cGRhdGUoW0V0aC5ob3BUcmFuc2FjdGlvblNhbHQsIC4uLnBhcmFtc0Fycl0uam9pbignJCcpKTtcbiAgICByZXR1cm4gaGFzaC5kaWdlc3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZnkgcHJlYnVpbGQgYmVmb3JlIHNlbmRpbmcgaXQgdG8gdGhlIHNlcnZlci4gQWRkIHRoaW5ncyBsaWtlIGhvcCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAgICogQHBhcmFtIGJ1aWxkUGFyYW1zIFRoZSB3aGl0ZWxpc3RlZCBwYXJhbWV0ZXJzIGZvciB0aGlzIHByZWJ1aWxkXG4gICAqIEBwYXJhbSBidWlsZFBhcmFtcy5ob3AgVHJ1ZSBpZiB0aGlzIHNob3VsZCBwcmVidWlsZCBhIGhvcCB0eCwgZWxzZSBmYWxzZVxuICAgKiBAcGFyYW0gYnVpbGRQYXJhbXMucmVjaXBpZW50cyBUaGUgcmVjaXBpZW50cyBhcnJheSBvZiB0aGlzIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBidWlsZFBhcmFtcy53YWxsZXQgVGhlIHdhbGxldCBzZW5kaW5nIHRoaXMgdHhcbiAgICogQHBhcmFtIGJ1aWxkUGFyYW1zLndhbGxldFBhc3NwaHJhc2UgdGhlIHBhc3NwaHJhc2UgZm9yIHRoaXMgd2FsbGV0XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZ2V0RXh0cmFQcmVidWlsZFBhcmFtcyhidWlsZFBhcmFtczogQnVpbGRPcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxCdWlsZE9wdGlvbnM+KTogQmx1ZWJpcmQ8QnVpbGRPcHRpb25zPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPEJ1aWxkT3B0aW9ucz4oZnVuY3Rpb24qKCkge1xuICAgICAgaWYgKFxuICAgICAgICAhXy5pc1VuZGVmaW5lZChidWlsZFBhcmFtcy5ob3ApICYmXG4gICAgICAgIGJ1aWxkUGFyYW1zLmhvcCAmJlxuICAgICAgICAhXy5pc1VuZGVmaW5lZChidWlsZFBhcmFtcy53YWxsZXQpICYmXG4gICAgICAgICFfLmlzVW5kZWZpbmVkKGJ1aWxkUGFyYW1zLnJlY2lwaWVudHMpICYmXG4gICAgICAgICFfLmlzVW5kZWZpbmVkKGJ1aWxkUGFyYW1zLndhbGxldFBhc3NwaHJhc2UpXG4gICAgICApIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBFcmMyMFRva2VuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEhvcCB0cmFuc2FjdGlvbnMgYXJlIG5vdCBlbmFibGVkIGZvciBFUkMtMjAgdG9rZW5zLCBub3IgYXJlIHRoZXkgbmVjZXNzYXJ5LiBQbGVhc2UgcmVtb3ZlIHRoZSAnaG9wJyBwYXJhbWV0ZXIgYW5kIHRyeSBhZ2Fpbi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWllbGQgc2VsZi5jcmVhdGVIb3BUcmFuc2FjdGlvblBhcmFtcyh7XG4gICAgICAgICAgd2FsbGV0OiBidWlsZFBhcmFtcy53YWxsZXQsXG4gICAgICAgICAgcmVjaXBpZW50czogYnVpbGRQYXJhbXMucmVjaXBpZW50cyxcbiAgICAgICAgICB3YWxsZXRQYXNzcGhyYXNlOiBidWlsZFBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZnkgcHJlYnVpbGQgYWZ0ZXIgcmVjZWl2aW5nIGl0IGZyb20gdGhlIHNlcnZlci4gQWRkIHRoaW5ncyBsaWtlIG5sb2NrdGltZVxuICAgKi9cbiAgcG9zdFByb2Nlc3NQcmVidWlsZChcbiAgICBwYXJhbXM6IFRyYW5zYWN0aW9uUHJlYnVpbGQsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8VHJhbnNhY3Rpb25QcmVidWlsZD5cbiAgKTogQmx1ZWJpcmQ8VHJhbnNhY3Rpb25QcmVidWlsZD4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxUcmFuc2FjdGlvblByZWJ1aWxkPihmdW5jdGlvbiooKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5ob3BUcmFuc2FjdGlvbikgJiZcbiAgICAgICAgIV8uaXNVbmRlZmluZWQocGFyYW1zLndhbGxldCkgJiZcbiAgICAgICAgIV8uaXNVbmRlZmluZWQocGFyYW1zLmJ1aWxkUGFyYW1zKVxuICAgICAgKSB7XG4gICAgICAgIHlpZWxkIHNlbGYudmFsaWRhdGVIb3BQcmVidWlsZChwYXJhbXMud2FsbGV0LCBwYXJhbXMuaG9wVHJhbnNhY3Rpb24sIHBhcmFtcy5idWlsZFBhcmFtcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENvaW4tc3BlY2lmaWMgdGhpbmdzIGRvbmUgYmVmb3JlIHNpZ25pbmcgYSB0cmFuc2FjdGlvbiwgaS5lLiB2ZXJpZmljYXRpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHByZXNpZ25UcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IFRyYW5zYWN0aW9uUHJlYnVpbGQsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8VHJhbnNhY3Rpb25QcmVidWlsZD5cbiAgKTogQmx1ZWJpcmQ8VHJhbnNhY3Rpb25QcmVidWlsZD4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxUcmFuc2FjdGlvblByZWJ1aWxkPihmdW5jdGlvbiooKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5ob3BUcmFuc2FjdGlvbikgJiZcbiAgICAgICAgIV8uaXNVbmRlZmluZWQocGFyYW1zLndhbGxldCkgJiZcbiAgICAgICAgIV8uaXNVbmRlZmluZWQocGFyYW1zLmJ1aWxkUGFyYW1zKVxuICAgICAgKSB7XG4gICAgICAgIHlpZWxkIHNlbGYudmFsaWRhdGVIb3BQcmVidWlsZChwYXJhbXMud2FsbGV0LCBwYXJhbXMuaG9wVHJhbnNhY3Rpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBmZWUgZXN0aW1hdGUgaW5mb3JtYXRpb24gZnJvbSB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhlIHBhcmFtcyBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmhvcF0gVHJ1ZSBpZiB3ZSBzaG91bGQgZXN0aW1hdGUgZmVlIGZvciBhIGhvcCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5yZWNpcGllbnRdIFRoZSByZWNpcGllbnQgb2YgdGhlIHRyYW5zYWN0aW9uIHRvIGVzdGltYXRlIGEgc2VuZCB0b1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5kYXRhXSBUaGUgRVRIIHR4IGRhdGEgdG8gZXN0aW1hdGUgYSBzZW5kIGZvclxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGZlZSBpbmZvIHJldHVybmVkIGZyb20gdGhlIHNlcnZlclxuICAgKi9cbiAgZmVlRXN0aW1hdGUocGFyYW1zOiBGZWVFc3RpbWF0ZU9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPEZlZUVzdGltYXRlPik6IEJsdWViaXJkPEZlZUVzdGltYXRlPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPEZlZUVzdGltYXRlPihmdW5jdGlvbiogY29GZWVFc3RpbWF0ZSgpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5OiBGZWVFc3RpbWF0ZU9wdGlvbnMgPSB7fTtcbiAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLmhvcCkge1xuICAgICAgICBxdWVyeS5ob3AgPSBwYXJhbXMuaG9wO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMucmVjaXBpZW50KSB7XG4gICAgICAgIHF1ZXJ5LnJlY2lwaWVudCA9IHBhcmFtcy5yZWNpcGllbnQ7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5kYXRhKSB7XG4gICAgICAgIHF1ZXJ5LmRhdGEgPSBwYXJhbXMuZGF0YTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLmFtb3VudCkge1xuICAgICAgICBxdWVyeS5hbW91bnQgPSBwYXJhbXMuYW1vdW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5iaXRnb1xuICAgICAgICAuZ2V0KHNlbGYudXJsKCcvdHgvZmVlJykpXG4gICAgICAgIC5xdWVyeShxdWVyeSlcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHNlY3AyNTZrMSBrZXkgcGFpclxuICAgKlxuICAgKiBAcGFyYW0gc2VlZFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2l0aCBnZW5lcmF0ZWQgcHViIGFuZCBwcnZcbiAgICovXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkOiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBpZiAoIXNlZWQpIHtcbiAgICAgIC8vIEFuIGV4dGVuZGVkIHByaXZhdGUga2V5IGhhcyBib3RoIGEgbm9ybWFsIDI1NiBiaXQgcHJpdmF0ZSBrZXkgYW5kIGEgMjU2XG4gICAgICAvLyBiaXQgY2hhaW4gY29kZSwgYm90aCBvZiB3aGljaCBtdXN0IGJlIHJhbmRvbS4gNTEyIGJpdHMgaXMgdGhlcmVmb3JlIHRoZVxuICAgICAgLy8gbWF4aW11bSBlbnRyb3B5IGFuZCBnaXZlcyB1cyBtYXhpbXVtIHNlY3VyaXR5IGFnYWluc3QgY3JhY2tpbmcuXG4gICAgICBzZWVkID0gcmFuZG9tQnl0ZXMoNTEyIC8gOCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuZGVkS2V5ID0gdXR4b0xpYi5IRE5vZGUuZnJvbVNlZWRCdWZmZXIoc2VlZCk7XG4gICAgY29uc3QgeHB1YiA9IGV4dGVuZGVkS2V5Lm5ldXRlcmVkKCkudG9CYXNlNTgoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiB4cHViLFxuICAgICAgcHJ2OiBleHRlbmRlZEtleS50b0Jhc2U1OCgpLFxuICAgIH07XG4gIH1cblxuICBwYXJzZVRyYW5zYWN0aW9uKFxuICAgIHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8UGFyc2VkVHJhbnNhY3Rpb24+XG4gICk6IEJsdWViaXJkPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUoe30pLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgdmVyaWZ5QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2ZXJpZnlUcmFuc2FjdGlvbihwYXJhbXM6IFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8Ym9vbGVhbj4pOiBCbHVlYmlyZDxib29sZWFuPiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUodHJ1ZSkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cbn1cbiJdfQ==