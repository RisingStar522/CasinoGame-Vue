"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var account_lib_1 = require("@bitgo/account-lib");
var Bluebird = require("bluebird");
var bitcoinMessage = require("bitcoinjs-message");
var bitgoUtxoLib = require("@bitgo/utxo-lib");
var crypto_1 = require("crypto");
var baseCoin_1 = require("../baseCoin");
var errors_1 = require("../../errors");
var bignumber_js_1 = require("bignumber.js");
var AbstractEthLikeCoin = /** @class */ (function (_super) {
    __extends(AbstractEthLikeCoin, _super);
    function AbstractEthLikeCoin(bitgo, staticsCoin) {
        var _this = _super.call(this, bitgo) || this;
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        _this._staticsCoin = staticsCoin;
        return _this;
    }
    AbstractEthLikeCoin.prototype.getChain = function () {
        return this._staticsCoin.name;
    };
    AbstractEthLikeCoin.prototype.getFamily = function () {
        return this._staticsCoin.family;
    };
    AbstractEthLikeCoin.prototype.getFullName = function () {
        return this._staticsCoin.fullName;
    };
    AbstractEthLikeCoin.prototype.getBaseFactor = function () {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    };
    AbstractEthLikeCoin.prototype.valuelessTransferAllowed = function () {
        return true;
    };
    AbstractEthLikeCoin.prototype.isValidAddress = function (address) {
        if (!address) {
            return false;
        }
        return account_lib_1.Eth.Utils.isValidEthAddress(address);
    };
    AbstractEthLikeCoin.prototype.generateKeyPair = function (seed) {
        if (!seed) {
            seed = crypto_1.randomBytes(512 / 8);
        }
        var extendedKey = bitgoUtxoLib.HDNode.fromSeedBuffer(seed);
        var xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58(),
        };
    };
    AbstractEthLikeCoin.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    AbstractEthLikeCoin.prototype.verifyAddress = function (_a) {
        var address = _a.address;
        if (!this.isValidAddress(address)) {
            throw new errors_1.InvalidAddressError("invalid address: " + address);
        }
        return true;
    };
    AbstractEthLikeCoin.prototype.verifyTransaction = function (params, callback) {
        return Bluebird.resolve(true).asCallback(callback);
    };
    AbstractEthLikeCoin.prototype.signTransaction = function (params, callback) {
        return __awaiter(this, void 0, Bluebird, function () {
            var txBuilder, transaction, recipients;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txBuilder = this.getTransactionBuilder();
                        txBuilder.from(params.txPrebuild.txHex);
                        txBuilder.transfer().key(new account_lib_1.Eth.KeyPair({ prv: params.prv }).getKeys().prv);
                        return [4 /*yield*/, txBuilder.build()];
                    case 1:
                        transaction = _a.sent();
                        recipients = transaction.outputs.map(function (output) { return ({ address: output.address, amount: output.value }); });
                        return [2 /*return*/, {
                                halfSigned: {
                                    txHex: transaction.toBroadcastFormat(),
                                    recipients: recipients,
                                    expiration: params.txPrebuild.expireTime,
                                },
                            }];
                }
            });
        });
    };
    AbstractEthLikeCoin.prototype.signMessage = function (key, message, callback) {
        return __awaiter(this, void 0, Bluebird, function () {
            var privateKey, privateKeyBuffer, isCompressed, prefix;
            return __generator(this, function (_a) {
                privateKey = bitgoUtxoLib.HDNode.fromBase58(key.prv).getKey();
                privateKeyBuffer = privateKey.d.toBuffer(32);
                isCompressed = privateKey.compressed;
                prefix = bitgoUtxoLib.networks.bitcoin.messagePrefix;
                return [2 /*return*/, bitcoinMessage.sign(message, privateKeyBuffer, isCompressed, prefix)];
            });
        });
    };
    AbstractEthLikeCoin.prototype.isValidPub = function (pub) {
        var valid = true;
        try {
            new account_lib_1.Eth.KeyPair({ pub: pub });
        }
        catch (e) {
            valid = false;
        }
        return valid;
    };
    /**
     * Builds a funds recovery transaction without BitGo.
     * We need to do three queries during this:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     * @param params The options with which to recover
     * @param callback Callback for the result of this operation
     */
    AbstractEthLikeCoin.prototype.recover = function (params, callback) {
        throw new errors_1.MethodNotImplementedError();
    };
    /**
     * Explain a transaction from txHex
     * @param params The options with which to explain the transaction
     * @param callback Callback for the result of this operation
     */
    AbstractEthLikeCoin.prototype.explainTransaction = function (params, callback) {
        return __awaiter(this, void 0, Bluebird, function () {
            var txHex, txBuilder, tx, outputs, displayOrder;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
                        if (!txHex || !params.feeInfo) {
                            throw new Error('missing explain tx parameters');
                        }
                        txBuilder = this.getTransactionBuilder();
                        txBuilder.from(txHex);
                        return [4 /*yield*/, txBuilder.build()];
                    case 1:
                        tx = _a.sent();
                        outputs = tx.outputs.map(function (output) {
                            return {
                                address: output.address,
                                amount: output.value,
                            };
                        });
                        displayOrder = ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee'];
                        return [2 /*return*/, {
                                displayOrder: displayOrder,
                                id: tx.id,
                                outputs: outputs,
                                outputAmount: outputs
                                    .reduce(function (accumulator, output) { return accumulator.plus(output.amount); }, new bignumber_js_1.default('0'))
                                    .toFixed(0),
                                changeOutputs: [],
                                changeAmount: '0',
                                fee: params.feeInfo,
                            }];
                }
            });
        });
    };
    /**
     * Create a new transaction builder for the current chain
     * @return a new transaction builder
     */
    AbstractEthLikeCoin.prototype.getTransactionBuilder = function () {
        return account_lib_1.getBuilder(this.getChain());
    };
    return AbstractEthLikeCoin;
}(baseCoin_1.BaseCoin));
exports.AbstractEthLikeCoin = AbstractEthLikeCoin;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJzdHJhY3RFdGhMaWtlQ29pbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy92Mi9jb2lucy9hYnN0cmFjdEV0aExpa2VDb2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSUEsa0RBQXFEO0FBQ3JELG1DQUFxQztBQUNyQyxrREFBb0Q7QUFDcEQsOENBQWdEO0FBQ2hELGlDQUFxQztBQUVyQyx3Q0FlcUI7QUFJckIsdUNBQThFO0FBQzlFLDZDQUFxQztBQThDckM7SUFBa0QsdUNBQVE7SUFHeEQsNkJBQXNCLEtBQVksRUFBRSxXQUF1QztRQUEzRSxZQUNFLGtCQUFNLEtBQUssQ0FBQyxTQU9iO1FBTEMsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7U0FDdkU7UUFFRCxLQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQzs7SUFDbEMsQ0FBQztJQUVELHNDQUFRLEdBQVI7UUFDRSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDO0lBQ2hDLENBQUM7SUFFRCx1Q0FBUyxHQUFUO1FBQ0UsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQztJQUNsQyxDQUFDO0lBRUQseUNBQVcsR0FBWDtRQUNFLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUM7SUFDcEMsQ0FBQztJQUVELDJDQUFhLEdBQWI7UUFDRSxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVELHNEQUF3QixHQUF4QjtRQUNFLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELDRDQUFjLEdBQWQsVUFBZSxPQUFlO1FBQzVCLElBQUksQ0FBQyxPQUFPLEVB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LFVBQUEsTUFBTTs0QkFDbkMsT0FBTztnQ0FDTCxPQUFPLEVBQUUsTUFBTSxDQUFDLE9BQU87Z0NBQ3ZCLE1BQU0sRUFBRSxNQUFNLENBQUMsS0FBSzs2QkFDckIsQ0FBQzt3QkFDSixDQUFDLENBQUMsQ0FBQzt3QkFFRyxZQUFZLEdBQUcsQ0FBQyxJQUFJLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRSxTQUFTLEVBQUUsZUFBZSxFQUFFLEtBQUssQ0FBQyxDQUFDO3dCQUUvRixzQkFBTztnQ0FDTCxZQUFZLGNBQUE7Z0NBQ1osRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFO2dDQUNULE9BQU8sRUFBRSxPQUFPO2dDQUNoQixZQUFZLEVBQUUsT0FBTztxQ0FDbEIsTUFBTSxDQUFDLFVBQUMsV0FBVyxFQUFFLE1BQU0sSUFBSyxPQUFBLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUEvQixDQUErQixFQUFFLElBQUksc0JBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztxQ0FDcEYsT0FBTyxDQUFDLENBQUMsQ0FBQztnQ0FDYixhQUFhLEVBQUUsRUFBRTtnQ0FDakIsWUFBWSxFQUFFLEdBQUc7Z0NBQ2pCLEdBQUcsRUFBRSxNQUFNLENBQUMsT0FBTzs2QkFDcEIsRUFBQzs7OztLQUNIO0lBRUQ7OztPQUdHO0lBQ0ssbURBQXFCLEdBQTdCO1FBQ0UsT0FBTyx3QkFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBMkIsQ0FBQztJQUMvRCxDQUFDO0lBQ0gsMEJBQUM7QUFBRCxDQUFDLEFBdktELENBQWtELG1CQUFRLEdBdUt6RDtBQXZLcUIsa0RBQW1CIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0IHsgQ29pbkZhbWlseSwgQmFzZUNvaW4gYXMgU3RhdGljc0Jhc2VDb2luIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHsgZ2V0QnVpbGRlciwgRXRoIH0gZnJvbSAnQGJpdGdvL2FjY291bnQtbGliJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCAqIGFzIGJpdGNvaW5NZXNzYWdlIGZyb20gJ2JpdGNvaW5qcy1tZXNzYWdlJztcbmltcG9ydCAqIGFzIGJpdGdvVXR4b0xpYiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdjcnlwdG8nO1xuXG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgRnVsbHlTaWduZWRUcmFuc2FjdGlvbixcbiAgSGFsZlNpZ25lZFRyYW5zYWN0aW9uLFxuICBLZXlQYWlyLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvbkZlZSxcbiAgVHJhbnNhY3Rpb25SZWNpcGllbnQgYXMgUmVjaXBpZW50LFxuICBUcmFuc2FjdGlvblByZWJ1aWxkIGFzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxufSBmcm9tICcuLi9iYXNlQ29pbic7XG5cbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vYml0Z28nO1xuaW1wb3J0IHsgTm9kZUNhbGxiYWNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgSW52YWxpZEFkZHJlc3NFcnJvciwgTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXRoU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwcnY6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUeEluZm8ge1xuICByZWNpcGllbnRzOiBSZWNpcGllbnRbXTtcbiAgZnJvbTogc3RyaW5nO1xuICB0eGlkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhIZXg6IHN0cmluZztcbiAgdHhJbmZvOiBUeEluZm87XG4gIGZlZUluZm86IEV0aFRyYW5zYWN0aW9uRmVlO1xuICBzb3VyY2U6IHN0cmluZztcbiAgZGF0YVRvU2lnbjogc3RyaW5nO1xuICBuZXh0Q29udHJhY3RTZXF1ZW5jZUlkPzogc3RyaW5nO1xuICBleHBpcmVUaW1lPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV0aFRyYW5zYWN0aW9uRmVlIHtcbiAgZmVlOiBzdHJpbmc7XG4gIGdhc0xpbWl0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEhleD86IHN0cmluZztcbiAgaGFsZlNpZ25lZD86IHtcbiAgICB0eEhleDogc3RyaW5nO1xuICB9O1xuICBmZWVJbmZvOiBUcmFuc2FjdGlvbkZlZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYWxmU2lnbmVkRXRoTGlrZVRyYW5zYWN0aW9uIGV4dGVuZHMgSGFsZlNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgaGFsZlNpZ25lZD86IHtcbiAgICB0eEhleD86IG5ldmVyO1xuICAgIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xuICAgIGV4cGlyYXRpb24/OiBudW1iZXI7XG4gIH07XG59XG5cbmV4cG9ydCB0eXBlIFNpZ25lZEV0aExpa2VUcmFuc2FjdGlvbiA9IEhhbGZTaWduZWRFdGhMaWtlVHJhbnNhY3Rpb24gfCBGdWxseVNpZ25lZFRyYW5zYWN0aW9uO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RFdGhMaWtlQ29pbiBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9zdGF0aWNzQ29pbjogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPjtcblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoYml0Z286IEJpdEdvLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pIHtcbiAgICBzdXBlcihiaXRnbyk7XG5cbiAgICBpZiAoIXN0YXRpY3NDb2luKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgY29uc3RydWN0b3IgcGFyYW1ldGVyIHN0YXRpY3NDb2luJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGljc0NvaW4gPSBzdGF0aWNzQ29pbjtcbiAgfVxuXG4gIGdldENoYWluKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5uYW1lO1xuICB9XG5cbiAgZ2V0RmFtaWx5KCk6IENvaW5GYW1pbHkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5mYW1pbHk7XG4gIH1cblxuICBnZXRGdWxsTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZnVsbE5hbWU7XG4gIH1cblxuICBnZXRCYXNlRmFjdG9yKCkge1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhdGljc0NvaW4uZGVjaW1hbFBsYWNlcyk7XG4gIH1cblxuICB2YWx1ZWxlc3NUcmFuc2ZlckFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIWFkZHJlc3MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIEV0aC5VdGlscy5pc1ZhbGlkRXRoQWRkcmVzcyhhZGRyZXNzKTtcbiAgfVxuXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkPzogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgaWYgKCFzZWVkKSB7XG4gICAgICBzZWVkID0gcmFuZG9tQnl0ZXMoNTEyIC8gOCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuZGVkS2V5ID0gYml0Z29VdHhvTGliLkhETm9kZS5mcm9tU2VlZEJ1ZmZlcihzZWVkKTtcbiAgICBjb25zdCB4cHViID0gZXh0ZW5kZWRLZXkubmV1dGVyZWQoKS50b0Jhc2U1OCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YjogeHB1YixcbiAgICAgIHBydjogZXh0ZW5kZWRLZXkudG9CYXNlNTgoKSxcbiAgICB9O1xuICB9XG5cbiAgcGFyc2VUcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFBhcnNlZFRyYW5zYWN0aW9uPlxuICApOiBCbHVlYmlyZDxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHt9KS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZlcmlmeUFkZHJlc3MoeyBhZGRyZXNzIH06IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGJvb2xlYW4+KTogQmx1ZWJpcmQ8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHRydWUpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKFxuICAgIHBhcmFtczogRXRoU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxTaWduZWRUcmFuc2FjdGlvbj5cbiAgKTogQmx1ZWJpcmQ8U2lnbmVkRXRoTGlrZVRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgdHhCdWlsZGVyID0gdGhpcy5nZXRUcmFuc2FjdGlvbkJ1aWxkZXIoKTtcbiAgICB0eEJ1aWxkZXIuZnJvbShwYXJhbXMudHhQcmVidWlsZC50eEhleCk7XG4gICAgdHhCdWlsZGVyLnRyYW5zZmVyKCkua2V5KG5ldyBFdGguS2V5UGFpcih7IHBydjogcGFyYW1zLnBydiB9KS5nZXRLZXlzKCkucHJ2ISk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcblxuICAgIGNvbnN0IHJlY2lwaWVudHMgPSB0cmFuc2FjdGlvbi5vdXRwdXRzLm1hcChvdXRwdXQgPT4gKHsgYWRkcmVzczogb3V0cHV0LmFkZHJlc3MsIGFtb3VudDogb3V0cHV0LnZhbHVlIH0pKTtcblxuICAgIHJldHVybiB7XG4gICAgICBoYWxmU2lnbmVkOiB7XG4gICAgICAgIHR4SGV4OiB0cmFuc2FjdGlvbi50b0Jyb2FkY2FzdEZvcm1hdCgpLFxuICAgICAgICByZWNpcGllbnRzOiByZWNpcGllbnRzLFxuICAgICAgICBleHBpcmF0aW9uOiBwYXJhbXMudHhQcmVidWlsZC5leHBpcmVUaW1lLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgc2lnbk1lc3NhZ2Uoa2V5OiB7IHBydjogc3RyaW5nIH0sIG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlciwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8QnVmZmVyPik6IEJsdWViaXJkPEJ1ZmZlcj4ge1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBiaXRnb1V0eG9MaWIuSEROb2RlLmZyb21CYXNlNTgoa2V5LnBydikuZ2V0S2V5KCk7XG4gICAgY29uc3QgcHJpdmF0ZUtleUJ1ZmZlciA9IHByaXZhdGVLZXkuZC50b0J1ZmZlcigzMik7XG4gICAgY29uc3QgaXNDb21wcmVzc2VkID0gcHJpdmF0ZUtleS5jb21wcmVzc2VkO1xuICAgIGNvbnN0IHByZWZpeCA9IGJpdGdvVXR4b0xpYi5uZXR3b3Jrcy5iaXRjb2luLm1lc3NhZ2VQcmVmaXg7XG4gICAgcmV0dXJuIGJpdGNvaW5NZXNzYWdlLnNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleUJ1ZmZlciwgaXNDb21wcmVzc2VkLCBwcmVmaXgpO1xuICB9XG5cbiAgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGxldCB2YWxpZCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBFdGguS2V5UGFpcih7IHB1YiB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB2YWxpZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWQ7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHby5cbiAgICogV2UgbmVlZCB0byBkbyB0aHJlZSBxdWVyaWVzIGR1cmluZyB0aGlzOlxuICAgKiAxKSBOb2RlIHF1ZXJ5IC0gaG93IG11Y2ggbW9uZXkgaXMgaW4gdGhlIGFjY291bnRcbiAgICogMikgQnVpbGQgdHJhbnNhY3Rpb24gLSBidWlsZCBvdXIgdHJhbnNhY3Rpb24gZm9yIHRoZSBhbW91bnRcbiAgICogMykgU2VuZCBzaWduZWQgYnVpbGQgLSBzZW5kIG91ciBzaWduZWQgYnVpbGQgdG8gYSBwdWJsaWMgbm9kZVxuICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBvcHRpb25zIHdpdGggd2hpY2ggdG8gcmVjb3ZlclxuICAgKiBAcGFyYW0gY2FsbGJhY2sgQ2FsbGJhY2sgZm9yIHRoZSByZXN1bHQgb2YgdGhpcyBvcGVyYXRpb25cbiAgICovXG4gIHJlY292ZXIocGFyYW1zOiBhbnksIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICB0aHJvdyBuZXcgTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGxhaW4gYSB0cmFuc2FjdGlvbiBmcm9tIHR4SGV4XG4gICAqIEBwYXJhbSBwYXJhbXMgVGhlIG9wdGlvbnMgd2l0aCB3aGljaCB0byBleHBsYWluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gY2FsbGJhY2sgQ2FsbGJhY2sgZm9yIHRoZSByZXN1bHQgb2YgdGhpcyBvcGVyYXRpb25cbiAgICovXG4gIGFzeW5jIGV4cGxhaW5UcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj5cbiAgKTogQmx1ZWJpcmQ8VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IHR4SGV4ID0gcGFyYW1zLnR4SGV4IHx8IChwYXJhbXMuaGFsZlNpZ25lZCAmJiBwYXJhbXMuaGFsZlNpZ25lZC50eEhleCk7XG4gICAgaWYgKCF0eEhleCB8fCAhcGFyYW1zLmZlZUluZm8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBleHBsYWluIHR4IHBhcmFtZXRlcnMnKTtcbiAgICB9XG4gICAgY29uc3QgdHhCdWlsZGVyID0gdGhpcy5nZXRUcmFuc2FjdGlvbkJ1aWxkZXIoKTtcbiAgICB0eEJ1aWxkZXIuZnJvbSh0eEhleCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICBjb25zdCBvdXRwdXRzID0gdHgub3V0cHV0cy5tYXAob3V0cHV0ID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IG91dHB1dC5hZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IG91dHB1dC52YWx1ZSxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBjb25zdCBkaXNwbGF5T3JkZXIgPSBbJ2lkJywgJ291dHB1dEFtb3VudCcsICdjaGFuZ2VBbW91bnQnLCAnb3V0cHV0cycsICdjaGFuZ2VPdXRwdXRzJywgJ2ZlZSddO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc3BsYXlPcmRlcixcbiAgICAgIGlkOiB0eC5pZCxcbiAgICAgIG91dHB1dHM6IG91dHB1dHMsXG4gICAgICBvdXRwdXRBbW91bnQ6IG91dHB1dHNcbiAgICAgICAgLnJlZHVjZSgoYWNjdW11bGF0b3IsIG91dHB1dCkgPT4gYWNjdW11bGF0b3IucGx1cyhvdXRwdXQuYW1vdW50KSwgbmV3IEJpZ051bWJlcignMCcpKVxuICAgICAgICAudG9GaXhlZCgwKSxcbiAgICAgIGNoYW5nZU91dHB1dHM6IFtdLCAvLyBhY2NvdW50IGJhc2VkIGRvZXMgbm90IHVzZSBjaGFuZ2Ugb3V0cHV0c1xuICAgICAgY2hhbmdlQW1vdW50OiAnMCcsIC8vIGFjY291bnQgYmFzZSBkb2VzIG5vdCBtYWtlIGNoYW5nZVxuICAgICAgZmVlOiBwYXJhbXMuZmVlSW5mbyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB0cmFuc2FjdGlvbiBidWlsZGVyIGZvciB0aGUgY3VycmVudCBjaGFpblxuICAgKiBAcmV0dXJuIGEgbmV3IHRyYW5zYWN0aW9uIGJ1aWxkZXJcbiAgICovXG4gIHByaXZhdGUgZ2V0VHJhbnNhY3Rpb25CdWlsZGVyKCk6IEV0aC5UcmFuc2FjdGlvbkJ1aWxkZXIge1xuICAgIHJldHVybiBnZXRCdWlsZGVyKHRoaXMuZ2V0Q2hhaW4oKSkgYXMgRXRoLlRyYW5zYWN0aW9uQnVpbGRlcjtcbiAgfVxufVxuIl19