"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var Bluebird = require("bluebird");
var crypto_1 = require("crypto");
var co = Bluebird.coroutine;
var bitgoAccountLib = require("@bitgo/account-lib");
var utxo_lib_1 = require("@bitgo/utxo-lib");
var request = require("superagent");
var common = require("../../common");
var baseCoin_1 = require("../baseCoin");
exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE = 1e6;
var NodeTypes;
(function (NodeTypes) {
    NodeTypes[NodeTypes["Full"] = 0] = "Full";
    NodeTypes[NodeTypes["Solidity"] = 1] = "Solidity";
})(NodeTypes = exports.NodeTypes || (exports.NodeTypes = {}));
var Trx = /** @class */ (function (_super) {
    __extends(Trx, _super);
    function Trx(bitgo, staticsCoin) {
        var _this = _super.call(this, bitgo) || this;
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        _this._staticsCoin = staticsCoin;
        return _this;
    }
    Trx.prototype.getChain = function () {
        return this._staticsCoin.name;
    };
    Trx.prototype.getFamily = function () {
        return this._staticsCoin.family;
    };
    Trx.prototype.getFullName = function () {
        return this._staticsCoin.fullName;
    };
    Trx.prototype.getBaseFactor = function () {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    };
    Trx.createInstance = function (bitgo, staticsCoin) {
        return new Trx(bitgo, staticsCoin);
    };
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    Trx.prototype.valuelessTransferAllowed = function () {
        return true;
    };
    /**
     * Checks if this is a valid base58 or hex address
     * @param address
     */
    Trx.prototype.isValidAddress = function (address) {
        if (!address) {
            return false;
        }
        return this.isValidHexAddress(address) || bitgoAccountLib.Trx.Utils.isBase58Address(address);
    };
    /**
     * Checks if this is a valid hex address
     * @param address hex address
     */
    Trx.prototype.isValidHexAddress = function (address) {
        return address.length === 42 && /^(0x)?([0-9a-f]{2})+$/i.test(address);
    };
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    Trx.prototype.generateKeyPair = function (seed) {
        // TODO: move this and address creation logic to account-lib
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256 bit chain code, both of which must be
            // random. 512 bits is therefore the maximum entropy and gives us maximum security against cracking.
            seed = crypto_1.randomBytes(512 / 8);
        }
        var hd = utxo_lib_1.HDNode.fromSeedBuffer(seed);
        return {
            pub: hd.neutered().toBase58(),
            prv: hd.toBase58(),
        };
    };
    Trx.prototype.isValidXpub = function (xpub) {
        try {
            return utxo_lib_1.HDNode.fromBase58(xpub).isNeutered();
        }
        catch (e) {
            return false;
        }
    };
    Trx.prototype.isValidPub = function (pub) {
        if (this.isValidXpub(pub)) {
            // xpubs can be converted into regular pubs, so technically it is a valid pub
            return true;
        }
        return new RegExp('^04[a-zA-Z0-9]{128}$').test(pub);
    };
    Trx.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    Trx.prototype.verifyAddress = function (params) {
        return true;
    };
    Trx.prototype.verifyTransaction = function (params, callback) {
        return Bluebird.resolve(true).asCallback(callback);
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param params.wallet.addressVersion {String} this is the version of the Algorand multisig address generation format
     * @param callback
     * @returns Bluebird<SignedTransaction>
     */
    Trx.prototype.signTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txBuilder, transaction, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txBuilder = bitgoAccountLib.getBuilder(self.getChain());
                        // Newer coins can return BaseTransactionBuilderFactory instead of BaseTransactionBuilder
                        if (!(txBuilder instanceof bitgoAccountLib.BaseCoin.BaseTransactionBuilder)) {
                            throw new Error('getBuilder() did not return an BaseTransactionBuilder object. Has it been updated?');
                        }
                        txBuilder.from(params.txPrebuild.txHex);
                        txBuilder.sign({ key: params.prv });
                        return [4 /*yield*/, txBuilder.build()];
                    case 1:
                        transaction = _a.sent();
                        response = {
                            txHex: JSON.stringify(transaction.toJson()),
                        };
                        if (transaction.toJson().signature.length >= 2) {
                            return [2 /*return*/, response];
                        }
                        // Half signed transaction
                        return [2 /*return*/, {
                                halfSigned: response,
                            }];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Return boolean indicating whether input is valid seed for the coin
     *
     * @param prv - the prv to be checked
     */
    Trx.prototype.isValidXprv = function (prv) {
        try {
            utxo_lib_1.HDNode.fromBase58(prv);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Convert a message to string in hexadecimal format.
     *
     * @param message {Buffer|String} message to sign
     * @return the message as a hexadecimal string
     */
    Trx.prototype.toHexString = function (message) {
        if (typeof message === 'string') {
            return Buffer.from(message).toString('hex');
        }
        else if (Buffer.isBuffer(message)) {
            return message.toString('hex');
        }
        else {
            throw new Error('Invalid messaged passed to signMessage');
        }
    };
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     * @param callback
     */
    Trx.prototype.signMessage = function (key, message, callback) {
        var self = this;
        return co(function cosignMessage() {
            var toSign, prv, sig;
            return __generator(this, function (_a) {
                toSign = self.toHexString(message);
                prv = key.prv;
                if (self.isValidXprv(prv)) {
                    prv = utxo_lib_1.HDNode.fromBase58(prv)
                        .getKey()
                        .getPrivateKeyBuffer();
                }
                sig = bitgoAccountLib.Trx.Utils.signString(toSign, prv, true);
                // remove the preceding 0x
                sig = sig.replace(/^0x/, '');
                return [2 /*return*/, Buffer.from(sig, 'hex')];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Converts an xpub to a compressed pub
     * @param xpub
     */
    Trx.prototype.xpubToCompressedPub = function (xpub) {
        if (!this.isValidXpub(xpub)) {
            throw new Error('invalid xpub');
        }
        var hdNode = utxo_lib_1.HDNode.fromBase58(xpub, utxo_lib_1.networks.bitcoin);
        return hdNode.keyPair.__Q.getEncoded(false).toString('hex');
    };
    Trx.prototype.compressedPubToHexAddress = function (pub) {
        var byteArrayAddr = bitgoAccountLib.Trx.Utils.getByteArrayFromHexAddress(pub);
        var rawAddress = bitgoAccountLib.Trx.Utils.getRawAddressFromPubKey(byteArrayAddr);
        return bitgoAccountLib.Trx.Utils.getHexAddressFromByteArray(rawAddress);
    };
    Trx.prototype.xprvToCompressedPrv = function (xprv) {
        if (!this.isValidXprv(xprv)) {
            throw new Error('invalid xprv');
        }
        var hdNode = utxo_lib_1.HDNode.fromBase58(xprv, utxo_lib_1.networks.bitcoin);
        return hdNode.keyPair.d.toBuffer(32).toString('hex');
    };
    /**
     * Make a query to Trongrid for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @param callback
     * @returns {Object} response from Trongrid
     */
    Trx.prototype.recoveryPost = function (query, callback) {
        var self = this;
        return co(function () {
            var nodeUri, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nodeUri = '';
                        switch (query.node) {
                            case NodeTypes.Full:
                                nodeUri = common.Environments[self.bitgo.getEnv()].tronNodes.full;
                                break;
                            case NodeTypes.Solidity:
                                nodeUri = common.Environments[self.bitgo.getEnv()].tronNodes.solidity;
                                break;
                            default:
                                throw new Error('node type not found');
                        }
                        return [4 /*yield*/, request
                                .post(nodeUri + query.path)
                                .type('json')
                                .send(query.jsonObj)];
                    case 1:
                        response = _a.sent();
                        if (!response.ok) {
                            throw new Error('could not reach Tron node');
                        }
                        // unfortunately, it doesn't look like most TRON nodes return valid json as body
                        return [2 /*return*/, JSON.parse(response.text)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Query our explorer for the balance of an address
     * @param address {String} the address encoded in hex
     * @param callback
     * @returns {BigNumber} address balance
     */
    Trx.prototype.getAccountFromNode = function (address, callback) {
        var self = this;
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.recoveryPost({
                            path: '/walletsolidity/getaccount',
                            jsonObj: { address: address },
                            node: NodeTypes.Solidity,
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Retrieves our build transaction from a node.
     * @param toAddr hex-encoded address
     * @param fromAddr hex-encoded address
     * @param amount
     * @param callback
     */
    Trx.prototype.getBuildTransaction = function (toAddr, fromAddr, amount, callback) {
        var self = this;
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.recoveryPost({
                            path: '/wallet/createtransaction',
                            jsonObj: {
                                to_address: toAddr,
                                owner_address: fromAddr,
                                amount: amount,
                            },
                            node: NodeTypes.Full,
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Throws an error if any keys in the ownerKeys collection don't match the keys array we pass
     * @param ownerKeys
     * @param keysToFind
     */
    Trx.prototype.checkPermissions = function (ownerKeys, keys) {
        keys = keys.map(function (k) { return k.toUpperCase(); });
        ownerKeys.map(function (key) {
            var hexKey = key.address.toUpperCase();
            if (!keys.includes(hexKey)) {
                throw new Error("pub address " + hexKey + " not found in account");
            }
            if (key.weight !== 1) {
                throw new Error('owner permission is invalid for this structure');
            }
        });
    };
    /**
     * Builds a funds recovery transaction without BitGo.
     * We need to do three queries during this:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     * @param params
     * @param callback
     */
    Trx.prototype.recover = function (params, callback) {
        var self = this;
        return co(function () {
            var isKrsRecovery, isUnsignedSweep, keys, bitgoHexAddr, recoveryAddressHex, account, recoveryAmount, userXPub, userXPrv, backupXPub, recoveryAmountMinusFees, buildTx, keyHexAddresses, txBuilder, _a, userPrv, backupXPrv, backupPrv, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
                        isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
                        return [4 /*yield*/, self.initiateRecovery(params)];
                    case 1:
                        keys = _c.sent();
                        bitgoHexAddr = self.compressedPubToHexAddress(self.xpubToCompressedPub(params.bitgoKey));
                        recoveryAddressHex = bitgoAccountLib.Trx.Utils.getHexAddressFromBase58Address(params.recoveryDestination);
                        return [4 /*yield*/, self.getAccountFromNode(bitgoHexAddr)];
                    case 2:
                        account = _c.sent();
                        recoveryAmount = account.balance;
                        userXPub = keys[0].neutered().toBase58();
                        userXPrv = keys[0].toBase58();
                        backupXPub = keys[1].neutered().toBase58();
                        // construct the tx -
                        // there's an assumption here being made about fees: for a wallet that hasn't been used in awhile, the implication is
                        // it has maximum bandwidth. thus, a recovery should cost the minimum amount (1e6 sun or 1 Tron)
                        if (exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE > recoveryAmount) {
                            throw new Error('Amount of funds to recover wouldnt be able to fund a send');
                        }
                        recoveryAmountMinusFees = recoveryAmount - exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE;
                        return [4 /*yield*/, self.getBuildTransaction(recoveryAddressHex, bitgoHexAddr, recoveryAmountMinusFees)];
                    case 3:
                        buildTx = _c.sent();
                        keyHexAddresses = [
                            self.compressedPubToHexAddress(self.xpubToCompressedPub(userXPub)),
                            self.compressedPubToHexAddress(self.xpubToCompressedPub(backupXPub)),
                            bitgoHexAddr,
                        ];
                        // run checks to ensure this is a valid tx - permissions match our signer keys
                        self.checkPermissions(account.owner_permission.keys, keyHexAddresses);
                        self.checkPermissions(account.active_permission[0].keys, keyHexAddresses);
                        txBuilder = bitgoAccountLib.getBuilder(self.getChain());
                        // Newer coins can return BaseTransactionBuilderFactory instead of BaseTransactionBuilder
                        if (!(txBuilder instanceof bitgoAccountLib.BaseCoin.BaseTransactionBuilder)) {
                            throw new Error('getBuilder() did not return an BaseTransactionBuilder object. Has it been updated?');
                        }
                        txBuilder.from(buildTx);
                        if (!isUnsignedSweep) return [3 /*break*/, 5];
                        _a = {};
                        return [4 /*yield*/, txBuilder.build()];
                    case 4: return [2 /*return*/, (_a.tx = (_c.sent()).toJson(),
                            _a.recoveryAmount = recoveryAmountMinusFees,
                            _a)];
                    case 5:
                        userPrv = self.xprvToCompressedPrv(userXPrv);
                        txBuilder.sign({ key: userPrv });
                        // krs recoveries don't get signed
                        if (!isKrsRecovery) {
                            backupXPrv = keys[1].toBase58();
                            backupPrv = self.xprvToCompressedPrv(backupXPrv);
                            txBuilder.sign({ key: backupPrv });
                        }
                        _b = {};
                        return [4 /*yield*/, txBuilder.build()];
                    case 6: return [2 /*return*/, (_b.tx = (_c.sent()).toJson(),
                            _b.recoveryAmount = recoveryAmountMinusFees,
                            _b)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Explain a Tron transaction from txHex
     * @param params
     * @param callback
     */
    Trx.prototype.explainTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txHex, txBuilder, tx, outputs, displayOrder, explanationResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
                        if (!txHex || !params.feeInfo) {
                            throw new Error('missing explain tx parameters');
                        }
                        txBuilder = bitgoAccountLib.getBuilder(self.getChain());
                        // Newer coins can return BaseTransactionBuilderFactory instead of BaseTransactionBuilder
                        if (!(txBuilder instanceof bitgoAccountLib.BaseCoin.BaseTransactionBuilder)) {
                            throw new Error('getBuilder() did not return an BaseTransactionBuilder object. Has it been updated?');
                        }
                        txBuilder.from(txHex);
                        return [4 /*yield*/, txBuilder.build()];
                    case 1:
                        tx = _a.sent();
                        outputs = [
                            {
                                amount: tx.outputs[0].value.toString(),
                                address: tx.outputs[0].address,
                            },
                        ];
                        displayOrder = [
                            'id',
                            'outputAmount',
                            'changeAmount',
                            'outputs',
                            'changeOutputs',
                            'fee',
                            'timestamp',
                            'expiration',
                        ];
                        explanationResult = {
                            displayOrder: displayOrder,
                            id: tx.id,
                            outputs: outputs,
                            outputAmount: outputs[0].amount,
                            changeOutputs: [],
                            changeAmount: '0',
                            fee: params.feeInfo,
                            timestamp: tx.validFrom,
                            expiration: tx.validTo,
                        };
                        return [2 /*return*/, explanationResult];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    return Trx;
}(baseCoin_1.BaseCoin));
exports.Trx = Trx;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJ4LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3RyeC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILG1DQUFxQztBQUNyQyxpQ0FBcUM7QUFFckMsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQUM5QixvREFBc0Q7QUFDdEQsNENBQW1EO0FBQ25ELG9DQUFzQztBQUN0QyxxQ0FBdUM7QUFFdkMsd0NBYXFCO0FBS1IsUUFBQSxpQ0FBaUMsR0FBRyxHQUFHLENBQUM7QUE4Q3JELElBQVksU0FHWDtBQUhELFdBQVksU0FBUztJQUNuQix5Q0FBSSxDQUFBO0lBQ0osaURBQVEsQ0FBQTtBQUNWLENBQUMsRUFIVyxTQUFTLEdBQVQsaUJBQVMsS0FBVCxpQkFBUyxRQUdwQjtBQWNEO0lBQXlCLHVCQUFRO0lBRy9CLGFBQVksS0FBWSxFQUFFLFdBQXVDO1FBQWpFLFlBQ0Usa0JBQU0sS0FBSyxDQUFDLFNBT2I7UUFMQyxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztTQUN2RTtRQUVELEtBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDOztJQUNsQyxDQUFDO0lBRUQsc0JBQVEsR0FBUjtRQUNFLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7SUFDaEMsQ0FBQztJQUVELHVCQUFTLEdBQVQ7UUFDRSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDO0lBQ2xDLENBQUM7SUFFRCx5QkFBVyxHQUFYO1FBQ0UsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQztJQUNwQyxDQUFDO0lBRUQsMkJBQWEsR0FBYjtRQUNFLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFB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Q2IsQ0FBQzt3QkFFSSxpQkFBaUIsR0FBK0I7NEJBQ3BELFlBQVksY0FBQTs0QkFDWixFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUU7NEJBQ1QsT0FBTyxTQUFBOzRCQUNQLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTTs0QkFDL0IsYUFBYSxFQUFFLEVBQUU7NEJBQ2pCLFlBQVksRUFBRSxHQUFHOzRCQUNqQixHQUFHLEVBQUUsTUFBTSxDQUFDLE9BQU87NEJBQ25CLFNBQVMsRUFBRSxFQUFFLENBQUMsU0FBUzs0QkFDdkIsVUFBVSxFQUFFLEVBQUUsQ0FBQyxPQUFPO3lCQUN2QixDQUFDO3dCQUVGLHNCQUFPLGlCQUFpQixFQUFDOzs7U0FDMUIsQ0FBQzthQUNDLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDVixVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUNILFVBQUM7QUFBRCxDQUFDLEFBNWVELENBQXlCLG1CQUFRLEdBNGVoQztBQTVlWSxrQkFBRyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IENvaW5GYW1pbHksIEJhc2VDb2luIGFzIFN0YXRpY3NCYXNlQ29pbiB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuaW1wb3J0ICogYXMgYml0Z29BY2NvdW50TGliIGZyb20gJ0BiaXRnby9hY2NvdW50LWxpYic7XG5pbXBvcnQgeyBIRE5vZGUsIG5ldHdvcmtzIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCAqIGFzIHJlcXVlc3QgZnJvbSAnc3VwZXJhZ2VudCc7XG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi4vLi4vY29tbW9uJztcblxuaW1wb3J0IHtcbiAgQmFzZUNvaW4sXG4gIEtleVBhaXIsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgU2lnbmVkVHJhbnNhY3Rpb24sXG4gIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFZlcmlmeUFkZHJlc3NPcHRpb25zLFxuICBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFRyYW5zYWN0aW9uRmVlLFxuICBUcmFuc2FjdGlvblJlY2lwaWVudCBhcyBSZWNpcGllbnQsXG4gIFRyYW5zYWN0aW9uUHJlYnVpbGQgYXMgQmFzZVRyYW5zYWN0aW9uUHJlYnVpbGQsXG4gIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24sXG59IGZyb20gJy4uL2Jhc2VDb2luJztcblxuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi8uLi9iaXRnbyc7XG5pbXBvcnQgeyBOb2RlQ2FsbGJhY2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBNSU5JTVVNX1RST05fTVNJR19UUkFOU0FDVElPTl9GRUUgPSAxZTY7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJvblNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcHJ2OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHhJbmZvIHtcbiAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gIGZyb206IHN0cmluZztcbiAgdHhpZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyb25UcmFuc2FjdGlvbkV4cGxhbmF0aW9uIGV4dGVuZHMgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiB7XG4gIGV4cGlyYXRpb246IG51bWJlcjtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhIZXg6IHN0cmluZztcbiAgdHhJbmZvOiBUeEluZm87XG4gIGZlZUluZm86IFRyYW5zYWN0aW9uRmVlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEhleD86IHN0cmluZzsgLy8gdHhIZXggaXMgcG9vcmx5IG5hbWVkIGhlcmU7IGl0IGlzIGp1c3QgYSB3cmFwcGVkIEpTT04gb2JqZWN0XG4gIGhhbGZTaWduZWQ/OiB7XG4gICAgdHhIZXg6IHN0cmluZzsgLy8gdHhIZXggaXMgcG9vcmx5IG5hbWVkIGhlcmU7IGl0IGlzIGp1c3QgYSB3cmFwcGVkIEpTT04gb2JqZWN0XG4gIH07XG4gIGZlZUluZm86IFRyYW5zYWN0aW9uRmVlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJ5T3B0aW9ucyB7XG4gIHVzZXJLZXk6IHN0cmluZzsgLy8gQm94IEFcbiAgYmFja3VwS2V5OiBzdHJpbmc7IC8vIEJveCBCXG4gIGJpdGdvS2V5OiBzdHJpbmc7IC8vIEJveCBDIC0gdGhpcyBpcyBiaXRnbydzIHhwdWIgYW5kIHdpbGwgYmUgdXNlZCB0byBkZXJpdmUgdGhlaXIgcm9vdCBhZGRyZXNzXG4gIHJlY292ZXJ5RGVzdGluYXRpb246IHN0cmluZzsgLy8gYmFzZTU4IGFkZHJlc3NcbiAga3JzUHJvdmlkZXI/OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjb3ZlcnlUcmFuc2FjdGlvbiB7XG4gIHR4OiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICByZWNvdmVyeUFtb3VudDogbnVtYmVyO1xufVxuXG5leHBvcnQgZW51bSBOb2RlVHlwZXMge1xuICBGdWxsLFxuICBTb2xpZGl0eSxcbn1cblxuLyoqXG4gKiBUaGlzIHN0cnVjdHVyZSBpcyBub3QgYSBjb21wbGV0ZSBtb2RlbCBvZiB0aGUgQWNjb3VudFJlc3BvbnNlIGZyb20gYSBub2RlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFjY291bnRSZXNwb25zZSB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgYmFsYW5jZTogbnVtYmVyO1xuICBvd25lcl9wZXJtaXNzaW9uOiB7XG4gICAga2V5czogW2JpdGdvQWNjb3VudExpYi5UcnguSW50ZXJmYWNlLlBlcm1pc3Npb25LZXldO1xuICB9O1xuICBhY3RpdmVfcGVybWlzc2lvbjogW3sga2V5czogW2JpdGdvQWNjb3VudExpYi5UcnguSW50ZXJmYWNlLlBlcm1pc3Npb25LZXldIH1dO1xufVxuXG5leHBvcnQgY2xhc3MgVHJ4IGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3N0YXRpY3NDb2luOiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+O1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHbywgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KSB7XG4gICAgc3VwZXIoYml0Z28pO1xuXG4gICAgaWYgKCFzdGF0aWNzQ29pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBzdGF0aWNzQ29pbicpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRpY3NDb2luID0gc3RhdGljc0NvaW47XG4gIH1cblxuICBnZXRDaGFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4ubmFtZTtcbiAgfVxuXG4gIGdldEZhbWlseSgpOiBDb2luRmFtaWx5IHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZmFtaWx5O1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZ1bGxOYW1lO1xuICB9XG5cbiAgZ2V0QmFzZUZhY3RvcigpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXRpY3NDb2luLmRlY2ltYWxQbGFjZXMpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHbywgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgVHJ4KGJpdGdvLCBzdGF0aWNzQ29pbik7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBmb3Igc2VuZGluZyB2YWx1ZSBvZiAwXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gc2VuZCAwIHZhbHVlLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHZhbHVlbGVzc1RyYW5zZmVyQWxsb3dlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBpcyBhIHZhbGlkIGJhc2U1OCBvciBoZXggYWRkcmVzc1xuICAgKiBAcGFyYW0gYWRkcmVzc1xuICAgKi9cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzVmFsaWRIZXhBZGRyZXNzKGFkZHJlc3MpIHx8IGJpdGdvQWNjb3VudExpYi5UcnguVXRpbHMuaXNCYXNlNThBZGRyZXNzKGFkZHJlc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGlzIGEgdmFsaWQgaGV4IGFkZHJlc3NcbiAgICogQHBhcmFtIGFkZHJlc3MgaGV4IGFkZHJlc3NcbiAgICovXG4gIGlzVmFsaWRIZXhBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBhZGRyZXNzLmxlbmd0aCA9PT0gNDIgJiYgL14oMHgpPyhbMC05YS1mXXsyfSkrJC9pLnRlc3QoYWRkcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgZWQyNTUxOSBrZXkgcGFpclxuICAgKlxuICAgKiBAcGFyYW0gc2VlZFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2l0aCBnZW5lcmF0ZWQgcHViLCBwcnZcbiAgICovXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkPzogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgLy8gVE9ETzogbW92ZSB0aGlzIGFuZCBhZGRyZXNzIGNyZWF0aW9uIGxvZ2ljIHRvIGFjY291bnQtbGliXG4gICAgaWYgKCFzZWVkKSB7XG4gICAgICAvLyBBbiBleHRlbmRlZCBwcml2YXRlIGtleSBoYXMgYm90aCBhIG5vcm1hbCAyNTYgYml0IHByaXZhdGUga2V5IGFuZCBhIDI1NiBiaXQgY2hhaW4gY29kZSwgYm90aCBvZiB3aGljaCBtdXN0IGJlXG4gICAgICAvLyByYW5kb20uIDUxMiBiaXRzIGlzIHRoZXJlZm9yZSB0aGUgbWF4aW11bSBlbnRyb3B5IGFuZCBnaXZlcyB1cyBtYXhpbXVtIHNlY3VyaXR5IGFnYWluc3QgY3JhY2tpbmcuXG4gICAgICBzZWVkID0gcmFuZG9tQnl0ZXMoNTEyIC8gOCk7XG4gICAgfVxuICAgIGNvbnN0IGhkID0gSEROb2RlLmZyb21TZWVkQnVmZmVyKHNlZWQpO1xuICAgIHJldHVybiB7XG4gICAgICBwdWI6IGhkLm5ldXRlcmVkKCkudG9CYXNlNTgoKSxcbiAgICAgIHBydjogaGQudG9CYXNlNTgoKSxcbiAgICB9O1xuICB9XG5cbiAgaXNWYWxpZFhwdWIoeHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBIRE5vZGUuZnJvbUJhc2U1OCh4cHViKS5pc05ldXRlcmVkKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkWHB1YihwdWIpKSB7XG4gICAgICAvLyB4cHVicyBjYW4gYmUgY29udmVydGVkIGludG8gcmVndWxhciBwdWJzLCBzbyB0ZWNobmljYWxseSBpdCBpcyBhIHZhbGlkIHB1YlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVnRXhwKCdeMDRbYS16QS1aMC05XXsxMjh9JCcpLnRlc3QocHViKTtcbiAgfVxuXG4gIHBhcnNlVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQYXJzZWRUcmFuc2FjdGlvbj5cbiAgKTogQmx1ZWJpcmQ8UGFyc2VkVHJhbnNhY3Rpb24+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSh7fSkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICB2ZXJpZnlBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZlcmlmeVRyYW5zYWN0aW9uKHBhcmFtczogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxib29sZWFuPik6IEJsdWViaXJkPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSh0cnVlKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50eFByZWJ1aWxkIHtPYmplY3R9IHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBwbGF0Zm9ybVxuICAgKiBAcGFyYW0gcGFyYW1zLnBydiB7U3RyaW5nfSB1c2VyIHBydlxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldC5hZGRyZXNzVmVyc2lvbiB7U3RyaW5nfSB0aGlzIGlzIHRoZSB2ZXJzaW9uIG9mIHRoZSBBbGdvcmFuZCBtdWx0aXNpZyBhZGRyZXNzIGdlbmVyYXRpb24gZm9ybWF0XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyBCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj5cbiAgICovXG4gIHNpZ25UcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IFRyb25TaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFNpZ25lZFRyYW5zYWN0aW9uPlxuICApOiBCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxTaWduZWRUcmFuc2FjdGlvbj4oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3QgdHhCdWlsZGVyID0gYml0Z29BY2NvdW50TGliLmdldEJ1aWxkZXIoc2VsZi5nZXRDaGFpbigpKTtcbiAgICAgIC8vIE5ld2VyIGNvaW5zIGNhbiByZXR1cm4gQmFzZVRyYW5zYWN0aW9uQnVpbGRlckZhY3RvcnkgaW5zdGVhZCBvZiBCYXNlVHJhbnNhY3Rpb25CdWlsZGVyXG4gICAgICBpZiAoISh0eEJ1aWxkZXIgaW5zdGFuY2VvZiBiaXRnb0FjY291bnRMaWIuQmFzZUNvaW4uQmFzZVRyYW5zYWN0aW9uQnVpbGRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRCdWlsZGVyKCkgZGlkIG5vdCByZXR1cm4gYW4gQmFzZVRyYW5zYWN0aW9uQnVpbGRlciBvYmplY3QuIEhhcyBpdCBiZWVuIHVwZGF0ZWQ/Jyk7XG4gICAgICB9XG4gICAgICB0eEJ1aWxkZXIuZnJvbShwYXJhbXMudHhQcmVidWlsZC50eEhleCk7XG4gICAgICB0eEJ1aWxkZXIuc2lnbih7IGtleTogcGFyYW1zLnBydiB9KTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0geWllbGQgdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgdHhIZXg6IEpTT04uc3RyaW5naWZ5KHRyYW5zYWN0aW9uLnRvSnNvbigpKSxcbiAgICAgIH07XG4gICAgICBpZiAodHJhbnNhY3Rpb24udG9Kc29uKCkuc2lnbmF0dXJlLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIC8vIEhhbGYgc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYWxmU2lnbmVkOiByZXNwb25zZSxcbiAgICAgIH07XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHNlZWQgZm9yIHRoZSBjb2luXG4gICAqXG4gICAqIEBwYXJhbSBwcnYgLSB0aGUgcHJ2IHRvIGJlIGNoZWNrZWRcbiAgICovXG4gIGlzVmFsaWRYcHJ2KHBydjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIEhETm9kZS5mcm9tQmFzZTU4KHBydik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBtZXNzYWdlIHRvIHN0cmluZyBpbiBoZXhhZGVjaW1hbCBmb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSBtZXNzYWdlIHtCdWZmZXJ8U3RyaW5nfSBtZXNzYWdlIHRvIHNpZ25cbiAgICogQHJldHVybiB0aGUgbWVzc2FnZSBhcyBhIGhleGFkZWNpbWFsIHN0cmluZ1xuICAgKi9cbiAgdG9IZXhTdHJpbmcobWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyKTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20obWVzc2FnZSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZS50b1N0cmluZygnaGV4Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlZCBwYXNzZWQgdG8gc2lnbk1lc3NhZ2UnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBtZXNzYWdlIHdpdGggcHJpdmF0ZSBrZXlcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHNpZ25NZXNzYWdlKGtleTogS2V5UGFpciwgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxCdWZmZXI+KTogQmx1ZWJpcmQ8QnVmZmVyPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPEJ1ZmZlcj4oZnVuY3Rpb24qIGNvc2lnbk1lc3NhZ2UoKSB7XG4gICAgICBjb25zdCB0b1NpZ24gPSBzZWxmLnRvSGV4U3RyaW5nKG1lc3NhZ2UpO1xuXG4gICAgICBsZXQgcHJ2ID0ga2V5LnBydjtcbiAgICAgIGlmIChzZWxmLmlzVmFsaWRYcHJ2KHBydikpIHtcbiAgICAgICAgcHJ2ID0gSEROb2RlLmZyb21CYXNlNTgocHJ2KVxuICAgICAgICAgIC5nZXRLZXkoKVxuICAgICAgICAgIC5nZXRQcml2YXRlS2V5QnVmZmVyKCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBzaWcgPSBiaXRnb0FjY291bnRMaWIuVHJ4LlV0aWxzLnNpZ25TdHJpbmcodG9TaWduLCBwcnYsIHRydWUpO1xuXG4gICAgICAvLyByZW1vdmUgdGhlIHByZWNlZGluZyAweFxuICAgICAgc2lnID0gc2lnLnJlcGxhY2UoL14weC8sICcnKTtcblxuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNpZywgJ2hleCcpO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIHhwdWIgdG8gYSBjb21wcmVzc2VkIHB1YlxuICAgKiBAcGFyYW0geHB1YlxuICAgKi9cbiAgeHB1YlRvQ29tcHJlc3NlZFB1Yih4cHViOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkWHB1Yih4cHViKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHhwdWInKTtcbiAgICB9XG5cbiAgICBjb25zdCBoZE5vZGUgPSBIRE5vZGUuZnJvbUJhc2U1OCh4cHViLCBuZXR3b3Jrcy5iaXRjb2luKTtcbiAgICByZXR1cm4gaGROb2RlLmtleVBhaXIuX19RLmdldEVuY29kZWQoZmFsc2UpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuXG4gIGNvbXByZXNzZWRQdWJUb0hleEFkZHJlc3MocHViOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGJ5dGVBcnJheUFkZHIgPSBiaXRnb0FjY291bnRMaWIuVHJ4LlV0aWxzLmdldEJ5dGVBcnJheUZyb21IZXhBZGRyZXNzKHB1Yik7XG4gICAgY29uc3QgcmF3QWRkcmVzcyA9IGJpdGdvQWNjb3VudExpYi5UcnguVXRpbHMuZ2V0UmF3QWRkcmVzc0Zyb21QdWJLZXkoYnl0ZUFycmF5QWRkcik7XG4gICAgcmV0dXJuIGJpdGdvQWNjb3VudExpYi5UcnguVXRpbHMuZ2V0SGV4QWRkcmVzc0Zyb21CeXRlQXJyYXkocmF3QWRkcmVzcyk7XG4gIH1cblxuICB4cHJ2VG9Db21wcmVzc2VkUHJ2KHhwcnY6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRYcHJ2KHhwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgeHBydicpO1xuICAgIH1cblxuICAgIGNvbnN0IGhkTm9kZSA9IEhETm9kZS5mcm9tQmFzZTU4KHhwcnYsIG5ldHdvcmtzLmJpdGNvaW4pO1xuICAgIHJldHVybiBoZE5vZGUua2V5UGFpci5kLnRvQnVmZmVyKDMyKS50b1N0cmluZygnaGV4Jyk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIHF1ZXJ5IHRvIFRyb25ncmlkIGZvciBpbmZvcm1hdGlvbiBzdWNoIGFzIGJhbGFuY2UsIHRva2VuIGJhbGFuY2UsIHNvbGlkaXR5IGNhbGxzXG4gICAqIEBwYXJhbSBxdWVyeSB7T2JqZWN0fSBrZXktdmFsdWUgcGFpcnMgb2YgcGFyYW1ldGVycyB0byBhcHBlbmQgYWZ0ZXIgL2FwaVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge09iamVjdH0gcmVzcG9uc2UgZnJvbSBUcm9uZ3JpZFxuICAgKi9cbiAgcHJpdmF0ZSByZWNvdmVyeVBvc3QoXG4gICAgcXVlcnk6IHsgcGF0aDogc3RyaW5nOyBqc29uT2JqOiBhbnk7IG5vZGU6IE5vZGVUeXBlcyB9LFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT5cbiAgKTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uKigpIHtcbiAgICAgIGxldCBub2RlVXJpID0gJyc7XG4gICAgICBzd2l0Y2ggKHF1ZXJ5Lm5vZGUpIHtcbiAgICAgICAgY2FzZSBOb2RlVHlwZXMuRnVsbDpcbiAgICAgICAgICBub2RlVXJpID0gY29tbW9uLkVudmlyb25tZW50c1tzZWxmLmJpdGdvLmdldEVudigpXS50cm9uTm9kZXMuZnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBOb2RlVHlwZXMuU29saWRpdHk6XG4gICAgICAgICAgbm9kZVVyaSA9IGNvbW1vbi5FbnZpcm9ubWVudHNbc2VsZi5iaXRnby5nZXRFbnYoKV0udHJvbk5vZGVzLnNvbGlkaXR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm9kZSB0eXBlIG5vdCBmb3VuZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHJlcXVlc3RcbiAgICAgICAgLnBvc3Qobm9kZVVyaSArIHF1ZXJ5LnBhdGgpXG4gICAgICAgIC50eXBlKCdqc29uJylcbiAgICAgICAgLnNlbmQocXVlcnkuanNvbk9iaik7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhY2ggVHJvbiBub2RlJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHVuZm9ydHVuYXRlbHksIGl0IGRvZXNuJ3QgbG9vayBsaWtlIG1vc3QgVFJPTiBub2RlcyByZXR1cm4gdmFsaWQganNvbiBhcyBib2R5XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwb25zZS50ZXh0KTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyeSBvdXIgZXhwbG9yZXIgZm9yIHRoZSBiYWxhbmNlIG9mIGFuIGFkZHJlc3NcbiAgICogQHBhcmFtIGFkZHJlc3Mge1N0cmluZ30gdGhlIGFkZHJlc3MgZW5jb2RlZCBpbiBoZXhcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IGFkZHJlc3MgYmFsYW5jZVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRBY2NvdW50RnJvbU5vZGUoYWRkcmVzczogc3RyaW5nLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxBY2NvdW50UmVzcG9uc2U+KTogQmx1ZWJpcmQ8QWNjb3VudFJlc3BvbnNlPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPEFjY291bnRSZXNwb25zZT4oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgc2VsZi5yZWNvdmVyeVBvc3Qoe1xuICAgICAgICBwYXRoOiAnL3dhbGxldHNvbGlkaXR5L2dldGFjY291bnQnLFxuICAgICAgICBqc29uT2JqOiB7IGFkZHJlc3MgfSxcbiAgICAgICAgbm9kZTogTm9kZVR5cGVzLlNvbGlkaXR5LFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBvdXIgYnVpbGQgdHJhbnNhY3Rpb24gZnJvbSBhIG5vZGUuXG4gICAqIEBwYXJhbSB0b0FkZHIgaGV4LWVuY29kZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gZnJvbUFkZHIgaGV4LWVuY29kZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gYW1vdW50XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcHJpdmF0ZSBnZXRCdWlsZFRyYW5zYWN0aW9uKFxuICAgIHRvQWRkcjogc3RyaW5nLFxuICAgIGZyb21BZGRyOiBzdHJpbmcsXG4gICAgYW1vdW50OiBudW1iZXIsXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8Yml0Z29BY2NvdW50TGliLlRyeC5JbnRlcmZhY2UuVHJhbnNhY3Rpb25SZWNlaXB0PlxuICApOiBCbHVlYmlyZDxiaXRnb0FjY291bnRMaWIuVHJ4LkludGVyZmFjZS5UcmFuc2FjdGlvblJlY2VpcHQ+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288Yml0Z29BY2NvdW50TGliLlRyeC5JbnRlcmZhY2UuVHJhbnNhY3Rpb25SZWNlaXB0PihmdW5jdGlvbiooKSB7XG4gICAgICAvLyBvdXIgYWRkcmVzc2VzIHNob3VsZCBiZSBiYXNlNTgsIHdlJ2xsIGhhdmUgdG8gZW5jb2RlIHRvIGhleFxuICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgc2VsZi5yZWNvdmVyeVBvc3Qoe1xuICAgICAgICBwYXRoOiAnL3dhbGxldC9jcmVhdGV0cmFuc2FjdGlvbicsXG4gICAgICAgIGpzb25PYmo6IHtcbiAgICAgICAgICB0b19hZGRyZXNzOiB0b0FkZHIsXG4gICAgICAgICAgb3duZXJfYWRkcmVzczogZnJvbUFkZHIsXG4gICAgICAgICAgYW1vdW50LFxuICAgICAgICB9LFxuICAgICAgICBub2RlOiBOb2RlVHlwZXMuRnVsbCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IGtleXMgaW4gdGhlIG93bmVyS2V5cyBjb2xsZWN0aW9uIGRvbid0IG1hdGNoIHRoZSBrZXlzIGFycmF5IHdlIHBhc3NcbiAgICogQHBhcmFtIG93bmVyS2V5c1xuICAgKiBAcGFyYW0ga2V5c1RvRmluZFxuICAgKi9cbiAgY2hlY2tQZXJtaXNzaW9ucyhvd25lcktleXM6IHsgYWRkcmVzczogc3RyaW5nOyB3ZWlnaHQ6IG51bWJlciB9W10sIGtleXM6IHN0cmluZ1tdKSB7XG4gICAga2V5cyA9IGtleXMubWFwKGsgPT4gay50b1VwcGVyQ2FzZSgpKTtcblxuICAgIG93bmVyS2V5cy5tYXAoa2V5ID0+IHtcbiAgICAgIGNvbnN0IGhleEtleSA9IGtleS5hZGRyZXNzLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpZiAoIWtleXMuaW5jbHVkZXMoaGV4S2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHB1YiBhZGRyZXNzICR7aGV4S2V5fSBub3QgZm91bmQgaW4gYWNjb3VudGApO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5LndlaWdodCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ293bmVyIHBlcm1pc3Npb24gaXMgaW52YWxpZCBmb3IgdGhpcyBzdHJ1Y3R1cmUnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBmdW5kcyByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRob3V0IEJpdEdvLlxuICAgKiBXZSBuZWVkIHRvIGRvIHRocmVlIHF1ZXJpZXMgZHVyaW5nIHRoaXM6XG4gICAqIDEpIE5vZGUgcXVlcnkgLSBob3cgbXVjaCBtb25leSBpcyBpbiB0aGUgYWNjb3VudFxuICAgKiAyKSBCdWlsZCB0cmFuc2FjdGlvbiAtIGJ1aWxkIG91ciB0cmFuc2FjdGlvbiBmb3IgdGhlIGFtb3VudFxuICAgKiAzKSBTZW5kIHNpZ25lZCBidWlsZCAtIHNlbmQgb3VyIHNpZ25lZCBidWlsZCB0byBhIHB1YmxpYyBub2RlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICByZWNvdmVyKHBhcmFtczogUmVjb3ZlcnlPcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxSZWNvdmVyeVRyYW5zYWN0aW9uPik6IEJsdWViaXJkPFJlY292ZXJ5VHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288UmVjb3ZlcnlUcmFuc2FjdGlvbj4oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IHBhcmFtcy5iYWNrdXBLZXkuc3RhcnRzV2l0aCgneHB1YicpICYmICFwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCd4cHViJyk7XG4gICAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBwYXJhbXMuYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSAmJiBwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCd4cHViJyk7XG5cbiAgICAgIC8vIGdldCBvdXIgdXNlciwgYmFja3VwIGtleXNcbiAgICAgIGNvbnN0IGtleXMgPSB5aWVsZCBzZWxmLmluaXRpYXRlUmVjb3ZlcnkocGFyYW1zKTtcblxuICAgICAgLy8gd2UgbmVlZCB0byBkZWNvZGUgb3VyIGJpdGdvS2V5IHRvIGEgYmFzZTU4IGFkZHJlc3NcbiAgICAgIGNvbnN0IGJpdGdvSGV4QWRkciA9IHNlbGYuY29tcHJlc3NlZFB1YlRvSGV4QWRkcmVzcyhzZWxmLnhwdWJUb0NvbXByZXNzZWRQdWIocGFyYW1zLmJpdGdvS2V5KSk7XG4gICAgICBjb25zdCByZWNvdmVyeUFkZHJlc3NIZXggPSBiaXRnb0FjY291bnRMaWIuVHJ4LlV0aWxzLmdldEhleEFkZHJlc3NGcm9tQmFzZTU4QWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbik7XG5cbiAgICAgIC8vIGNhbGwgdGhlIG5vZGUgdG8gZ2V0IG91ciBhY2NvdW50IGJhbGFuY2VcbiAgICAgIGNvbnN0IGFjY291bnQgPSB5aWVsZCBzZWxmLmdldEFjY291bnRGcm9tTm9kZShiaXRnb0hleEFkZHIpO1xuICAgICAgY29uc3QgcmVjb3ZlcnlBbW91bnQgPSBhY2NvdW50LmJhbGFuY2U7XG5cbiAgICAgIGNvbnN0IHVzZXJYUHViID0ga2V5c1swXS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCk7XG4gICAgICBjb25zdCB1c2VyWFBydiA9IGtleXNbMF0udG9CYXNlNTgoKTtcbiAgICAgIGNvbnN0IGJhY2t1cFhQdWIgPSBrZXlzWzFdLm5ldXRlcmVkKCkudG9CYXNlNTgoKTtcblxuICAgICAgLy8gY29uc3RydWN0IHRoZSB0eCAtXG4gICAgICAvLyB0aGVyZSdzIGFuIGFzc3VtcHRpb24gaGVyZSBiZWluZyBtYWRlIGFib3V0IGZlZXM6IGZvciBhIHdhbGxldCB0aGF0IGhhc24ndCBiZWVuIHVzZWQgaW4gYXdoaWxlLCB0aGUgaW1wbGljYXRpb24gaXNcbiAgICAgIC8vIGl0IGhhcyBtYXhpbXVtIGJhbmR3aWR0aC4gdGh1cywgYSByZWNvdmVyeSBzaG91bGQgY29zdCB0aGUgbWluaW11bSBhbW91bnQgKDFlNiBzdW4gb3IgMSBUcm9uKVxuICAgICAgaWYgKE1JTklNVU1fVFJPTl9NU0lHX1RSQU5TQUNUSU9OX0ZFRSA+IHJlY292ZXJ5QW1vdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQW1vdW50IG9mIGZ1bmRzIHRvIHJlY292ZXIgd291bGRudCBiZSBhYmxlIHRvIGZ1bmQgYSBzZW5kJyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWNvdmVyeUFtb3VudE1pbnVzRmVlcyA9IHJlY292ZXJ5QW1vdW50IC0gTUlOSU1VTV9UUk9OX01TSUdfVFJBTlNBQ1RJT05fRkVFO1xuICAgICAgY29uc3QgYnVpbGRUeCA9IHlpZWxkIHNlbGYuZ2V0QnVpbGRUcmFuc2FjdGlvbihyZWNvdmVyeUFkZHJlc3NIZXgsIGJpdGdvSGV4QWRkciwgcmVjb3ZlcnlBbW91bnRNaW51c0ZlZXMpO1xuXG4gICAgICBjb25zdCBrZXlIZXhBZGRyZXNzZXMgPSBbXG4gICAgICAgIHNlbGYuY29tcHJlc3NlZFB1YlRvSGV4QWRkcmVzcyhzZWxmLnhwdWJUb0NvbXByZXNzZWRQdWIodXNlclhQdWIpKSxcbiAgICAgICAgc2VsZi5jb21wcmVzc2VkUHViVG9IZXhBZGRyZXNzKHNlbGYueHB1YlRvQ29tcHJlc3NlZFB1YihiYWNrdXBYUHViKSksXG4gICAgICAgIGJpdGdvSGV4QWRkcixcbiAgICAgIF07XG5cbiAgICAgIC8vIHJ1biBjaGVja3MgdG8gZW5zdXJlIHRoaXMgaXMgYSB2YWxpZCB0eCAtIHBlcm1pc3Npb25zIG1hdGNoIG91ciBzaWduZXIga2V5c1xuICAgICAgc2VsZi5jaGVja1Blcm1pc3Npb25zKGFjY291bnQub3duZXJfcGVybWlzc2lvbi5rZXlzLCBrZXlIZXhBZGRyZXNzZXMpO1xuICAgICAgc2VsZi5jaGVja1Blcm1pc3Npb25zKGFjY291bnQuYWN0aXZlX3Blcm1pc3Npb25bMF0ua2V5cywga2V5SGV4QWRkcmVzc2VzKTtcblxuICAgICAgLy8gY29uc3RydWN0IG91ciB0eFxuICAgICAgY29uc3QgdHhCdWlsZGVyID0gYml0Z29BY2NvdW50TGliLmdldEJ1aWxkZXIoc2VsZi5nZXRDaGFpbigpKTtcbiAgICAgIC8vIE5ld2VyIGNvaW5zIGNhbiByZXR1cm4gQmFzZVRyYW5zYWN0aW9uQnVpbGRlckZhY3RvcnkgaW5zdGVhZCBvZiBCYXNlVHJhbnNhY3Rpb25CdWlsZGVyXG4gICAgICBpZiAoISh0eEJ1aWxkZXIgaW5zdGFuY2VvZiBiaXRnb0FjY291bnRMaWIuQmFzZUNvaW4uQmFzZVRyYW5zYWN0aW9uQnVpbGRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRCdWlsZGVyKCkgZGlkIG5vdCByZXR1cm4gYW4gQmFzZVRyYW5zYWN0aW9uQnVpbGRlciBvYmplY3QuIEhhcyBpdCBiZWVuIHVwZGF0ZWQ/Jyk7XG4gICAgICB9XG4gICAgICB0eEJ1aWxkZXIuZnJvbShidWlsZFR4KTtcblxuICAgICAgLy8gdGhpcyB0eCBzaG91bGQgYmUgZW5vdWdoIHRvIGRyb3AgaW50byBhIG5vZGVcbiAgICAgIGlmIChpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eDogKHlpZWxkIHR4QnVpbGRlci5idWlsZCgpKS50b0pzb24oKSxcbiAgICAgICAgICByZWNvdmVyeUFtb3VudDogcmVjb3ZlcnlBbW91bnRNaW51c0ZlZXMsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVzZXJQcnYgPSBzZWxmLnhwcnZUb0NvbXByZXNzZWRQcnYodXNlclhQcnYpO1xuXG4gICAgICB0eEJ1aWxkZXIuc2lnbih7IGtleTogdXNlclBydiB9KTtcblxuICAgICAgLy8ga3JzIHJlY292ZXJpZXMgZG9uJ3QgZ2V0IHNpZ25lZFxuICAgICAgaWYgKCFpc0tyc1JlY292ZXJ5KSB7XG4gICAgICAgIGNvbnN0IGJhY2t1cFhQcnYgPSBrZXlzWzFdLnRvQmFzZTU4KCk7XG4gICAgICAgIGNvbnN0IGJhY2t1cFBydiA9IHNlbGYueHBydlRvQ29tcHJlc3NlZFBydihiYWNrdXBYUHJ2KTtcblxuICAgICAgICB0eEJ1aWxkZXIuc2lnbih7IGtleTogYmFja3VwUHJ2IH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eDogKHlpZWxkIHR4QnVpbGRlci5idWlsZCgpKS50b0pzb24oKSxcbiAgICAgICAgcmVjb3ZlcnlBbW91bnQ6IHJlY292ZXJ5QW1vdW50TWludXNGZWVzLFxuICAgICAgfTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluIGEgVHJvbiB0cmFuc2FjdGlvbiBmcm9tIHR4SGV4XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBleHBsYWluVHJhbnNhY3Rpb24oXG4gICAgcGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFRyb25UcmFuc2FjdGlvbkV4cGxhbmF0aW9uPlxuICApOiBCbHVlYmlyZDxUcm9uVHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxUcm9uVHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3QgdHhIZXggPSBwYXJhbXMudHhIZXggfHwgKHBhcmFtcy5oYWxmU2lnbmVkICYmIHBhcmFtcy5oYWxmU2lnbmVkLnR4SGV4KTtcbiAgICAgIGlmICghdHhIZXggfHwgIXBhcmFtcy5mZWVJbmZvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBleHBsYWluIHR4IHBhcmFtZXRlcnMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR4QnVpbGRlciA9IGJpdGdvQWNjb3VudExpYi5nZXRCdWlsZGVyKHNlbGYuZ2V0Q2hhaW4oKSk7XG4gICAgICAvLyBOZXdlciBjb2lucyBjYW4gcmV0dXJuIEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5IGluc3RlYWQgb2YgQmFzZVRyYW5zYWN0aW9uQnVpbGRlclxuICAgICAgaWYgKCEodHhCdWlsZGVyIGluc3RhbmNlb2YgYml0Z29BY2NvdW50TGliLkJhc2VDb2luLkJhc2VUcmFuc2FjdGlvbkJ1aWxkZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0QnVpbGRlcigpIGRpZCBub3QgcmV0dXJuIGFuIEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXIgb2JqZWN0LiBIYXMgaXQgYmVlbiB1cGRhdGVkPycpO1xuICAgICAgfVxuICAgICAgdHhCdWlsZGVyLmZyb20odHhIZXgpO1xuICAgICAgY29uc3QgdHggPSB5aWVsZCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICAgIGNvbnN0IG91dHB1dHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBhbW91bnQ6IHR4Lm91dHB1dHNbMF0udmFsdWUudG9TdHJpbmcoKSxcbiAgICAgICAgICBhZGRyZXNzOiB0eC5vdXRwdXRzWzBdLmFkZHJlc3MsIC8vIFNob3VsZCB0dXJuIGl0IGludG8gYSByZWFkYWJsZSBmb3JtYXQsIGFrYSBiYXNlNThcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGRpc3BsYXlPcmRlciA9IFtcbiAgICAgICAgJ2lkJyxcbiAgICAgICAgJ291dHB1dEFtb3VudCcsXG4gICAgICAgICdjaGFuZ2VBbW91bnQnLFxuICAgICAgICAnb3V0cHV0cycsXG4gICAgICAgICdjaGFuZ2VPdXRwdXRzJyxcbiAgICAgICAgJ2ZlZScsXG4gICAgICAgICd0aW1lc3RhbXAnLFxuICAgICAgICAnZXhwaXJhdGlvbicsXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBleHBsYW5hdGlvblJlc3VsdDogVHJvblRyYW5zYWN0aW9uRXhwbGFuYXRpb24gPSB7XG4gICAgICAgIGRpc3BsYXlPcmRlcixcbiAgICAgICAgaWQ6IHR4LmlkLFxuICAgICAgICBvdXRwdXRzLFxuICAgICAgICBvdXRwdXRBbW91bnQ6IG91dHB1dHNbMF0uYW1vdW50LFxuICAgICAgICBjaGFuZ2VPdXRwdXRzOiBbXSwgLy8gYWNjb3VudCBiYXNlZCBkb2VzIG5vdCB1c2UgY2hhbmdlIG91dHB1dHNcbiAgICAgICAgY2hhbmdlQW1vdW50OiAnMCcsIC8vIGFjY291bnQgYmFzZSBkb2VzIG5vdCBtYWtlIGNoYW5nZVxuICAgICAgICBmZWU6IHBhcmFtcy5mZWVJbmZvLFxuICAgICAgICB0aW1lc3RhbXA6IHR4LnZhbGlkRnJvbSxcbiAgICAgICAgZXhwaXJhdGlvbjogdHgudmFsaWRUbyxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBleHBsYW5hdGlvblJlc3VsdDtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxufVxuIl19