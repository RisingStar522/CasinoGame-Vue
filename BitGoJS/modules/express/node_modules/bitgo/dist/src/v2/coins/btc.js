"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("../../errors");
var abstractUtxoCoin_1 = require("./abstractUtxoCoin");
var common = require("../../common");
var bitcoin = require("@bitgo/utxo-lib");
var request = require("superagent");
var _ = require("lodash");
var Bluebird = require("bluebird");
var blockstreamApi_1 = require("../recovery/blockstreamApi");
var blockchairApi_1 = require("../recovery/blockchairApi");
var co = Bluebird.coroutine;
var Btc = /** @class */ (function (_super) {
    __extends(Btc, _super);
    function Btc(bitgo, network) {
        return _super.call(this, bitgo, network || bitcoin.networks.bitcoin) || this;
    }
    Btc.createInstance = function (bitgo) {
        return new Btc(bitgo);
    };
    Btc.prototype.getChain = function () {
        return 'btc';
    };
    Btc.prototype.getFamily = function () {
        return 'btc';
    };
    Btc.prototype.getFullName = function () {
        return 'Bitcoin';
    };
    Btc.prototype.supportsBlockTarget = function () {
        return true;
    };
    Btc.prototype.supportsP2shP2wsh = function () {
        return true;
    };
    Btc.prototype.supportsP2wsh = function () {
        return true;
    };
    Btc.prototype.getRecoveryFeePerBytes = function () {
        var self = this;
        return co(function getRecoveryFeePerBytes() {
            var recoveryFeeUrl, publicFeeDataReq, publicFeeData, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.getRecoveryFeeRecommendationApiBaseUrl()];
                    case 1:
                        recoveryFeeUrl = _a.sent();
                        publicFeeDataReq = request.get(recoveryFeeUrl);
                        publicFeeDataReq.forceV1Auth = true;
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, publicFeeDataReq.result()];
                    case 3:
                        publicFeeData = _a.sent();
                        if (publicFeeData && publicFeeData.hourFee && _.isInteger(publicFeeData.hourFee)) {
                            return [2 /*return*/, publicFeeData.hourFee];
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        e_1 = _a.sent();
                        // if bitcoinfees does not respond, we would resort to the default fee value, 100
                        // but we don't want to block the recovery process
                        console.dir(e_1);
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/, 100];
                }
            });
        }).call(this);
    };
    Btc.prototype.getRecoveryFeeRecommendationApiBaseUrl = function () {
        return Bluebird.resolve('https://bitcoinfees.earn.com/api/v1/fees/recommended');
    };
    Btc.prototype.recoveryBlockchainExplorerUrl = function (url) {
        return blockchairApi_1.BlockchairApi.getBaseUrl(this.bitgo.getEnv(), 'bitcoin');
    };
    Btc.prototype.getAddressInfoFromExplorer = function (addressBase58, apiKey) {
        // TODO: allow users to choose the API to use
        var api = new blockstreamApi_1.BlockstreamApi(this.bitgo, apiKey);
        return Bluebird.resolve(api.getAccountInfo(addressBase58));
    };
    Btc.prototype.getUnspentInfoFromExplorer = function (addressBase58, apiKey) {
        // TODO: allow users to choose the API to use
        var api = new blockstreamApi_1.BlockstreamApi(this.bitgo, apiKey);
        return Bluebird.resolve(api.getUnspents(addressBase58));
    };
    /**
     * Verify that the txhex user signs correspond to the correct tx they intended
     * by 1) getting back the decoded transaction based on the txhex
     * and then 2) compute the txid (hash), h1 of the decoded transaction 3) compare h1
     * to the txid (hash) of the transaction (including unspent info) we constructed
     * @param {TransactionInfo} txInfo
     * @returns {Bluebird<any>}
     */
    Btc.prototype.verifyRecoveryTransaction = function (txInfo) {
        var self = this;
        return co(function verifyRecoveryTransaction() {
            var smartbitURL, res, e_2, transactionDetails, tx;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        smartbitURL = common.Environments[this.bitgo.getEnv()].smartbitBaseUrl + '/blockchain/decodetx';
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, request.post(smartbitURL)
                                .send({ hex: txInfo.transactionHex })
                                .result()];
                    case 2:
                        res = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_2 = _a.sent();
                        if (e_2 || !res) { // if smartbit fails to respond
                            throw new errors_1.BlockExplorerUnavailable(e_2);
                        }
                        return [3 /*break*/, 4];
                    case 4:
                        /**
                         * Smartbit's response when something goes wrong
                         * {"success":false,"error":{"code":"REQ_ERROR","message":"TX decode failed"}}
                         * we should process the error message here
                         * interpret the res from smartbit
                         */
                        if (!res.success) {
                            throw new Error(res.error.message);
                        }
                        transactionDetails = res.transaction;
                        tx = bitcoin.Transaction.fromHex(txInfo.transactionHex, this.network);
                        if (transactionDetails.TxId !== tx.getId()) {
                            console.log('txhash/txid returned by blockexplorer: ', transactionDetails.TxId);
                            console.log('txhash/txid of the transaction bitgo constructed', tx.getId());
                            throw new Error('inconsistent recovery transaction id');
                        }
                        return [2 /*return*/, transactionDetails];
                }
            });
        }).call(this);
    };
    return Btc;
}(abstractUtxoCoin_1.AbstractUtxoCoin));
exports.Btc = Btc;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnRjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL2J0Yy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSx1Q0FBd0Q7QUFFeEQsdURBQW1FO0FBQ25FLHFDQUF1QztBQUN2Qyx5Q0FBMkM7QUFDM0Msb0NBQXNDO0FBQ3RDLDBCQUE0QjtBQUM1QixtQ0FBcUM7QUFDckMsNkRBQTREO0FBQzVELDJEQUEwRDtBQUUxRCxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBTTlCO0lBQXlCLHVCQUFnQjtJQUN2QyxhQUFZLEtBQVksRUFBRSxPQUFxQjtlQUM3QyxrQkFBTSxLQUFLLEVBQUUsT0FBTyxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDO0lBQ25ELENBQUM7SUFFTSxrQkFBYyxHQUFyQixVQUFzQixLQUFZO1FBQ2hDLE9BQU8sSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVELHNCQUFRLEdBQVI7UUFDRSxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRCx1QkFBUyxHQUFUO1FBQ0UsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQseUJBQVcsR0FBWDtRQUNFLE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRCxpQ0FBbUIsR0FBbkI7UUFDRSxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCwrQkFBaUIsR0FBakI7UUFDRSxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCwyQkFBYSxHQUFiO1FBQ0UsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsb0NBQXNCLEdBQXRCO1FBQ0UsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUFTLFNBQVUsc0JBQXNCOzs7OzRCQUN6QixxQkFBTSxJQUFJLENBQUMs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QUFPLENBQUMsQ0FBQzt3QkFDNUUsSUFBSSxrQkFBa0IsQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFOzRCQUMxQyxPQUFPLENBQUMsR0FBRyxDQUFDLHlDQUF5QyxFQUFFLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDOzRCQUNoRixPQUFPLENBQUMsR0FBRyxDQUFDLGtEQUFrRCxFQUFFLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDOzRCQUM1RSxNQUFNLElBQUksS0FBSyxDQUFDLHNDQUFzQyxDQUFDLENBQUM7eUJBQ3pEO3dCQUNELHNCQUFPLGtCQUFrQixFQUFDOzs7U0FDM0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoQixDQUFDO0lBQ0gsVUFBQztBQUFELENBQUMsQUF2SEQsQ0FBeUIsbUNBQWdCLEdBdUh4QztBQXZIWSxrQkFBRyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vYml0Z28nO1xuaW1wb3J0IHsgQmxvY2tFeHBsb3JlclVuYXZhaWxhYmxlIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IEJhc2VDb2luIH0gZnJvbSAnLi4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgQWJzdHJhY3RVdHhvQ29pbiwgVXR4b05ldHdvcmsgfSBmcm9tICcuL2Fic3RyYWN0VXR4b0NvaW4nO1xuaW1wb3J0ICogYXMgY29tbW9uIGZyb20gJy4uLy4uL2NvbW1vbic7XG5pbXBvcnQgKiBhcyBiaXRjb2luIGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgKiBhcyByZXF1ZXN0IGZyb20gJ3N1cGVyYWdlbnQnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgQmxvY2tzdHJlYW1BcGkgfSBmcm9tICcuLi9yZWNvdmVyeS9ibG9ja3N0cmVhbUFwaSc7XG5pbXBvcnQgeyBCbG9ja2NoYWlyQXBpIH0gZnJvbSAnLi4vcmVjb3ZlcnkvYmxvY2tjaGFpckFwaSc7XG5pbXBvcnQgeyBSZWNvdmVyeUFjY291bnREYXRhLCBSZWNvdmVyeVVuc3BlbnQgfSBmcm9tICcuLi9yZWNvdmVyeS90eXBlcyc7XG5jb25zdCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbkluZm8ge1xuICB0cmFuc2FjdGlvbkhleDogc3RyaW5nLFxufVxuXG5leHBvcnQgY2xhc3MgQnRjIGV4dGVuZHMgQWJzdHJhY3RVdHhvQ29pbiB7XG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHbywgbmV0d29yaz86IFV0eG9OZXR3b3JrKSB7XG4gICAgc3VwZXIoYml0Z28sIG5ldHdvcmsgfHwgYml0Y29pbi5uZXR3b3Jrcy5iaXRjb2luKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R28pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBCdGMoYml0Z28pO1xuICB9XG5cbiAgZ2V0Q2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2J0Yyc7XG4gIH1cblxuICBnZXRGYW1pbHkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2J0Yyc7XG4gIH1cblxuICBnZXRGdWxsTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnQml0Y29pbic7XG4gIH1cblxuICBzdXBwb3J0c0Jsb2NrVGFyZ2V0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3VwcG9ydHNQMnNoUDJ3c2goKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzdXBwb3J0c1Ayd3NoKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZ2V0UmVjb3ZlcnlGZWVQZXJCeXRlcygpOiBCbHVlYmlyZDxudW1iZXI+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288bnVtYmVyPihmdW5jdGlvbiAqZ2V0UmVjb3ZlcnlGZWVQZXJCeXRlcygpIHtcbiAgICAgIGNvbnN0IHJlY292ZXJ5RmVlVXJsID0geWllbGQgc2VsZi5nZXRSZWNvdmVyeUZlZVJlY29tbWVuZGF0aW9uQXBpQmFzZVVybCgpO1xuXG4gICAgICBjb25zdCBwdWJsaWNGZWVEYXRhUmVxID0gcmVxdWVzdC5nZXQocmVjb3ZlcnlGZWVVcmwpO1xuICAgICAgcHVibGljRmVlRGF0YVJlcS5mb3JjZVYxQXV0aCA9IHRydWU7XG4gICAgICBsZXQgcHVibGljRmVlRGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHB1YmxpY0ZlZURhdGEgPSB5aWVsZCBwdWJsaWNGZWVEYXRhUmVxLnJlc3VsdCgpO1xuICAgICAgICBpZiAocHVibGljRmVlRGF0YSAmJiBwdWJsaWNGZWVEYXRhLmhvdXJGZWUgJiYgXy5pc0ludGVnZXIocHVibGljRmVlRGF0YS5ob3VyRmVlKSkge1xuICAgICAgICAgIHJldHVybiBwdWJsaWNGZWVEYXRhLmhvdXJGZWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWYgYml0Y29pbmZlZXMgZG9lcyBub3QgcmVzcG9uZCwgd2Ugd291bGQgcmVzb3J0IHRvIHRoZSBkZWZhdWx0IGZlZSB2YWx1ZSwgMTAwXG4gICAgICAgIC8vIGJ1dCB3ZSBkb24ndCB3YW50IHRvIGJsb2NrIHRoZSByZWNvdmVyeSBwcm9jZXNzXG4gICAgICAgIGNvbnNvbGUuZGlyKGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDEwMDtcbiAgICB9KS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgZ2V0UmVjb3ZlcnlGZWVSZWNvbW1lbmRhdGlvbkFwaUJhc2VVcmwoKTogQmx1ZWJpcmQ8c3RyaW5nPiB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUoJ2h0dHBzOi8vYml0Y29pbmZlZXMuZWFybi5jb20vYXBpL3YxL2ZlZXMvcmVjb21tZW5kZWQnKTtcbiAgfVxuXG4gIHJlY292ZXJ5QmxvY2tjaGFpbkV4cGxvcmVyVXJsKHVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gQmxvY2tjaGFpckFwaS5nZXRCYXNlVXJsKHRoaXMuYml0Z28uZ2V0RW52KCksICdiaXRjb2luJyk7XG4gIH1cblxuICBnZXRBZGRyZXNzSW5mb0Zyb21FeHBsb3JlcihhZGRyZXNzQmFzZTU4OiBzdHJpbmcsIGFwaUtleT86IHN0cmluZyk6IEJsdWViaXJkPFJlY292ZXJ5QWNjb3VudERhdGE+IHtcbiAgICAvLyBUT0RPOiBhbGxvdyB1c2VycyB0byBjaG9vc2UgdGhlIEFQSSB0byB1c2VcbiAgICBjb25zdCBhcGkgPSBuZXcgQmxvY2tzdHJlYW1BcGkodGhpcy5iaXRnbywgYXBpS2V5KTtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZShhcGkuZ2V0QWNjb3VudEluZm8oYWRkcmVzc0Jhc2U1OCkpO1xuICB9XG5cbiAgZ2V0VW5zcGVudEluZm9Gcm9tRXhwbG9yZXIoYWRkcmVzc0Jhc2U1ODogc3RyaW5nLCBhcGlLZXk/OiBzdHJpbmcpOiBCbHVlYmlyZDxSZWNvdmVyeVVuc3BlbnRbXT4ge1xuICAgIC8vIFRPRE86IGFsbG93IHVzZXJzIHRvIGNob29zZSB0aGUgQVBJIHRvIHVzZVxuICAgIGNvbnN0IGFwaSA9IG5ldyBCbG9ja3N0cmVhbUFwaSh0aGlzLmJpdGdvLCBhcGlLZXkpO1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKGFwaS5nZXRVbnNwZW50cyhhZGRyZXNzQmFzZTU4KSk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgdGhlIHR4aGV4IHVzZXIgc2lnbnMgY29ycmVzcG9uZCB0byB0aGUgY29ycmVjdCB0eCB0aGV5IGludGVuZGVkXG4gICAqIGJ5IDEpIGdldHRpbmcgYmFjayB0aGUgZGVjb2RlZCB0cmFuc2FjdGlvbiBiYXNlZCBvbiB0aGUgdHhoZXhcbiAgICogYW5kIHRoZW4gMikgY29tcHV0ZSB0aGUgdHhpZCAoaGFzaCksIGgxIG9mIHRoZSBkZWNvZGVkIHRyYW5zYWN0aW9uIDMpIGNvbXBhcmUgaDFcbiAgICogdG8gdGhlIHR4aWQgKGhhc2gpIG9mIHRoZSB0cmFuc2FjdGlvbiAoaW5jbHVkaW5nIHVuc3BlbnQgaW5mbykgd2UgY29uc3RydWN0ZWRcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbkluZm99IHR4SW5mb1xuICAgKiBAcmV0dXJucyB7Qmx1ZWJpcmQ8YW55Pn1cbiAgICovXG4gIHB1YmxpYyB2ZXJpZnlSZWNvdmVyeVRyYW5zYWN0aW9uKHR4SW5mbzogVHJhbnNhY3Rpb25JbmZvKTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICp2ZXJpZnlSZWNvdmVyeVRyYW5zYWN0aW9uKCkge1xuICAgICAgY29uc3Qgc21hcnRiaXRVUkwgPSBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZ2V0RW52KCldLnNtYXJ0Yml0QmFzZVVybCArICcvYmxvY2tjaGFpbi9kZWNvZGV0eCc7XG4gICAgICBsZXQgcmVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzID0geWllbGQgcmVxdWVzdC5wb3N0KHNtYXJ0Yml0VVJMKVxuICAgICAgICAgIC5zZW5kKHsgaGV4OiB0eEluZm8udHJhbnNhY3Rpb25IZXggfSlcbiAgICAgICAgICAucmVzdWx0KCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICggZSB8fCAhcmVzKSB7IC8vIGlmIHNtYXJ0Yml0IGZhaWxzIHRvIHJlc3BvbmRcbiAgICAgICAgICB0aHJvdyBuZXcgQmxvY2tFeHBsb3JlclVuYXZhaWxhYmxlKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU21hcnRiaXQncyByZXNwb25zZSB3aGVuIHNvbWV0aGluZyBnb2VzIHdyb25nXG4gICAgICAgKiB7XCJzdWNjZXNzXCI6ZmFsc2UsXCJlcnJvclwiOntcImNvZGVcIjpcIlJFUV9FUlJPUlwiLFwibWVzc2FnZVwiOlwiVFggZGVjb2RlIGZhaWxlZFwifX1cbiAgICAgICAqIHdlIHNob3VsZCBwcm9jZXNzIHRoZSBlcnJvciBtZXNzYWdlIGhlcmVcbiAgICAgICAqIGludGVycHJldCB0aGUgcmVzIGZyb20gc21hcnRiaXRcbiAgICAgICAqL1xuICAgICAgaWYgKCFyZXMuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkRldGFpbHMgPSByZXMudHJhbnNhY3Rpb247XG5cbiAgICAgIGNvbnN0IHR4ID0gYml0Y29pbi5UcmFuc2FjdGlvbi5mcm9tSGV4KHR4SW5mby50cmFuc2FjdGlvbkhleCwgdGhpcy5uZXR3b3JrKTtcbiAgICAgIGlmICh0cmFuc2FjdGlvbkRldGFpbHMuVHhJZCAhPT0gdHguZ2V0SWQoKSkge1xuICAgICAgICBjb25zb2xlLmxvZygndHhoYXNoL3R4aWQgcmV0dXJuZWQgYnkgYmxvY2tleHBsb3JlcjogJywgdHJhbnNhY3Rpb25EZXRhaWxzLlR4SWQpO1xuICAgICAgICBjb25zb2xlLmxvZygndHhoYXNoL3R4aWQgb2YgdGhlIHRyYW5zYWN0aW9uIGJpdGdvIGNvbnN0cnVjdGVkJywgdHguZ2V0SWQoKSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5jb25zaXN0ZW50IHJlY292ZXJ5IHRyYW5zYWN0aW9uIGlkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb25EZXRhaWxzO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gIH1cbn1cbiJdfQ==