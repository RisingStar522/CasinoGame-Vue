"use strict";
/**
 * @prettier
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var debugLib = require("debug");
var _ = require("lodash");
var errors = require("../../errors");
var abstractUtxoCoin_1 = require("../coins/abstractUtxoCoin");
var debug = debugLib('bitgo:v2:parseoutput');
/**
 * Check an address which failed initial validation to see if it's the base address of a migrated v1 bch wallet.
 *
 * The wallet in question could be a migrated SafeHD BCH wallet, and the transaction we
 * are currently parsing is trying to spend change back to the v1 wallet base address.
 *
 * It does this since we don't allow new address creation for these wallets,
 * and instead return the base address from the v1 wallet when a new address is requested.
 * If this new address is requested for the purposes of spending change back to the wallet,
 * the change will go to the v1 wallet base address. This address *is* on the wallet,
 * but it will still cause an error to be thrown by verifyAddress, since the derivation path
 * used for this address is non-standard. (I have seen these addresses derived using paths m/0/0 and m/101,
 * whereas the v2 addresses are derived using path  m/0/0/${chain}/${index}).
 *
 * This means we need to check for this case explicitly in this catch block, and classify
 * these types of outputs as internal instead of external. Failing to do so would cause the
 * transaction's implicit external outputs (ie, outputs which go to addresses not specified in
 * the recipients array) to add up to more than the 150 basis point limit which we enforce on
 * pay-as-you-go outputs (which should be the only implicit external outputs on our transactions).
 *
 * The 150 basis point limit for implicit external sends is enforced in verifyTransaction,
 * which calls this function to get information on the total external/internal spend amounts
 * for a transaction. The idea here is to protect from the transaction being maliciously modified
 * to add more implicit external spends (eg, to an attacker-controlled wallet).
 *
 * See verifyTransaction for more information on how transaction prebuilds are verified before signing.
 *
 * @param wallet {Wallet} wallet which is making the transaction
 * @param currentAddress {string} address to check for externality relative to v1 wallet base address
 */
function isMigratedAddress(wallet, currentAddress) {
    if (_.isString(wallet.migratedFrom()) && wallet.migratedFrom() === currentAddress) {
        debug('found address %s which was migrated from v1 wallet, address is not external', currentAddress);
        return true;
    }
    return false;
}
/**
 * Check to see if an address is derived from the given custom change keys
 * @param {VerifyCustomChangeAddressOptions} params
 * @return {boolean}
 */
function verifyCustomChangeAddress(params) {
    var coin = params.coin, customChangeKeys = params.customChangeKeys, addressType = params.addressType, addressDetails = params.addressDetails, currentAddress = params.currentAddress;
    try {
        return coin.verifyAddress(_.extend({ addressType: addressType }, addressDetails, {
            keychains: customChangeKeys,
            address: currentAddress,
        }));
    }
    catch (e) {
        debug('failed to verify custom change address %s', currentAddress);
        return false;
    }
}
function handleVerifyAddressError(_a) {
    var e = _a.e, currentAddress = _a.currentAddress, wallet = _a.wallet, txParams = _a.txParams, customChangeKeys = _a.customChangeKeys, coin = _a.coin, addressDetails = _a.addressDetails, addressType = _a.addressType;
    // Todo: name server-side errors to avoid message-based checking [BG-5124]
    var walletAddressNotFound = e.message.includes('wallet address not found');
    var unexpectedAddress = e instanceof errors.UnexpectedAddressError;
    if (walletAddressNotFound || unexpectedAddress) {
        if (unexpectedAddress && !walletAddressNotFound) {
            // check to see if this is a migrated v1 bch address - it could be internal
            var isMigrated = isMigratedAddress(wallet, currentAddress);
            if (isMigrated) {
                return { external: false };
            }
            debug('Address %s was found on wallet but could not be reconstructed', currentAddress);
            // attempt to verify address using custom change address keys if the wallet has that feature enabled
            if (customChangeKeys &&
                verifyCustomChangeAddress({ coin: coin, addressDetails: addressDetails, addressType: addressType, currentAddress: currentAddress, customChangeKeys: customChangeKeys })) {
                // address is valid against the custom change keys. Mark address as not external
                // and request signature verification for the custom change keys
                debug('Address %s verified as derived from the custom change keys', currentAddress);
                return { external: false, needsCustomChangeKeySignatureVerification: true };
            }
        }
        // the address was found, but not on the wallet, which simply means it's external
        debug('Address %s presumed external', currentAddress);
        return { external: true };
    }
    else if (e instanceof errors.InvalidAddressDerivationPropertyError && currentAddress === txParams.changeAddress) {
        // expect to see this error when passing in a custom changeAddress with no chain or index
        return { external: false };
    }
    debug('Address %s verification failed', currentAddress);
    /**
     * It might be a completely invalid address or a bad validation attempt or something else completely, in
     * which case we do not proceed and rather rethrow the error, which is safer than assuming that the address
     * validation failed simply because it's external to the wallet.
     */
    throw e;
}
function fetchAddressDetails(_a) {
    var reqId = _a.reqId, disableNetworking = _a.disableNetworking, addressDetailsPrebuild = _a.addressDetailsPrebuild, addressDetailsVerification = _a.addressDetailsVerification, currentAddress = _a.currentAddress, wallet = _a.wallet;
    return __awaiter(this, void 0, void 0, function () {
        var addressDetails;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    addressDetails = _.extend({}, addressDetailsPrebuild, addressDetailsVerification);
                    debug('Locally available address %s details: %O', currentAddress, addressDetails);
                    if (!(_.isEmpty(addressDetails) && !disableNetworking)) return [3 /*break*/, 2];
                    return [4 /*yield*/, wallet.getAddress({ address: currentAddress, reqId: reqId })];
                case 1:
                    addressDetails = _b.sent();
                    debug('Downloaded address %s details: %O', currentAddress, addressDetails);
                    _b.label = 2;
                case 2: return [2 /*return*/, addressDetails];
            }
        });
    });
}
function parseOutput(_a) {
    var currentOutput = _a.currentOutput, coin = _a.coin, txPrebuild = _a.txPrebuild, verification = _a.verification, keychainArray = _a.keychainArray, wallet = _a.wallet, txParams = _a.txParams, customChange = _a.customChange, reqId = _a.reqId;
    return __awaiter(this, void 0, void 0, function () {
        var disableNetworking, currentAddress, addressDetailsPrebuild, addressDetailsVerification, currentAddressDetails, currentAddressType, addressDetails, e_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    disableNetworking = !!verification.disableNetworking;
                    currentAddress = currentOutput.address;
                    addressDetailsPrebuild = _.get(txPrebuild, "txInfo.walletAddressDetails." + currentAddress, {});
                    addressDetailsVerification = _.get(verification, "addresses." + currentAddress, {});
                    debug('Parsing address details for %s', currentAddress);
                    currentAddressDetails = undefined;
                    currentAddressType = undefined;
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, fetchAddressDetails({
                            reqId: reqId,
                            addressDetailsVerification: addressDetailsVerification,
                            addressDetailsPrebuild: addressDetailsPrebuild,
                            currentAddress: currentAddress,
                            disableNetworking: disableNetworking,
                            wallet: wallet,
                        })];
                case 2:
                    addressDetails = _b.sent();
                    // verify that the address is on the wallet. verifyAddress throws if
                    // it fails to correctly rederive the address, meaning it's external
                    currentAddressType = abstractUtxoCoin_1.AbstractUtxoCoin.inferAddressType(addressDetails) || undefined;
                    currentAddressDetails = addressDetails;
                    coin.verifyAddress(_.extend({ addressType: currentAddressType }, addressDetails, {
                        keychains: keychainArray,
                        address: currentAddress,
                    }));
                    debug('Address %s verification passed', currentAddress);
                    // verify address succeeded without throwing, so the address was
                    // correctly rederived from the wallet keychains, making it not external
                    return [2 /*return*/, _.extend({}, currentOutput, addressDetails, { external: false })];
                case 3:
                    e_1 = _b.sent();
                    debug('Address %s verification threw an error:', currentAddress, e_1);
                    return [2 /*return*/, _.extend({}, currentOutput, handleVerifyAddressError({
                            e: e_1,
                            coin: coin,
                            currentAddress: currentAddress,
                            wallet: wallet,
                            txParams: txParams,
                            customChangeKeys: customChange && customChange.keys,
                            addressDetails: currentAddressDetails,
                            addressType: currentAddressType,
                        }))];
                case 4: return [2 /*return*/];
            }
        });
    });
}
exports.parseOutput = parseOutput;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2VPdXRwdXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdjIvaW50ZXJuYWwvcGFyc2VPdXRwdXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOztHQUVHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUgsZ0NBQWtDO0FBQ2xDLDBCQUE0QjtBQUM1QixxQ0FBdUM7QUFFdkMsOERBQXdGO0FBS3hGLElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBRS9DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZCRztBQUNILFNBQVMsaUJBQWlCLENBQUMsTUFBYyxFQUFFLGNBQXNCO0lBQy9ELElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUMsSUFBSSxNQUFNLENBQUMsWUFBWSxFQUFFLEtBQUssY0FBYyxFQUFFO1FBQ2pGLEtBQUssQ0FBQyw2RUFBNkUsRUFBRSxjQUFjLENBQUMsQ0FBQztRQUNyRyxPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBVUQ7Ozs7R0FJRztBQUNILFNBQVMseUJBQXlCLENBQUMsTUFBd0M7SUFDakUsSUFBQSxrQkFBSSxFQUFFLDBDQUFnQixFQUFFLGdDQUFXLEVBQUUsc0NBQWMsRUFBRSxzQ0FBYyxDQUFZO0lBQ3ZGLElBQUk7UUFDRixPQUFPLElBQUksQ0FBQyxhQUFhLENBQ3ZCLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxXQUFXLGFBQUEsRUFBRSxFQUFFLGNBQWMsRUFBRTtZQUN4QyxTQUFTLEVBQUUsZ0JBQWdCO1lBQzNCLE9BQU8sRUFBRSxjQUFjO1NBQ3hCLENBQUMsQ0FDSCxDQUFDO0tBQ0g7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLEtBQUssQ0FBQywyQ0FBMkMsRUFBRSxjQUFjLENBQUMsQ0FBQztRQUNuRSxPQUFP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QyxFQUFFLEVBQUUsYUFBYSxFQUFFLGNBQWMsRUFBRSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFDOzs7b0JBRXhFLEtBQUssQ0FBQyx5Q0FBeUMsRUFBRSxjQUFjLEVBQUUsR0FBQyxDQUFDLENBQUM7b0JBQ3BFLHNCQUFPLENBQUMsQ0FBQyxNQUFNLENBQ2IsRUFBRSxFQUNGLGFBQWEsRUFDYix3QkFBd0IsQ0FBQzs0QkFDdkIsQ0FBQyxLQUFBOzRCQUNELElBQUksTUFBQTs0QkFDSixjQUFjLGdCQUFBOzRCQUNkLE1BQU0sUUFBQTs0QkFDTixRQUFRLFVBQUE7NEJBQ1IsZ0JBQWdCLEVBQUUsWUFBWSxJQUFJLFlBQVksQ0FBQyxJQUFJOzRCQUNuRCxjQUFjLEVBQUUscUJBQXFCOzRCQUNyQyxXQUFXLEVBQUUsa0JBQWtCO3lCQUNoQyxDQUFDLENBQ0gsRUFBQzs7Ozs7Q0FFTDtBQXJFRCxrQ0FxRUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5cbmltcG9ydCAqIGFzIGRlYnVnTGliIGZyb20gJ2RlYnVnJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIGVycm9ycyBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgQWRkcmVzc1ZlcmlmaWNhdGlvbkRhdGEsIFRyYW5zYWN0aW9uUHJlYnVpbGQsIFZlcmlmaWNhdGlvbk9wdGlvbnMgfSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBBYnN0cmFjdFV0eG9Db2luLCBPdXRwdXQsIFRyYW5zYWN0aW9uUGFyYW1zIH0gZnJvbSAnLi4vY29pbnMvYWJzdHJhY3RVdHhvQ29pbic7XG5pbXBvcnQgeyBLZXljaGFpbiB9IGZyb20gJy4uL2tleWNoYWlucyc7XG5pbXBvcnQgeyBXYWxsZXQgfSBmcm9tICcuLi93YWxsZXQnO1xuaW1wb3J0IHsgUmVxdWVzdFRyYWNlciB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdMaWIoJ2JpdGdvOnYyOnBhcnNlb3V0cHV0Jyk7XG5cbi8qKlxuICogQ2hlY2sgYW4gYWRkcmVzcyB3aGljaCBmYWlsZWQgaW5pdGlhbCB2YWxpZGF0aW9uIHRvIHNlZSBpZiBpdCdzIHRoZSBiYXNlIGFkZHJlc3Mgb2YgYSBtaWdyYXRlZCB2MSBiY2ggd2FsbGV0LlxuICpcbiAqIFRoZSB3YWxsZXQgaW4gcXVlc3Rpb24gY291bGQgYmUgYSBtaWdyYXRlZCBTYWZlSEQgQkNIIHdhbGxldCwgYW5kIHRoZSB0cmFuc2FjdGlvbiB3ZVxuICogYXJlIGN1cnJlbnRseSBwYXJzaW5nIGlzIHRyeWluZyB0byBzcGVuZCBjaGFuZ2UgYmFjayB0byB0aGUgdjEgd2FsbGV0IGJhc2UgYWRkcmVzcy5cbiAqXG4gKiBJdCBkb2VzIHRoaXMgc2luY2Ugd2UgZG9uJ3QgYWxsb3cgbmV3IGFkZHJlc3MgY3JlYXRpb24gZm9yIHRoZXNlIHdhbGxldHMsXG4gKiBhbmQgaW5zdGVhZCByZXR1cm4gdGhlIGJhc2UgYWRkcmVzcyBmcm9tIHRoZSB2MSB3YWxsZXQgd2hlbiBhIG5ldyBhZGRyZXNzIGlzIHJlcXVlc3RlZC5cbiAqIElmIHRoaXMgbmV3IGFkZHJlc3MgaXMgcmVxdWVzdGVkIGZvciB0aGUgcHVycG9zZXMgb2Ygc3BlbmRpbmcgY2hhbmdlIGJhY2sgdG8gdGhlIHdhbGxldCxcbiAqIHRoZSBjaGFuZ2Ugd2lsbCBnbyB0byB0aGUgdjEgd2FsbGV0IGJhc2UgYWRkcmVzcy4gVGhpcyBhZGRyZXNzICppcyogb24gdGhlIHdhbGxldCxcbiAqIGJ1dCBpdCB3aWxsIHN0aWxsIGNhdXNlIGFuIGVycm9yIHRvIGJlIHRocm93biBieSB2ZXJpZnlBZGRyZXNzLCBzaW5jZSB0aGUgZGVyaXZhdGlvbiBwYXRoXG4gKiB1c2VkIGZvciB0aGlzIGFkZHJlc3MgaXMgbm9uLXN0YW5kYXJkLiAoSSBoYXZlIHNlZW4gdGhlc2UgYWRkcmVzc2VzIGRlcml2ZWQgdXNpbmcgcGF0aHMgbS8wLzAgYW5kIG0vMTAxLFxuICogd2hlcmVhcyB0aGUgdjIgYWRkcmVzc2VzIGFyZSBkZXJpdmVkIHVzaW5nIHBhdGggIG0vMC8wLyR7Y2hhaW59LyR7aW5kZXh9KS5cbiAqXG4gKiBUaGlzIG1lYW5zIHdlIG5lZWQgdG8gY2hlY2sgZm9yIHRoaXMgY2FzZSBleHBsaWNpdGx5IGluIHRoaXMgY2F0Y2ggYmxvY2ssIGFuZCBjbGFzc2lmeVxuICogdGhlc2UgdHlwZXMgb2Ygb3V0cHV0cyBhcyBpbnRlcm5hbCBpbnN0ZWFkIG9mIGV4dGVybmFsLiBGYWlsaW5nIHRvIGRvIHNvIHdvdWxkIGNhdXNlIHRoZVxuICogdHJhbnNhY3Rpb24ncyBpbXBsaWNpdCBleHRlcm5hbCBvdXRwdXRzIChpZSwgb3V0cHV0cyB3aGljaCBnbyB0byBhZGRyZXNzZXMgbm90IHNwZWNpZmllZCBpblxuICogdGhlIHJlY2lwaWVudHMgYXJyYXkpIHRvIGFkZCB1cCB0byBtb3JlIHRoYW4gdGhlIDE1MCBiYXNpcyBwb2ludCBsaW1pdCB3aGljaCB3ZSBlbmZvcmNlIG9uXG4gKiBwYXktYXMteW91LWdvIG91dHB1dHMgKHdoaWNoIHNob3VsZCBiZSB0aGUgb25seSBpbXBsaWNpdCBleHRlcm5hbCBvdXRwdXRzIG9uIG91ciB0cmFuc2FjdGlvbnMpLlxuICpcbiAqIFRoZSAxNTAgYmFzaXMgcG9pbnQgbGltaXQgZm9yIGltcGxpY2l0IGV4dGVybmFsIHNlbmRzIGlzIGVuZm9yY2VkIGluIHZlcmlmeVRyYW5zYWN0aW9uLFxuICogd2hpY2ggY2FsbHMgdGhpcyBmdW5jdGlvbiB0byBnZXQgaW5mb3JtYXRpb24gb24gdGhlIHRvdGFsIGV4dGVybmFsL2ludGVybmFsIHNwZW5kIGFtb3VudHNcbiAqIGZvciBhIHRyYW5zYWN0aW9uLiBUaGUgaWRlYSBoZXJlIGlzIHRvIHByb3RlY3QgZnJvbSB0aGUgdHJhbnNhY3Rpb24gYmVpbmcgbWFsaWNpb3VzbHkgbW9kaWZpZWRcbiAqIHRvIGFkZCBtb3JlIGltcGxpY2l0IGV4dGVybmFsIHNwZW5kcyAoZWcsIHRvIGFuIGF0dGFja2VyLWNvbnRyb2xsZWQgd2FsbGV0KS5cbiAqXG4gKiBTZWUgdmVyaWZ5VHJhbnNhY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRyYW5zYWN0aW9uIHByZWJ1aWxkcyBhcmUgdmVyaWZpZWQgYmVmb3JlIHNpZ25pbmcuXG4gKlxuICogQHBhcmFtIHdhbGxldCB7V2FsbGV0fSB3YWxsZXQgd2hpY2ggaXMgbWFraW5nIHRoZSB0cmFuc2FjdGlvblxuICogQHBhcmFtIGN1cnJlbnRBZGRyZXNzIHtzdHJpbmd9IGFkZHJlc3MgdG8gY2hlY2sgZm9yIGV4dGVybmFsaXR5IHJlbGF0aXZlIHRvIHYxIHdhbGxldCBiYXNlIGFkZHJlc3NcbiAqL1xuZnVuY3Rpb24gaXNNaWdyYXRlZEFkZHJlc3Mod2FsbGV0OiBXYWxsZXQsIGN1cnJlbnRBZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKF8uaXNTdHJpbmcod2FsbGV0Lm1pZ3JhdGVkRnJvbSgpKSAmJiB3YWxsZXQubWlncmF0ZWRGcm9tKCkgPT09IGN1cnJlbnRBZGRyZXNzKSB7XG4gICAgZGVidWcoJ2ZvdW5kIGFkZHJlc3MgJXMgd2hpY2ggd2FzIG1pZ3JhdGVkIGZyb20gdjEgd2FsbGV0LCBhZGRyZXNzIGlzIG5vdCBleHRlcm5hbCcsIGN1cnJlbnRBZGRyZXNzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuaW50ZXJmYWNlIFZlcmlmeUN1c3RvbUNoYW5nZUFkZHJlc3NPcHRpb25zIHtcbiAgY29pbjogQWJzdHJhY3RVdHhvQ29pbjtcbiAgY3VzdG9tQ2hhbmdlS2V5czogSGFuZGxlVmVyaWZ5QWRkcmVzc0Vycm9yT3B0aW9uc1snY3VzdG9tQ2hhbmdlS2V5cyddO1xuICBhZGRyZXNzVHlwZTogSGFuZGxlVmVyaWZ5QWRkcmVzc0Vycm9yT3B0aW9uc1snYWRkcmVzc1R5cGUnXTtcbiAgYWRkcmVzc0RldGFpbHM6IEhhbmRsZVZlcmlmeUFkZHJlc3NFcnJvck9wdGlvbnNbJ2FkZHJlc3NEZXRhaWxzJ107XG4gIGN1cnJlbnRBZGRyZXNzOiBIYW5kbGVWZXJpZnlBZGRyZXNzRXJyb3JPcHRpb25zWydjdXJyZW50QWRkcmVzcyddO1xufVxuXG4vKipcbiAqIENoZWNrIHRvIHNlZSBpZiBhbiBhZGRyZXNzIGlzIGRlcml2ZWQgZnJvbSB0aGUgZ2l2ZW4gY3VzdG9tIGNoYW5nZSBrZXlzXG4gKiBAcGFyYW0ge1ZlcmlmeUN1c3RvbUNoYW5nZUFkZHJlc3NPcHRpb25zfSBwYXJhbXNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHZlcmlmeUN1c3RvbUNoYW5nZUFkZHJlc3MocGFyYW1zOiBWZXJpZnlDdXN0b21DaGFuZ2VBZGRyZXNzT3B0aW9ucyk6IGJvb2xlYW4ge1xuICBjb25zdCB7IGNvaW4sIGN1c3RvbUNoYW5nZUtleXMsIGFkZHJlc3NUeXBlLCBhZGRyZXNzRGV0YWlscywgY3VycmVudEFkZHJlc3MgfSA9IHBhcmFtcztcbiAgdHJ5IHtcbiAgICByZXR1cm4gY29pbi52ZXJpZnlBZGRyZXNzKFxuICAgICAgXy5leHRlbmQoeyBhZGRyZXNzVHlwZSB9LCBhZGRyZXNzRGV0YWlscywge1xuICAgICAgICBrZXljaGFpbnM6IGN1c3RvbUNoYW5nZUtleXMsXG4gICAgICAgIGFkZHJlc3M6IGN1cnJlbnRBZGRyZXNzLFxuICAgICAgfSlcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoJ2ZhaWxlZCB0byB2ZXJpZnkgY3VzdG9tIGNoYW5nZSBhZGRyZXNzICVzJywgY3VycmVudEFkZHJlc3MpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgSGFuZGxlVmVyaWZ5QWRkcmVzc0Vycm9yT3B0aW9ucyB7XG4gIGU6IEVycm9yO1xuICBjdXJyZW50QWRkcmVzczogc3RyaW5nO1xuICB3YWxsZXQ6IFdhbGxldDtcbiAgdHhQYXJhbXM6IFRyYW5zYWN0aW9uUGFyYW1zO1xuICBjdXN0b21DaGFuZ2VLZXlzPzogQ3VzdG9tQ2hhbmdlT3B0aW9uc1sna2V5cyddO1xuICBjb2luOiBBYnN0cmFjdFV0eG9Db2luO1xuICBhZGRyZXNzRGV0YWlscz86IGFueTtcbiAgYWRkcmVzc1R5cGU/OiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVZlcmlmeUFkZHJlc3NFcnJvcih7XG4gIGUsXG4gIGN1cnJlbnRBZGRyZXNzLFxuICB3YWxsZXQsXG4gIHR4UGFyYW1zLFxuICBjdXN0b21DaGFuZ2VLZXlzLFxuICBjb2luLFxuICBhZGRyZXNzRGV0YWlscyxcbiAgYWRkcmVzc1R5cGUsXG59OiBIYW5kbGVWZXJpZnlBZGRyZXNzRXJyb3JPcHRpb25zKTogeyBleHRlcm5hbDogYm9vbGVhbjsgbmVlZHNDdXN0b21DaGFuZ2VLZXlTaWduYXR1cmVWZXJpZmljYXRpb24/OiBib29sZWFuIH0ge1xuICAvLyBUb2RvOiBuYW1lIHNlcnZlci1zaWRlIGVycm9ycyB0byBhdm9pZCBtZXNzYWdlLWJhc2VkIGNoZWNraW5nIFtCRy01MTI0XVxuICBjb25zdCB3YWxsZXRBZGRyZXNzTm90Rm91bmQgPSBlLm1lc3NhZ2UuaW5jbHVkZXMoJ3dhbGxldCBhZGRyZXNzIG5vdCBmb3VuZCcpO1xuICBjb25zdCB1bmV4cGVjdGVkQWRkcmVzcyA9IGUgaW5zdGFuY2VvZiBlcnJvcnMuVW5leHBlY3RlZEFkZHJlc3NFcnJvcjtcbiAgaWYgKHdhbGxldEFkZHJlc3NOb3RGb3VuZCB8fCB1bmV4cGVjdGVkQWRkcmVzcykge1xuICAgIGlmICh1bmV4cGVjdGVkQWRkcmVzcyAmJiAhd2FsbGV0QWRkcmVzc05vdEZvdW5kKSB7XG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhpcyBpcyBhIG1pZ3JhdGVkIHYxIGJjaCBhZGRyZXNzIC0gaXQgY291bGQgYmUgaW50ZXJuYWxcbiAgICAgIGNvbnN0IGlzTWlncmF0ZWQgPSBpc01pZ3JhdGVkQWRkcmVzcyh3YWxsZXQsIGN1cnJlbnRBZGRyZXNzKTtcbiAgICAgIGlmIChpc01pZ3JhdGVkKSB7XG4gICAgICAgIHJldHVybiB7IGV4dGVybmFsOiBmYWxzZSB9O1xuICAgICAgfVxuXG4gICAgICBkZWJ1ZygnQWRkcmVzcyAlcyB3YXMgZm91bmQgb24gd2FsbGV0IGJ1dCBjb3VsZCBub3QgYmUgcmVjb25zdHJ1Y3RlZCcsIGN1cnJlbnRBZGRyZXNzKTtcblxuICAgICAgLy8gYXR0ZW1wdCB0byB2ZXJpZnkgYWRkcmVzcyB1c2luZyBjdXN0b20gY2hhbmdlIGFkZHJlc3Mga2V5cyBpZiB0aGUgd2FsbGV0IGhhcyB0aGF0IGZlYXR1cmUgZW5hYmxlZFxuICAgICAgaWYgKFxuICAgICAgICBjdXN0b21DaGFuZ2VLZXlzICYmXG4gICAgICAgIHZlcmlmeUN1c3RvbUNoYW5nZUFkZHJlc3MoeyBjb2luLCBhZGRyZXNzRGV0YWlscywgYWRkcmVzc1R5cGUsIGN1cnJlbnRBZGRyZXNzLCBjdXN0b21DaGFuZ2VLZXlzIH0pXG4gICAgICApIHtcbiAgICAgICAgLy8gYWRkcmVzcyBpcyB2YWxpZCBhZ2FpbnN0IHRoZSBjdXN0b20gY2hhbmdlIGtleXMuIE1hcmsgYWRkcmVzcyBhcyBub3QgZXh0ZXJuYWxcbiAgICAgICAgLy8gYW5kIHJlcXVlc3Qgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmb3IgdGhlIGN1c3RvbSBjaGFuZ2Uga2V5c1xuICAgICAgICBkZWJ1ZygnQWRkcmVzcyAlcyB2ZXJpZmllZCBhcyBkZXJpdmVkIGZyb20gdGhlIGN1c3RvbSBjaGFuZ2Uga2V5cycsIGN1cnJlbnRBZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHsgZXh0ZXJuYWw6IGZhbHNlLCBuZWVkc0N1c3RvbUNoYW5nZUtleVNpZ25hdHVyZVZlcmlmaWNhdGlvbjogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRoZSBhZGRyZXNzIHdhcyBmb3VuZCwgYnV0IG5vdCBvbiB0aGUgd2FsbGV0LCB3aGljaCBzaW1wbHkgbWVhbnMgaXQncyBleHRlcm5hbFxuICAgIGRlYnVnKCdBZGRyZXNzICVzIHByZXN1bWVkIGV4dGVybmFsJywgY3VycmVudEFkZHJlc3MpO1xuICAgIHJldHVybiB7IGV4dGVybmFsOiB0cnVlIH07XG4gIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIGVycm9ycy5JbnZhbGlkQWRkcmVzc0Rlcml2YXRpb25Qcm9wZXJ0eUVycm9yICYmIGN1cnJlbnRBZGRyZXNzID09PSB0eFBhcmFtcy5jaGFuZ2VBZGRyZXNzKSB7XG4gICAgLy8gZXhwZWN0IHRvIHNlZSB0aGlzIGVycm9yIHdoZW4gcGFzc2luZyBpbiBhIGN1c3RvbSBjaGFuZ2VBZGRyZXNzIHdpdGggbm8gY2hhaW4gb3IgaW5kZXhcbiAgICByZXR1cm4geyBleHRlcm5hbDogZmFsc2UgfTtcbiAgfVxuXG4gIGRlYnVnKCdBZGRyZXNzICVzIHZlcmlmaWNhdGlvbiBmYWlsZWQnLCBjdXJyZW50QWRkcmVzcyk7XG4gIC8qKlxuICAgKiBJdCBtaWdodCBiZSBhIGNvbXBsZXRlbHkgaW52YWxpZCBhZGRyZXNzIG9yIGEgYmFkIHZhbGlkYXRpb24gYXR0ZW1wdCBvciBzb21ldGhpbmcgZWxzZSBjb21wbGV0ZWx5LCBpblxuICAgKiB3aGljaCBjYXNlIHdlIGRvIG5vdCBwcm9jZWVkIGFuZCByYXRoZXIgcmV0aHJvdyB0aGUgZXJyb3IsIHdoaWNoIGlzIHNhZmVyIHRoYW4gYXNzdW1pbmcgdGhhdCB0aGUgYWRkcmVzc1xuICAgKiB2YWxpZGF0aW9uIGZhaWxlZCBzaW1wbHkgYmVjYXVzZSBpdCdzIGV4dGVybmFsIHRvIHRoZSB3YWxsZXQuXG4gICAqL1xuICB0aHJvdyBlO1xufVxuXG5pbnRlcmZhY2UgRmV0Y2hBZGRyZXNzRGV0YWlsc09wdGlvbnMge1xuICByZXFJZD86IFJlcXVlc3RUcmFjZXI7XG4gIGRpc2FibGVOZXR3b3JraW5nOiBib29sZWFuO1xuICBhZGRyZXNzRGV0YWlsc1ByZWJ1aWxkOiBhbnk7XG4gIGFkZHJlc3NEZXRhaWxzVmVyaWZpY2F0aW9uOiBhbnk7XG4gIGN1cnJlbnRBZGRyZXNzOiBzdHJpbmc7XG4gIHdhbGxldDogV2FsbGV0O1xufVxuXG5hc3luYyBmdW5jdGlvbiBmZXRjaEFkZHJlc3NEZXRhaWxzKHtcbiAgcmVxSWQsXG4gIGRpc2FibGVOZXR3b3JraW5nLFxuICBhZGRyZXNzRGV0YWlsc1ByZWJ1aWxkLFxuICBhZGRyZXNzRGV0YWlsc1ZlcmlmaWNhdGlvbixcbiAgY3VycmVudEFkZHJlc3MsXG4gIHdhbGxldCxcbn06IEZldGNoQWRkcmVzc0RldGFpbHNPcHRpb25zKSB7XG4gIGxldCBhZGRyZXNzRGV0YWlscyA9IF8uZXh0ZW5kKHt9LCBhZGRyZXNzRGV0YWlsc1ByZWJ1aWxkLCBhZGRyZXNzRGV0YWlsc1ZlcmlmaWNhdGlvbik7XG4gIGRlYnVnKCdMb2NhbGx5IGF2YWlsYWJsZSBhZGRyZXNzICVzIGRldGFpbHM6ICVPJywgY3VycmVudEFkZHJlc3MsIGFkZHJlc3NEZXRhaWxzKTtcbiAgaWYgKF8uaXNFbXB0eShhZGRyZXNzRGV0YWlscykgJiYgIWRpc2FibGVOZXR3b3JraW5nKSB7XG4gICAgYWRkcmVzc0RldGFpbHMgPSBhd2FpdCB3YWxsZXQuZ2V0QWRkcmVzcyh7IGFkZHJlc3M6IGN1cnJlbnRBZGRyZXNzLCByZXFJZCB9KTtcbiAgICBkZWJ1ZygnRG93bmxvYWRlZCBhZGRyZXNzICVzIGRldGFpbHM6ICVPJywgY3VycmVudEFkZHJlc3MsIGFkZHJlc3NEZXRhaWxzKTtcbiAgfVxuICByZXR1cm4gYWRkcmVzc0RldGFpbHM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3VzdG9tQ2hhbmdlT3B0aW9ucyB7XG4gIGtleXM6IFtLZXljaGFpbiwgS2V5Y2hhaW4sIEtleWNoYWluXTtcbiAgc2lnbmF0dXJlczogW3N0cmluZywgc3RyaW5nLCBzdHJpbmddO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnNlT3V0cHV0T3B0aW9ucyB7XG4gIGN1cnJlbnRPdXRwdXQ6IE91dHB1dDtcbiAgY29pbjogQWJzdHJhY3RVdHhvQ29pbjtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgdmVyaWZpY2F0aW9uOiBWZXJpZmljYXRpb25PcHRpb25zO1xuICBrZXljaGFpbkFycmF5OiBbS2V5Y2hhaW4sIEtleWNoYWluLCBLZXljaGFpbl07XG4gIHdhbGxldDogV2FsbGV0O1xuICB0eFBhcmFtczogVHJhbnNhY3Rpb25QYXJhbXM7XG4gIGN1c3RvbUNoYW5nZT86IEN1c3RvbUNoYW5nZU9wdGlvbnM7XG4gIHJlcUlkPzogUmVxdWVzdFRyYWNlcjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlT3V0cHV0KHtcbiAgY3VycmVudE91dHB1dCxcbiAgY29pbixcbiAgdHhQcmVidWlsZCxcbiAgdmVyaWZpY2F0aW9uLFxuICBrZXljaGFpbkFycmF5LFxuICB3YWxsZXQsXG4gIHR4UGFyYW1zLFxuICBjdXN0b21DaGFuZ2UsXG4gIHJlcUlkLFxufTogUGFyc2VPdXRwdXRPcHRpb25zKTogUHJvbWlzZTxPdXRwdXQ+IHtcbiAgY29uc3QgZGlzYWJsZU5ldHdvcmtpbmcgPSAhIXZlcmlmaWNhdGlvbi5kaXNhYmxlTmV0d29ya2luZztcbiAgY29uc3QgY3VycmVudEFkZHJlc3MgPSBjdXJyZW50T3V0cHV0LmFkZHJlc3M7XG5cbiAgLy8gYXR0ZW1wdCB0byBncmFiIHRoZSBhZGRyZXNzIGRldGFpbHMgZnJvbSBlaXRoZXIgdGhlIHByZWJ1aWx0IHR4LCBvciB0aGUgdmVyaWZpY2F0aW9uIHBhcmFtcy5cbiAgLy8gSWYgYm90aCBvZiB0aGVzZSBhcmUgZW1wdHksIHRoZW4gd2Ugd2lsbCB0cnkgdG8gZ2V0IHRoZSBhZGRyZXNzIGRldGFpbHMgZnJvbSBiaXRnbyBpbnN0ZWFkXG4gIGNvbnN0IGFkZHJlc3NEZXRhaWxzUHJlYnVpbGQgPSBfLmdldCh0eFByZWJ1aWxkLCBgdHhJbmZvLndhbGxldEFkZHJlc3NEZXRhaWxzLiR7Y3VycmVudEFkZHJlc3N9YCwge30pO1xuICBjb25zdCBhZGRyZXNzRGV0YWlsc1ZlcmlmaWNhdGlvbjogQWRkcmVzc1ZlcmlmaWNhdGlvbkRhdGEgPSBfLmdldCh2ZXJpZmljYXRpb24sIGBhZGRyZXNzZXMuJHtjdXJyZW50QWRkcmVzc31gLCB7fSk7XG4gIGRlYnVnKCdQYXJzaW5nIGFkZHJlc3MgZGV0YWlscyBmb3IgJXMnLCBjdXJyZW50QWRkcmVzcyk7XG4gIGxldCBjdXJyZW50QWRkcmVzc0RldGFpbHMgPSB1bmRlZmluZWQ7XG4gIGxldCBjdXJyZW50QWRkcmVzc1R5cGU6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgdHJ5IHtcbiAgICAvKipcbiAgICAgKiBUaGUgb25seSB3YXkgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYW4gYWRkcmVzcyBpcyBrbm93biBvbiB0aGUgd2FsbGV0IGlzIHRvIGluaXRpYXRlIGEgbmV0d29yayByZXF1ZXN0IGFuZFxuICAgICAqIGZldGNoIGl0LiBTaG91bGQgdGhlIHJlcXVlc3QgZmFpbCBhbmQgcmV0dXJuIGEgNDA0LCBpdCB3aWxsIHRocm93IGFuZCB0aGVyZWZvcmUgaGFzIHRvIGJlIGNhdWdodC4gRm9yIHRoYXRcbiAgICAgKiByZWFzb24sIGFkZHJlc3Mgd2FsbGV0IG93bmVyc2hpcCBkZXRlY3Rpb24gaXMgd3JhcHBlZCBpbiBhIHRyeS9jYXRjaC4gQWRkaXRpb25hbGx5LCBvbmNlIHRoZSBhZGRyZXNzXG4gICAgICogZGV0YWlscyBhcmUgZmV0Y2hlZCBvbiB0aGUgd2FsbGV0LCBhIGxvY2FsIGFkZHJlc3MgdmFsaWRhdGlvbiBpcyBydW4sIHdob3NlIGVycm9ycyBob3dldmVyIGFyZSBnZW5lcmF0ZWRcbiAgICAgKiBjbGllbnQtc2lkZSBhbmQgY2FuIHRoZXJlZm9yZSBiZSBhbmFseXplZCB3aXRoIG1vcmUgZ3JhbnVsYXJpdHkgYW5kIHR5cGUgY2hlY2tpbmcuXG4gICAgICovXG4gICAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSBhd2FpdCBmZXRjaEFkZHJlc3NEZXRhaWxzKHtcbiAgICAgIHJlcUlkLFxuICAgICAgYWRkcmVzc0RldGFpbHNWZXJpZmljYXRpb24sXG4gICAgICBhZGRyZXNzRGV0YWlsc1ByZWJ1aWxkLFxuICAgICAgY3VycmVudEFkZHJlc3MsXG4gICAgICBkaXNhYmxlTmV0d29ya2luZyxcbiAgICAgIHdhbGxldCxcbiAgICB9KTtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGUgYWRkcmVzcyBpcyBvbiB0aGUgd2FsbGV0LiB2ZXJpZnlBZGRyZXNzIHRocm93cyBpZlxuICAgIC8vIGl0IGZhaWxzIHRvIGNvcnJlY3RseSByZWRlcml2ZSB0aGUgYWRkcmVzcywgbWVhbmluZyBpdCdzIGV4dGVybmFsXG4gICAgY3VycmVudEFkZHJlc3NUeXBlID0gQWJzdHJhY3RVdHhvQ29pbi5pbmZlckFkZHJlc3NUeXBlKGFkZHJlc3NEZXRhaWxzKSB8fCB1bmRlZmluZWQ7XG4gICAgY3VycmVudEFkZHJlc3NEZXRhaWxzID0gYWRkcmVzc0RldGFpbHM7XG4gICAgY29pbi52ZXJpZnlBZGRyZXNzKFxuICAgICAgXy5leHRlbmQoeyBhZGRyZXNzVHlwZTogY3VycmVudEFkZHJlc3NUeXBlIH0sIGFkZHJlc3NEZXRhaWxzLCB7XG4gICAgICAgIGtleWNoYWluczoga2V5Y2hhaW5BcnJheSxcbiAgICAgICAgYWRkcmVzczogY3VycmVudEFkZHJlc3MsXG4gICAgICB9KVxuICAgICk7XG4gICAgZGVidWcoJ0FkZHJlc3MgJXMgdmVyaWZpY2F0aW9uIHBhc3NlZCcsIGN1cnJlbnRBZGRyZXNzKTtcblxuICAgIC8vIHZlcmlmeSBhZGRyZXNzIHN1Y2NlZWRlZCB3aXRob3V0IHRocm93aW5nLCBzbyB0aGUgYWRkcmVzcyB3YXNcbiAgICAvLyBjb3JyZWN0bHkgcmVkZXJpdmVkIGZyb20gdGhlIHdhbGxldCBrZXljaGFpbnMsIG1ha2luZyBpdCBub3QgZXh0ZXJuYWxcbiAgICByZXR1cm4gXy5leHRlbmQoe30sIGN1cnJlbnRPdXRwdXQsIGFkZHJlc3NEZXRhaWxzLCB7IGV4dGVybmFsOiBmYWxzZSB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKCdBZGRyZXNzICVzIHZlcmlmaWNhdGlvbiB0aHJldyBhbiBlcnJvcjonLCBjdXJyZW50QWRkcmVzcywgZSk7XG4gICAgcmV0dXJuIF8uZXh0ZW5kKFxuICAgICAge30sXG4gICAgICBjdXJyZW50T3V0cHV0LFxuICAgICAgaGFuZGxlVmVyaWZ5QWRkcmVzc0Vycm9yKHtcbiAgICAgICAgZSxcbiAgICAgICAgY29pbixcbiAgICAgICAgY3VycmVudEFkZHJlc3MsXG4gICAgICAgIHdhbGxldCxcbiAgICAgICAgdHhQYXJhbXMsXG4gICAgICAgIGN1c3RvbUNoYW5nZUtleXM6IGN1c3RvbUNoYW5nZSAmJiBjdXN0b21DaGFuZ2Uua2V5cyxcbiAgICAgICAgYWRkcmVzc0RldGFpbHM6IGN1cnJlbnRBZGRyZXNzRGV0YWlscyxcbiAgICAgICAgYWRkcmVzc1R5cGU6IGN1cnJlbnRBZGRyZXNzVHlwZSxcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIl19