"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_js_1 = require("bignumber.js");
var utxo_lib_1 = require("@bitgo/utxo-lib");
var Bluebird = require("bluebird");
var crypto_1 = require("crypto");
var _ = require("lodash");
var url = require("url");
var querystring = require("querystring");
var rippleAddressCodec = require("ripple-address-codec");
var rippleBinaryCodec = require("ripple-binary-codec");
var hashes_1 = require("ripple-lib/dist/npm/common/hashes");
var rippleKeypairs = require("ripple-keypairs");
var baseCoin_1 = require("../baseCoin");
var config = require("../../config");
var errors_1 = require("../../errors");
var ripple = require('../../ripple');
var sjcl = require('../../vendor/sjcl.min.js');
var co = Bluebird.coroutine;
var Xrp = /** @class */ (function (_super) {
    __extends(Xrp, _super);
    function Xrp(bitgo) {
        return _super.call(this, bitgo) || this;
    }
    Xrp.createInstance = function (bitgo) {
        return new Xrp(bitgo);
    };
    /**
     * Factor between the coin's base unit and its smallest subdivison
     */
    Xrp.prototype.getBaseFactor = function () {
        return 1e6;
    };
    /**
     * Identifier for the blockchain which supports this coin
     */
    Xrp.prototype.getChain = function () {
        return 'xrp';
    };
    /**
     * Identifier for the coin family
     */
    Xrp.prototype.getFamily = function () {
        return 'xrp';
    };
    /**
     * Complete human-readable name of this coin
     */
    Xrp.prototype.getFullName = function () {
        return 'Ripple';
    };
    /**
     * Parse an address string into address and destination tag
     */
    Xrp.prototype.getAddressDetails = function (address) {
        var destinationDetails = url.parse(address);
        var destinationAddress = destinationDetails.pathname;
        if (!destinationAddress || !rippleAddressCodec.isValidClassicAddress(destinationAddress)) {
            throw new errors_1.InvalidAddressError("destination address \"" + destinationAddress + "\" is not valid");
        }
        // there are no other properties like destination tags
        if (destinationDetails.pathname === address) {
            return {
                address: address,
                destinationTag: undefined,
            };
        }
        if (!destinationDetails.query) {
            throw new errors_1.InvalidAddressError('no query params present');
        }
        var queryDetails = querystring.parse(destinationDetails.query);
        if (!queryDetails.dt) {
            // if there are more properties, the query details need to contain the destination tag property.
            throw new errors_1.InvalidAddressError('destination tag missing');
        }
        if (Array.isArray(queryDetails.dt)) {
            // if queryDetails.dt is an array, that means dt was given multiple times, which is not valid
            throw new errors_1.InvalidAddressError("destination tag can appear at most once, but " + queryDetails.dt.length + " destination tags were found");
        }
        var parsedTag = parseInt(queryDetails.dt, 10);
        if (!Number.isSafeInteger(parsedTag)) {
            throw new errors_1.InvalidAddressError('invalid destination tag');
        }
        if (parsedTag > 0xFFFFFFFF || parsedTag < 0) {
            throw new errors_1.InvalidAddressError('destination tag out of range');
        }
        return {
            address: destinationAddress,
            destinationTag: parsedTag,
        };
    };
    /**
     * Construct a full, normalized address from an address and destination tag
     */
    Xrp.prototype.normalizeAddress = function (_a) {
        var address = _a.address, destinationTag = _a.destinationTag;
        if (!_.isString(address)) {
            throw new errors_1.InvalidAddressError('invalid address details');
        }
        if (_.isInteger(destinationTag)) {
            return address + "?dt=" + destinationTag;
        }
        return address;
    };
    /**
     * Evaluates whether an address string is valid for this coin
     * @param address
     */
    Xrp.prototype.isValidAddress = function (address) {
        try {
            var addressDetails = this.getAddressDetails(address);
            return address === this.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Xrp.prototype.isValidPub = function (pub) {
        try {
            utxo_lib_1.HDNode.fromBase58(pub);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Get fee info from server
     */
    Xrp.prototype.getFeeInfo = function (_, callback) {
        return this.bitgo.get(this.url('/public/feeinfo'))
            .result()
            .nodeify(callback);
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @param callback
     * @returns Bluebird<HalfSignedTransaction>
     */
    Xrp.prototype.signTransaction = function (_a, callback) {
        var txPrebuild = _a.txPrebuild, prv = _a.prv;
        return co(function () {
            var userKey, userPrivateKey, userAddress, rippleLib, halfSigned;
            return __generator(this, function (_a) {
                if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
                    if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                        throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
                    }
                    throw new Error('missing txPrebuild parameter');
                }
                if (_.isUndefined(prv) || !_.isString(prv)) {
                    if (!_.isUndefined(prv) && !_.isString(prv)) {
                        throw new Error("prv must be a string, got type " + typeof prv);
                    }
                    throw new Error('missing prv parameter to sign transaction');
                }
                userKey = utxo_lib_1.HDNode.fromBase58(prv).getKey();
                userPrivateKey = userKey.getPrivateKeyBuffer();
                userAddress = rippleKeypairs.deriveAddress(userKey.getPublicKeyBuffer().toString('hex'));
                rippleLib = ripple();
                halfSigned = rippleLib.signWithPrivateKey(txPrebuild.txHex, userPrivateKey.toString('hex'), { signAs: userAddress });
                return [2 /*return*/, { halfSigned: { txHex: halfSigned.signedTransaction } }];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Ripple requires additional parameters for wallet generation to be sent to the server. The additional parameters are
     * the root public key, which is the basis of the root address, two signed, and one half-signed initialization txs
     * @param walletParams
     * - rootPrivateKey: optional hex-encoded Ripple private key
     */
    Xrp.prototype.supplementGenerateWallet = function (walletParams) {
        return co(function () {
            var keyPair;
            return __generator(this, function (_a) {
                if (walletParams.rootPrivateKey) {
                    if (walletParams.rootPrivateKey.length !== 64) {
                        throw new Error('rootPrivateKey needs to be a hexadecimal private key string');
                    }
                }
                else {
                    keyPair = utxo_lib_1.ECPair.makeRandom();
                    walletParams.rootPrivateKey = keyPair.getPrivateKeyBuffer().toString('hex');
                }
                return [2 /*return*/, walletParams];
            });
        }).call(this);
    };
    /**
     * Explain/parse transaction
     * @param params
     * @param callback
     */
    Xrp.prototype.explainTransaction = function (params, callback) {
        if (params === void 0) { params = {}; }
        return co(function () {
            var transaction, txHex, id, address;
            return __generator(this, function (_a) {
                if (!params.txHex) {
                    throw new Error('missing required param txHex');
                }
                try {
                    transaction = rippleBinaryCodec.decode(params.txHex);
                    txHex = params.txHex;
                }
                catch (e) {
                    try {
                        transaction = JSON.parse(params.txHex);
                        txHex = rippleBinaryCodec.encode(transaction);
                    }
                    catch (e) {
                        throw new Error('txHex needs to be either hex or JSON string for XRP');
                    }
                }
                id = hashes_1.computeBinaryTransactionHash(txHex);
                address = transaction.Destination + ((transaction.DestinationTag >= 0) ? '?dt=' + transaction.DestinationTag : '');
                return [2 /*return*/, {
                        displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee'],
                        id: id,
                        changeOutputs: [],
                        outputAmount: transaction.Amount,
                        changeAmount: 0,
                        outputs: [
                            {
                                address: address,
                                amount: transaction.Amount
                            }
                        ],
                        fee: {
                            fee: transaction.Fee,
                            feeRate: null,
                            size: txHex.length / 2
                        }
                    }];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Verify that a transaction prebuild complies with the original intention
     * @param txParams params object passed to send
     * @param txPrebuild prebuild object returned by server
     * @param wallet
     * @param callback
     * @returns {boolean}
     */
    Xrp.prototype.verifyTransaction = function (_a, callback) {
        var txParams = _a.txParams, txPrebuild = _a.txPrebuild;
        var self = this;
        return co(function () {
            var explanation, output, expectedOutput, comparator;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.explainTransaction({
                            txHex: txPrebuild.txHex
                        })];
                    case 1:
                        explanation = _a.sent();
                        output = explanation.outputs.concat(explanation.changeOutputs)[0];
                        expectedOutput = txParams.recipients && txParams.recipients[0];
                        comparator = function (recipient1, recipient2) {
                            if (recipient1.address !== recipient2.address) {
                                return false;
                            }
                            var amount1 = new bignumber_js_1.BigNumber(recipient1.amount);
                            var amount2 = new bignumber_js_1.BigNumber(recipient2.amount);
                            return amount1.toFixed() === amount2.toFixed();
                        };
                        if (!comparator(output, expectedOutput)) {
                            throw new Error('transaction prebuild does not match expected output');
                        }
                        return [2 /*return*/, true];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Check if address is a valid XRP address, and then make sure the root addresses match.
     * This prevents attacks where an attack may switch out the new address for one of their own
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     */
    Xrp.prototype.verifyAddress = function (_a) {
        var address = _a.address, rootAddress = _a.rootAddress;
        if (!this.isValidAddress(address)) {
            throw new errors_1.InvalidAddressError("address verification failure: address \"" + address + "\" is not valid");
        }
        var addressDetails = this.getAddressDetails(address);
        var rootAddressDetails = this.getAddressDetails(rootAddress);
        if (addressDetails.address !== rootAddressDetails.address) {
            throw new errors_1.UnexpectedAddressError("address validation failure: " + addressDetails.address + " vs. " + rootAddressDetails.address);
        }
        return true;
    };
    /**
     * URL of a well-known, public facing (non-bitgo) rippled instance which can be used for recovery
     */
    Xrp.prototype.getRippledUrl = function () {
        return 'https://s1.ripple.com:51234';
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - rootAddress: root XRP wallet address to recover funds from
     * - userKey: [encrypted] xprv
     * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
     * - walletPassphrase: necessary if one of the xprvs is encrypted
     * - bitgoKey: xpub
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * @param callback
     */
    Xrp.prototype.recover = function (params, callback) {
        var self = this;
        return co(function explainTransaction() {
            var rippledUrl, isKrsRecovery, isUnsignedSweep, accountInfoParams, _a, keys, addressDetails, feeDetails, serverDetails, openLedgerFee, baseReserve, reserveDelta, currentLedger, sequenceId, balance, signerLists, accountFlags, userAddress, backupAddress, signerList, foundAddresses, signerEntries, _i, signerEntries_1, SignerEntry, weight, address, USER_KEY_SETTING_FLAG, MASTER_KEY_DEACTIVATION_FLAG, REQUIRE_DESTINATION_TAG_FLAG, reserve, recoverableBalance, rawDestination, destinationDetails, destinationAddress, destinationTag, queryDetails, parsedTag, transaction, txJSON, rippleLib, userKey, userSignature, signedTransaction, backupKey, backupSignature, transactionExplanation;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        rippledUrl = self.getRippledUrl();
                        isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
                        isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
                        accountInfoParams = {
                            method: 'account_info',
                            params: [{
                                    account: params.rootAddress,
                                    strict: true,
                                    ledger_index: 'current',
                                    queue: true,
                                    signer_lists: true,
                                }],
                        };
                        return [4 /*yield*/, Bluebird.props({
                                keys: self.initiateRecovery(params),
                                addressDetails: self.bitgo.post(rippledUrl).send(accountInfoParams),
                                feeDetails: self.bitgo.post(rippledUrl).send({ method: 'fee' }),
                                serverDetails: self.bitgo.post(rippledUrl).send({ method: 'server_info' }),
                            })];
                    case 1:
                        _a = _b.sent(), keys = _a.keys, addressDetails = _a.addressDetails, feeDetails = _a.feeDetails, serverDetails = _a.serverDetails;
                        openLedgerFee = new bignumber_js_1.BigNumber(feeDetails.body.result.drops.open_ledger_fee);
                        baseReserve = new bignumber_js_1.BigNumber(serverDetails.body.result.info.validated_ledger.reserve_base_xrp).times(self.getBaseFactor());
                        reserveDelta = new bignumber_js_1.BigNumber(serverDetails.body.result.info.validated_ledger.reserve_inc_xrp).times(self.getBaseFactor());
                        currentLedger = serverDetails.body.result.info.validated_ledger.seq;
                        sequenceId = addressDetails.body.result.account_data.Sequence;
                        balance = new bignumber_js_1.BigNumber(addressDetails.body.result.account_data.Balance);
                        signerLists = addressDetails.body.result.account_data.signer_lists;
                        accountFlags = addressDetails.body.result.account_data.Flags;
                        // make sure there is only one signer list set
                        if (signerLists.length !== 1) {
                            throw new Error('unexpected set of signer lists');
                        }
                        userAddress = rippleKeypairs.deriveAddress(keys[0].getPublicKeyBuffer().toString('hex'));
                        backupAddress = rippleKeypairs.deriveAddress(keys[1].getPublicKeyBuffer().toString('hex'));
                        signerList = signerLists[0];
                        if (signerList.SignerQuorum !== 2) {
                            throw new Error('invalid minimum signature count');
                        }
                        foundAddresses = {};
                        signerEntries = signerList.SignerEntries;
                        if (signerEntries.length !== 3) {
                            throw new Error('invalid signer list length');
                        }
                        for (_i = 0, signerEntries_1 = signerEntries; _i < signerEntries_1.length; _i++) {
                            SignerEntry = signerEntries_1[_i].SignerEntry;
                            weight = SignerEntry.SignerWeight;
                            address = SignerEntry.Account;
                            if (weight !== 1) {
                                throw new Error('invalid signer weight');
                            }
                            // if it's a dupe of an address we already know, block
                            if (foundAddresses[address] >= 1) {
                                throw new Error('duplicate signer address');
                            }
                            foundAddresses[address] = (foundAddresses[address] || 0) + 1;
                        }
                        if (foundAddresses[userAddress] !== 1) {
                            throw new Error('unexpected incidence frequency of user signer address');
                        }
                        if (foundAddresses[backupAddress] !== 1) {
                            throw new Error('unexpected incidence frequency of user signer address');
                        }
                        USER_KEY_SETTING_FLAG = 65536;
                        MASTER_KEY_DEACTIVATION_FLAG = 1048576;
                        REQUIRE_DESTINATION_TAG_FLAG = 131072;
                        if ((accountFlags & USER_KEY_SETTING_FLAG) !== 0) {
                            throw new Error('a custom user key has been set');
                        }
                        if ((accountFlags & MASTER_KEY_DEACTIVATION_FLAG) !== MASTER_KEY_DEACTIVATION_FLAG) {
                            throw new Error('the master key has not been deactivated');
                        }
                        if ((accountFlags & REQUIRE_DESTINATION_TAG_FLAG) !== REQUIRE_DESTINATION_TAG_FLAG) {
                            throw new Error('the destination flag requirement has not been activated');
                        }
                        reserve = baseReserve.plus(reserveDelta.times(5));
                        recoverableBalance = balance.minus(reserve);
                        rawDestination = params.recoveryDestination;
                        destinationDetails = url.parse(rawDestination);
                        destinationAddress = destinationDetails.pathname;
                        if (destinationDetails.query) {
                            queryDetails = querystring.parse(destinationDetails.query);
                            if (Array.isArray(queryDetails.dt)) {
                                // if queryDetails.dt is an array, that means dt was given multiple times, which is not valid
                                throw new errors_1.InvalidAddressError("destination tag can appear at most once, but " + queryDetails.dt.length + " destination tags were found");
                            }
                            parsedTag = parseInt(queryDetails.dt, 10);
                            if (Number.isInteger(parsedTag)) {
                                destinationTag = parsedTag;
                            }
                        }
                        transaction = {
                            TransactionType: 'Payment',
                            Account: params.rootAddress,
                            Destination: destinationAddress,
                            DestinationTag: destinationTag,
                            Amount: recoverableBalance.toFixed(0),
                            Flags: 2147483648,
                            LastLedgerSequence: currentLedger + 1000000,
                            Fee: openLedgerFee.times(3).toFixed(0),
                            Sequence: sequenceId,
                        };
                        txJSON = JSON.stringify(transaction);
                        if (isUnsignedSweep) {
                            return [2 /*return*/, txJSON];
                        }
                        rippleLib = ripple();
                        userKey = keys[0].getKey().getPrivateKeyBuffer().toString('hex');
                        userSignature = rippleLib.signWithPrivateKey(txJSON, userKey, { signAs: userAddress });
                        if (isKrsRecovery) {
                            signedTransaction = userSignature;
                        }
                        else {
                            backupKey = keys[1].getKey().getPrivateKeyBuffer().toString('hex');
                            backupSignature = rippleLib.signWithPrivateKey(txJSON, backupKey, { signAs: backupAddress });
                            signedTransaction = rippleLib.combine([userSignature.signedTransaction, backupSignature.signedTransaction]);
                        }
                        return [4 /*yield*/, self.explainTransaction({
                                txHex: signedTransaction.signedTransaction,
                            })];
                    case 2:
                        transactionExplanation = _b.sent();
                        transactionExplanation.txHex = signedTransaction.signedTransaction;
                        if (isKrsRecovery) {
                            transactionExplanation.backupKey = params.backupKey;
                            transactionExplanation.coin = self.getChain();
                        }
                        return [2 /*return*/, transactionExplanation];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Prepare and validate all keychains from the keycard for recovery
     */
    Xrp.prototype.initiateRecovery = function (params) {
        var self = this;
        return co(function initiateRecovery() {
            var keys, userKey, backupKey, bitgoXpub, destinationAddress, passphrase, isKrsRecovery, isUnsignedSweep, validatePassphraseKey, key, backupHDNode, bitgoHDNode;
            return __generator(this, function (_a) {
                keys = [];
                userKey = params.userKey;
                backupKey = params.backupKey;
                bitgoXpub = params.bitgoKey;
                destinationAddress = params.recoveryDestination;
                passphrase = params.walletPassphrase;
                isKrsRecovery = backupKey.startsWith('xpub') && !userKey.startsWith('xpub');
                isUnsignedSweep = backupKey.startsWith('xpub') && userKey.startsWith('xpub');
                if (isKrsRecovery && params.krsProvider && _.isUndefined(config.krsProviders[params.krsProvider])) {
                    throw new Error('unknown key recovery service provider');
                }
                validatePassphraseKey = function (userKey, passphrase) {
                    try {
                        if (!userKey.startsWith('xprv') && !isUnsignedSweep) {
                            userKey = sjcl.decrypt(passphrase, userKey);
                        }
                        return utxo_lib_1.HDNode.fromBase58(userKey);
                    }
                    catch (e) {
                        throw new Error('Failed to decrypt user key with passcode - try again!');
                    }
                };
                key = validatePassphraseKey(userKey, passphrase);
                keys.push(key);
                // Validate the backup key
                try {
                    if (!backupKey.startsWith('xprv') && !isKrsRecovery && !isUnsignedSweep) {
                        backupKey = sjcl.decrypt(passphrase, backupKey);
                    }
                    backupHDNode = utxo_lib_1.HDNode.fromBase58(backupKey);
                    keys.push(backupHDNode);
                }
                catch (e) {
                    throw new Error('Failed to decrypt backup key with passcode - try again!');
                }
                try {
                    bitgoHDNode = utxo_lib_1.HDNode.fromBase58(bitgoXpub);
                    keys.push(bitgoHDNode);
                }
                catch (e) {
                    if (self.getFamily() !== 'xrp') {
                        // in XRP recoveries, the BitGo xpub is optional
                        throw new Error('Failed to parse bitgo xpub!');
                    }
                }
                // Validate the destination address
                if (!self.isValidAddress(destinationAddress)) {
                    throw new Error('Invalid destination address!');
                }
                return [2 /*return*/, keys];
            });
        }).call(this);
    };
    /**
     * Generate a new keypair for this coin.
     * @param seed Seed from which the new keypair should be generated, otherwise a random seed is used
     */
    Xrp.prototype.generateKeyPair = function (seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto_1.randomBytes(512 / 8);
        }
        var extendedKey = utxo_lib_1.HDNode.fromSeedBuffer(seed);
        var xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58(),
        };
    };
    Xrp.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    return Xrp;
}(baseCoin_1.BaseCoin));
exports.Xrp = Xrp;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieHJwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3hycC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw2Q0FBeUM7QUFDekMsNENBQWlEO0FBQ2pELG1DQUFxQztBQUNyQyxpQ0FBcUM7QUFDckMsMEJBQTRCO0FBQzVCLHlCQUEyQjtBQUMzQix5Q0FBMkM7QUFHM0MseURBQTJEO0FBQzNELHVEQUF5RDtBQUN6RCw0REFBaUY7QUFDakYsZ0RBQWtEO0FBRWxELHdDQVVxQjtBQUNyQixxQ0FBdUM7QUFFdkMsdUNBQTJFO0FBRTNFLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN2QyxJQUFNLElBQUksR0FBRyxPQUFPLENBQUMsMEJBQTBCLENBQUMsQ0FBQztBQUVqRCxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBeUQ5QjtJQUF5Qix1QkFBUTtJQUMvQixhQUFzQixLQUFZO2VBQ2hDLGtCQUFNLEtBQUssQ0FBQztJQUNkLENBQUM7SUFFTSxrQkFBYyxHQUFyQixVQUFzQixLQUFZO1FBQ2hDLE9BQU8sSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksMkJBQWEsR0FBcEI7UUFDRSxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRDs7T0FFRztJQUNJLHNCQUFRLEdBQWY7UUFDRSxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7T0FFRztJQUNJLHVCQUFTLEdBQWhCO1FBQ0UsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSSx5QkFBVyxHQUFsQjtRQUNFLE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7T0FFRztJQUNJLCtCQUFpQixHQUF4QixVQUF5QixPQUFlO1FBQ3RDLElB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QUU7b0JBQzVDLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQztpQkFDakQ7Z0JBRUQsc0JBQU8sSUFBSSxFQUFDOztTQUNiLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7T0FHRztJQUNJLDZCQUFlLEdBQXRCLFVBQXVCLElBQWE7UUFDbEMsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNULDBFQUEwRTtZQUMxRSwwRUFBMEU7WUFDMUUsa0VBQWtFO1lBQ2xFLElBQUksR0FBRyxvQkFBVyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUM3QjtRQUNELElBQU0sV0FBVyxHQUFHLGlCQUFNLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hELElBQU0sSUFBSSxHQUFHLFdBQVcsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUMvQyxPQUFPO1lBQ0wsR0FBRyxFQUFFLElBQUk7WUFDVCxHQUFHLEVBQUUsV0FBVyxDQUFDLFFBQVEsRUFBRTtTQUM1QixDQUFDO0lBQ0osQ0FBQztJQUVELDhCQUFnQixHQUFoQixVQUFpQixNQUErQixFQUFFLFFBQTBDO1FBQzFGLE9BQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUNILFVBQUM7QUFBRCxDQUFDLEFBdGlCRCxDQUF5QixtQkFBUSxHQXNpQmhDO0FBdGlCWSxrQkFBRyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBIRE5vZGUsIEVDUGFpciB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyB1cmwgZnJvbSAndXJsJztcbmltcG9ydCAqIGFzIHF1ZXJ5c3RyaW5nIGZyb20gJ3F1ZXJ5c3RyaW5nJztcbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vYml0Z28nO1xuXG5pbXBvcnQgKiBhcyByaXBwbGVBZGRyZXNzQ29kZWMgZnJvbSAncmlwcGxlLWFkZHJlc3MtY29kZWMnO1xuaW1wb3J0ICogYXMgcmlwcGxlQmluYXJ5Q29kZWMgZnJvbSAncmlwcGxlLWJpbmFyeS1jb2RlYyc7XG5pbXBvcnQgeyBjb21wdXRlQmluYXJ5VHJhbnNhY3Rpb25IYXNoIH0gZnJvbSAncmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vaGFzaGVzJztcbmltcG9ydCAqIGFzIHJpcHBsZUtleXBhaXJzIGZyb20gJ3JpcHBsZS1rZXlwYWlycyc7XG5cbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBLZXlQYWlyLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyBhcyBCYXNlVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBJbml0aWF0ZVJlY292ZXJ5T3B0aW9ucyBhcyBCYXNlSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMsXG59IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCAqIGFzIGNvbmZpZyBmcm9tICcuLi8uLi9jb25maWcnO1xuaW1wb3J0IHsgTm9kZUNhbGxiYWNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgSW52YWxpZEFkZHJlc3NFcnJvciwgVW5leHBlY3RlZEFkZHJlc3NFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5cbmNvbnN0IHJpcHBsZSA9IHJlcXVpcmUoJy4uLy4uL3JpcHBsZScpO1xuY29uc3Qgc2pjbCA9IHJlcXVpcmUoJy4uLy4uL3ZlbmRvci9zamNsLm1pbi5qcycpO1xuXG5jb25zdCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcblxuaW50ZXJmYWNlIEFkZHJlc3Mge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGRlc3RpbmF0aW9uVGFnPzogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgRmVlSW5mbyB7XG4gIGRhdGU6IHN0cmluZztcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIGJhc2VSZXNlcnZlOiBzdHJpbmc7XG4gIGJhc2VGZWU6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwcnY6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEhleD86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFZlcmlmeUFkZHJlc3NPcHRpb25zIGV4dGVuZHMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zIHtcbiAgcm9vdEFkZHJlc3M6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlY292ZXJ5SW5mbyBleHRlbmRzIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24ge1xuICB0eEhleDogc3RyaW5nO1xuICBiYWNrdXBLZXk/OiBzdHJpbmc7XG4gIGNvaW4/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMgZXh0ZW5kcyBCYXNlSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMge1xuICBrcnNQcm92aWRlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyeU9wdGlvbnMge1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgdXNlcktleTogc3RyaW5nO1xuICByb290QWRkcmVzczogc3RyaW5nO1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7XG4gIGJpdGdvS2V5Pzogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlOiBzdHJpbmc7XG4gIGtyc1Byb3ZpZGVyPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgSGFsZlNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgaGFsZlNpZ25lZDoge1xuICAgIHR4SGV4OiBzdHJpbmdcbiAgfVxufVxuXG5pbnRlcmZhY2UgU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyB7XG4gIHJvb3RQcml2YXRlS2V5Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgWHJwIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoYml0Z286IEJpdEdvKSB7XG4gICAgc3VwZXIoYml0Z28pO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHbyk6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IFhycChiaXRnbyk7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yIGJldHdlZW4gdGhlIGNvaW4ncyBiYXNlIHVuaXQgYW5kIGl0cyBzbWFsbGVzdCBzdWJkaXZpc29uXG4gICAqL1xuICBwdWJsaWMgZ2V0QmFzZUZhY3RvcigpOiBudW1iZXIge1xuICAgIHJldHVybiAxZTY7XG4gIH1cblxuICAvKipcbiAgICogSWRlbnRpZmllciBmb3IgdGhlIGJsb2NrY2hhaW4gd2hpY2ggc3VwcG9ydHMgdGhpcyBjb2luXG4gICAqL1xuICBwdWJsaWMgZ2V0Q2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3hycCc7XG4gIH1cblxuICAvKipcbiAgICogSWRlbnRpZmllciBmb3IgdGhlIGNvaW4gZmFtaWx5XG4gICAqL1xuICBwdWJsaWMgZ2V0RmFtaWx5KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICd4cnAnO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhpcyBjb2luXG4gICAqL1xuICBwdWJsaWMgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ1JpcHBsZSc7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYW4gYWRkcmVzcyBzdHJpbmcgaW50byBhZGRyZXNzIGFuZCBkZXN0aW5hdGlvbiB0YWdcbiAgICovXG4gIHB1YmxpYyBnZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzOiBzdHJpbmcpOiBBZGRyZXNzIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkRldGFpbHMgPSB1cmwucGFyc2UoYWRkcmVzcyk7XG4gICAgY29uc3QgZGVzdGluYXRpb25BZGRyZXNzID0gZGVzdGluYXRpb25EZXRhaWxzLnBhdGhuYW1lO1xuICAgIGlmICghZGVzdGluYXRpb25BZGRyZXNzIHx8ICFyaXBwbGVBZGRyZXNzQ29kZWMuaXNWYWxpZENsYXNzaWNBZGRyZXNzKGRlc3RpbmF0aW9uQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBkZXN0aW5hdGlvbiBhZGRyZXNzIFwiJHtkZXN0aW5hdGlvbkFkZHJlc3N9XCIgaXMgbm90IHZhbGlkYCk7XG4gICAgfVxuICAgIC8vIHRoZXJlIGFyZSBubyBvdGhlciBwcm9wZXJ0aWVzIGxpa2UgZGVzdGluYXRpb24gdGFnc1xuICAgIGlmIChkZXN0aW5hdGlvbkRldGFpbHMucGF0aG5hbWUgPT09IGFkZHJlc3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgIGRlc3RpbmF0aW9uVGFnOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcignbm8gcXVlcnkgcGFyYW1zIHByZXNlbnQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyeURldGFpbHMgPSBxdWVyeXN0cmluZy5wYXJzZShkZXN0aW5hdGlvbkRldGFpbHMucXVlcnkpO1xuICAgIGlmICghcXVlcnlEZXRhaWxzLmR0KSB7XG4gICAgICAvLyBpZiB0aGVyZSBhcmUgbW9yZSBwcm9wZXJ0aWVzLCB0aGUgcXVlcnkgZGV0YWlscyBuZWVkIHRvIGNvbnRhaW4gdGhlIGRlc3RpbmF0aW9uIHRhZyBwcm9wZXJ0eS5cbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKCdkZXN0aW5hdGlvbiB0YWcgbWlzc2luZycpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5RGV0YWlscy5kdCkpIHtcbiAgICAgIC8vIGlmIHF1ZXJ5RGV0YWlscy5kdCBpcyBhbiBhcnJheSwgdGhhdCBtZWFucyBkdCB3YXMgZ2l2ZW4gbXVsdGlwbGUgdGltZXMsIHdoaWNoIGlzIG5vdCB2YWxpZFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGRlc3RpbmF0aW9uIHRhZyBjYW4gYXBwZWFyIGF0IG1vc3Qgb25jZSwgYnV0ICR7cXVlcnlEZXRhaWxzLmR0Lmxlbmd0aH0gZGVzdGluYXRpb24gdGFncyB3ZXJlIGZvdW5kYCk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkVGFnID0gcGFyc2VJbnQocXVlcnlEZXRhaWxzLmR0LCAxMCk7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihwYXJzZWRUYWcpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcignaW52YWxpZCBkZXN0aW5hdGlvbiB0YWcnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyc2VkVGFnID4gMHhGRkZGRkZGRiB8fCBwYXJzZWRUYWcgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcignZGVzdGluYXRpb24gdGFnIG91dCBvZiByYW5nZScpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhZGRyZXNzOiBkZXN0aW5hdGlvbkFkZHJlc3MsXG4gICAgICBkZXN0aW5hdGlvblRhZzogcGFyc2VkVGFnLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgZnVsbCwgbm9ybWFsaXplZCBhZGRyZXNzIGZyb20gYW4gYWRkcmVzcyBhbmQgZGVzdGluYXRpb24gdGFnXG4gICAqL1xuICBwdWJsaWMgbm9ybWFsaXplQWRkcmVzcyh7IGFkZHJlc3MsIGRlc3RpbmF0aW9uVGFnIH06IEFkZHJlc3MpOiBzdHJpbmcge1xuICAgIGlmICghXy5pc1N0cmluZyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoJ2ludmFsaWQgYWRkcmVzcyBkZXRhaWxzJyk7XG4gICAgfVxuICAgIGlmIChfLmlzSW50ZWdlcihkZXN0aW5hdGlvblRhZykpIHtcbiAgICAgIHJldHVybiBgJHthZGRyZXNzfT9kdD0ke2Rlc3RpbmF0aW9uVGFnfWA7XG4gICAgfVxuICAgIHJldHVybiBhZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlcyB3aGV0aGVyIGFuIGFkZHJlc3Mgc3RyaW5nIGlzIHZhbGlkIGZvciB0aGlzIGNvaW5cbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICovXG4gIHB1YmxpYyBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3MpO1xuICAgICAgcmV0dXJuIGFkZHJlc3MgPT09IHRoaXMubm9ybWFsaXplQWRkcmVzcyhhZGRyZXNzRGV0YWlscyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwdWIgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIHB1YmxpYyBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIEhETm9kZS5mcm9tQmFzZTU4KHB1Yik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBmZWUgaW5mbyBmcm9tIHNlcnZlclxuICAgKi9cbiAgcHVibGljIGdldEZlZUluZm8oXz8sIGNhbGxiYWNrPyk6IFByb21pc2U8RmVlSW5mbz4ge1xuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3B1YmxpYy9mZWVpbmZvJykpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSB0eFByZWJ1aWxkXG4gICAqIC0gcHJ2XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyBCbHVlYmlyZDxIYWxmU2lnbmVkVHJhbnNhY3Rpb24+XG4gICAqL1xuICBwdWJsaWMgc2lnblRyYW5zYWN0aW9uKHsgdHhQcmVidWlsZCwgcHJ2IH06IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPEhhbGZTaWduZWRUcmFuc2FjdGlvbj4pOiBCbHVlYmlyZDxIYWxmU2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICByZXR1cm4gY288SGFsZlNpZ25lZFRyYW5zYWN0aW9uPihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQodHhQcmVidWlsZCkgfHwgIV8uaXNPYmplY3QodHhQcmVidWlsZCkpIHtcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHR4UHJlYnVpbGQpICYmICFfLmlzT2JqZWN0KHR4UHJlYnVpbGQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eFByZWJ1aWxkIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgdHlwZSAke3R5cGVvZiB0eFByZWJ1aWxkfWApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB0eFByZWJ1aWxkIHBhcmFtZXRlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwcnYpIHx8ICFfLmlzU3RyaW5nKHBydikpIHtcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBydikgJiYgIV8uaXNTdHJpbmcocHJ2KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJ2IG11c3QgYmUgYSBzdHJpbmcsIGdvdCB0eXBlICR7dHlwZW9mIHBydn1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHJ2IHBhcmFtZXRlciB0byBzaWduIHRyYW5zYWN0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVzZXJLZXkgPSBIRE5vZGUuZnJvbUJhc2U1OChwcnYpLmdldEtleSgpO1xuICAgICAgY29uc3QgdXNlclByaXZhdGVLZXk6IEJ1ZmZlciA9IHVzZXJLZXkuZ2V0UHJpdmF0ZUtleUJ1ZmZlcigpO1xuICAgICAgY29uc3QgdXNlckFkZHJlc3MgPSByaXBwbGVLZXlwYWlycy5kZXJpdmVBZGRyZXNzKHVzZXJLZXkuZ2V0UHVibGljS2V5QnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpKTtcblxuICAgICAgY29uc3QgcmlwcGxlTGliID0gcmlwcGxlKCk7XG4gICAgICBjb25zdCBoYWxmU2lnbmVkID0gcmlwcGxlTGliLnNpZ25XaXRoUHJpdmF0ZUtleSh0eFByZWJ1aWxkLnR4SGV4LCB1c2VyUHJpdmF0ZUtleS50b1N0cmluZygnaGV4JyksIHsgc2lnbkFzOiB1c2VyQWRkcmVzcyB9KTtcbiAgICAgIHJldHVybiB7IGhhbGZTaWduZWQ6IHsgdHhIZXg6IGhhbGZTaWduZWQuc2lnbmVkVHJhbnNhY3Rpb24gfSB9O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJpcHBsZSByZXF1aXJlcyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHdhbGxldCBnZW5lcmF0aW9uIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci4gVGhlIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBhcmVcbiAgICogdGhlIHJvb3QgcHVibGljIGtleSwgd2hpY2ggaXMgdGhlIGJhc2lzIG9mIHRoZSByb290IGFkZHJlc3MsIHR3byBzaWduZWQsIGFuZCBvbmUgaGFsZi1zaWduZWQgaW5pdGlhbGl6YXRpb24gdHhzXG4gICAqIEBwYXJhbSB3YWxsZXRQYXJhbXNcbiAgICogLSByb290UHJpdmF0ZUtleTogb3B0aW9uYWwgaGV4LWVuY29kZWQgUmlwcGxlIHByaXZhdGUga2V5XG4gICAqL1xuICBzdXBwbGVtZW50R2VuZXJhdGVXYWxsZXQod2FsbGV0UGFyYW1zOiBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zKTogQmx1ZWJpcmQ8U3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucz4ge1xuICAgIHJldHVybiBjbzxTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zPihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleSkge1xuICAgICAgICBpZiAod2FsbGV0UGFyYW1zLnJvb3RQcml2YXRlS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jvb3RQcml2YXRlS2V5IG5lZWRzIHRvIGJlIGEgaGV4YWRlY2ltYWwgcHJpdmF0ZSBrZXkgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGtleVBhaXIgPSBFQ1BhaXIubWFrZVJhbmRvbSgpO1xuICAgICAgICB3YWxsZXRQYXJhbXMucm9vdFByaXZhdGVLZXkgPSBrZXlQYWlyLmdldFByaXZhdGVLZXlCdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2FsbGV0UGFyYW1zO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGFpbi9wYXJzZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZXhwbGFpblRyYW5zYWN0aW9uKHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPik6IEJsdWViaXJkPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+IHtcbiAgICByZXR1cm4gY288VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGlmICghcGFyYW1zLnR4SGV4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwYXJhbSB0eEhleCcpO1xuICAgICAgfVxuICAgICAgbGV0IHRyYW5zYWN0aW9uO1xuICAgICAgbGV0IHR4SGV4O1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHJhbnNhY3Rpb24gPSByaXBwbGVCaW5hcnlDb2RlYy5kZWNvZGUocGFyYW1zLnR4SGV4KTtcbiAgICAgICAgdHhIZXggPSBwYXJhbXMudHhIZXg7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSBKU09OLnBhcnNlKHBhcmFtcy50eEhleCk7XG4gICAgICAgICAgdHhIZXggPSByaXBwbGVCaW5hcnlDb2RlYy5lbmNvZGUodHJhbnNhY3Rpb24pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eEhleCBuZWVkcyB0byBiZSBlaXRoZXIgaGV4IG9yIEpTT04gc3RyaW5nIGZvciBYUlAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaWQgPSBjb21wdXRlQmluYXJ5VHJhbnNhY3Rpb25IYXNoKHR4SGV4KTtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSB0cmFuc2FjdGlvbi5EZXN0aW5hdGlvbiArICgodHJhbnNhY3Rpb24uRGVzdGluYXRpb25UYWcgPj0gMCkgPyAnP2R0PScgKyB0cmFuc2FjdGlvbi5EZXN0aW5hdGlvblRhZyA6ICcnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXlPcmRlcjogWydpZCcsICdvdXRwdXRBbW91bnQnLCAnY2hhbmdlQW1vdW50JywgJ291dHB1dHMnLCAnY2hhbmdlT3V0cHV0cycsICdmZWUnXSxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBjaGFuZ2VPdXRwdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0QW1vdW50OiB0cmFuc2FjdGlvbi5BbW91bnQsXG4gICAgICAgIGNoYW5nZUFtb3VudDogMCxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBhbW91bnQ6IHRyYW5zYWN0aW9uLkFtb3VudFxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgZmVlOiB7XG4gICAgICAgICAgZmVlOiB0cmFuc2FjdGlvbi5GZWUsXG4gICAgICAgICAgZmVlUmF0ZTogbnVsbCxcbiAgICAgICAgICBzaXplOiB0eEhleC5sZW5ndGggLyAyXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhhdCBhIHRyYW5zYWN0aW9uIHByZWJ1aWxkIGNvbXBsaWVzIHdpdGggdGhlIG9yaWdpbmFsIGludGVudGlvblxuICAgKiBAcGFyYW0gdHhQYXJhbXMgcGFyYW1zIG9iamVjdCBwYXNzZWQgdG8gc2VuZFxuICAgKiBAcGFyYW0gdHhQcmVidWlsZCBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgc2VydmVyXG4gICAqIEBwYXJhbSB3YWxsZXRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgcHVibGljIHZlcmlmeVRyYW5zYWN0aW9uKHsgdHhQYXJhbXMsIHR4UHJlYnVpbGQgfTogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjayk6IEJsdWViaXJkPGJvb2xlYW4+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288Ym9vbGVhbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IGV4cGxhbmF0aW9uID0geWllbGQgc2VsZi5leHBsYWluVHJhbnNhY3Rpb24oe1xuICAgICAgICB0eEhleDogdHhQcmVidWlsZC50eEhleFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG91dHB1dCA9IFsuLi5leHBsYW5hdGlvbi5vdXRwdXRzLCAuLi5leHBsYW5hdGlvbi5jaGFuZ2VPdXRwdXRzXVswXTtcbiAgICAgIGNvbnN0IGV4cGVjdGVkT3V0cHV0ID0gdHhQYXJhbXMucmVjaXBpZW50cyAmJiB0eFBhcmFtcy5yZWNpcGllbnRzWzBdO1xuXG4gICAgICBjb25zdCBjb21wYXJhdG9yID0gKHJlY2lwaWVudDEsIHJlY2lwaWVudDIpID0+IHtcbiAgICAgICAgaWYgKHJlY2lwaWVudDEuYWRkcmVzcyAhPT0gcmVjaXBpZW50Mi5hZGRyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFtb3VudDEgPSBuZXcgQmlnTnVtYmVyKHJlY2lwaWVudDEuYW1vdW50KTtcbiAgICAgICAgY29uc3QgYW1vdW50MiA9IG5ldyBCaWdOdW1iZXIocmVjaXBpZW50Mi5hbW91bnQpO1xuICAgICAgICByZXR1cm4gYW1vdW50MS50b0ZpeGVkKCkgPT09IGFtb3VudDIudG9GaXhlZCgpO1xuICAgICAgfTtcblxuICAgICAgaWYgKCFjb21wYXJhdG9yKG91dHB1dCwgZXhwZWN0ZWRPdXRwdXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgb3V0cHV0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYWRkcmVzcyBpcyBhIHZhbGlkIFhSUCBhZGRyZXNzLCBhbmQgdGhlbiBtYWtlIHN1cmUgdGhlIHJvb3QgYWRkcmVzc2VzIG1hdGNoLlxuICAgKiBUaGlzIHByZXZlbnRzIGF0dGFja3Mgd2hlcmUgYW4gYXR0YWNrIG1heSBzd2l0Y2ggb3V0IHRoZSBuZXcgYWRkcmVzcyBmb3Igb25lIG9mIHRoZWlyIG93blxuICAgKiBAcGFyYW0gYWRkcmVzcyB7U3RyaW5nfSB0aGUgYWRkcmVzcyB0byB2ZXJpZnlcbiAgICogQHBhcmFtIHJvb3RBZGRyZXNzIHtTdHJpbmd9IHRoZSB3YWxsZXQncyByb290IGFkZHJlc3NcbiAgICovXG4gIHB1YmxpYyB2ZXJpZnlBZGRyZXNzKHsgYWRkcmVzcywgcm9vdEFkZHJlc3MgfTogVmVyaWZ5QWRkcmVzc09wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBhZGRyZXNzIHZlcmlmaWNhdGlvbiBmYWlsdXJlOiBhZGRyZXNzIFwiJHthZGRyZXNzfVwiIGlzIG5vdCB2YWxpZGApO1xuICAgIH1cblxuICAgIGNvbnN0IGFkZHJlc3NEZXRhaWxzID0gdGhpcy5nZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKTtcbiAgICBjb25zdCByb290QWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKHJvb3RBZGRyZXNzKTtcblxuICAgIGlmIChhZGRyZXNzRGV0YWlscy5hZGRyZXNzICE9PSByb290QWRkcmVzc0RldGFpbHMuYWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IoYGFkZHJlc3MgdmFsaWRhdGlvbiBmYWlsdXJlOiAke2FkZHJlc3NEZXRhaWxzLmFkZHJlc3N9IHZzLiAke3Jvb3RBZGRyZXNzRGV0YWlscy5hZGRyZXNzfWApO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVSTCBvZiBhIHdlbGwta25vd24sIHB1YmxpYyBmYWNpbmcgKG5vbi1iaXRnbykgcmlwcGxlZCBpbnN0YW5jZSB3aGljaCBjYW4gYmUgdXNlZCBmb3IgcmVjb3ZlcnlcbiAgICovXG4gIHB1YmxpYyBnZXRSaXBwbGVkVXJsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdodHRwczovL3MxLnJpcHBsZS5jb206NTEyMzQnO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R29cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHJvb3RBZGRyZXNzOiByb290IFhSUCB3YWxsZXQgYWRkcmVzcyB0byByZWNvdmVyIGZ1bmRzIGZyb21cbiAgICogLSB1c2VyS2V5OiBbZW5jcnlwdGVkXSB4cHJ2XG4gICAqIC0gYmFja3VwS2V5OiBbZW5jcnlwdGVkXSB4cHJ2LCBvciB4cHViIGlmIHRoZSB4cHJ2IGlzIGhlbGQgYnkgYSBLUlMgcHJvdmlkZXJcbiAgICogLSB3YWxsZXRQYXNzcGhyYXNlOiBuZWNlc3NhcnkgaWYgb25lIG9mIHRoZSB4cHJ2cyBpcyBlbmNyeXB0ZWRcbiAgICogLSBiaXRnb0tleTogeHB1YlxuICAgKiAtIGtyc1Byb3ZpZGVyOiBuZWNlc3NhcnkgaWYgYmFja3VwIGtleSBpcyBoZWxkIGJ5IEtSU1xuICAgKiAtIHJlY292ZXJ5RGVzdGluYXRpb246IHRhcmdldCBhZGRyZXNzIHRvIHNlbmQgcmVjb3ZlcmVkIGZ1bmRzIHRvXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIHJlY292ZXIocGFyYW1zOiBSZWNvdmVyeU9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFJlY292ZXJ5SW5mbyB8IHN0cmluZz4pOiBCbHVlYmlyZDxSZWNvdmVyeUluZm8gfCBzdHJpbmc+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288UmVjb3ZlcnlJbmZvIHwgc3RyaW5nPihmdW5jdGlvbiAqZXhwbGFpblRyYW5zYWN0aW9uKCkge1xuICAgICAgY29uc3QgcmlwcGxlZFVybCA9IHNlbGYuZ2V0UmlwcGxlZFVybCgpO1xuICAgICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IHBhcmFtcy5iYWNrdXBLZXkuc3RhcnRzV2l0aCgneHB1YicpICYmICFwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCd4cHViJyk7XG4gICAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBwYXJhbXMuYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSAmJiBwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCd4cHViJyk7XG5cbiAgICAgIGNvbnN0IGFjY291bnRJbmZvUGFyYW1zID0ge1xuICAgICAgICBtZXRob2Q6ICdhY2NvdW50X2luZm8nLFxuICAgICAgICBwYXJhbXM6IFt7XG4gICAgICAgICAgYWNjb3VudDogcGFyYW1zLnJvb3RBZGRyZXNzLFxuICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICBsZWRnZXJfaW5kZXg6ICdjdXJyZW50JyxcbiAgICAgICAgICBxdWV1ZTogdHJ1ZSxcbiAgICAgICAgICBzaWduZXJfbGlzdHM6IHRydWUsXG4gICAgICAgIH1dLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgeyBrZXlzLCBhZGRyZXNzRGV0YWlscywgZmVlRGV0YWlscywgc2VydmVyRGV0YWlscyB9ID0geWllbGQgQmx1ZWJpcmQucHJvcHMoe1xuICAgICAgICBrZXlzOiBzZWxmLmluaXRpYXRlUmVjb3ZlcnkocGFyYW1zKSxcbiAgICAgICAgYWRkcmVzc0RldGFpbHM6IHNlbGYuYml0Z28ucG9zdChyaXBwbGVkVXJsKS5zZW5kKGFjY291bnRJbmZvUGFyYW1zKSxcbiAgICAgICAgZmVlRGV0YWlsczogc2VsZi5iaXRnby5wb3N0KHJpcHBsZWRVcmwpLnNlbmQoeyBtZXRob2Q6ICdmZWUnIH0pLFxuICAgICAgICBzZXJ2ZXJEZXRhaWxzOiBzZWxmLmJpdGdvLnBvc3QocmlwcGxlZFVybCkuc2VuZCh7IG1ldGhvZDogJ3NlcnZlcl9pbmZvJyB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBvcGVuTGVkZ2VyRmVlID0gbmV3IEJpZ051bWJlcihmZWVEZXRhaWxzLmJvZHkucmVzdWx0LmRyb3BzLm9wZW5fbGVkZ2VyX2ZlZSk7XG4gICAgICBjb25zdCBiYXNlUmVzZXJ2ZSA9IG5ldyBCaWdOdW1iZXIoc2VydmVyRGV0YWlscy5ib2R5LnJlc3VsdC5pbmZvLnZhbGlkYXRlZF9sZWRnZXIucmVzZXJ2ZV9iYXNlX3hycCkudGltZXMoc2VsZi5nZXRCYXNlRmFjdG9yKCkpO1xuICAgICAgY29uc3QgcmVzZXJ2ZURlbHRhID0gbmV3IEJpZ051bWJlcihzZXJ2ZXJEZXRhaWxzLmJvZHkucmVzdWx0LmluZm8udmFsaWRhdGVkX2xlZGdlci5yZXNlcnZlX2luY194cnApLnRpbWVzKHNlbGYuZ2V0QmFzZUZhY3RvcigpKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRMZWRnZXIgPSBzZXJ2ZXJEZXRhaWxzLmJvZHkucmVzdWx0LmluZm8udmFsaWRhdGVkX2xlZGdlci5zZXE7XG4gICAgICBjb25zdCBzZXF1ZW5jZUlkID0gYWRkcmVzc0RldGFpbHMuYm9keS5yZXN1bHQuYWNjb3VudF9kYXRhLlNlcXVlbmNlO1xuICAgICAgY29uc3QgYmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoYWRkcmVzc0RldGFpbHMuYm9keS5yZXN1bHQuYWNjb3VudF9kYXRhLkJhbGFuY2UpO1xuICAgICAgY29uc3Qgc2lnbmVyTGlzdHMgPSBhZGRyZXNzRGV0YWlscy5ib2R5LnJlc3VsdC5hY2NvdW50X2RhdGEuc2lnbmVyX2xpc3RzO1xuICAgICAgY29uc3QgYWNjb3VudEZsYWdzID0gYWRkcmVzc0RldGFpbHMuYm9keS5yZXN1bHQuYWNjb3VudF9kYXRhLkZsYWdzO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgdGhlcmUgaXMgb25seSBvbmUgc2lnbmVyIGxpc3Qgc2V0XG4gICAgICBpZiAoc2lnbmVyTGlzdHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBzZXQgb2Ygc2lnbmVyIGxpc3RzJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgc2lnbmVycyBhcmUgdXNlciwgYmFja3VwLCBiaXRnb1xuICAgICAgY29uc3QgdXNlckFkZHJlc3MgPSByaXBwbGVLZXlwYWlycy5kZXJpdmVBZGRyZXNzKGtleXNbMF0uZ2V0UHVibGljS2V5QnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgIGNvbnN0IGJhY2t1cEFkZHJlc3MgPSByaXBwbGVLZXlwYWlycy5kZXJpdmVBZGRyZXNzKGtleXNbMV0uZ2V0UHVibGljS2V5QnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpKTtcblxuICAgICAgY29uc3Qgc2lnbmVyTGlzdCA9IHNpZ25lckxpc3RzWzBdO1xuICAgICAgaWYgKHNpZ25lckxpc3QuU2lnbmVyUXVvcnVtICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBtaW5pbXVtIHNpZ25hdHVyZSBjb3VudCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgZm91bmRBZGRyZXNzZXMgPSB7fTtcblxuICAgICAgY29uc3Qgc2lnbmVyRW50cmllcyA9IHNpZ25lckxpc3QuU2lnbmVyRW50cmllcztcbiAgICAgIGlmIChzaWduZXJFbnRyaWVzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnbmVyIGxpc3QgbGVuZ3RoJyk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHsgU2lnbmVyRW50cnkgfSBvZiBzaWduZXJFbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IHdlaWdodCA9IFNpZ25lckVudHJ5LlNpZ25lcldlaWdodDtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IFNpZ25lckVudHJ5LkFjY291bnQ7XG4gICAgICAgIGlmICh3ZWlnaHQgIT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnbmVyIHdlaWdodCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXQncyBhIGR1cGUgb2YgYW4gYWRkcmVzcyB3ZSBhbHJlYWR5IGtub3csIGJsb2NrXG4gICAgICAgIGlmIChmb3VuZEFkZHJlc3Nlc1thZGRyZXNzXSA+PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkdXBsaWNhdGUgc2lnbmVyIGFkZHJlc3MnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZEFkZHJlc3Nlc1thZGRyZXNzXSA9IChmb3VuZEFkZHJlc3Nlc1thZGRyZXNzXSB8fCAwKSArIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZEFkZHJlc3Nlc1t1c2VyQWRkcmVzc10gIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGluY2lkZW5jZSBmcmVxdWVuY3kgb2YgdXNlciBzaWduZXIgYWRkcmVzcycpO1xuICAgICAgfVxuICAgICAgaWYgKGZvdW5kQWRkcmVzc2VzW2JhY2t1cEFkZHJlc3NdICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBpbmNpZGVuY2UgZnJlcXVlbmN5IG9mIHVzZXIgc2lnbmVyIGFkZHJlc3MnKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIHRoZSBmbGFncyBkaXNhYmxlIHRoZSBtYXN0ZXIga2V5IGFuZCBlbmZvcmNlIGRlc3RpbmF0aW9uIHRhZ3NcbiAgICAgIGNvbnN0IFVTRVJfS0VZX1NFVFRJTkdfRkxBRyA9IDY1NTM2O1xuICAgICAgY29uc3QgTUFTVEVSX0tFWV9ERUFDVElWQVRJT05fRkxBRyA9IDEwNDg1NzY7XG4gICAgICBjb25zdCBSRVFVSVJFX0RFU1RJTkFUSU9OX1RBR19GTEFHID0gMTMxMDcyO1xuICAgICAgaWYgKChhY2NvdW50RmxhZ3MgJiBVU0VSX0tFWV9TRVRUSU5HX0ZMQUcpICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYSBjdXN0b20gdXNlciBrZXkgaGFzIGJlZW4gc2V0Jyk7XG4gICAgICB9XG4gICAgICBpZiAoKGFjY291bnRGbGFncyAmIE1BU1RFUl9LRVlfREVBQ1RJVkFUSU9OX0ZMQUcpICE9PSBNQVNURVJfS0VZX0RFQUNUSVZBVElPTl9GTEFHKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIG1hc3RlciBrZXkgaGFzIG5vdCBiZWVuIGRlYWN0aXZhdGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAoKGFjY291bnRGbGFncyAmIFJFUVVJUkVfREVTVElOQVRJT05fVEFHX0ZMQUcpICE9PSBSRVFVSVJFX0RFU1RJTkFUSU9OX1RBR19GTEFHKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIGRlc3RpbmF0aW9uIGZsYWcgcmVxdWlyZW1lbnQgaGFzIG5vdCBiZWVuIGFjdGl2YXRlZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyByZWNvdmVyIHRoZSBmdW5kc1xuICAgICAgY29uc3QgcmVzZXJ2ZSA9IGJhc2VSZXNlcnZlLnBsdXMocmVzZXJ2ZURlbHRhLnRpbWVzKDUpKTtcbiAgICAgIGNvbnN0IHJlY292ZXJhYmxlQmFsYW5jZSA9IGJhbGFuY2UubWludXMocmVzZXJ2ZSk7XG5cbiAgICAgIGNvbnN0IHJhd0Rlc3RpbmF0aW9uID0gcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb247XG4gICAgICBjb25zdCBkZXN0aW5hdGlvbkRldGFpbHMgPSB1cmwucGFyc2UocmF3RGVzdGluYXRpb24pO1xuICAgICAgY29uc3QgZGVzdGluYXRpb25BZGRyZXNzID0gZGVzdGluYXRpb25EZXRhaWxzLnBhdGhuYW1lO1xuXG4gICAgICAvLyBwYXJzZSBkZXN0aW5hdGlvbiB0YWcgZnJvbSBxdWVyeVxuICAgICAgbGV0IGRlc3RpbmF0aW9uVGFnOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgICBpZiAoZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5RGV0YWlscyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKGRlc3RpbmF0aW9uRGV0YWlscy5xdWVyeSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5RGV0YWlscy5kdCkpIHtcbiAgICAgICAgICAvLyBpZiBxdWVyeURldGFpbHMuZHQgaXMgYW4gYXJyYXksIHRoYXQgbWVhbnMgZHQgd2FzIGdpdmVuIG11bHRpcGxlIHRpbWVzLCB3aGljaCBpcyBub3QgdmFsaWRcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgZGVzdGluYXRpb24gdGFnIGNhbiBhcHBlYXIgYXQgbW9zdCBvbmNlLCBidXQgJHtxdWVyeURldGFpbHMuZHQubGVuZ3RofSBkZXN0aW5hdGlvbiB0YWdzIHdlcmUgZm91bmRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhcnNlZFRhZyA9IHBhcnNlSW50KHF1ZXJ5RGV0YWlscy5kdCwgMTApO1xuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihwYXJzZWRUYWcpKSB7XG4gICAgICAgICAgZGVzdGluYXRpb25UYWcgPSBwYXJzZWRUYWc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIFRyYW5zYWN0aW9uVHlwZTogJ1BheW1lbnQnLFxuICAgICAgICBBY2NvdW50OiBwYXJhbXMucm9vdEFkZHJlc3MsIC8vIHNvdXJjZSBhZGRyZXNzXG4gICAgICAgIERlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbkFkZHJlc3MsXG4gICAgICAgIERlc3RpbmF0aW9uVGFnOiBkZXN0aW5hdGlvblRhZyxcbiAgICAgICAgQW1vdW50OiByZWNvdmVyYWJsZUJhbGFuY2UudG9GaXhlZCgwKSxcbiAgICAgICAgRmxhZ3M6IDIxNDc0ODM2NDgsXG4gICAgICAgIExhc3RMZWRnZXJTZXF1ZW5jZTogY3VycmVudExlZGdlciArIDEwMDAwMDAsIC8vIGdpdmUgaXQgMSBtaWxsaW9uIGxlZGdlcnMnIHRpbWUgKH4xIG1vbnRoLCBzdWl0YWJsZSBmb3IgS1JTKVxuICAgICAgICBGZWU6IG9wZW5MZWRnZXJGZWUudGltZXMoMykudG9GaXhlZCgwKSwgLy8gdGhlIGZhY3RvciB0aHJlZSBpcyBmb3IgdGhlIG11bHRpc2lnbmluZ1xuICAgICAgICBTZXF1ZW5jZTogc2VxdWVuY2VJZCxcbiAgICAgIH07XG4gICAgICBjb25zdCB0eEpTT046IHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KHRyYW5zYWN0aW9uKTtcblxuICAgICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICByZXR1cm4gdHhKU09OO1xuICAgICAgfVxuICAgICAgY29uc3QgcmlwcGxlTGliID0gcmlwcGxlKCk7XG4gICAgICBjb25zdCB1c2VyS2V5ID0ga2V5c1swXS5nZXRLZXkoKS5nZXRQcml2YXRlS2V5QnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgY29uc3QgdXNlclNpZ25hdHVyZSA9IHJpcHBsZUxpYi5zaWduV2l0aFByaXZhdGVLZXkodHhKU09OLCB1c2VyS2V5LCB7IHNpZ25BczogdXNlckFkZHJlc3MgfSk7XG5cbiAgICAgIGxldCBzaWduZWRUcmFuc2FjdGlvbjtcblxuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgICAgc2lnbmVkVHJhbnNhY3Rpb24gPSB1c2VyU2lnbmF0dXJlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYmFja3VwS2V5ID0ga2V5c1sxXS5nZXRLZXkoKS5nZXRQcml2YXRlS2V5QnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICBjb25zdCBiYWNrdXBTaWduYXR1cmUgPSByaXBwbGVMaWIuc2lnbldpdGhQcml2YXRlS2V5KHR4SlNPTiwgYmFja3VwS2V5LCB7IHNpZ25BczogYmFja3VwQWRkcmVzcyB9KTtcbiAgICAgICAgc2lnbmVkVHJhbnNhY3Rpb24gPSByaXBwbGVMaWIuY29tYmluZShbdXNlclNpZ25hdHVyZS5zaWduZWRUcmFuc2FjdGlvbiwgYmFja3VwU2lnbmF0dXJlLnNpZ25lZFRyYW5zYWN0aW9uXSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRXhwbGFuYXRpb246IFJlY292ZXJ5SW5mbyA9IHlpZWxkIHNlbGYuZXhwbGFpblRyYW5zYWN0aW9uKHtcbiAgICAgICAgdHhIZXg6IHNpZ25lZFRyYW5zYWN0aW9uLnNpZ25lZFRyYW5zYWN0aW9uLFxuICAgICAgfSk7XG4gICAgICB0cmFuc2FjdGlvbkV4cGxhbmF0aW9uLnR4SGV4ID0gc2lnbmVkVHJhbnNhY3Rpb24uc2lnbmVkVHJhbnNhY3Rpb247XG5cbiAgICAgIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgICAgIHRyYW5zYWN0aW9uRXhwbGFuYXRpb24uYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleTtcbiAgICAgICAgdHJhbnNhY3Rpb25FeHBsYW5hdGlvbi5jb2luID0gc2VsZi5nZXRDaGFpbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uRXhwbGFuYXRpb247XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlIGFuZCB2YWxpZGF0ZSBhbGwga2V5Y2hhaW5zIGZyb20gdGhlIGtleWNhcmQgZm9yIHJlY292ZXJ5XG4gICAqL1xuICBpbml0aWF0ZVJlY292ZXJ5KHBhcmFtczogSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMpOiBCbHVlYmlyZDxIRE5vZGVbXT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxIRE5vZGVbXT4oZnVuY3Rpb24gKmluaXRpYXRlUmVjb3ZlcnkoKSB7XG4gICAgICBjb25zdCBrZXlzOiBIRE5vZGVbXSA9IFtdO1xuICAgICAgY29uc3QgdXNlcktleSA9IHBhcmFtcy51c2VyS2V5OyAvLyBCb3ggQVxuICAgICAgbGV0IGJhY2t1cEtleSA9IHBhcmFtcy5iYWNrdXBLZXk7IC8vIEJveCBCXG4gICAgICBjb25zdCBiaXRnb1hwdWIgPSBwYXJhbXMuYml0Z29LZXk7IC8vIEJveCBDXG4gICAgICBjb25zdCBkZXN0aW5hdGlvbkFkZHJlc3MgPSBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbjtcbiAgICAgIGNvbnN0IHBhc3NwaHJhc2UgPSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZTtcblxuICAgICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IGJhY2t1cEtleS5zdGFydHNXaXRoKCd4cHViJykgJiYgIXVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpO1xuICAgICAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSAmJiB1c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKTtcblxuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkgJiYgcGFyYW1zLmtyc1Byb3ZpZGVyICYmIF8uaXNVbmRlZmluZWQoY29uZmlnLmtyc1Byb3ZpZGVyc1twYXJhbXMua3JzUHJvdmlkZXJdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24ga2V5IHJlY292ZXJ5IHNlcnZpY2UgcHJvdmlkZXInKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsaWRhdGVQYXNzcGhyYXNlS2V5ID0gZnVuY3Rpb24odXNlcktleSwgcGFzc3BocmFzZSk6IEhETm9kZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCF1c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwcnYnKSAmJiAhaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAgICAgICB1c2VyS2V5ID0gc2pjbC5kZWNyeXB0KHBhc3NwaHJhc2UsIHVzZXJLZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gSEROb2RlLmZyb21CYXNlNTgodXNlcktleSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IHVzZXIga2V5IHdpdGggcGFzc2NvZGUgLSB0cnkgYWdhaW4hJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGtleSA9IHZhbGlkYXRlUGFzc3BocmFzZUtleSh1c2VyS2V5LCBwYXNzcGhyYXNlKTtcblxuICAgICAga2V5cy5wdXNoKGtleSk7XG5cbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBiYWNrdXAga2V5XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWJhY2t1cEtleS5zdGFydHNXaXRoKCd4cHJ2JykgJiYgIWlzS3JzUmVjb3ZlcnkgJiYgIWlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICAgIGJhY2t1cEtleSA9IHNqY2wuZGVjcnlwdChwYXNzcGhyYXNlLCBiYWNrdXBLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhY2t1cEhETm9kZSA9IEhETm9kZS5mcm9tQmFzZTU4KGJhY2t1cEtleSk7XG4gICAgICAgIGtleXMucHVzaChiYWNrdXBIRE5vZGUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IGJhY2t1cCBrZXkgd2l0aCBwYXNzY29kZSAtIHRyeSBhZ2FpbiEnKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJpdGdvSEROb2RlID0gSEROb2RlLmZyb21CYXNlNTgoYml0Z29YcHViKTtcbiAgICAgICAga2V5cy5wdXNoKGJpdGdvSEROb2RlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHNlbGYuZ2V0RmFtaWx5KCkgIT09ICd4cnAnKSB7XG4gICAgICAgICAgLy8gaW4gWFJQIHJlY292ZXJpZXMsIHRoZSBCaXRHbyB4cHViIGlzIG9wdGlvbmFsXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgYml0Z28geHB1YiEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVmFsaWRhdGUgdGhlIGRlc3RpbmF0aW9uIGFkZHJlc3NcbiAgICAgIGlmICghc2VsZi5pc1ZhbGlkQWRkcmVzcyhkZXN0aW5hdGlvbkFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkZXN0aW5hdGlvbiBhZGRyZXNzIScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9KS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IGtleXBhaXIgZm9yIHRoaXMgY29pbi5cbiAgICogQHBhcmFtIHNlZWQgU2VlZCBmcm9tIHdoaWNoIHRoZSBuZXcga2V5cGFpciBzaG91bGQgYmUgZ2VuZXJhdGVkLCBvdGhlcndpc2UgYSByYW5kb20gc2VlZCBpcyB1c2VkXG4gICAqL1xuICBwdWJsaWMgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBpZiAoIXNlZWQpIHtcbiAgICAgIC8vIEFuIGV4dGVuZGVkIHByaXZhdGUga2V5IGhhcyBib3RoIGEgbm9ybWFsIDI1NiBiaXQgcHJpdmF0ZSBrZXkgYW5kIGEgMjU2XG4gICAgICAvLyBiaXQgY2hhaW4gY29kZSwgYm90aCBvZiB3aGljaCBtdXN0IGJlIHJhbmRvbS4gNTEyIGJpdHMgaXMgdGhlcmVmb3JlIHRoZVxuICAgICAgLy8gbWF4aW11bSBlbnRyb3B5IGFuZCBnaXZlcyB1cyBtYXhpbXVtIHNlY3VyaXR5IGFnYWluc3QgY3JhY2tpbmcuXG4gICAgICBzZWVkID0gcmFuZG9tQnl0ZXMoNTEyIC8gOCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuZGVkS2V5ID0gSEROb2RlLmZyb21TZWVkQnVmZmVyKHNlZWQpO1xuICAgIGNvbnN0IHhwdWIgPSBleHRlbmRlZEtleS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YjogeHB1YixcbiAgICAgIHBydjogZXh0ZW5kZWRLZXkudG9CYXNlNTgoKSxcbiAgICB9O1xuICB9XG5cbiAgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxQYXJzZWRUcmFuc2FjdGlvbj4pOiBCbHVlYmlyZDxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHt9KS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxufVxuIl19