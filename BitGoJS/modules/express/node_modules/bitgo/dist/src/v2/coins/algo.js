"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var Bluebird = require("bluebird");
var _ = require("lodash");
var stellar = require("stellar-sdk");
var statics_1 = require("@bitgo/statics");
var algosdk_1 = require("algosdk");
var baseCoin_1 = require("../baseCoin");
var keychains_1 = require("../keychains");
var seedValidator_1 = require("../internal/seedValidator");
var co = Bluebird.coroutine;
var Algo = /** @class */ (function (_super) {
    __extends(Algo, _super);
    function Algo(bitgo) {
        return _super.call(this, bitgo) || this;
    }
    Algo.createInstance = function (bitgo) {
        return new Algo(bitgo);
    };
    Algo.prototype.getChain = function () {
        return 'algo';
    };
    Algo.prototype.getFamily = function () {
        return 'algo';
    };
    Algo.prototype.getFullName = function () {
        return 'Algorand';
    };
    Algo.prototype.getBaseFactor = function () {
        return 1e6;
    };
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    Algo.prototype.valuelessTransferAllowed = function () {
        // TODO: this sounds like its true with the staking txes - confirm before launch
        return false;
    };
    /**
     * Algorand supports account consolidations. These are transfers from the receive addresses
     * to the main address.
     */
    Algo.prototype.allowsAccountConsolidations = function () {
        return true;
    };
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    Algo.prototype.generateKeyPair = function (seed) {
        var pair = seed ? algosdk_1.generateAccountFromSeed(seed) : algosdk_1.generateAccount();
        return {
            pub: pair.addr,
            prv: algosdk_1.Seed.encode(pair.sk),
        };
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Algo.prototype.isValidPub = function (pub) {
        return algosdk_1.isValidAddress(pub);
    };
    /**
     * Return boolean indicating whether input is valid seed for the coin
     * In Algorand, when the private key is encoded as base32 string only the first 32 bytes are taken,
     * so the encoded value is actually the seed
     *
     * @param {String} prv the prv to be checked
     * @returns {Boolean} is it valid?
     */
    Algo.prototype.isValidPrv = function (prv) {
        return algosdk_1.isValidSeed(prv);
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {String} address the pub to be checked
     * @returns {Boolean} is it valid?
     */
    Algo.prototype.isValidAddress = function (address) {
        return algosdk_1.isValidAddress(address);
    };
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    Algo.prototype.signMessage = function (key, message, callback) {
        var self = this;
        return co(function cosignMessage() {
            var seed, keyPair;
            return __generator(this, function (_a) {
                seed = key.prv;
                if (!self.isValidPrv(seed)) {
                    throw new Error("invalid seed: " + seed);
                }
                if (typeof seed === 'string') {
                    try {
                        seed = algosdk_1.Seed.decode(seed).seed;
                    }
                    catch (e) {
                        throw new Error("could not decode seed: " + seed);
                    }
                }
                keyPair = algosdk_1.generateAccountFromSeed(seed);
                if (!Buffer.isBuffer(message)) {
                    message = Buffer.from(message);
                }
                return [2 /*return*/, Buffer.from(algosdk_1.NaclWrapper.sign(message, keyPair.sk))];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Specifies what key we will need for signing` - Algorand needs the backup, bitgo pubs.
     */
    Algo.prototype.keyIdsForSigning = function () {
        return [keychains_1.KeyIndices.USER, keychains_1.KeyIndices.BACKUP, keychains_1.KeyIndices.BITGO];
    };
    /**
     * Explain/parse transaction
     * @param params
     * @param callback
     */
    Algo.prototype.explainTransaction = function (params, callback) {
        return co(function () {
            var txHex, tx, type, senderAddress, voteKeyBase64, voteLastBlock, txToHex, decodedTx, txnForDecoding, id, fee, outputAmount, outputs, memo;
            return __generator(this, function (_a) {
                txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
                if (!txHex) {
                    throw new Error('missing required param txHex or halfSigned.txHex');
                }
                try {
                    txToHex = Buffer.from(txHex, 'base64');
                    decodedTx = algosdk_1.Encoding.decode(txToHex);
                    txnForDecoding = decodedTx.txn || decodedTx;
                    if (!!txnForDecoding.votekey) {
                        type = txnForDecoding.type;
                        senderAddress = algosdk_1.Address.encode(txnForDecoding.snd);
                        voteKeyBase64 = txnForDecoding.votekey.toString('base64');
                        voteLastBlock = txnForDecoding.votelst;
                    }
                    tx = algosdk_1.Multisig.MultiSigTransaction.from_obj_for_encoding(txnForDecoding);
                }
                catch (ex) {
                    throw new Error('txHex needs to be a valid tx encoded as base64 string');
                }
                id = tx.txID();
                fee = { fee: tx.fee };
                outputAmount = tx.amount || 0;
                outputs = [];
                if (tx.to) {
                    outputs.push({
                        amount: outputAmount,
                        address: algosdk_1.Address.encode(new Uint8Array(tx.to.publicKey)),
                    });
                }
                memo = tx.note;
                return [2 /*return*/, {
                        displayOrder: [
                            'id',
                            'outputAmount',
                            'changeAmount',
                            'outputs',
                            'changeOutputs',
                            'fee',
                            'memo',
                            'type',
                            'senderAddress',
                            'voteKeyBase64',
                            'voteLastBlock',
                        ],
                        id: id,
                        outputs: outputs,
                        outputAmount: outputAmount,
                        changeAmount: 0,
                        fee: fee,
                        changeOutputs: [],
                        memo: memo,
                        type: type,
                        senderAddress: senderAddress,
                        voteKeyBase64: voteKeyBase64,
                        voteLastBlock: voteLastBlock,
                    }];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    Algo.prototype.isStellarSeed = function (seed) {
        return seedValidator_1.SeedValidator.isValidEd25519SeedForCoin(seed, statics_1.CoinFamily.XLM);
    };
    Algo.prototype.convertFromStellarSeed = function (seed) {
        // assume this is a trust custodial seed if its a valid ed25519 prv
        if (!this.isStellarSeed(seed) || seedValidator_1.SeedValidator.hasCompetingSeedFormats(seed)) {
            return null;
        }
        if (seedValidator_1.SeedValidator.isValidEd25519SeedForCoin(seed, statics_1.CoinFamily.XLM)) {
            return algosdk_1.Seed.encode(stellar.StrKey.decodeEd25519SecretSeed(seed));
        }
        return null;
    };
    Algo.prototype.verifySignTransactionParams = function (params) {
        var prv = params.prv;
        var addressVersion = params.txPrebuild.addressVersion;
        var isHalfSigned = false;
        // it's possible this tx was already signed - take the halfSigned
        // txHex if it is
        var txHex = params.txPrebuild.txHex;
        if (params.txPrebuild.halfSigned) {
            isHalfSigned = true;
            txHex = params.txPrebuild.halfSigned.txHex;
        }
        if (_.isUndefined(txHex)) {
            throw new Error('missing txPrebuild parameter');
        }
        if (!_.isString(txHex)) {
            throw new Error("txPrebuild must be an object, got type " + typeof txHex);
        }
        if (_.isUndefined(prv)) {
            throw new Error('missing prv parameter to sign transaction');
        }
        if (!_.isString(prv)) {
            throw new Error("prv must be a string, got type " + typeof prv);
        }
        if (!_.has(params.txPrebuild, 'keys[0]') ||
            !_.has(params.txPrebuild, 'keys[1]') ||
            !_.has(params.txPrebuild, 'keys[2]')) {
            throw new Error('missing public keys parameter to sign transaction');
        }
        if (!_.isNumber(addressVersion)) {
            throw new Error('missing addressVersion parameter to sign transaction');
        }
        // we need to re-encode our public keys using algosdk's format
        var keys = [params.txPrebuild.keys[0], params.txPrebuild.keys[1], params.txPrebuild.keys[2]];
        // re-encode sk from our prv (this acts as a seed out of the keychain)
        var seed = algosdk_1.Seed.decode(prv).seed;
        var pair = algosdk_1.generateAccountFromSeed(seed);
        var sk = pair.sk;
        return { txHex: txHex, addressVersion: addressVersion, keys: keys, sk: sk, isHalfSigned: isHalfSigned };
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {TransactionPrebuild} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param callback
     * @returns {Bluebird<SignedTransaction>}
     */
    Algo.prototype.signTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var _a, txHex, addressVersion, keys, sk, isHalfSigned, encodedPublicKeys, transaction, txToHex, initialDecodedTx, decodedTx, signed, signedBase64;
            return __generator(this, function (_b) {
                _a = self.verifySignTransactionParams(params), txHex = _a.txHex, addressVersion = _a.addressVersion, keys = _a.keys, sk = _a.sk, isHalfSigned = _a.isHalfSigned;
                encodedPublicKeys = _.map(keys, function (k) { return algosdk_1.Address.decode(k).publicKey; });
                try {
                    txToHex = Buffer.from(txHex, 'base64');
                    initialDecodedTx = algosdk_1.Encoding.decode(txToHex);
                    decodedTx = isHalfSigned ? initialDecodedTx.txn : initialDecodedTx;
                    transaction = algosdk_1.Multisig.MultiSigTransaction.from_obj_for_encoding(decodedTx);
                }
                catch (e) {
                    throw new Error('transaction needs to be a valid tx encoded as base64 string');
                }
                signed = transaction.partialSignTxn({ version: addressVersion, threshold: 2, pks: encodedPublicKeys }, sk);
                // if we have already signed it, we'll have to merge that with our previous tx
                if (isHalfSigned) {
                    signed = algosdk_1.mergeMultisigTransactions([Buffer.from(signed), txToHex]);
                }
                signedBase64 = Buffer.from(signed).toString('base64');
                if (isHalfSigned) {
                    return [2 /*return*/, { txHex: signedBase64 }];
                }
                else {
                    return [2 /*return*/, { halfSigned: { txHex: signedBase64 } }];
                }
                return [2 /*return*/];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    Algo.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    Algo.prototype.verifyAddress = function (params) {
        return true;
    };
    Algo.prototype.verifyTransaction = function (params, callback) {
        return Bluebird.resolve(true).asCallback(callback);
    };
    return Algo;
}(baseCoin_1.BaseCoin));
exports.Algo = Algo;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWxnby5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy92Mi9jb2lucy9hbGdvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0gsbUNBQXFDO0FBQ3JDLDBCQUE0QjtBQUM1QixxQ0FBdUM7QUFDdkMsMENBQTRDO0FBQzVDLG1DQVdpQjtBQUdqQix3Q0FTcUI7QUFDckIsMENBQTBDO0FBRTFDLDJEQUEwRDtBQUUxRCxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBNEQ5QjtJQUEwQix3QkFBUTtJQUNoQyxjQUFZLEtBQVk7ZUFDdEIsa0JBQU0sS0FBSyxDQUFDO0lBQ2QsQ0FBQztJQUVNLG1CQUFjLEdBQXJCLFVBQXNCLEtBQVk7UUFDaEMsT0FBTyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBRUQsdUJBQVEsR0FBUjtRQUNFLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRCx3QkFBUyxHQUFUO1FBQ0UsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVELDBCQUFXLEdBQVg7UUFDRSxPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDO0lBRUQsNEJBQWEsR0FBYjtRQUNFLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVEOzs7T0FHRztJQUNILHVDQUF3QixHQUF4QjtRQUNFLGdGQUFnRjtRQUNoRixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7O09BR0c7SUFDSCwwQ0FBMkIsR0FBM0I7UUFDRSxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILDhCQUFlLEdBQWYsVUFBZ0IsSUFBYTtRQUMzQixJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLGlDQUF1QixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyx5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LE9BQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVELDRCQUFhLEdBQWIsVUFBYyxNQUE0QjtRQUN4QyxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxnQ0FBaUIsR0FBakIsVUFBa0IsTUFBZ0MsRUFBRSxRQUFnQztRQUNsRixPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFDSCxXQUFDO0FBQUQsQ0FBQyxBQTVWRCxDQUEwQixtQkFBUSxHQTRWakM7QUE1Vlksb0JBQUkiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyBzdGVsbGFyIGZyb20gJ3N0ZWxsYXItc2RrJztcbmltcG9ydCB7IENvaW5GYW1pbHkgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQge1xuICBOYWNsV3JhcHBlcixcbiAgTXVsdGlzaWcsXG4gIEFkZHJlc3MsXG4gIFNlZWQsXG4gIGdlbmVyYXRlQWNjb3VudEZyb21TZWVkLFxuICBnZW5lcmF0ZUFjY291bnQsXG4gIGlzVmFsaWRBZGRyZXNzLFxuICBpc1ZhbGlkU2VlZCxcbiAgRW5jb2RpbmcsXG4gIG1lcmdlTXVsdGlzaWdUcmFuc2FjdGlvbnMsXG59IGZyb20gJ2FsZ29zZGsnO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi8uLi9iaXRnbyc7XG5cbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uIGFzIEJhc2VUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBLZXlQYWlyLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFZlcmlmeUFkZHJlc3NPcHRpb25zLFxuICBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxufSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBLZXlJbmRpY2VzIH0gZnJvbSAnLi4va2V5Y2hhaW5zJztcbmltcG9ydCB7IE5vZGVDYWxsYmFjayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFNlZWRWYWxpZGF0b3IgfSBmcm9tICcuLi9pbnRlcm5hbC9zZWVkVmFsaWRhdG9yJztcblxuY29uc3QgY28gPSBCbHVlYmlyZC5jb3JvdXRpbmU7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbkV4cGxhbmF0aW9uIHtcbiAgbWVtbzogc3RyaW5nO1xuICB0eXBlPzogc3RyaW5nO1xuICBzZW5kZXJBZGRyZXNzPzogc3RyaW5nO1xuICB2b3RlS2V5QmFzZTY0Pzogc3RyaW5nO1xuICB2b3RlTGFzdEJsb2NrPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwcnY6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhIZXg6IHN0cmluZztcbiAgaGFsZlNpZ25lZD86IHtcbiAgICB0eEhleDogc3RyaW5nO1xuICB9O1xuICB0eEluZm86IHtcbiAgICBmcm9tOiBzdHJpbmc7XG4gICAgdG86IHN0cmluZztcbiAgICBhbW91bnQ6IHN0cmluZztcbiAgICBmZWU6IG51bWJlcjtcbiAgICBmaXJzdFJvdW5kOiBudW1iZXI7XG4gICAgbGFzdFJvdW5kOiBudW1iZXI7XG4gICAgZ2VuZXNpc0lEOiBzdHJpbmc7XG4gICAgZ2VuZXNpc0hhc2g6IHN0cmluZztcbiAgICBub3RlPzogc3RyaW5nO1xuICB9O1xuICBrZXlzOiBzdHJpbmdbXTtcbiAgYWRkcmVzc1ZlcnNpb246IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGdWxseVNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgdHhIZXg6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYWxmU2lnbmVkVHJhbnNhY3Rpb24ge1xuICBoYWxmU2lnbmVkOiB7XG4gICAgdHhIZXg6IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhIZXg/OiBzdHJpbmc7XG4gIGhhbGZTaWduZWQ/OiB7XG4gICAgdHhIZXg6IHN0cmluZztcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZXJpZmllZFRyYW5zYWN0aW9uUGFyYW1ldGVycyB7XG4gIHR4SGV4OiBzdHJpbmc7XG4gIGFkZHJlc3NWZXJzaW9uOiBudW1iZXI7XG4gIGtleXM6IHN0cmluZ1tdO1xuICBzazogc3RyaW5nO1xuICBpc0hhbGZTaWduZWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBBbGdvIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28pIHtcbiAgICBzdXBlcihiaXRnbyk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvKTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgQWxnbyhiaXRnbyk7XG4gIH1cblxuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnYWxnbyc7XG4gIH1cblxuICBnZXRGYW1pbHkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2FsZ28nO1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ0FsZ29yYW5kJztcbiAgfVxuXG4gIGdldEJhc2VGYWN0b3IoKTogYW55IHtcbiAgICByZXR1cm4gMWU2O1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgdmFsdWUgb2YgMFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgMCB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB2YWx1ZWxlc3NUcmFuc2ZlckFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgLy8gVE9ETzogdGhpcyBzb3VuZHMgbGlrZSBpdHMgdHJ1ZSB3aXRoIHRoZSBzdGFraW5nIHR4ZXMgLSBjb25maXJtIGJlZm9yZSBsYXVuY2hcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQWxnb3JhbmQgc3VwcG9ydHMgYWNjb3VudCBjb25zb2xpZGF0aW9ucy4gVGhlc2UgYXJlIHRyYW5zZmVycyBmcm9tIHRoZSByZWNlaXZlIGFkZHJlc3Nlc1xuICAgKiB0byB0aGUgbWFpbiBhZGRyZXNzLlxuICAgKi9cbiAgYWxsb3dzQWNjb3VudENvbnNvbGlkYXRpb25zKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGVkMjU1MTkga2V5IHBhaXJcbiAgICpcbiAgICogQHBhcmFtIHNlZWRcbiAgICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IHdpdGggZ2VuZXJhdGVkIHB1YiwgcHJ2XG4gICAqL1xuICBnZW5lcmF0ZUtleVBhaXIoc2VlZD86IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIGNvbnN0IHBhaXIgPSBzZWVkID8gZ2VuZXJhdGVBY2NvdW50RnJvbVNlZWQoc2VlZCkgOiBnZW5lcmF0ZUFjY291bnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiBwYWlyLmFkZHIsIC8vIGVuY29kZWQgcHViXG4gICAgICBwcnY6IFNlZWQuZW5jb2RlKHBhaXIuc2spLCAvLyBlbmNvZGVkIHNlZWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHB1YiB0aGUgcHViIHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc1ZhbGlkQWRkcmVzcyhwdWIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBzZWVkIGZvciB0aGUgY29pblxuICAgKiBJbiBBbGdvcmFuZCwgd2hlbiB0aGUgcHJpdmF0ZSBrZXkgaXMgZW5jb2RlZCBhcyBiYXNlMzIgc3RyaW5nIG9ubHkgdGhlIGZpcnN0IDMyIGJ5dGVzIGFyZSB0YWtlbixcbiAgICogc28gdGhlIGVuY29kZWQgdmFsdWUgaXMgYWN0dWFsbHkgdGhlIHNlZWRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBydiB0aGUgcHJ2IHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc1ZhbGlkU2VlZChwcnYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pblxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB0aGUgcHViIHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gbWVzc2FnZSB3aXRoIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICovXG4gIHNpZ25NZXNzYWdlKGtleTogS2V5UGFpciwgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxCdWZmZXI+KTogQmx1ZWJpcmQ8QnVmZmVyPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPEJ1ZmZlcj4oZnVuY3Rpb24qIGNvc2lnbk1lc3NhZ2UoKSB7XG4gICAgICAvLyBrZXkucHJ2IGFjdHVhbGx5IGhvbGRzIHRoZSBlbmNvZGVkIHNlZWQsIGJ1dCB3ZSB1c2UgdGhlIHBydiBuYW1lIHRvIGF2b2lkIGJyZWFraW5nIHRoZSBrZXlwYWlyIHNjaGVtYS5cbiAgICAgIC8vIFNlZSBqc2RvYyBjb21tZW50IGluIGlzVmFsaWRQcnZcbiAgICAgIGxldCBzZWVkID0ga2V5LnBydjtcbiAgICAgIGlmICghc2VsZi5pc1ZhbGlkUHJ2KHNlZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzZWVkOiAke3NlZWR9YCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNlZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2VlZCA9IFNlZWQuZGVjb2RlKHNlZWQpLnNlZWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvdWxkIG5vdCBkZWNvZGUgc2VlZDogJHtzZWVkfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBrZXlQYWlyID0gZ2VuZXJhdGVBY2NvdW50RnJvbVNlZWQoc2VlZCk7XG5cbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBCdWZmZXIuZnJvbShtZXNzYWdlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKE5hY2xXcmFwcGVyLnNpZ24obWVzc2FnZSwga2V5UGFpci5zaykpO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB3aGF0IGtleSB3ZSB3aWxsIG5lZWQgZm9yIHNpZ25pbmdgIC0gQWxnb3JhbmQgbmVlZHMgdGhlIGJhY2t1cCwgYml0Z28gcHVicy5cbiAgICovXG4gIGtleUlkc0ZvclNpZ25pbmcoKTogbnVtYmVyW10ge1xuICAgIHJldHVybiBbS2V5SW5kaWNlcy5VU0VSLCBLZXlJbmRpY2VzLkJBQ0tVUCwgS2V5SW5kaWNlcy5CSVRHT107XG4gIH1cblxuICAvKipcbiAgICogRXhwbGFpbi9wYXJzZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZXhwbGFpblRyYW5zYWN0aW9uKFxuICAgIHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPlxuICApOiBCbHVlYmlyZDxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPiB7XG4gICAgcmV0dXJuIGNvPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+KGZ1bmN0aW9uKigpIHtcbiAgICAgIC8vIHRha2UgdHhIZXggZmlyc3QgYWx3YXlzLCBidXQgYXMgaXQgbWlnaHQgYWxyZWFkeSBiZSBzaWduZWQsIHRha2UgaGFsZlNpZ25lZCBzZWNvbmRcbiAgICAgIGNvbnN0IHR4SGV4ID0gcGFyYW1zLnR4SGV4IHx8IChwYXJhbXMuaGFsZlNpZ25lZCAmJiBwYXJhbXMuaGFsZlNpZ25lZC50eEhleCk7XG5cbiAgICAgIGlmICghdHhIZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHBhcmFtIHR4SGV4IG9yIGhhbGZTaWduZWQudHhIZXgnKTtcbiAgICAgIH1cbiAgICAgIGxldCB0eCwgdHlwZSwgc2VuZGVyQWRkcmVzcywgdm90ZUtleUJhc2U2NCwgdm90ZUxhc3RCbG9jaztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHR4VG9IZXggPSBCdWZmZXIuZnJvbSh0eEhleCwgJ2Jhc2U2NCcpO1xuICAgICAgICBjb25zdCBkZWNvZGVkVHggPSBFbmNvZGluZy5kZWNvZGUodHhUb0hleCk7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIGEgc2lnbmVkIG1zaWcgdHgsIHRoZSBzdHJ1Y3R1cmUgYWN0dWFsbHkgaGFzIHRoZSB7IG1zaWcsIHR4biB9IGFzIHRoZSByb290IG9iamVjdFxuICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IHNpZ25lZCwgdGhlIGRlY29kZWQgdHggaXMgdGhlIHR4biAtIHJlZmVyIHRvIHBhcnRpYWxTaWduVHhuIGFuZCBNdWx0aVNpZyBjb25zdHJ1Y3RvclxuICAgICAgICAvLyAgIGluIGFsZ29zZGsgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAgICAgICAgY29uc3QgdHhuRm9yRGVjb2RpbmcgPSBkZWNvZGVkVHgudHhuIHx8IGRlY29kZWRUeDtcbiAgICAgICAgaWYgKCEhdHhuRm9yRGVjb2Rpbmcudm90ZWtleSkge1xuICAgICAgICAgIHR5cGUgPSB0eG5Gb3JEZWNvZGluZy50eXBlO1xuICAgICAgICAgIHNlbmRlckFkZHJlc3MgPSBBZGRyZXNzLmVuY29kZSh0eG5Gb3JEZWNvZGluZy5zbmQpO1xuICAgICAgICAgIHZvdGVLZXlCYXNlNjQgPSB0eG5Gb3JEZWNvZGluZy52b3Rla2V5LnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgICB2b3RlTGFzdEJsb2NrID0gdHhuRm9yRGVjb2Rpbmcudm90ZWxzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHR4ID0gTXVsdGlzaWcuTXVsdGlTaWdUcmFuc2FjdGlvbi5mcm9tX29ial9mb3JfZW5jb2RpbmcodHhuRm9yRGVjb2RpbmcpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eEhleCBuZWVkcyB0byBiZSBhIHZhbGlkIHR4IGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpZCA9IHR4LnR4SUQoKTtcbiAgICAgIGNvbnN0IGZlZSA9IHsgZmVlOiB0eC5mZWUgfTtcblxuICAgICAgY29uc3Qgb3V0cHV0QW1vdW50ID0gdHguYW1vdW50IHx8IDA7XG4gICAgICBjb25zdCBvdXRwdXRzOiB7IGFtb3VudDogbnVtYmVyOyBhZGRyZXNzOiBzdHJpbmcgfVtdID0gW107XG4gICAgICBpZiAodHgudG8pIHtcbiAgICAgICAgb3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICBhbW91bnQ6IG91dHB1dEFtb3VudCxcbiAgICAgICAgICBhZGRyZXNzOiBBZGRyZXNzLmVuY29kZShuZXcgVWludDhBcnJheSh0eC50by5wdWJsaWNLZXkpKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE8oQ1QtNDgwKTogYWRkIHJlY2lldmluZyBhZGRyZXNzIGRpc3BsYXkgaGVyZVxuICAgICAgY29uc3QgbWVtbyA9IHR4Lm5vdGU7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXlPcmRlcjogW1xuICAgICAgICAgICdpZCcsXG4gICAgICAgICAgJ291dHB1dEFtb3VudCcsXG4gICAgICAgICAgJ2NoYW5nZUFtb3VudCcsXG4gICAgICAgICAgJ291dHB1dHMnLFxuICAgICAgICAgICdjaGFuZ2VPdXRwdXRzJyxcbiAgICAgICAgICAnZmVlJyxcbiAgICAgICAgICAnbWVtbycsXG4gICAgICAgICAgJ3R5cGUnLFxuICAgICAgICAgICdzZW5kZXJBZGRyZXNzJyxcbiAgICAgICAgICAndm90ZUtleUJhc2U2NCcsXG4gICAgICAgICAgJ3ZvdGVMYXN0QmxvY2snLFxuICAgICAgICBdLFxuICAgICAgICBpZCxcbiAgICAgICAgb3V0cHV0cyxcbiAgICAgICAgb3V0cHV0QW1vdW50LFxuICAgICAgICBjaGFuZ2VBbW91bnQ6IDAsXG4gICAgICAgIGZlZSxcbiAgICAgICAgY2hhbmdlT3V0cHV0czogW10sXG4gICAgICAgIG1lbW8sXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHNlbmRlckFkZHJlc3MsXG4gICAgICAgIHZvdGVLZXlCYXNlNjQsXG4gICAgICAgIHZvdGVMYXN0QmxvY2ssXG4gICAgICB9O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgaXNTdGVsbGFyU2VlZChzZWVkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gU2VlZFZhbGlkYXRvci5pc1ZhbGlkRWQyNTUxOVNlZWRGb3JDb2luKHNlZWQsIENvaW5GYW1pbHkuWExNKTtcbiAgfVxuXG4gIGNvbnZlcnRGcm9tU3RlbGxhclNlZWQoc2VlZDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgLy8gYXNzdW1lIHRoaXMgaXMgYSB0cnVzdCBjdXN0b2RpYWwgc2VlZCBpZiBpdHMgYSB2YWxpZCBlZDI1NTE5IHBydlxuICAgIGlmICghdGhpcy5pc1N0ZWxsYXJTZWVkKHNlZWQpIHx8IFNlZWRWYWxpZGF0b3IuaGFzQ29tcGV0aW5nU2VlZEZvcm1hdHMoc2VlZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChTZWVkVmFsaWRhdG9yLmlzVmFsaWRFZDI1NTE5U2VlZEZvckNvaW4oc2VlZCwgQ29pbkZhbWlseS5YTE0pKSB7XG4gICAgICByZXR1cm4gU2VlZC5lbmNvZGUoc3RlbGxhci5TdHJLZXkuZGVjb2RlRWQyNTUxOVNlY3JldFNlZWQoc2VlZCkpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmVyaWZ5U2lnblRyYW5zYWN0aW9uUGFyYW1zKHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFZlcmlmaWVkVHJhbnNhY3Rpb25QYXJhbWV0ZXJzIHtcbiAgICBjb25zdCBwcnYgPSBwYXJhbXMucHJ2O1xuICAgIGNvbnN0IGFkZHJlc3NWZXJzaW9uID0gcGFyYW1zLnR4UHJlYnVpbGQuYWRkcmVzc1ZlcnNpb247XG4gICAgbGV0IGlzSGFsZlNpZ25lZCA9IGZhbHNlO1xuXG4gICAgLy8gaXQncyBwb3NzaWJsZSB0aGlzIHR4IHdhcyBhbHJlYWR5IHNpZ25lZCAtIHRha2UgdGhlIGhhbGZTaWduZWRcbiAgICAvLyB0eEhleCBpZiBpdCBpc1xuICAgIGxldCB0eEhleCA9IHBhcmFtcy50eFByZWJ1aWxkLnR4SGV4O1xuICAgIGlmIChwYXJhbXMudHhQcmVidWlsZC5oYWxmU2lnbmVkKSB7XG4gICAgICBpc0hhbGZTaWduZWQgPSB0cnVlO1xuICAgICAgdHhIZXggPSBwYXJhbXMudHhQcmVidWlsZC5oYWxmU2lnbmVkLnR4SGV4O1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHR4SGV4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHR4UHJlYnVpbGQgcGFyYW1ldGVyJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHR4SGV4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eFByZWJ1aWxkIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgdHlwZSAke3R5cGVvZiB0eEhleH1gKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHJ2IHBhcmFtZXRlciB0byBzaWduIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBydikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcHJ2IG11c3QgYmUgYSBzdHJpbmcsIGdvdCB0eXBlICR7dHlwZW9mIHBydn1gKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhXy5oYXMocGFyYW1zLnR4UHJlYnVpbGQsICdrZXlzWzBdJykgfHxcbiAgICAgICFfLmhhcyhwYXJhbXMudHhQcmVidWlsZCwgJ2tleXNbMV0nKSB8fFxuICAgICAgIV8uaGFzKHBhcmFtcy50eFByZWJ1aWxkLCAna2V5c1syXScpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHVibGljIGtleXMgcGFyYW1ldGVyIHRvIHNpZ24gdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNOdW1iZXIoYWRkcmVzc1ZlcnNpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYWRkcmVzc1ZlcnNpb24gcGFyYW1ldGVyIHRvIHNpZ24gdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBuZWVkIHRvIHJlLWVuY29kZSBvdXIgcHVibGljIGtleXMgdXNpbmcgYWxnb3NkaydzIGZvcm1hdFxuICAgIGNvbnN0IGtleXMgPSBbcGFyYW1zLnR4UHJlYnVpbGQua2V5c1swXSwgcGFyYW1zLnR4UHJlYnVpbGQua2V5c1sxXSwgcGFyYW1zLnR4UHJlYnVpbGQua2V5c1syXV07XG5cbiAgICAvLyByZS1lbmNvZGUgc2sgZnJvbSBvdXIgcHJ2ICh0aGlzIGFjdHMgYXMgYSBzZWVkIG91dCBvZiB0aGUga2V5Y2hhaW4pXG4gICAgY29uc3Qgc2VlZCA9IFNlZWQuZGVjb2RlKHBydikuc2VlZDtcbiAgICBjb25zdCBwYWlyID0gZ2VuZXJhdGVBY2NvdW50RnJvbVNlZWQoc2VlZCk7XG4gICAgY29uc3Qgc2sgPSBwYWlyLnNrO1xuXG4gICAgcmV0dXJuIHsgdHhIZXgsIGFkZHJlc3NWZXJzaW9uLCBrZXlzLCBzaywgaXNIYWxmU2lnbmVkIH07XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZCB7VHJhbnNhY3Rpb25QcmVidWlsZH0gcHJlYnVpbGQgb2JqZWN0IHJldHVybmVkIGJ5IHBsYXRmb3JtXG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2IHtTdHJpbmd9IHVzZXIgcHJ2XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Qmx1ZWJpcmQ8U2lnbmVkVHJhbnNhY3Rpb24+fVxuICAgKi9cbiAgc2lnblRyYW5zYWN0aW9uKFxuICAgIHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgICBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxTaWduZWRUcmFuc2FjdGlvbj5cbiAgKTogQmx1ZWJpcmQ8U2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288U2lnbmVkVHJhbnNhY3Rpb24+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbnN0IHsgdHhIZXgsIGFkZHJlc3NWZXJzaW9uLCBrZXlzLCBzaywgaXNIYWxmU2lnbmVkIH0gPSBzZWxmLnZlcmlmeVNpZ25UcmFuc2FjdGlvblBhcmFtcyhwYXJhbXMpO1xuICAgICAgY29uc3QgZW5jb2RlZFB1YmxpY0tleXMgPSBfLm1hcChrZXlzLCBrID0+IEFkZHJlc3MuZGVjb2RlKGspLnB1YmxpY0tleSk7XG5cbiAgICAgIC8vIGRlY29kZSBvdXIgdW5zaWduZWQvaGFsZi1zaWduZWQgdHhcbiAgICAgIGxldCB0cmFuc2FjdGlvbjtcbiAgICAgIGxldCB0eFRvSGV4O1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHhUb0hleCA9IEJ1ZmZlci5mcm9tKHR4SGV4LCAnYmFzZTY0Jyk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxEZWNvZGVkVHggPSBFbmNvZGluZy5kZWNvZGUodHhUb0hleCk7XG5cbiAgICAgICAgLy8gd2UgbmVlZCB0byBzY3J1YiB0aGUgdHhuIG9mIHNpZ3MgZm9yIGhhbGYtc2lnbmVkXG4gICAgICAgIGNvbnN0IGRlY29kZWRUeCA9IGlzSGFsZlNpZ25lZCA/IGluaXRpYWxEZWNvZGVkVHgudHhuIDogaW5pdGlhbERlY29kZWRUeDtcblxuICAgICAgICB0cmFuc2FjdGlvbiA9IE11bHRpc2lnLk11bHRpU2lnVHJhbnNhY3Rpb24uZnJvbV9vYmpfZm9yX2VuY29kaW5nKGRlY29kZWRUeCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gbmVlZHMgdG8gYmUgYSB2YWxpZCB0eCBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2lnbiBvdXIgdHhcbiAgICAgIGxldCBzaWduZWQgPSB0cmFuc2FjdGlvbi5wYXJ0aWFsU2lnblR4bih7IHZlcnNpb246IGFkZHJlc3NWZXJzaW9uLCB0aHJlc2hvbGQ6IDIsIHBrczogZW5jb2RlZFB1YmxpY0tleXMgfSwgc2spO1xuXG4gICAgICAvLyBpZiB3ZSBoYXZlIGFscmVhZHkgc2lnbmVkIGl0LCB3ZSdsbCBoYXZlIHRvIG1lcmdlIHRoYXQgd2l0aCBvdXIgcHJldmlvdXMgdHhcbiAgICAgIGlmIChpc0hhbGZTaWduZWQpIHtcbiAgICAgICAgc2lnbmVkID0gbWVyZ2VNdWx0aXNpZ1RyYW5zYWN0aW9ucyhbQnVmZmVyLmZyb20oc2lnbmVkKSwgdHhUb0hleF0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzaWduZWRCYXNlNjQgPSBCdWZmZXIuZnJvbShzaWduZWQpLnRvU3RyaW5nKCdiYXNlNjQnKTtcblxuICAgICAgaWYgKGlzSGFsZlNpZ25lZCkge1xuICAgICAgICByZXR1cm4geyB0eEhleDogc2lnbmVkQmFzZTY0IH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBoYWxmU2lnbmVkOiB7IHR4SGV4OiBzaWduZWRCYXNlNjQgfSB9O1xuICAgICAgfVxuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgcGFyc2VUcmFuc2FjdGlvbihcbiAgICBwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPFBhcnNlZFRyYW5zYWN0aW9uPlxuICApOiBCbHVlYmlyZDxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHt9KS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZlcmlmeUFkZHJlc3MocGFyYW1zOiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGJvb2xlYW4+KTogQmx1ZWJpcmQ8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHRydWUpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG59XG4iXX0=