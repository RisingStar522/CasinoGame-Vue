"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var bitcoin_1 = require("../../bitcoin");
var errors_1 = require("../../errors");
var abstractUtxoCoin_1 = require("./abstractUtxoCoin");
var _ = require("lodash");
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var prova = require('../../prova');
var Rmg = /** @class */ (function (_super) {
    __extends(Rmg, _super);
    function Rmg(bitgo, network) {
        var _this = this;
        // TODO: move to @bitgo/utxo-lib (BG-6821)
        prova.networks.rmg.coin = 'rmg';
        _this = _super.call(this, bitgo, network || prova.networks.rmg) || this;
        return _this;
    }
    Rmg.createInstance = function (bitgo) {
        return new Rmg(bitgo);
    };
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    Rmg.prototype.getBaseFactor = function () {
        return 1e6;
    };
    Rmg.prototype.getChain = function () {
        return 'rmg';
    };
    Rmg.prototype.getFamily = function () {
        return 'rmg';
    };
    Rmg.prototype.getFullName = function () {
        return 'Royal Mint Gold';
    };
    Rmg.prototype.isValidAddress = function (address) {
        return prova.Address.validateBase58(address, this.network);
    };
    /**
     * Make sure an address is valid and throw an error if it's not.
     * @param address The address string on the network
     * @param keychains Keychain objects with xpubs
     * @param chain Derivation chain
     * @param index Derivation index
     */
    Rmg.prototype.verifyAddress = function (params) {
        if (!params.keychains) {
            throw new Error('missing required param keychains');
        }
        if (!this.isValidAddress(params.address)) {
            throw new Error("invalid address: " + params.address);
        }
        var expectedAddress = this.generateAddress({
            keychains: params.keychains,
            threshold: 2,
            chain: params.chain,
            index: params.index,
        });
        if (expectedAddress.address !== params.address) {
            throw new Error("address validation failure: expected " + expectedAddress.address + " but got " + params.address);
        }
        return true;
    };
    /**
     * Generate an address for a wallet based on a set of configurations
     * @param keychains Array of objects with xpubs
     * @param threshold Minimum number of signatures
     * @param chain Derivation chain
     * @param index Derivation index
     * @returns {{chain: number, index: number, coin: number, coinSpecific: {outputScript}}}
     */
    Rmg.prototype.generateAddress = function (params) {
        var signatureThreshold = 2;
        if (_.isInteger(params.threshold)) {
            signatureThreshold = params.threshold;
            if (signatureThreshold <= 0) {
                throw new Error('threshold has to be positive');
            }
            if (signatureThreshold > params.keychains.length) {
                throw new Error('threshold cannot exceed number of keys');
            }
        }
        var derivationChain = 0;
        if (_.isNumber(params.chain) && _.isInteger(params.chain) && params.chain > 0) {
            derivationChain = params.chain;
        }
        var derivationIndex = 0;
        if (_.isInteger(params.index) && params.index > 0) {
            derivationIndex = params.index;
        }
        var path = 'm/0/0/' + derivationChain + '/' + derivationIndex;
        // do not modify the original argument
        var keychainCopy = _.cloneDeep(params.keychains);
        var userKey = keychainCopy.shift();
        if (!userKey) {
            throw new Error('invalid required param keychains - missing user key');
        }
        var aspKeyIds = keychainCopy.map(function (key) { return key.aspKeyId; });
        var userKeyNode = prova.HDNode.fromBase58(userKey.pub);
        var derivedUserKey = bitcoin_1.hdPath(userKeyNode).deriveKey(path).getPublicKeyBuffer();
        var provaAddress = new prova.Address(derivedUserKey, aspKeyIds, this.network);
        provaAddress.signatureCount = signatureThreshold;
        var addressDetails = {
            chain: derivationChain,
            index: derivationIndex,
            coin: this.getChain(),
            coinSpecific: {
                outputScript: provaAddress.toScript().toString('hex')
            },
        };
        try {
            addressDetails.address = provaAddress.toString();
        }
        catch (e) {
            // non-(n-1)/n signature count
            addressDetails.address = null;
        }
        return addressDetails;
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @param callback
     * @returns {Bluebird<SignedTransaction>}
     */
    Rmg.prototype.signTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txPrebuild, userPrv, transaction, keychain, signatureIssues, keychainHdPath, index, currentUnspent, path, privKey, currentSignatureIssue, unspentAddress, subscript, txb, isValidSignature, failedIndices, error;
            return __generator(this, function (_a) {
                txPrebuild = params.txPrebuild;
                userPrv = params.prv;
                if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
                    if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                        throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
                    }
                    throw new Error('missing txPrebuild parameter');
                }
                transaction = prova.Transaction.fromHex(txPrebuild.txHex);
                if (transaction.ins.length !== txPrebuild.txInfo.unspents.length) {
                    throw new Error('length of unspents array should equal to the number of transaction inputs');
                }
                if (_.isUndefined(userPrv) || !_.isString(userPrv)) {
                    if (!_.isUndefined(userPrv) && !_.isString(userPrv)) {
                        throw new Error("prv must be a string, got type " + typeof userPrv);
                    }
                    throw new Error('missing prv parameter to sign transaction');
                }
                keychain = prova.HDNode.fromBase58(userPrv, self.network);
                signatureIssues = [];
                keychainHdPath = bitcoin_1.hdPath(keychain);
                for (index = 0; index < transaction.ins.length; ++index) {
                    currentUnspent = txPrebuild.txInfo.unspents[index];
                    path = 'm/0/0/' + currentUnspent.chain + '/' + currentUnspent.index;
                    privKey = keychainHdPath.deriveKey(path);
                    currentSignatureIssue = {
                        inputIndex: index,
                        unspent: currentUnspent,
                        path: path
                    };
                    unspentAddress = prova.Address.fromBase58(currentUnspent.address);
                    subscript = unspentAddress.toScript();
                    txb = prova.TransactionBuilder.fromTransaction(transaction, self.network);
                    try {
                        txb.sign(index, privKey, subscript, currentUnspent.value);
                    }
                    catch (e) {
                        currentSignatureIssue.error = e;
                        signatureIssues.push(currentSignatureIssue);
                        continue;
                    }
                    transaction = txb.buildIncomplete();
                    isValidSignature = self.verifySignature(transaction, index, currentUnspent.value);
                    if (!isValidSignature) {
                        currentSignatureIssue.error = new Error('invalid signature');
                        signatureIssues.push(currentSignatureIssue);
                    }
                }
                if (signatureIssues.length > 0) {
                    failedIndices = signatureIssues.map(function (currentIssue) { return currentIssue.inputIndex; });
                    error = new Error("Failed to sign inputs at indices " + failedIndices.join(', '));
                    error.code = 'input_signature_failure';
                    error.signingErrors = signatureIssues;
                    throw error;
                }
                return [2 /*return*/, {
                        txHex: transaction.toHex()
                    }];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Verify the signature(s) on a (half-signed) transaction
     * @param transaction provajs-lib tx object
     * @param inputIndex The input whose signature is to be verified
     * @param amount The input amount needs to be known for signature verification
     * @param verificationSettings
     * @param verificationSettings.signatureIndex The index of the signature to verify (only iterates over non-empty signatures)
     * @param verificationSettings.publicKey The hex of the public key to verify (will verify all signatures)
     * @returns {boolean}
     */
    Rmg.prototype.verifySignature = function (transaction, inputIndex, amount, verificationSettings) {
        if (verificationSettings === void 0) { verificationSettings = {}; }
        if (!(transaction instanceof prova.Transaction)) {
            throw new Error('transaction has to be an instance of prova.Transaction');
        }
        var currentInput = transaction.ins[inputIndex];
        var signatureScript = currentInput.script;
        var decompiledSigScript = prova.script.decompile(signatureScript);
        // the public keys are all the even-indexed entries
        var publicKeys = _.filter(decompiledSigScript, function (item, index) { return index % 2 === 0; });
        // convert the keys to their hex representations
        var publicKeyHexes = _.map(publicKeys, function (k) { return k.toString('hex'); });
        // the signatures are all the odd-indexed ones
        var signatures = _.filter(decompiledSigScript, function (item, index) { return index % 2 === 1; });
        // we map them to each other
        var signaturesByKeys = _.zipObject(publicKeyHexes, signatures);
        var publicKeysToVerify = publicKeyHexes;
        var publicKeyHex = verificationSettings.publicKey;
        if (!_.isUndefined(verificationSettings.signatureIndex)) {
            publicKeysToVerify = [publicKeyHexes[verificationSettings.signatureIndex]];
        }
        var areAllSignaturesValid = true;
        for (var _i = 0, publicKeysToVerify_1 = publicKeysToVerify; _i < publicKeysToVerify_1.length; _i++) {
            var currentPublicKeyHex = publicKeysToVerify_1[_i];
            if (!_.isUndefined(publicKeyHex) && publicKeyHex !== currentPublicKeyHex) {
                areAllSignaturesValid = false;
                continue;
            }
            if (_.isEmpty(currentPublicKeyHex)) {
                areAllSignaturesValid = false;
                continue;
            }
            var isSignatureValid = false;
            var publicKeyBuffer = Buffer.from(currentPublicKeyHex, 'hex');
            var signatureBuffer = signaturesByKeys[currentPublicKeyHex];
            if (Buffer.isBuffer(publicKeyBuffer) && publicKeyBuffer.length > 0 && Buffer.isBuffer(signatureBuffer) && signatureBuffer.length > 0) {
                var publicKey = prova.ECPair.fromPublicKeyBuffer(publicKeyBuffer);
                var signatureHash = transaction.hashForWitnessV0(inputIndex, null, amount, prova.Transaction.SIGHASH_ALL);
                isSignatureValid = publicKey.verify(signatureHash, signatureBuffer);
            }
            if (!_.isUndefined(publicKeyHex) && isSignatureValid) {
                // We were trying to see if any of the signatures was valid for the given public key. Evidently yes.
                return true;
            }
            areAllSignaturesValid = isSignatureValid && areAllSignaturesValid;
        }
        return areAllSignaturesValid;
    };
    /**
     * Explain/parse transaction
     * @param params
     * @param callback
     */
    Rmg.prototype.explainTransaction = function (params, callback) {
        return co(function () {
            var self, transaction, id, changeAddresses, spendAmount, changeAmount, explanation;
            return __generator(this, function (_a) {
                self = this;
                transaction = prova.Transaction.fromHex(params.txHex);
                id = transaction.getId();
                changeAddresses = [];
                spendAmount = 0;
                changeAmount = 0;
                if (params.txInfo && params.txInfo.changeAddresses) {
                    changeAddresses = params.txInfo.changeAddresses;
                }
                explanation = {
                    displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs'],
                    id: id,
                    outputs: [],
                    changeOutputs: []
                };
                transaction.outs.forEach(function (currentOutput) {
                    var currentAddress = prova.Address.fromScript(currentOutput.script, self.network).toString();
                    var currentAmount = currentOutput.value;
                    if (changeAddresses.indexOf(currentAddress) !== -1) {
                        // this is change
                        changeAmount += currentAmount;
                        explanation.changeOutputs.push({
                            address: currentAddress,
                            amount: currentAmount
                        });
                        return;
                    }
                    spendAmount += currentAmount;
                    explanation.outputs.push({
                        address: currentAddress,
                        amount: currentAmount
                    });
                });
                explanation.outputAmount = spendAmount;
                explanation.changeAmount = changeAmount;
                // add fee info if available
                if (params.feeInfo) {
                    explanation.displayOrder.push('fee');
                    explanation.fee = params.feeInfo;
                }
                return [2 /*return*/, explanation];
            });
        }).call(this).asCallback(callback);
    };
    Rmg.prototype.getAddressInfoFromExplorer = function (address) {
        throw new errors_1.MethodNotImplementedError();
    };
    Rmg.prototype.getUnspentInfoFromExplorer = function (address) {
        throw new errors_1.MethodNotImplementedError();
    };
    return Rmg;
}(abstractUtxoCoin_1.AbstractUtxoCoin));
exports.Rmg = Rmg;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm1nLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3JtZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx5Q0FBdUM7QUFFdkMsdUNBQXlEO0FBRXpELHVEQU00QjtBQUU1QiwwQkFBNEI7QUFDNUIsbUNBQXFDO0FBQ3JDLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUFDOUIsSUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBRXJDO0lBQXlCLHVCQUFnQjtJQUN2QyxhQUFZLEtBQVksRUFBRSxPQUFRO1FBQWxDLGlCQUlDO1FBSEMsMENBQTBDO1FBQzFDLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDaEMsUUFBQSxrQkFBTSxLQUFLLEVBQUUsT0FBTyxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFNBQUM7O0lBQzlDLENBQUM7SUFFTSxrQkFBYyxHQUFyQixVQUFzQixLQUFZO1FBQ2hDLE9BQU8sSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILDJCQUFhLEdBQWI7UUFDRSxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRCxzQkFBUSxHQUFSO1FBQ0UsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsdUJBQVMsR0FBVDtRQUNFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVELHlCQUFXLEdBQVg7UUFDRSxPQUFPLGlCQUFpQixDQUFDO0lBQzNCLENBQUM7SUFFRCw0QkFBYyxHQUFkLFVBQWUsT0FBZTtRQUM1QixPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFD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QVcsSUFBSSxhQUFhLENBQUM7b0JBQzdCLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO3dCQUN2QixPQUFPLEVBQUUsY0FBYzt3QkFDdkIsTUFBTSxFQUFFLGFBQWE7cUJBQ3RCLENBQUMsQ0FBQztnQkFDTCxDQUFDLENBQUMsQ0FBQztnQkFDSCxXQUFXLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztnQkFDdkMsV0FBVyxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7Z0JBRXhDLDRCQUE0QjtnQkFDNUIsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFO29CQUNsQixXQUFXLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDckMsV0FBVyxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO2lCQUNsQztnQkFDRCxzQkFBTyxXQUFXLEVBQUM7O1NBQ3BCLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFUyx3Q0FBMEIsR0FBcEMsVUFBcUMsT0FBZTtRQUNsRCxNQUFNLElBQUksa0NBQXlCLEVBQUUsQ0FBQztJQUN4QyxDQUFDO0lBRVMsd0NBQTBCLEdBQXBDLFVBQXFDLE9BQWU7UUFDbEQsTUFBTSxJQUFJLGtDQUF5QixFQUFFLENBQUM7SUFDeEMsQ0FBQztJQUNILFVBQUM7QUFBRCxDQUFDLEFBdlZELENBQXlCLG1DQUFnQixHQXVWeEM7QUF2Vlksa0JBQUciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoZFBhdGggfSBmcm9tICcuLi8uLi9iaXRjb2luJztcbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vLi4vYml0Z28nO1xuaW1wb3J0IHsgTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBCYXNlQ29pbiwgU2lnbmVkVHJhbnNhY3Rpb24gfSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQge1xuICBBYnN0cmFjdFV0eG9Db2luLCBBZGRyZXNzSW5mbyxcbiAgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiwgVW5zcGVudEluZm8sXG4gIEdlbmVyYXRlQWRkcmVzc09wdGlvbnMsIEFkZHJlc3NEZXRhaWxzLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zLCBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbn0gZnJvbSAnLi9hYnN0cmFjdFV0eG9Db2luJztcbmltcG9ydCB7IE5vZGVDYWxsYmFjayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIEJsdWViaXJkIGZyb20gJ2JsdWViaXJkJztcbmNvbnN0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuY29uc3QgcHJvdmEgPSByZXF1aXJlKCcuLi8uLi9wcm92YScpO1xuXG5leHBvcnQgY2xhc3MgUm1nIGV4dGVuZHMgQWJzdHJhY3RVdHhvQ29pbiB7XG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHbywgbmV0d29yaz8pIHtcbiAgICAvLyBUT0RPOiBtb3ZlIHRvIEBiaXRnby91dHhvLWxpYiAoQkctNjgyMSlcbiAgICBwcm92YS5uZXR3b3Jrcy5ybWcuY29pbiA9ICdybWcnO1xuICAgIHN1cGVyKGJpdGdvLCBuZXR3b3JrIHx8IHByb3ZhLm5ldHdvcmtzLnJtZyk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvKTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgUm1nKGJpdGdvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmYWN0b3IgYmV0d2VlbiB0aGUgYmFzZSB1bml0IGFuZCBpdHMgc21hbGxlc3Qgc3ViZGl2aXNvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRCYXNlRmFjdG9yKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIDFlNjtcbiAgfVxuXG4gIGdldENoYWluKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdybWcnO1xuICB9XG5cbiAgZ2V0RmFtaWx5KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdybWcnO1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ1JveWFsIE1pbnQgR29sZCc7XG4gIH1cblxuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcHJvdmEuQWRkcmVzcy52YWxpZGF0ZUJhc2U1OChhZGRyZXNzLCB0aGlzLm5ldHdvcmspO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2Ugc3VyZSBhbiBhZGRyZXNzIGlzIHZhbGlkIGFuZCB0aHJvdyBhbiBlcnJvciBpZiBpdCdzIG5vdC5cbiAgICogQHBhcmFtIGFkZHJlc3MgVGhlIGFkZHJlc3Mgc3RyaW5nIG9uIHRoZSBuZXR3b3JrXG4gICAqIEBwYXJhbSBrZXljaGFpbnMgS2V5Y2hhaW4gb2JqZWN0cyB3aXRoIHhwdWJzXG4gICAqIEBwYXJhbSBjaGFpbiBEZXJpdmF0aW9uIGNoYWluXG4gICAqIEBwYXJhbSBpbmRleCBEZXJpdmF0aW9uIGluZGV4XG4gICAqL1xuICB2ZXJpZnlBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpIHtcbiAgICBpZiAoIXBhcmFtcy5rZXljaGFpbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwYXJhbSBrZXljaGFpbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MocGFyYW1zLmFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHtwYXJhbXMuYWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBleHBlY3RlZEFkZHJlc3M6IGFueSA9IHRoaXMuZ2VuZXJhdGVBZGRyZXNzKHtcbiAgICAgIGtleWNoYWluczogcGFyYW1zLmtleWNoYWlucyxcbiAgICAgIHRocmVzaG9sZDogMixcbiAgICAgIGNoYWluOiBwYXJhbXMuY2hhaW4sXG4gICAgICBpbmRleDogcGFyYW1zLmluZGV4LFxuICAgIH0pO1xuXG4gICAgaWYgKGV4cGVjdGVkQWRkcmVzcy5hZGRyZXNzICE9PSBwYXJhbXMuYWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhZGRyZXNzIHZhbGlkYXRpb24gZmFpbHVyZTogZXhwZWN0ZWQgJHtleHBlY3RlZEFkZHJlc3MuYWRkcmVzc30gYnV0IGdvdCAke3BhcmFtcy5hZGRyZXNzfWApO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIGFkZHJlc3MgZm9yIGEgd2FsbGV0IGJhc2VkIG9uIGEgc2V0IG9mIGNvbmZpZ3VyYXRpb25zXG4gICAqIEBwYXJhbSBrZXljaGFpbnMgQXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHhwdWJzXG4gICAqIEBwYXJhbSB0aHJlc2hvbGQgTWluaW11bSBudW1iZXIgb2Ygc2lnbmF0dXJlc1xuICAgKiBAcGFyYW0gY2hhaW4gRGVyaXZhdGlvbiBjaGFpblxuICAgKiBAcGFyYW0gaW5kZXggRGVyaXZhdGlvbiBpbmRleFxuICAgKiBAcmV0dXJucyB7e2NoYWluOiBudW1iZXIsIGluZGV4OiBudW1iZXIsIGNvaW46IG51bWJlciwgY29pblNwZWNpZmljOiB7b3V0cHV0U2NyaXB0fX19XG4gICAqL1xuICBnZW5lcmF0ZUFkZHJlc3MocGFyYW1zOiBHZW5lcmF0ZUFkZHJlc3NPcHRpb25zKTogQWRkcmVzc0RldGFpbHMge1xuICAgIGxldCBzaWduYXR1cmVUaHJlc2hvbGQgPSAyO1xuICAgIGlmIChfLmlzSW50ZWdlcihwYXJhbXMudGhyZXNob2xkKSkge1xuICAgICAgc2lnbmF0dXJlVGhyZXNob2xkID0gcGFyYW1zLnRocmVzaG9sZDtcbiAgICAgIGlmIChzaWduYXR1cmVUaHJlc2hvbGQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RocmVzaG9sZCBoYXMgdG8gYmUgcG9zaXRpdmUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduYXR1cmVUaHJlc2hvbGQgPiBwYXJhbXMua2V5Y2hhaW5zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RocmVzaG9sZCBjYW5ub3QgZXhjZWVkIG51bWJlciBvZiBrZXlzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGRlcml2YXRpb25DaGFpbiA9IDA7XG4gICAgaWYgKF8uaXNOdW1iZXIocGFyYW1zLmNoYWluKSAmJiBfLmlzSW50ZWdlcihwYXJhbXMuY2hhaW4pICYmIHBhcmFtcy5jaGFpbiA+IDApIHtcbiAgICAgIGRlcml2YXRpb25DaGFpbiA9IHBhcmFtcy5jaGFpbjtcbiAgICB9XG5cbiAgICBsZXQgZGVyaXZhdGlvbkluZGV4ID0gMDtcbiAgICBpZiAoXy5pc0ludGVnZXIocGFyYW1zLmluZGV4KSAmJiBwYXJhbXMuaW5kZXggPiAwKSB7XG4gICAgICBkZXJpdmF0aW9uSW5kZXggPSBwYXJhbXMuaW5kZXg7XG4gICAgfVxuXG4gICAgY29uc3QgcGF0aCA9ICdtLzAvMC8nICsgZGVyaXZhdGlvbkNoYWluICsgJy8nICsgZGVyaXZhdGlvbkluZGV4O1xuICAgIC8vIGRvIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIGFyZ3VtZW50XG4gICAgY29uc3Qga2V5Y2hhaW5Db3B5ID0gXy5jbG9uZURlZXAocGFyYW1zLmtleWNoYWlucyk7XG4gICAgY29uc3QgdXNlcktleSA9IGtleWNoYWluQ29weS5zaGlmdCgpO1xuXG4gICAgaWYgKCF1c2VyS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVxdWlyZWQgcGFyYW0ga2V5Y2hhaW5zIC0gbWlzc2luZyB1c2VyIGtleScpO1xuICAgIH1cbiAgICBjb25zdCBhc3BLZXlJZHMgPSBrZXljaGFpbkNvcHkubWFwKChrZXkpID0+IGtleS5hc3BLZXlJZCk7XG4gICAgY29uc3QgdXNlcktleU5vZGUgPSBwcm92YS5IRE5vZGUuZnJvbUJhc2U1OCh1c2VyS2V5LnB1Yik7XG4gICAgY29uc3QgZGVyaXZlZFVzZXJLZXkgPSBoZFBhdGgodXNlcktleU5vZGUpLmRlcml2ZUtleShwYXRoKS5nZXRQdWJsaWNLZXlCdWZmZXIoKTtcblxuICAgIGNvbnN0IHByb3ZhQWRkcmVzcyA9IG5ldyBwcm92YS5BZGRyZXNzKGRlcml2ZWRVc2VyS2V5LCBhc3BLZXlJZHMsIHRoaXMubmV0d29yayk7XG4gICAgcHJvdmFBZGRyZXNzLnNpZ25hdHVyZUNvdW50ID0gc2lnbmF0dXJlVGhyZXNob2xkO1xuXG4gICAgY29uc3QgYWRkcmVzc0RldGFpbHM6IGFueSA9IHtcbiAgICAgIGNoYWluOiBkZXJpdmF0aW9uQ2hhaW4sXG4gICAgICBpbmRleDogZGVyaXZhdGlvbkluZGV4LFxuICAgICAgY29pbjogdGhpcy5nZXRDaGFpbigpLFxuICAgICAgY29pblNwZWNpZmljOiB7XG4gICAgICAgIG91dHB1dFNjcmlwdDogcHJvdmFBZGRyZXNzLnRvU2NyaXB0KCkudG9TdHJpbmcoJ2hleCcpXG4gICAgICB9LFxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgYWRkcmVzc0RldGFpbHMuYWRkcmVzcyA9IHByb3ZhQWRkcmVzcy50b1N0cmluZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5vbi0obi0xKS9uIHNpZ25hdHVyZSBjb3VudFxuICAgICAgYWRkcmVzc0RldGFpbHMuYWRkcmVzcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZHJlc3NEZXRhaWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VtYmxlIGtleWNoYWluIGFuZCBoYWxmLXNpZ24gcHJlYnVpbHQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHR4UHJlYnVpbGRcbiAgICogLSBwcnZcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj59XG4gICAqL1xuICBzaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxTaWduZWRUcmFuc2FjdGlvbj4pOiBCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxTaWduZWRUcmFuc2FjdGlvbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IHR4UHJlYnVpbGQgPSBwYXJhbXMudHhQcmVidWlsZDtcbiAgICAgIGNvbnN0IHVzZXJQcnYgPSBwYXJhbXMucHJ2O1xuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh0eFByZWJ1aWxkKSB8fCAhXy5pc09iamVjdCh0eFByZWJ1aWxkKSkge1xuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQodHhQcmVidWlsZCkgJiYgIV8uaXNPYmplY3QodHhQcmVidWlsZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHR4UHJlYnVpbGQgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCB0eXBlICR7dHlwZW9mIHR4UHJlYnVpbGR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHR4UHJlYnVpbGQgcGFyYW1ldGVyJyk7XG4gICAgICB9XG5cbiAgICAgIGxldCB0cmFuc2FjdGlvbiA9IHByb3ZhLlRyYW5zYWN0aW9uLmZyb21IZXgodHhQcmVidWlsZC50eEhleCk7XG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbi5pbnMubGVuZ3RoICE9PSB0eFByZWJ1aWxkLnR4SW5mby51bnNwZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2YgdW5zcGVudHMgYXJyYXkgc2hvdWxkIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgdHJhbnNhY3Rpb24gaW5wdXRzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHVzZXJQcnYpIHx8ICFfLmlzU3RyaW5nKHVzZXJQcnYpKSB7XG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh1c2VyUHJ2KSAmJiAhXy5pc1N0cmluZyh1c2VyUHJ2KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJ2IG11c3QgYmUgYSBzdHJpbmcsIGdvdCB0eXBlICR7dHlwZW9mIHVzZXJQcnZ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBydiBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXljaGFpbiA9IHByb3ZhLkhETm9kZS5mcm9tQmFzZTU4KHVzZXJQcnYsIHNlbGYubmV0d29yayk7XG5cbiAgICAgIGNvbnN0IHNpZ25hdHVyZUlzc3VlczogYW55W10gPSBbXTtcbiAgICAgIGNvbnN0IGtleWNoYWluSGRQYXRoID0gaGRQYXRoKGtleWNoYWluKTtcblxuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRyYW5zYWN0aW9uLmlucy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFVuc3BlbnQgPSB0eFByZWJ1aWxkLnR4SW5mby51bnNwZW50c1tpbmRleF07XG4gICAgICAgIGNvbnN0IHBhdGggPSAnbS8wLzAvJyArIGN1cnJlbnRVbnNwZW50LmNoYWluICsgJy8nICsgY3VycmVudFVuc3BlbnQuaW5kZXg7XG4gICAgICAgIGNvbnN0IHByaXZLZXkgPSBrZXljaGFpbkhkUGF0aC5kZXJpdmVLZXkocGF0aCk7XG5cbiAgICAgICAgY29uc3QgY3VycmVudFNpZ25hdHVyZUlzc3VlOiBhbnkgPSB7XG4gICAgICAgICAgaW5wdXRJbmRleDogaW5kZXgsXG4gICAgICAgICAgdW5zcGVudDogY3VycmVudFVuc3BlbnQsXG4gICAgICAgICAgcGF0aDogcGF0aFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHVuc3BlbnRBZGRyZXNzID0gcHJvdmEuQWRkcmVzcy5mcm9tQmFzZTU4KGN1cnJlbnRVbnNwZW50LmFkZHJlc3MpO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHQgPSB1bnNwZW50QWRkcmVzcy50b1NjcmlwdCgpO1xuICAgICAgICBjb25zdCB0eGIgPSBwcm92YS5UcmFuc2FjdGlvbkJ1aWxkZXIuZnJvbVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBzZWxmLm5ldHdvcmspO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHR4Yi5zaWduKGluZGV4LCBwcml2S2V5LCBzdWJzY3JpcHQsIGN1cnJlbnRVbnNwZW50LnZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGN1cnJlbnRTaWduYXR1cmVJc3N1ZS5lcnJvciA9IGU7XG4gICAgICAgICAgc2lnbmF0dXJlSXNzdWVzLnB1c2goY3VycmVudFNpZ25hdHVyZUlzc3VlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zYWN0aW9uID0gdHhiLmJ1aWxkSW5jb21wbGV0ZSgpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkU2lnbmF0dXJlID0gc2VsZi52ZXJpZnlTaWduYXR1cmUodHJhbnNhY3Rpb24sIGluZGV4LCBjdXJyZW50VW5zcGVudC52YWx1ZSk7XG4gICAgICAgIGlmICghaXNWYWxpZFNpZ25hdHVyZSkge1xuICAgICAgICAgIGN1cnJlbnRTaWduYXR1cmVJc3N1ZS5lcnJvciA9IG5ldyBFcnJvcignaW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICAgICAgICBzaWduYXR1cmVJc3N1ZXMucHVzaChjdXJyZW50U2lnbmF0dXJlSXNzdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaWduYXR1cmVJc3N1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBmYWlsZWRJbmRpY2VzID0gc2lnbmF0dXJlSXNzdWVzLm1hcChjdXJyZW50SXNzdWUgPT4gY3VycmVudElzc3VlLmlucHV0SW5kZXgpO1xuICAgICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKGBGYWlsZWQgdG8gc2lnbiBpbnB1dHMgYXQgaW5kaWNlcyAke2ZhaWxlZEluZGljZXMuam9pbignLCAnKX1gKTtcbiAgICAgICAgZXJyb3IuY29kZSA9ICdpbnB1dF9zaWduYXR1cmVfZmFpbHVyZSc7XG4gICAgICAgIGVycm9yLnNpZ25pbmdFcnJvcnMgPSBzaWduYXR1cmVJc3N1ZXM7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eEhleDogdHJhbnNhY3Rpb24udG9IZXgoKVxuICAgICAgfTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhlIHNpZ25hdHVyZShzKSBvbiBhIChoYWxmLXNpZ25lZCkgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uIHByb3ZhanMtbGliIHR4IG9iamVjdFxuICAgKiBAcGFyYW0gaW5wdXRJbmRleCBUaGUgaW5wdXQgd2hvc2Ugc2lnbmF0dXJlIGlzIHRvIGJlIHZlcmlmaWVkXG4gICAqIEBwYXJhbSBhbW91bnQgVGhlIGlucHV0IGFtb3VudCBuZWVkcyB0byBiZSBrbm93biBmb3Igc2lnbmF0dXJlIHZlcmlmaWNhdGlvblxuICAgKiBAcGFyYW0gdmVyaWZpY2F0aW9uU2V0dGluZ3NcbiAgICogQHBhcmFtIHZlcmlmaWNhdGlvblNldHRpbmdzLnNpZ25hdHVyZUluZGV4IFRoZSBpbmRleCBvZiB0aGUgc2lnbmF0dXJlIHRvIHZlcmlmeSAob25seSBpdGVyYXRlcyBvdmVyIG5vbi1lbXB0eSBzaWduYXR1cmVzKVxuICAgKiBAcGFyYW0gdmVyaWZpY2F0aW9uU2V0dGluZ3MucHVibGljS2V5IFRoZSBoZXggb2YgdGhlIHB1YmxpYyBrZXkgdG8gdmVyaWZ5ICh3aWxsIHZlcmlmeSBhbGwgc2lnbmF0dXJlcylcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICB2ZXJpZnlTaWduYXR1cmUodHJhbnNhY3Rpb246IGFueSwgaW5wdXRJbmRleDogbnVtYmVyLCBhbW91bnQ/OiBudW1iZXIsIHZlcmlmaWNhdGlvblNldHRpbmdzOiB7IHNpZ25hdHVyZUluZGV4PzogbnVtYmVyOyBwdWJsaWNLZXk/OiBzdHJpbmc7IH0gPSB7fSk6IGJvb2xlYW4ge1xuICAgIGlmICghKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgcHJvdmEuVHJhbnNhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIGhhcyB0byBiZSBhbiBpbnN0YW5jZSBvZiBwcm92YS5UcmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRJbnB1dCA9IHRyYW5zYWN0aW9uLmluc1tpbnB1dEluZGV4XTtcbiAgICBjb25zdCBzaWduYXR1cmVTY3JpcHQgPSBjdXJyZW50SW5wdXQuc2NyaXB0O1xuICAgIGNvbnN0IGRlY29tcGlsZWRTaWdTY3JpcHQgPSBwcm92YS5zY3JpcHQuZGVjb21waWxlKHNpZ25hdHVyZVNjcmlwdCk7XG4gICAgLy8gdGhlIHB1YmxpYyBrZXlzIGFyZSBhbGwgdGhlIGV2ZW4taW5kZXhlZCBlbnRyaWVzXG4gICAgY29uc3QgcHVibGljS2V5cyA9IF8uZmlsdGVyKGRlY29tcGlsZWRTaWdTY3JpcHQsIChpdGVtLCBpbmRleDogbnVtYmVyKSA9PiBpbmRleCAlIDIgPT09IDApO1xuICAgIC8vIGNvbnZlcnQgdGhlIGtleXMgdG8gdGhlaXIgaGV4IHJlcHJlc2VudGF0aW9uc1xuICAgIGNvbnN0IHB1YmxpY0tleUhleGVzID0gXy5tYXAocHVibGljS2V5cywgayA9PiAoayBhcyBhbnkpLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgLy8gdGhlIHNpZ25hdHVyZXMgYXJlIGFsbCB0aGUgb2RkLWluZGV4ZWQgb25lc1xuICAgIGNvbnN0IHNpZ25hdHVyZXMgPSBfLmZpbHRlcihkZWNvbXBpbGVkU2lnU2NyaXB0LCAoaXRlbSwgaW5kZXg6IG51bWJlcikgPT4gaW5kZXggJSAyID09PSAxKTtcbiAgICAvLyB3ZSBtYXAgdGhlbSB0byBlYWNoIG90aGVyXG4gICAgY29uc3Qgc2lnbmF0dXJlc0J5S2V5cyA9IF8uemlwT2JqZWN0KHB1YmxpY0tleUhleGVzLCBzaWduYXR1cmVzKTtcblxuICAgIGxldCBwdWJsaWNLZXlzVG9WZXJpZnkgPSBwdWJsaWNLZXlIZXhlcztcbiAgICBjb25zdCBwdWJsaWNLZXlIZXggPSB2ZXJpZmljYXRpb25TZXR0aW5ncy5wdWJsaWNLZXk7XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQodmVyaWZpY2F0aW9uU2V0dGluZ3Muc2lnbmF0dXJlSW5kZXgpKSB7XG4gICAgICBwdWJsaWNLZXlzVG9WZXJpZnkgPSBbcHVibGljS2V5SGV4ZXNbdmVyaWZpY2F0aW9uU2V0dGluZ3Muc2lnbmF0dXJlSW5kZXhdXTtcbiAgICB9XG5cbiAgICBsZXQgYXJlQWxsU2lnbmF0dXJlc1ZhbGlkID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IGN1cnJlbnRQdWJsaWNLZXlIZXggb2YgcHVibGljS2V5c1RvVmVyaWZ5KSB7XG5cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChwdWJsaWNLZXlIZXgpICYmIHB1YmxpY0tleUhleCAhPT0gY3VycmVudFB1YmxpY0tleUhleCkge1xuICAgICAgICBhcmVBbGxTaWduYXR1cmVzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzRW1wdHkoY3VycmVudFB1YmxpY0tleUhleCkpIHtcbiAgICAgICAgYXJlQWxsU2lnbmF0dXJlc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgaXNTaWduYXR1cmVWYWxpZCA9IGZhbHNlO1xuICAgICAgY29uc3QgcHVibGljS2V5QnVmZmVyID0gQnVmZmVyLmZyb20oY3VycmVudFB1YmxpY0tleUhleCwgJ2hleCcpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlQnVmZmVyID0gc2lnbmF0dXJlc0J5S2V5c1tjdXJyZW50UHVibGljS2V5SGV4XTtcblxuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihwdWJsaWNLZXlCdWZmZXIpICYmIHB1YmxpY0tleUJ1ZmZlci5sZW5ndGggPiAwICYmIEJ1ZmZlci5pc0J1ZmZlcihzaWduYXR1cmVCdWZmZXIpICYmIHNpZ25hdHVyZUJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHByb3ZhLkVDUGFpci5mcm9tUHVibGljS2V5QnVmZmVyKHB1YmxpY0tleUJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZUhhc2ggPSB0cmFuc2FjdGlvbi5oYXNoRm9yV2l0bmVzc1YwKGlucHV0SW5kZXgsIG51bGwsIGFtb3VudCwgcHJvdmEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEwpO1xuICAgICAgICBpc1NpZ25hdHVyZVZhbGlkID0gcHVibGljS2V5LnZlcmlmeShzaWduYXR1cmVIYXNoLCBzaWduYXR1cmVCdWZmZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQocHVibGljS2V5SGV4KSAmJiBpc1NpZ25hdHVyZVZhbGlkKSB7XG4gICAgICAgIC8vIFdlIHdlcmUgdHJ5aW5nIHRvIHNlZSBpZiBhbnkgb2YgdGhlIHNpZ25hdHVyZXMgd2FzIHZhbGlkIGZvciB0aGUgZ2l2ZW4gcHVibGljIGtleS4gRXZpZGVudGx5IHllcy5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGFyZUFsbFNpZ25hdHVyZXNWYWxpZCA9IGlzU2lnbmF0dXJlVmFsaWQgJiYgYXJlQWxsU2lnbmF0dXJlc1ZhbGlkO1xuICAgIH1cblxuICAgIHJldHVybiBhcmVBbGxTaWduYXR1cmVzVmFsaWQ7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGFpbi9wYXJzZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZXhwbGFpblRyYW5zYWN0aW9uKHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4pOiBCbHVlYmlyZDxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPiB7XG4gICAgcmV0dXJuIGNvPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+KGZ1bmN0aW9uICooKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gcHJvdmEuVHJhbnNhY3Rpb24uZnJvbUhleChwYXJhbXMudHhIZXgpO1xuICAgICAgY29uc3QgaWQgPSB0cmFuc2FjdGlvbi5nZXRJZCgpO1xuICAgICAgbGV0IGNoYW5nZUFkZHJlc3Nlczogc3RyaW5nW10gPSBbXTtcbiAgICAgIGxldCBzcGVuZEFtb3VudCA9IDA7XG4gICAgICBsZXQgY2hhbmdlQW1vdW50ID0gMDtcbiAgICAgIGlmIChwYXJhbXMudHhJbmZvICYmIHBhcmFtcy50eEluZm8uY2hhbmdlQWRkcmVzc2VzKSB7XG4gICAgICAgIGNoYW5nZUFkZHJlc3NlcyA9IHBhcmFtcy50eEluZm8uY2hhbmdlQWRkcmVzc2VzO1xuICAgICAgfVxuICAgICAgY29uc3QgZXhwbGFuYXRpb246IGFueSA9IHtcbiAgICAgICAgZGlzcGxheU9yZGVyOiBbJ2lkJywgJ291dHB1dEFtb3VudCcsICdjaGFuZ2VBbW91bnQnLCAnb3V0cHV0cycsICdjaGFuZ2VPdXRwdXRzJ10sXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIGNoYW5nZU91dHB1dHM6IFtdXG4gICAgICB9O1xuICAgICAgdHJhbnNhY3Rpb24ub3V0cy5mb3JFYWNoKGZ1bmN0aW9uKGN1cnJlbnRPdXRwdXQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEFkZHJlc3MgPSBwcm92YS5BZGRyZXNzLmZyb21TY3JpcHQoY3VycmVudE91dHB1dC5zY3JpcHQsIHNlbGYubmV0d29yaykudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEFtb3VudCA9IGN1cnJlbnRPdXRwdXQudmFsdWU7XG5cbiAgICAgICAgaWYgKGNoYW5nZUFkZHJlc3Nlcy5pbmRleE9mKGN1cnJlbnRBZGRyZXNzKSAhPT0gLTEpIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIGNoYW5nZVxuICAgICAgICAgIGNoYW5nZUFtb3VudCArPSBjdXJyZW50QW1vdW50O1xuICAgICAgICAgIGV4cGxhbmF0aW9uLmNoYW5nZU91dHB1dHMucHVzaCh7XG4gICAgICAgICAgICBhZGRyZXNzOiBjdXJyZW50QWRkcmVzcyxcbiAgICAgICAgICAgIGFtb3VudDogY3VycmVudEFtb3VudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNwZW5kQW1vdW50ICs9IGN1cnJlbnRBbW91bnQ7XG4gICAgICAgIGV4cGxhbmF0aW9uLm91dHB1dHMucHVzaCh7XG4gICAgICAgICAgYWRkcmVzczogY3VycmVudEFkZHJlc3MsXG4gICAgICAgICAgYW1vdW50OiBjdXJyZW50QW1vdW50XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBleHBsYW5hdGlvbi5vdXRwdXRBbW91bnQgPSBzcGVuZEFtb3VudDtcbiAgICAgIGV4cGxhbmF0aW9uLmNoYW5nZUFtb3VudCA9IGNoYW5nZUFtb3VudDtcblxuICAgICAgLy8gYWRkIGZlZSBpbmZvIGlmIGF2YWlsYWJsZVxuICAgICAgaWYgKHBhcmFtcy5mZWVJbmZvKSB7XG4gICAgICAgIGV4cGxhbmF0aW9uLmRpc3BsYXlPcmRlci5wdXNoKCdmZWUnKTtcbiAgICAgICAgZXhwbGFuYXRpb24uZmVlID0gcGFyYW1zLmZlZUluZm87XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwbGFuYXRpb247XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRBZGRyZXNzSW5mb0Zyb21FeHBsb3JlcihhZGRyZXNzOiBzdHJpbmcpOiBCbHVlYmlyZDxBZGRyZXNzSW5mbz4ge1xuICAgIHRocm93IG5ldyBNZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0VW5zcGVudEluZm9Gcm9tRXhwbG9yZXIoYWRkcmVzczogc3RyaW5nKTogQmx1ZWJpcmQ8VW5zcGVudEluZm9bXT4ge1xuICAgIHRocm93IG5ldyBNZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gIH1cbn1cbiJdfQ==