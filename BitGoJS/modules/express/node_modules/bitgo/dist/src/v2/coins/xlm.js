"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var bitcoin = require("@bitgo/utxo-lib");
var querystring = require("querystring");
var url = require("url");
var Bluebird = require("bluebird");
var request = require("superagent");
var stellar = require("stellar-sdk");
var bignumber_js_1 = require("bignumber.js");
var keychains_1 = require("../keychains");
var keyDeriver_1 = require("../internal/keyDeriver");
var config = require("../../config");
var common = require("../../common");
var errors_1 = require("../../errors");
var baseCoin_1 = require("../baseCoin");
var co = Bluebird.coroutine;
var Xlm = /** @class */ (function (_super) {
    __extends(Xlm, _super);
    function Xlm(bitgo) {
        var _this = _super.call(this, bitgo) || this;
        _this.homeDomain = 'bitgo.com'; // used for reverse federation lookup
        stellar.Network.use(new stellar.Network(stellar.Networks.PUBLIC));
        return _this;
    }
    Xlm.createInstance = function (bitgo) {
        return new Xlm(bitgo);
    };
    /**
     * Factor between the base unit and its smallest subdivison
     */
    Xlm.prototype.getBaseFactor = function () {
        return 1e7;
    };
    /**
     * Identifier for the blockchain which supports this coin
     */
    Xlm.prototype.getChain = function () {
        return 'xlm';
    };
    /**
     * Identifier for the coin family
     */
    Xlm.prototype.getFamily = function () {
        return 'xlm';
    };
    /**
     * Complete human-readable name of this coin
     */
    Xlm.prototype.getFullName = function () {
        return 'Stellar';
    };
    /**
     * Url at which the stellar federation server can be reached
     */
    Xlm.prototype.getFederationServerUrl = function () {
        return common.Environments[this.bitgo.getEnv()].stellarFederationServerUrl;
    };
    /**
     * Url at which horizon can be reached
     */
    Xlm.prototype.getHorizonUrl = function () {
        return 'https://horizon.stellar.org';
    };
    /**
     * Generate a new key pair on the ed25519 curve
     * @param seed
     * @returns generated pub and prv
     */
    Xlm.prototype.generateKeyPair = function (seed) {
        var pair = seed ? stellar.Keypair.fromRawEd25519Seed(seed) : stellar.Keypair.random();
        return {
            pub: pair.publicKey(),
            prv: pair.secret(),
        };
    };
    /**
     * Get decoded ed25519 public key from raw data
     *
     * @param pub Raw public key
     * @returns Encoded public key
     */
    Xlm.prototype.getPubFromRaw = function (pub) {
        return stellar.StrKey.encodeEd25519PublicKey(Buffer.from(pub, 'hex'));
    };
    /**
     * Get decoded ed25519 private key from raw data
     *
     * @param prv Raw private key
     * @returns Encoded private key
     */
    Xlm.prototype.getPrvFromRaw = function (prv) {
        return stellar.StrKey.encodeEd25519SecretSeed(Buffer.from(prv, 'hex'));
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param pub the pub to be checked
     * @returns is it valid?
     */
    Xlm.prototype.isValidPub = function (pub) {
        return stellar.StrKey.isValidEd25519PublicKey(pub);
    };
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param prv the prv to be checked
     * @returns is it valid?
     */
    Xlm.prototype.isValidPrv = function (prv) {
        return stellar.StrKey.isValidEd25519SecretSeed(prv);
    };
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId memo id
     * @returns true if memo id is valid
     */
    Xlm.prototype.isValidMemoId = function (memoId) {
        var memoIdNumber;
        try {
            stellar.Memo.id(memoId); // throws if the value is not valid memo id
            memoIdNumber = new bignumber_js_1.BigNumber(memoId);
        }
        catch (e) {
            return false;
        }
        return (memoIdNumber.gte(0) && memoIdNumber.lt(Xlm.maxMemoId));
    };
    /**
     * Evaluates whether a memo is valid
     *
     * @param value value of the memo
     * @param type type of the memo
     * @returns true if value and type are a valid
     */
    Xlm.prototype.isValidMemo = function (_a) {
        var value = _a.value, type = _a.type;
        if (!value || !type) {
            return false;
        }
        try {
            // throws if the value is not valid for the type
            // valid types are: 'id', 'text', 'hash', 'return'
            // See https://www.stellar.org/developers/guides/concepts/transactions.html#memo
            stellar.Memo[type](value);
        }
        catch (e) {
            return false;
        }
        return true;
    };
    /**
     * Minimum balance of a 2-of-3 multisig wallet
     * @returns minimum balance in stroops
     */
    Xlm.prototype.getMinimumReserve = function () {
        var self = this;
        return co(function () {
            var server, horizonLedgerInfo, baseReserve;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        server = new stellar.Server(self.getHorizonUrl());
                        return [4 /*yield*/, server
                                .ledgers()
                                .order('desc')
                                .limit(1)
                                .call()];
                    case 1:
                        horizonLedgerInfo = _a.sent();
                        if (!horizonLedgerInfo) {
                            throw new Error('unable to connect to Horizon for reserve requirement data');
                        }
                        baseReserve = horizonLedgerInfo.records[0].base_reserve_in_stroops;
                        // 2-of-3 wallets have a minimum reserve of 5x the base reserve
                        return [2 /*return*/, 5 * baseReserve];
                }
            });
        }).call(this);
    };
    /**
     * Transaction fee for each operation
     * @returns transaction fee in stroops
     */
    Xlm.prototype.getBaseTransactionFee = function () {
        var self = this;
        return co(function () {
            var server, horizonLedgerInfo;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        server = new stellar.Server(self.getHorizonUrl());
                        return [4 /*yield*/, server
                                .ledgers()
                                .order('desc')
                                .limit(1)
                                .call()];
                    case 1:
                        horizonLedgerInfo = _a.sent();
                        if (!horizonLedgerInfo) {
                            throw new Error('unable to connect to Horizon for reserve requirement data');
                        }
                        return [2 /*return*/, horizonLedgerInfo.records[0].base_fee_in_stroops];
                }
            });
        }).call(this);
    };
    /**
     * Process address into address and memo id
     *
     * @param address the address
     * @returns object containing address and memo id
     */
    Xlm.prototype.getAddressDetails = function (address) {
        var destinationDetails = url.parse(address);
        var destinationAddress = destinationDetails.pathname;
        if (!destinationAddress || !stellar.StrKey.isValidEd25519PublicKey(destinationAddress)) {
            throw new Error("invalid address: " + address);
        }
        // address doesn't have a memo id
        if (destinationDetails.pathname === address) {
            return {
                address: address,
                memoId: undefined,
            };
        }
        if (!destinationDetails.query) {
            throw new errors_1.InvalidAddressError("invalid address: " + address);
        }
        var queryDetails = querystring.parse(destinationDetails.query);
        if (!queryDetails.memoId) {
            // if there are more properties, the query details need to contain the memo id property
            throw new errors_1.InvalidAddressError("invalid address: " + address);
        }
        if (Array.isArray(queryDetails.memoId)) {
            throw new errors_1.InvalidAddressError("memoId may only be given at most once, but found " + queryDetails.memoId.length + " instances in address " + address);
        }
        if (Array.isArray(queryDetails.memoId) && queryDetails.memoId.length !== 1) {
            // valid addresses can only contain one memo id
            throw new errors_1.InvalidAddressError("invalid address '" + address + "', must contain exactly one memoId");
        }
        var memoId = _.castArray(queryDetails.memoId)[0];
        if (!this.isValidMemoId(memoId)) {
            throw new errors_1.InvalidMemoIdError("invalid address: '" + address + "', memoId is not valid");
        }
        return {
            address: destinationAddress,
            memoId: memoId,
        };
    };
    /**
     * Validate and return address with appended memo id
     *
     * @param address address
     * @param memoId memo id
     * @returns address with memo id
     */
    Xlm.prototype.normalizeAddress = function (_a) {
        var address = _a.address, memoId = _a.memoId;
        if (!stellar.StrKey.isValidEd25519PublicKey(address)) {
            throw new Error("invalid address details: " + address);
        }
        if (memoId && this.isValidMemoId(memoId)) {
            return address + "?memoId=" + memoId;
        }
        return address;
    };
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param address the pub to be checked
     * @returns is it valid?
     */
    Xlm.prototype.isValidAddress = function (address) {
        try {
            var addressDetails = this.getAddressDetails(address);
            return address === this.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Return a Stellar Asset in coin:token form (i.e. (t)xlm:<code>-<issuer>)
     * If the asset is XLM, return the chain
     * @param {stellar.Asset} asset - instance of Stellar Asset
     */
    Xlm.prototype.getTokenNameFromStellarAsset = function (asset) {
        var code = asset.getCode();
        var issuer = asset.getIssuer();
        if (asset.isNative()) {
            return this.getChain();
        }
        return "" + this.getChain() + baseCoin_1.BaseCoin.coinTokenPatternSeparator + code + Xlm.tokenPatternSeparator + issuer;
    };
    /**
     * Evaluate whether a stellar username has valid format
     * This method is used by the client when a stellar address is being added to a wallet
     * Example of a common stellar username: foo@bar.baz
     * The above example would result in the Stellar address: foo@bar.baz*bitgo.com
     *
     * @param username - stellar username
     * @return true if stellar username is valid
     */
    Xlm.prototype.isValidStellarUsername = function (username) {
        return /^[a-z0-9\-_.+@]+$/.test(username);
    };
    /**
     * Get an instance of FederationServer for BitGo lookups
     *
     * @returns instance of BitGo Federation Server
     */
    Xlm.prototype.getBitGoFederationServer = function () {
        // Identify the URI scheme in case we need to allow connecting to HTTP server.
        var isNonSecureEnv = !_.startsWith(common.Environments[this.bitgo.env].uri, 'https');
        var federationServerOptions = { allowHttp: isNonSecureEnv };
        return new stellar.FederationServer(this.getFederationServerUrl(), 'bitgo.com', federationServerOptions);
    };
    /**
     * Perform federation lookups
     * Our federation server handles lookups for bitgo as well as for other federation domains
     *
     * @param {String} [address] - address to look up
     * @param {String} [accountId] - account id to look up
     */
    Xlm.prototype.federationLookup = function (_a) {
        var address = _a.address, accountId = _a.accountId;
        var self = this;
        return co(function () {
            var federationServer, e_1, error;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 6, , 7]);
                        federationServer = self.getBitGoFederationServer();
                        if (!address) return [3 /*break*/, 2];
                        return [4 /*yield*/, federationServer.resolveAddress(address)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        if (!accountId) return [3 /*break*/, 4];
                        return [4 /*yield*/, federationServer.resolveAccountId(accountId)];
                    case 3: return [2 /*return*/, _a.sent()];
                    case 4: throw new Error('invalid argument - must provide Stellar address or account id');
                    case 5: return [3 /*break*/, 7];
                    case 6:
                        e_1 = _a.sent();
                        error = _.get(e_1, 'response.data.detail');
                        if (error) {
                            throw new errors_1.StellarFederationUserNotFoundError(error);
                        }
                        else {
                            throw e_1;
                        }
                        return [3 /*break*/, 7];
                    case 7: return [2 /*return*/];
                }
            });
        }).call(this);
    };
    /**
     * Attempt to resolve a stellar address into a stellar account
     *
     * @param {String} address - stellar address to look for
     */
    Xlm.prototype.federationLookupByName = function (address) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                if (!address) {
                    throw new Error('invalid Stellar address');
                }
                return [2 /*return*/, self.federationLookup({ address: address })];
            });
        }).call(this);
    };
    /**
     * Attempt to resolve an account id into a stellar account
     * Only works for accounts that can be resolved by our federation server
     *
     * @param {String} accountId - stellar account id
     */
    Xlm.prototype.federationLookupByAccountId = function (accountId) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                if (!accountId) {
                    throw new Error('invalid Stellar account');
                }
                return [2 /*return*/, self.federationLookup({ accountId: accountId })];
            });
        }).call(this);
    };
    /**
     * Check if address is a valid XLM address, and then make sure it matches the root address.
     *
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     */
    Xlm.prototype.verifyAddress = function (_a) {
        var address = _a.address, rootAddress = _a.rootAddress;
        if (!this.isValidAddress(address)) {
            throw new errors_1.InvalidAddressError("invalid address: " + address);
        }
        var addressDetails = this.getAddressDetails(address);
        var rootAddressDetails = this.getAddressDetails(rootAddress);
        if (addressDetails.address !== rootAddressDetails.address) {
            throw new errors_1.UnexpectedAddressError("address validation failure: " + addressDetails.address + " vs " + rootAddressDetails.address);
        }
        return true;
    };
    /**
     * Get extra parameters for prebuilding a tx
     * Set empty recipients array in trustline txs
     */
    Xlm.prototype.getExtraPrebuildParams = function (buildParams, callback) {
        var params = {};
        if (buildParams.type === 'trustline') {
            params.recipients = [];
        }
        return Bluebird.resolve(params).asCallback(callback);
    };
    /**
     * Generates Stellar keypairs from the user key and backup key
     * @param params
     */
    Xlm.prototype.initiateRecovery = function (params) {
        var self = this;
        return co(function () {
            var keys, userKey, backupKey, isKrsRecovery, isUnsignedSweep, userKeyPair;
            return __generator(this, function (_a) {
                keys = [];
                userKey = params.userKey;
                backupKey = params.backupKey;
                isKrsRecovery = backupKey.startsWith('G') && !userKey.startsWith('G');
                isUnsignedSweep = backupKey.startsWith('G') && userKey.startsWith('G');
                if (isKrsRecovery && params.krsProvider && _.isUndefined(config.krsProviders[params.krsProvider])) {
                    throw new errors_1.KeyRecoveryServiceError("Unknown key recovery service provider - " + params.krsProvider);
                }
                if (isKrsRecovery && params.krsProvider && !config.krsProviders[params.krsProvider].supportedCoins.includes(self.getFamily())) {
                    throw new errors_1.KeyRecoveryServiceError("Specified key recovery service does not support recoveries for " + self.getChain());
                }
                if (!self.isValidAddress(params.recoveryDestination)) {
                    throw new errors_1.InvalidAddressError('Invalid destination address!');
                }
                try {
                    if (!userKey.startsWith('S') && !userKey.startsWith('G')) {
                        userKey = self.bitgo.decrypt({
                            input: userKey,
                            password: params.walletPassphrase,
                        });
                    }
                    userKeyPair = isUnsignedSweep ?
                        stellar.Keypair.fromPublicKey(userKey) :
                        stellar.Keypair.fromSecret(userKey);
                    keys.push(userKeyPair);
                }
                catch (e) {
                    throw new Error('Failed to decrypt user key with passcode - try again!');
                }
                try {
                    if (!backupKey.startsWith('S') && !isKrsRecovery && !isUnsignedSweep) {
                        backupKey = this.bitgo.decrypt({
                            input: backupKey,
                            password: params.walletPassphrase,
                        });
                    }
                    if (isKrsRecovery || isUnsignedSweep) {
                        keys.push(stellar.Keypair.fromPublicKey(backupKey));
                    }
                    else {
                        keys.push(stellar.Keypair.fromSecret(backupKey));
                    }
                }
                catch (e) {
                    throw new Error('Failed to decrypt backup key with passcode - try again!');
                }
                return [2 /*return*/, keys];
            });
        }).call(this);
    };
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - userKey: [encrypted] Stellar private key
     * - backupKey: [encrypted] Stellar private key, or public key if the private key is held by a KRS provider
     * - walletPassphrase: necessary if one of the private keys is encrypted
     * - rootAddress: base address of the wallet to recover funds from
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     * @param callback
     */
    Xlm.prototype.recover = function (params, callback) {
        var self = this;
        return co(function () {
            var _a, userKey, backupKey, isKrsRecovery, isUnsignedSweep, accountDataUrl, destinationUrl, accountData, e_2, unfundedDestination, e_3, account, nativeBalanceInfo, walletBalance, minimumReserve, baseTxFee, recoveryAmount, formattedRecoveryAmount, txBuilder, operation, tx, transaction;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, self.initiateRecovery(params)];
                    case 1:
                        _a = _b.sent(), userKey = _a[0], backupKey = _a[1];
                        isKrsRecovery = params.backupKey.startsWith('G') && !params.userKey.startsWith('G');
                        isUnsignedSweep = params.backupKey.startsWith('G') && params.userKey.startsWith('G');
                        if (!params.rootAddress || !stellar.StrKey.isValidEd25519PublicKey(params.rootAddress)) {
                            throw new Error("Invalid wallet address: " + params.rootAddress);
                        }
                        accountDataUrl = self.getHorizonUrl() + "/accounts/" + params.rootAddress;
                        destinationUrl = self.getHorizonUrl() + "/accounts/" + params.recoveryDestination;
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, request.get(accountDataUrl).result()];
                    case 3:
                        accountData = _b.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        e_2 = _b.sent();
                        throw new Error('Unable to reach the Stellar network via Horizon.');
                    case 5:
                        unfundedDestination = false;
                        _b.label = 6;
                    case 6:
                        _b.trys.push([6, 8, , 9]);
                        return [4 /*yield*/, request.get(destinationUrl)];
                    case 7:
                        _b.sent();
                        return [3 /*break*/, 9];
                    case 8:
                        e_3 = _b.sent();
                        if (e_3.status === 404) {
                            // If the destination account does not yet exist, horizon responds with 404
                            unfundedDestination = true;
                        }
                        return [3 /*break*/, 9];
                    case 9:
                        if (!accountData.sequence || !accountData.balances) {
                            throw new Error('Horizon server error - unable to retrieve sequence ID or account balance');
                        }
                        account = new stellar.Account(params.rootAddress, accountData.sequence);
                        nativeBalanceInfo = accountData.balances.find(function (assetBalance) { return assetBalance['asset_type'] === 'native'; });
                        if (!nativeBalanceInfo) {
                            throw new Error('Provided wallet has a balance of 0 XLM, recovery aborted');
                        }
                        walletBalance = Number(self.bigUnitsToBaseUnits(nativeBalanceInfo.balance));
                        return [4 /*yield*/, self.getMinimumReserve()];
                    case 10:
                        minimumReserve = _b.sent();
                        return [4 /*yield*/, self.getBaseTransactionFee()];
                    case 11:
                        baseTxFee = _b.sent();
                        recoveryAmount = walletBalance - minimumReserve - baseTxFee;
                        formattedRecoveryAmount = self.baseUnitsToBigUnits(recoveryAmount).toString();
                        txBuilder = new stellar.TransactionBuilder(account);
                        operation = unfundedDestination ?
                            // In this case, we need to create the account
                            stellar.Operation.createAccount({
                                destination: params.recoveryDestination,
                                startingBalance: formattedRecoveryAmount,
                            }) :
                            // Otherwise if the account already exists, we do a normal send
                            stellar.Operation.payment({
                                destination: params.recoveryDestination,
                                asset: stellar.Asset.native(),
                                amount: formattedRecoveryAmount,
                            });
                        tx = txBuilder.addOperation(operation).build();
                        if (!isUnsignedSweep) {
                            tx.sign(userKey);
                        }
                        if (!isKrsRecovery && !isUnsignedSweep) {
                            tx.sign(backupKey);
                        }
                        transaction = {
                            tx: Xlm.txToString(tx),
                            recoveryAmount: recoveryAmount,
                        };
                        if (isKrsRecovery) {
                            transaction.backupKey = params.backupKey;
                            transaction.coin = self.getChain();
                        }
                        return [2 /*return*/, transaction];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param callback
     * @returns {Bluebird<HalfSignedTransaction>}
     */
    Xlm.prototype.signTransaction = function (params, callback) {
        return co(function () {
            var txPrebuild, prv, keyPair, tx;
            return __generator(this, function (_a) {
                txPrebuild = params.txPrebuild, prv = params.prv;
                if (_.isUndefined(txPrebuild)) {
                    throw new Error('missing txPrebuild parameter');
                }
                if (!_.isObject(txPrebuild)) {
                    throw new Error("txPrebuild must be an object, got type " + typeof txPrebuild);
                }
                if (_.isUndefined(prv)) {
                    throw new Error('missing prv parameter to sign transaction');
                }
                if (!_.isString(prv)) {
                    throw new Error("prv must be a string, got type " + typeof prv);
                }
                keyPair = stellar.Keypair.fromSecret(prv);
                tx = new stellar.Transaction(txPrebuild.txBase64);
                tx.sign(keyPair);
                return [2 /*return*/, {
                        halfSigned: {
                            txBase64: Xlm.txToString(tx),
                        },
                    }];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Extend walletParams with extra params required for generating an XLM wallet
     *
     * Stellar wallets have three keychains on them. Two are generated by the platform, and the last is generated by the user.
     * Initially, we need a root prv to generate the account, which must be distinct from all three keychains on the wallet.
     * If a root prv is not provided, a random one is generated.
     */
    Xlm.prototype.supplementGenerateWallet = function (walletParams) {
        var self = this;
        return co(function () {
            var seed, rootPrv, keyPair;
            return __generator(this, function (_a) {
                rootPrv = walletParams.rootPrivateKey;
                if (rootPrv) {
                    if (!self.isValidPrv(rootPrv)) {
                        throw new Error('rootPrivateKey needs to be valid ed25519 secret seed');
                    }
                    seed = stellar.StrKey.decodeEd25519SecretSeed(rootPrv);
                }
                keyPair = self.generateKeyPair(seed);
                // extend the wallet initialization params
                walletParams.rootPrivateKey = keyPair.prv;
                return [2 /*return*/, walletParams];
            });
        }).call(this);
    };
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     * @param callback
     */
    Xlm.prototype.signMessage = function (key, message, callback) {
        var self = this;
        return co(function cosignMessage() {
            var keypair;
            return __generator(this, function (_a) {
                if (!self.isValidPrv(key.prv)) {
                    throw new Error("invalid prv: " + key.prv);
                }
                if (!Buffer.isBuffer(message)) {
                    message = Buffer.from(message);
                }
                keypair = stellar.Keypair.fromSecret(key.prv);
                return [2 /*return*/, keypair.sign(message)];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Verifies if signature for message is valid.
     *
     * @param pub public key
     * @param message signed message
     * @param signature signature to verify
     * @returns true if signature is valid.
     */
    Xlm.prototype.verifySignature = function (pub, message, signature) {
        if (!this.isValidPub(pub)) {
            throw new Error("invalid pub: " + pub);
        }
        if (!Buffer.isBuffer(message)) {
            message = Buffer.from(message);
        }
        var keyPair = stellar.Keypair.fromPublicKey(pub);
        return keyPair.verify(message, signature);
    };
    /**
     * Explain/parse transaction
     * @param params
     * @param callback
     */
    Xlm.prototype.explainTransaction = function (params, callback) {
        var self = this;
        return co(function () {
            var txBase64, tx, id, memo, spendAmount, spendAmounts, outputs, operations, outputAmount, outputAmounts, fee;
            return __generator(this, function (_a) {
                txBase64 = params.txBase64;
                try {
                    tx = new stellar.Transaction(txBase64);
                }
                catch (e) {
                    throw new Error('txBase64 needs to be a valid tx encoded as base64 string');
                }
                id = tx.hash().toString('hex');
                memo = _.result(tx, '_memo.value') && _.result(tx, '_memo.arm') ?
                    {
                        value: _.result(tx, '_memo.value').toString(),
                        type: _.result(tx, '_memo.arm'),
                    } : {};
                spendAmount = new bignumber_js_1.BigNumber(0);
                spendAmounts = {};
                if (_.isEmpty(tx.operations)) {
                    throw new Error('missing operations');
                }
                outputs = [];
                operations = [];
                _.forEach(tx.operations, function (op) {
                    if (op.type === 'createAccount' || op.type === 'payment') {
                        // TODO Remove memoId from address
                        // Get memo to attach to address, if type is 'id'
                        var memoId = _.get(memo, 'type') === 'id' && !_.get(memo, 'value') ?
                            "?memoId=" + memo.value :
                            '';
                        var asset = op.type === 'payment' ? op.asset : stellar.Asset.native();
                        var coin = self.getTokenNameFromStellarAsset(asset); // coin or token id
                        var output = {
                            amount: self.bigUnitsToBaseUnits(op.startingBalance || op.amount),
                            address: op.destination + memoId,
                            coin: coin,
                        };
                        if (!_.isUndefined(spendAmounts[coin])) {
                            spendAmounts[coin] = spendAmounts[coin].plus(output.amount);
                        }
                        else {
                            spendAmounts[coin] = new bignumber_js_1.BigNumber(output.amount);
                        }
                        if (asset.isNative()) {
                            spendAmount = spendAmount.plus(output.amount);
                        }
                        outputs.push(output);
                    }
                    else if (op.type === 'changeTrust') {
                        operations.push({
                            type: op.type,
                            coin: self.getTokenNameFromStellarAsset(op.line),
                            asset: op.line,
                            limit: self.bigUnitsToBaseUnits(op.limit),
                        });
                    }
                });
                outputAmount = spendAmount.toFixed(0);
                outputAmounts = _.mapValues(spendAmounts, function (amount) { return amount.toFixed(0); });
                fee = {
                    fee: tx.fee.toFixed(0),
                    feeRate: null,
                    size: null,
                };
                return [2 /*return*/, {
                        displayOrder: ['id', 'outputAmount', 'outputAmounts', 'changeAmount', 'outputs', 'changeOutputs', 'fee', 'memo', 'operations'],
                        id: id,
                        outputs: outputs,
                        outputAmount: outputAmount,
                        outputAmounts: outputAmounts,
                        changeOutputs: [],
                        changeAmount: '0',
                        memo: memo,
                        fee: fee,
                        operations: operations,
                    }];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Verify that a tx prebuild's operations comply with the original intention
     * @param {stellar.Operation} operations - tx operations
     * @param {TransactionParams} txParams - params used to build the tx
     */
    Xlm.prototype.verifyTrustlineTxOperations = function (operations, txParams) {
        var _this = this;
        var trustlineOperations = _.filter(operations, ['type', 'changeTrust']);
        if (trustlineOperations.length !== _.get(txParams, 'trustlines', []).length) {
            throw new Error('transaction prebuild does not match expected trustline operations');
        }
        _.forEach(trustlineOperations, function (op) {
            var opToken = _this.getTokenNameFromStellarAsset(op.line);
            var tokenTrustline = _.find(txParams.trustlines, function (trustline) {
                // trustline params use limits in base units
                var opLimitBaseUnits = _this.bigUnitsToBaseUnits(op.limit);
                // Prepare the conditions to check for
                // Limit will always be set in the operation, even if it was omitted from txParams in the following cases:
                // 1. Action is 'add' - limit is set to Xlm.maxTrustlineLimit by default
                // 2. Action is 'remove' - limit is set to '0'
                var noLimit = _.isUndefined(trustline.limit);
                var addTrustlineWithDefaultLimit = (trustline.action === 'add' && opLimitBaseUnits === Xlm.maxTrustlineLimit);
                var removeTrustline = (trustline.action === 'remove' && opLimitBaseUnits === '0');
                return (trustline.token === opToken &&
                    (trustline.limit === opLimitBaseUnits || (noLimit && (addTrustlineWithDefaultLimit || removeTrustline))));
            });
            if (!tokenTrustline) {
                throw new Error('transaction prebuild does not match expected trustline tokens');
            }
        });
    };
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param options
     * @param options.txPrebuild prebuild object returned by platform
     * @param options.txPrebuild.txBase64 prebuilt transaction encoded as base64 string
     * @param options.wallet wallet object to obtain keys to verify against
     * @param options.verification specifying some verification parameters
     * @param options.verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param options.verification.keychains Pass keychains manually rather than fetching them by id
     * @param callback
     */
    Xlm.prototype.verifyTransaction = function (options, callback) {
        // TODO BG-5600 Add parseTransaction / improve verification
        var self = this;
        return co(function () {
            var txParams, txPrebuild, wallet, _a, verification, disableNetworking, tx, outputOperations, userSignature, keychains;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        txParams = options.txParams, txPrebuild = options.txPrebuild, wallet = options.wallet, _a = options.verification, verification = _a === void 0 ? {} : _a;
                        disableNetworking = !!verification.disableNetworking;
                        if (!txPrebuild.txBase64) {
                            throw new Error('missing required tx prebuild property txBase64');
                        }
                        tx = new stellar.Transaction(txPrebuild.txBase64);
                        if (txParams.recipients && txParams.recipients.length > 1) {
                            throw new Error('cannot specify more than 1 recipient');
                        }
                        outputOperations = _.filter(tx.operations, function (operation) {
                            return operation.type === 'createAccount' || operation.type === 'payment';
                        });
                        if (txParams.type === 'trustline') {
                            this.verifyTrustlineTxOperations(tx.operations, txParams);
                        }
                        else {
                            if (_.isEmpty(outputOperations)) {
                                throw new Error('transaction prebuild does not have any operations');
                            }
                            _.forEach(txParams.recipients, function (expectedOutput, index) {
                                var expectedOutputAddress = self.getAddressDetails(expectedOutput.address);
                                var output = outputOperations[index];
                                if (output.destination !== expectedOutputAddress.address) {
                                    throw new Error('transaction prebuild does not match expected recipient');
                                }
                                var expectedOutputAmount = new bignumber_js_1.BigNumber(expectedOutput.amount);
                                // The output amount is expressed as startingBalance in createAccount operations and as amount in payment operations.
                                var outputAmountString = (output.type === 'createAccount') ? output.startingBalance : output.amount;
                                var outputAmount = new bignumber_js_1.BigNumber(self.bigUnitsToBaseUnits(outputAmountString));
                                if (!outputAmount.eq(expectedOutputAmount)) {
                                    throw new Error('transaction prebuild does not match expected amount');
                                }
                            });
                        }
                        if (!!_.isEmpty(tx.signatures)) return [3 /*break*/, 4];
                        userSignature = tx.signatures[0].signature();
                        keychains = verification.keychains;
                        if (!(!keychains && disableNetworking)) return [3 /*break*/, 1];
                        throw new Error('cannot fetch keychains without networking');
                    case 1:
                        if (!!keychains) return [3 /*break*/, 3];
                        return [4 /*yield*/, Bluebird.props({
                                user: self.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.USER] }),
                                backup: self.keychains().get({ id: wallet.keyIds()[keychains_1.KeyIndices.BACKUP] }),
                            })];
                    case 2:
                        keychains = _b.sent();
                        _b.label = 3;
                    case 3:
                        if (!keychains || !keychains.backup || !keychains.user) {
                            throw new Error('keychains are required, but could not be fetched');
                        }
                        if (self.verifySignature(keychains.backup.pub, tx.hash(), userSignature)) {
                            throw new Error('transaction signed with wrong key');
                        }
                        if (!self.verifySignature(keychains.user.pub, tx.hash(), userSignature)) {
                            throw new Error('transaction signature invalid');
                        }
                        _b.label = 4;
                    case 4: return [2 /*return*/, true];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Derive a hardened child public key from a master key seed using an additional seed for randomness.
     *
     * Due to technical differences between keypairs on the ed25519 curve and the secp256k1 curve,
     * only hardened private key derivation is supported.
     *
     * @param key seed for the master key. Note: Not the public key or encoded private key. This is the raw seed.
     * @param entropySeed random seed which is hashed to generate the derivation path
     */
    Xlm.prototype.deriveKeyWithSeed = function (_a) {
        var key = _a.key, seed = _a.seed;
        var derivationPathInput = bitcoin.crypto.hash256("" + seed).toString('hex');
        var derivationPathParts = [
            999999,
            parseInt(derivationPathInput.slice(0, 7), 16),
            parseInt(derivationPathInput.slice(7, 14), 16),
        ];
        var derivationPath = 'm/' + derivationPathParts
            .map(function (part) { return part + "'"; })
            .join('/');
        var derivedKey = keyDeriver_1.Ed25519KeyDeriver.derivePath(derivationPath, key).key;
        var keypair = stellar.Keypair.fromRawEd25519Seed(derivedKey);
        return {
            key: keypair.publicKey(),
            derivationPath: derivationPath,
        };
    };
    Xlm.prototype.parseTransaction = function (params, callback) {
        return Bluebird.resolve({}).asCallback(callback);
    };
    Xlm.tokenPatternSeparator = '-'; // separator for token code and issuer
    Xlm.maxMemoId = '0xFFFFFFFFFFFFFFFF'; // max unsigned 64-bit number = 18446744073709551615
    // max int64 number supported by the network (2^63)-1
    // See: https://www.stellar.org/developers/guides/concepts/assets.html#amount-precision-and-representation
    Xlm.maxTrustlineLimit = '9223372036854775807';
    /**
     * stellar-sdk has two overloads for toXDR, and typescript can't seem to figure out the
     * correct one to use, so we have to be very explicit as to which one we want.
     * @param tx transaction to convert
     */
    Xlm.txToString = function (tx) { return tx.toEnvelope().toXDR('base64'); };
    return Xlm;
}(baseCoin_1.BaseCoin));
exports.Xlm = Xlm;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieGxtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3YyL2NvaW5zL3hsbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwwQkFBNEI7QUFDNUIseUNBQTJDO0FBQzNDLHlDQUEyQztBQUMzQyx5QkFBMkI7QUFDM0IsbUNBQXFDO0FBQ3JDLG9DQUFzQztBQUN0QyxxQ0FBdUM7QUFDdkMsNkNBQXlDO0FBRXpDLDBDQUEwQztBQUUxQyxxREFBMkQ7QUFDM0QscUNBQXVDO0FBQ3ZDLHFDQUF1QztBQUN2Qyx1Q0FNc0I7QUFDdEIsd0NBWXFCO0FBSXJCLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUFtRzlCO0lBQXlCLHVCQUFRO0lBUS9CLGFBQVksS0FBWTtRQUF4QixZQUNFLGtCQUFNLEtBQUssQ0FBQyxTQUdiO1FBRkMsS0FBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUMsQ0FBQyxxQ0FBcUM7UUFDcEUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQzs7SUFDcEUsQ0FBQztJQUVNLGtCQUFjLEdBQXJCLFVBQXNCLEtBQVk7UUFDaEMsT0FBTyxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQ7O09BRUc7SUFDSCwyQkFBYSxHQUFiO1FBQ0UsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7O09BRUc7SUFDSCxzQkFBUSxHQUFSO1FBQ0UsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSCx1QkFBUyxHQUFUO1FBQ0UsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7O09BRUc7SUFDSCx5QkFBVyxHQUFYO1FBQ0UsT0FBTyxTQUFTLENB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QUFHLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDekUsSUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMvRCxPQUFPO1lBQ0wsR0FBRyxFQUFFLE9BQU8sQ0FBQyxTQUFTLEVBQUU7WUFDeEIsY0FBYyxnQkFBQTtTQUNmLENBQUM7SUFDSixDQUFDO0lBU0QsOEJBQWdCLEdBQWhCLFVBQWlCLE1BQStCLEVBQUUsUUFBMEM7UUFDMUYsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBbjdCc0IseUJBQXFCLEdBQUcsR0FBRyxDQUFDLENBQUMsc0NBQXNDO0lBQzFFLGFBQVMsR0FBVyxvQkFBb0IsQ0FBQyxDQUFDLG9EQUFvRDtJQUM5RyxxREFBcUQ7SUFDckQsMEdBQTBHO0lBQzFGLHFCQUFpQixHQUFXLHFCQUFxQixDQUFDO0lBczZCbEU7Ozs7T0FJRztJQUNjLGNBQVUsR0FBRyxVQUFDLEVBQXVCLElBQWEsT0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLENBQUMsS0FBaUMsQ0FBQyxRQUFRLENBQUMsRUFBNUQsQ0FBNEQsQ0FBQztJQUtsSSxVQUFDO0NBQUEsQUF0N0JELENBQXlCLG1CQUFRLEdBczdCaEM7QUF0N0JZLGtCQUFHIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgYml0Y29pbiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0ICogYXMgcXVlcnlzdHJpbmcgZnJvbSAncXVlcnlzdHJpbmcnO1xuaW1wb3J0ICogYXMgdXJsIGZyb20gJ3VybCc7XG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgKiBhcyByZXF1ZXN0IGZyb20gJ3N1cGVyYWdlbnQnO1xuaW1wb3J0ICogYXMgc3RlbGxhciBmcm9tICdzdGVsbGFyLXNkayc7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgQml0R28gfSBmcm9tICcuLi8uLi9iaXRnbyc7XG5pbXBvcnQgeyBLZXlJbmRpY2VzIH0gZnJvbSAnLi4va2V5Y2hhaW5zJztcblxuaW1wb3J0IHsgRWQyNTUxOUtleURlcml2ZXIgfSBmcm9tICcuLi9pbnRlcm5hbC9rZXlEZXJpdmVyJztcbmltcG9ydCAqIGFzIGNvbmZpZyBmcm9tICcuLi8uLi9jb25maWcnO1xuaW1wb3J0ICogYXMgY29tbW9uIGZyb20gJy4uLy4uL2NvbW1vbic7XG5pbXBvcnQge1xuICBJbnZhbGlkQWRkcmVzc0Vycm9yLFxuICBJbnZhbGlkTWVtb0lkRXJyb3IsXG4gIEtleVJlY292ZXJ5U2VydmljZUVycm9yLFxuICBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yLFxuICBTdGVsbGFyRmVkZXJhdGlvblVzZXJOb3RGb3VuZEVycm9yLFxufSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHtcbiAgQmFzZUNvaW4sXG4gIFRyYW5zYWN0aW9uUmVjaXBpZW50IGFzIEJhc2VUcmFuc2FjdGlvbk91dHB1dCxcbiAgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiBhcyBCYXNlVHJhbnNhY3Rpb25FeHBsYW5hdGlvbixcbiAgS2V5UGFpcixcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMgYXMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zLFxuICBUcmFuc2FjdGlvblByZWJ1aWxkIGFzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvblBhcmFtcyBhcyBCYXNlVHJhbnNhY3Rpb25QYXJhbXMsIEV4dHJhUHJlYnVpbGRQYXJhbXNPcHRpb25zLFxufSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBOb2RlQ2FsbGJhY2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBXYWxsZXQgfSBmcm9tICcuLi93YWxsZXQnO1xuXG5jb25zdCBjbyA9IEJsdWViaXJkLmNvcm91dGluZTtcblxuaW50ZXJmYWNlIEFkZHJlc3NEZXRhaWxzIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBtZW1vSWQ/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBNZW1vIHtcbiAgdHlwZTogc3RlbGxhci5NZW1vVHlwZTtcbiAgdmFsdWU6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEluaXRpYXRlUmVjb3ZlcnlPcHRpb25zIHtcbiAgdXNlcktleTogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgcmVjb3ZlcnlEZXN0aW5hdGlvbjogc3RyaW5nO1xuICBrcnNQcm92aWRlcj86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlY292ZXJ5T3B0aW9ucyBleHRlbmRzIEluaXRpYXRlUmVjb3ZlcnlPcHRpb25zIHtcbiAgcm9vdEFkZHJlc3M/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBSZWNvdmVyeVRyYW5zYWN0aW9uIHtcbiAgdHg6IHN0cmluZztcbiAgcmVjb3ZlcnlBbW91bnQ6IG51bWJlcjtcbiAgYmFja3VwS2V5Pzogc3RyaW5nO1xuICBjb2luPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgQnVpbGRPcHRpb25zIHtcbiAgd2FsbGV0PzogV2FsbGV0O1xuICByZWNpcGllbnRzPzogb2JqZWN0W107XG4gIHR5cGU/OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvblByZWJ1aWxkIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uUHJlYnVpbGQge1xuICB0eEJhc2U2NDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcHJ2OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBIYWxmU2lnbmVkVHJhbnNhY3Rpb24ge1xuICBoYWxmU2lnbmVkOiB7XG4gICAgdHhCYXNlNjQ6IHN0cmluZztcbiAgfVxufVxuXG5pbnRlcmZhY2UgU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyB7XG4gIHJvb3RQcml2YXRlS2V5Pzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4QmFzZTY0OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbk1lbW8ge1xuICB2YWx1ZT86IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uT3BlcmF0aW9uIHtcbiAgdHlwZTogc3RyaW5nO1xuICBjb2luOiBzdHJpbmc7XG4gIGxpbWl0Pzogc3RyaW5nO1xuICBhc3NldD86IHN0ZWxsYXIuQXNzZXQ7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbk91dHB1dCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbk91dHB1dCB7XG4gIGNvaW46IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24gZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiB7XG4gIG1lbW86IFRyYW5zYWN0aW9uTWVtbztcbn1cblxuaW50ZXJmYWNlIFZlcmlmeUFkZHJlc3NPcHRpb25zIGV4dGVuZHMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zIHtcbiAgcm9vdEFkZHJlc3M6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRydXN0bGluZU9wdGlvbnMge1xuICB0b2tlbjogc3RyaW5nO1xuICBhY3Rpb246IHN0cmluZztcbiAgbGltaXQ/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvblBhcmFtcyBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblBhcmFtcyB7XG4gIHRydXN0bGluZXM/OiBUcnVzdGxpbmVPcHRpb25zW107XG59XG5cbmludGVyZmFjZSBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBCYXNlVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQYXJhbXM6IFRyYW5zYWN0aW9uUGFyYW1zO1xufVxuXG5leHBvcnQgY2xhc3MgWGxtIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwdWJsaWMgcmVhZG9ubHkgaG9tZURvbWFpbjogc3RyaW5nO1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHRva2VuUGF0dGVyblNlcGFyYXRvciA9ICctJzsgLy8gc2VwYXJhdG9yIGZvciB0b2tlbiBjb2RlIGFuZCBpc3N1ZXJcbiAgc3RhdGljIHJlYWRvbmx5IG1heE1lbW9JZDogc3RyaW5nID0gJzB4RkZGRkZGRkZGRkZGRkZGRic7IC8vIG1heCB1bnNpZ25lZCA2NC1iaXQgbnVtYmVyID0gMTg0NDY3NDQwNzM3MDk1NTE2MTVcbiAgLy8gbWF4IGludDY0IG51bWJlciBzdXBwb3J0ZWQgYnkgdGhlIG5ldHdvcmsgKDJeNjMpLTFcbiAgLy8gU2VlOiBodHRwczovL3d3dy5zdGVsbGFyLm9yZy9kZXZlbG9wZXJzL2d1aWRlcy9jb25jZXB0cy9hc3NldHMuaHRtbCNhbW91bnQtcHJlY2lzaW9uLWFuZC1yZXByZXNlbnRhdGlvblxuICBzdGF0aWMgcmVhZG9ubHkgbWF4VHJ1c3RsaW5lTGltaXQ6IHN0cmluZyA9ICc5MjIzMzcyMDM2ODU0Nzc1ODA3JztcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28pIHtcbiAgICBzdXBlcihiaXRnbyk7XG4gICAgdGhpcy5ob21lRG9tYWluID0gJ2JpdGdvLmNvbSc7IC8vIHVzZWQgZm9yIHJldmVyc2UgZmVkZXJhdGlvbiBsb29rdXBcbiAgICBzdGVsbGFyLk5ldHdvcmsudXNlKG5ldyBzdGVsbGFyLk5ldHdvcmsoc3RlbGxhci5OZXR3b3Jrcy5QVUJMSUMpKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R28pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBYbG0oYml0Z28pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhY3RvciBiZXR3ZWVuIHRoZSBiYXNlIHVuaXQgYW5kIGl0cyBzbWFsbGVzdCBzdWJkaXZpc29uXG4gICAqL1xuICBnZXRCYXNlRmFjdG9yKCkge1xuICAgIHJldHVybiAxZTc7XG4gIH1cblxuICAvKipcbiAgICogSWRlbnRpZmllciBmb3IgdGhlIGJsb2NrY2hhaW4gd2hpY2ggc3VwcG9ydHMgdGhpcyBjb2luXG4gICAqL1xuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAneGxtJztcbiAgfVxuXG4gIC8qKlxuICAgKiBJZGVudGlmaWVyIGZvciB0aGUgY29pbiBmYW1pbHlcbiAgICovXG4gIGdldEZhbWlseSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAneGxtJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoaXMgY29pblxuICAgKi9cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ1N0ZWxsYXInO1xuICB9XG5cbiAgLyoqXG4gICAqIFVybCBhdCB3aGljaCB0aGUgc3RlbGxhciBmZWRlcmF0aW9uIHNlcnZlciBjYW4gYmUgcmVhY2hlZFxuICAgKi9cbiAgZ2V0RmVkZXJhdGlvblNlcnZlclVybCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZ2V0RW52KCldLnN0ZWxsYXJGZWRlcmF0aW9uU2VydmVyVXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFVybCBhdCB3aGljaCBob3Jpem9uIGNhbiBiZSByZWFjaGVkXG4gICAqL1xuICBnZXRIb3Jpem9uVXJsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdodHRwczovL2hvcml6b24uc3RlbGxhci5vcmcnO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IGtleSBwYWlyIG9uIHRoZSBlZDI1NTE5IGN1cnZlXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIGdlbmVyYXRlZCBwdWIgYW5kIHBydlxuICAgKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ6IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIGNvbnN0IHBhaXIgPSBzZWVkID8gc3RlbGxhci5LZXlwYWlyLmZyb21SYXdFZDI1NTE5U2VlZChzZWVkKSA6IHN0ZWxsYXIuS2V5cGFpci5yYW5kb20oKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiBwYWlyLnB1YmxpY0tleSgpLFxuICAgICAgcHJ2OiBwYWlyLnNlY3JldCgpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRlY29kZWQgZWQyNTUxOSBwdWJsaWMga2V5IGZyb20gcmF3IGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHB1YiBSYXcgcHVibGljIGtleVxuICAgKiBAcmV0dXJucyBFbmNvZGVkIHB1YmxpYyBrZXlcbiAgICovXG4gIGdldFB1YkZyb21SYXcocHViOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBzdGVsbGFyLlN0cktleS5lbmNvZGVFZDI1NTE5UHVibGljS2V5KEJ1ZmZlci5mcm9tKHB1YiwgJ2hleCcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGVjb2RlZCBlZDI1NTE5IHByaXZhdGUga2V5IGZyb20gcmF3IGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHBydiBSYXcgcHJpdmF0ZSBrZXlcbiAgICogQHJldHVybnMgRW5jb2RlZCBwcml2YXRlIGtleVxuICAgKi9cbiAgZ2V0UHJ2RnJvbVJhdyhwcnY6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHN0ZWxsYXIuU3RyS2V5LmVuY29kZUVkMjU1MTlTZWNyZXRTZWVkKEJ1ZmZlci5mcm9tKHBydiwgJ2hleCcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW4uXG4gICAqXG4gICAqIEBwYXJhbSBwdWIgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzdGVsbGFyLlN0cktleS5pc1ZhbGlkRWQyNTUxOVB1YmxpY0tleShwdWIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwcml2YXRlIGtleSBmb3IgdGhlIGNvaW5cbiAgICpcbiAgICogQHBhcmFtIHBydiB0aGUgcHJ2IHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMgaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHJ2KHBydjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHN0ZWxsYXIuU3RyS2V5LmlzVmFsaWRFZDI1NTE5U2VjcmV0U2VlZChwcnYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhIG1lbW8gaWQgaXMgdmFsaWRcbiAgICpcbiAgICogQHBhcmFtIG1lbW9JZCBtZW1vIGlkXG4gICAqIEByZXR1cm5zIHRydWUgaWYgbWVtbyBpZCBpcyB2YWxpZFxuICAgKi9cbiAgaXNWYWxpZE1lbW9JZChtZW1vSWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGxldCBtZW1vSWROdW1iZXI7XG4gICAgdHJ5IHtcbiAgICAgIHN0ZWxsYXIuTWVtby5pZChtZW1vSWQpOyAvLyB0aHJvd3MgaWYgdGhlIHZhbHVlIGlzIG5vdCB2YWxpZCBtZW1vIGlkXG4gICAgICBtZW1vSWROdW1iZXIgPSBuZXcgQmlnTnVtYmVyKG1lbW9JZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAobWVtb0lkTnVtYmVyLmd0ZSgwKSAmJiBtZW1vSWROdW1iZXIubHQoWGxtLm1heE1lbW9JZCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlcyB3aGV0aGVyIGEgbWVtbyBpcyB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgdmFsdWUgb2YgdGhlIG1lbW9cbiAgICogQHBhcmFtIHR5cGUgdHlwZSBvZiB0aGUgbWVtb1xuICAgKiBAcmV0dXJucyB0cnVlIGlmIHZhbHVlIGFuZCB0eXBlIGFyZSBhIHZhbGlkXG4gICAqL1xuICBpc1ZhbGlkTWVtbyh7IHZhbHVlLCB0eXBlIH06IE1lbW8pOiBib29sZWFuIHtcbiAgICBpZiAoIXZhbHVlIHx8ICF0eXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyB0aHJvd3MgaWYgdGhlIHZhbHVlIGlzIG5vdCB2YWxpZCBmb3IgdGhlIHR5cGVcbiAgICAgIC8vIHZhbGlkIHR5cGVzIGFyZTogJ2lkJywgJ3RleHQnLCAnaGFzaCcsICdyZXR1cm4nXG4gICAgICAvLyBTZWUgaHR0cHM6Ly93d3cuc3RlbGxhci5vcmcvZGV2ZWxvcGVycy9ndWlkZXMvY29uY2VwdHMvdHJhbnNhY3Rpb25zLmh0bWwjbWVtb1xuICAgICAgc3RlbGxhci5NZW1vW3R5cGVdKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1pbmltdW0gYmFsYW5jZSBvZiBhIDItb2YtMyBtdWx0aXNpZyB3YWxsZXRcbiAgICogQHJldHVybnMgbWluaW11bSBiYWxhbmNlIGluIHN0cm9vcHNcbiAgICovXG4gIGdldE1pbmltdW1SZXNlcnZlKCk6IEJsdWViaXJkPG51bWJlcj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxudW1iZXI+KGZ1bmN0aW9uICooKSB7XG4gICAgICBjb25zdCBzZXJ2ZXIgPSBuZXcgc3RlbGxhci5TZXJ2ZXIoc2VsZi5nZXRIb3Jpem9uVXJsKCkpO1xuXG4gICAgICBjb25zdCBob3Jpem9uTGVkZ2VySW5mbyA9IHlpZWxkIHNlcnZlclxuICAgICAgICAubGVkZ2VycygpXG4gICAgICAgIC5vcmRlcignZGVzYycpXG4gICAgICAgIC5saW1pdCgxKVxuICAgICAgICAuY2FsbCgpO1xuXG4gICAgICBpZiAoIWhvcml6b25MZWRnZXJJbmZvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGNvbm5lY3QgdG8gSG9yaXpvbiBmb3IgcmVzZXJ2ZSByZXF1aXJlbWVudCBkYXRhJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJhc2VSZXNlcnZlOiBudW1iZXIgPSBob3Jpem9uTGVkZ2VySW5mby5yZWNvcmRzWzBdLmJhc2VfcmVzZXJ2ZV9pbl9zdHJvb3BzO1xuXG4gICAgICAvLyAyLW9mLTMgd2FsbGV0cyBoYXZlIGEgbWluaW11bSByZXNlcnZlIG9mIDV4IHRoZSBiYXNlIHJlc2VydmVcbiAgICAgIHJldHVybiA1ICogYmFzZVJlc2VydmU7XG4gICAgfSkuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2FjdGlvbiBmZWUgZm9yIGVhY2ggb3BlcmF0aW9uXG4gICAqIEByZXR1cm5zIHRyYW5zYWN0aW9uIGZlZSBpbiBzdHJvb3BzXG4gICAqL1xuICBnZXRCYXNlVHJhbnNhY3Rpb25GZWUoKTogQmx1ZWJpcmQ8bnVtYmVyPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPG51bWJlcj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IHNlcnZlciA9IG5ldyBzdGVsbGFyLlNlcnZlcihzZWxmLmdldEhvcml6b25VcmwoKSk7XG5cbiAgICAgIGNvbnN0IGhvcml6b25MZWRnZXJJbmZvID0geWllbGQgc2VydmVyXG4gICAgICAgIC5sZWRnZXJzKClcbiAgICAgICAgLm9yZGVyKCdkZXNjJylcbiAgICAgICAgLmxpbWl0KDEpXG4gICAgICAgIC5jYWxsKCk7XG5cbiAgICAgIGlmICghaG9yaXpvbkxlZGdlckluZm8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gY29ubmVjdCB0byBIb3Jpem9uIGZvciByZXNlcnZlIHJlcXVpcmVtZW50IGRhdGEnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhvcml6b25MZWRnZXJJbmZvLnJlY29yZHNbMF0uYmFzZV9mZWVfaW5fc3Ryb29wcztcbiAgICB9KS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYWRkcmVzcyBpbnRvIGFkZHJlc3MgYW5kIG1lbW8gaWRcbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgdGhlIGFkZHJlc3NcbiAgICogQHJldHVybnMgb2JqZWN0IGNvbnRhaW5pbmcgYWRkcmVzcyBhbmQgbWVtbyBpZFxuICAgKi9cbiAgZ2V0QWRkcmVzc0RldGFpbHMoYWRkcmVzczogc3RyaW5nKTogQWRkcmVzc0RldGFpbHMge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uRGV0YWlscyA9IHVybC5wYXJzZShhZGRyZXNzKTtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkFkZHJlc3MgPSBkZXN0aW5hdGlvbkRldGFpbHMucGF0aG5hbWU7XG4gICAgaWYgKCFkZXN0aW5hdGlvbkFkZHJlc3MgfHwgIXN0ZWxsYXIuU3RyS2V5LmlzVmFsaWRFZDI1NTE5UHVibGljS2V5KGRlc3RpbmF0aW9uQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICAgIC8vIGFkZHJlc3MgZG9lc24ndCBoYXZlIGEgbWVtbyBpZFxuICAgIGlmIChkZXN0aW5hdGlvbkRldGFpbHMucGF0aG5hbWUgPT09IGFkZHJlc3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgIG1lbW9JZDogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWRlc3RpbmF0aW9uRGV0YWlscy5xdWVyeSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IHF1ZXJ5RGV0YWlscyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKGRlc3RpbmF0aW9uRGV0YWlscy5xdWVyeSk7XG4gICAgaWYgKCFxdWVyeURldGFpbHMubWVtb0lkKSB7XG4gICAgICAvLyBpZiB0aGVyZSBhcmUgbW9yZSBwcm9wZXJ0aWVzLCB0aGUgcXVlcnkgZGV0YWlscyBuZWVkIHRvIGNvbnRhaW4gdGhlIG1lbW8gaWQgcHJvcGVydHlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShxdWVyeURldGFpbHMubWVtb0lkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoXG4gICAgICAgIGBtZW1vSWQgbWF5IG9ubHkgYmUgZ2l2ZW4gYXQgbW9zdCBvbmNlLCBidXQgZm91bmQgJHtxdWVyeURldGFpbHMubWVtb0lkLmxlbmd0aH0gaW5zdGFuY2VzIGluIGFkZHJlc3MgJHthZGRyZXNzfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlEZXRhaWxzLm1lbW9JZCkgJiYgcXVlcnlEZXRhaWxzLm1lbW9JZC5sZW5ndGggIT09IDEpIHtcbiAgICAgIC8vIHZhbGlkIGFkZHJlc3NlcyBjYW4gb25seSBjb250YWluIG9uZSBtZW1vIGlkXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzICcke2FkZHJlc3N9JywgbXVzdCBjb250YWluIGV4YWN0bHkgb25lIG1lbW9JZGApO1xuICAgIH1cblxuICAgIGNvbnN0IFttZW1vSWRdID0gXy5jYXN0QXJyYXkocXVlcnlEZXRhaWxzLm1lbW9JZCk7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRNZW1vSWQobWVtb0lkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRNZW1vSWRFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAnJHthZGRyZXNzfScsIG1lbW9JZCBpcyBub3QgdmFsaWRgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogZGVzdGluYXRpb25BZGRyZXNzLFxuICAgICAgbWVtb0lkLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgYW5kIHJldHVybiBhZGRyZXNzIHdpdGggYXBwZW5kZWQgbWVtbyBpZFxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyBhZGRyZXNzXG4gICAqIEBwYXJhbSBtZW1vSWQgbWVtbyBpZFxuICAgKiBAcmV0dXJucyBhZGRyZXNzIHdpdGggbWVtbyBpZFxuICAgKi9cbiAgbm9ybWFsaXplQWRkcmVzcyh7IGFkZHJlc3MsIG1lbW9JZCB9OiBBZGRyZXNzRGV0YWlscyk6IHN0cmluZyB7XG4gICAgaWYgKCFzdGVsbGFyLlN0cktleS5pc1ZhbGlkRWQyNTUxOVB1YmxpY0tleShhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFkZHJlc3MgZGV0YWlsczogJHthZGRyZXNzfWApO1xuICAgIH1cbiAgICBpZiAobWVtb0lkICYmIHRoaXMuaXNWYWxpZE1lbW9JZChtZW1vSWQpKSB7XG4gICAgICByZXR1cm4gYCR7YWRkcmVzc30/bWVtb0lkPSR7bWVtb0lkfWA7XG4gICAgfVxuICAgIHJldHVybiBhZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pblxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyB0aGUgcHViIHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMgaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3MpO1xuICAgICAgcmV0dXJuIGFkZHJlc3MgPT09IHRoaXMubm9ybWFsaXplQWRkcmVzcyhhZGRyZXNzRGV0YWlscyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBTdGVsbGFyIEFzc2V0IGluIGNvaW46dG9rZW4gZm9ybSAoaS5lLiAodCl4bG06PGNvZGU+LTxpc3N1ZXI+KVxuICAgKiBJZiB0aGUgYXNzZXQgaXMgWExNLCByZXR1cm4gdGhlIGNoYWluXG4gICAqIEBwYXJhbSB7c3RlbGxhci5Bc3NldH0gYXNzZXQgLSBpbnN0YW5jZSBvZiBTdGVsbGFyIEFzc2V0XG4gICAqL1xuICBnZXRUb2tlbk5hbWVGcm9tU3RlbGxhckFzc2V0KGFzc2V0OiBzdGVsbGFyLkFzc2V0KSB7XG4gICAgY29uc3QgY29kZSA9IGFzc2V0LmdldENvZGUoKTtcbiAgICBjb25zdCBpc3N1ZXIgPSBhc3NldC5nZXRJc3N1ZXIoKTtcbiAgICBpZiAoYXNzZXQuaXNOYXRpdmUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hhaW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3RoaXMuZ2V0Q2hhaW4oKX0ke0Jhc2VDb2luLmNvaW5Ub2tlblBhdHRlcm5TZXBhcmF0b3J9JHtjb2RlfSR7WGxtLnRva2VuUGF0dGVyblNlcGFyYXRvcn0ke2lzc3Vlcn1gO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIHdoZXRoZXIgYSBzdGVsbGFyIHVzZXJuYW1lIGhhcyB2YWxpZCBmb3JtYXRcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCBieSB0aGUgY2xpZW50IHdoZW4gYSBzdGVsbGFyIGFkZHJlc3MgaXMgYmVpbmcgYWRkZWQgdG8gYSB3YWxsZXRcbiAgICogRXhhbXBsZSBvZiBhIGNvbW1vbiBzdGVsbGFyIHVzZXJuYW1lOiBmb29AYmFyLmJhelxuICAgKiBUaGUgYWJvdmUgZXhhbXBsZSB3b3VsZCByZXN1bHQgaW4gdGhlIFN0ZWxsYXIgYWRkcmVzczogZm9vQGJhci5iYXoqYml0Z28uY29tXG4gICAqXG4gICAqIEBwYXJhbSB1c2VybmFtZSAtIHN0ZWxsYXIgdXNlcm5hbWVcbiAgICogQHJldHVybiB0cnVlIGlmIHN0ZWxsYXIgdXNlcm5hbWUgaXMgdmFsaWRcbiAgICovXG4gIGlzVmFsaWRTdGVsbGFyVXNlcm5hbWUodXNlcm5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAvXlthLXowLTlcXC1fLitAXSskLy50ZXN0KHVzZXJuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugb2YgRmVkZXJhdGlvblNlcnZlciBmb3IgQml0R28gbG9va3Vwc1xuICAgKlxuICAgKiBAcmV0dXJucyBpbnN0YW5jZSBvZiBCaXRHbyBGZWRlcmF0aW9uIFNlcnZlclxuICAgKi9cbiAgZ2V0Qml0R29GZWRlcmF0aW9uU2VydmVyKCk6IHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlciB7XG4gICAgLy8gSWRlbnRpZnkgdGhlIFVSSSBzY2hlbWUgaW4gY2FzZSB3ZSBuZWVkIHRvIGFsbG93IGNvbm5lY3RpbmcgdG8gSFRUUCBzZXJ2ZXIuXG4gICAgY29uc3QgaXNOb25TZWN1cmVFbnYgPSAhXy5zdGFydHNXaXRoKGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5iaXRnby5lbnZdLnVyaSwgJ2h0dHBzJyk7XG4gICAgY29uc3QgZmVkZXJhdGlvblNlcnZlck9wdGlvbnMgPSB7IGFsbG93SHR0cDogaXNOb25TZWN1cmVFbnYgfTtcbiAgICByZXR1cm4gbmV3IHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlcih0aGlzLmdldEZlZGVyYXRpb25TZXJ2ZXJVcmwoKSwgJ2JpdGdvLmNvbScsIGZlZGVyYXRpb25TZXJ2ZXJPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGZlZGVyYXRpb24gbG9va3Vwc1xuICAgKiBPdXIgZmVkZXJhdGlvbiBzZXJ2ZXIgaGFuZGxlcyBsb29rdXBzIGZvciBiaXRnbyBhcyB3ZWxsIGFzIGZvciBvdGhlciBmZWRlcmF0aW9uIGRvbWFpbnNcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFthZGRyZXNzXSAtIGFkZHJlc3MgdG8gbG9vayB1cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2FjY291bnRJZF0gLSBhY2NvdW50IGlkIHRvIGxvb2sgdXBcbiAgICovXG4gIHByaXZhdGUgZmVkZXJhdGlvbkxvb2t1cCh7IGFkZHJlc3MsIGFjY291bnRJZCB9OiB7IGFkZHJlc3M/OiBzdHJpbmcsIGFjY291bnRJZD86IHN0cmluZyB9KTogQmx1ZWJpcmQ8c3RlbGxhci5GZWRlcmF0aW9uU2VydmVyLlJlY29yZD4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxzdGVsbGFyLkZlZGVyYXRpb25TZXJ2ZXIuUmVjb3JkPihmdW5jdGlvbiAqKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmVkZXJhdGlvblNlcnZlciA9IHNlbGYuZ2V0Qml0R29GZWRlcmF0aW9uU2VydmVyKCk7XG4gICAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHlpZWxkIGZlZGVyYXRpb25TZXJ2ZXIucmVzb2x2ZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWNjb3VudElkKSB7XG4gICAgICAgICAgcmV0dXJuIHlpZWxkIGZlZGVyYXRpb25TZXJ2ZXIucmVzb2x2ZUFjY291bnRJZChhY2NvdW50SWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCAtIG11c3QgcHJvdmlkZSBTdGVsbGFyIGFkZHJlc3Mgb3IgYWNjb3VudCBpZCcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gXy5nZXQoZSwgJ3Jlc3BvbnNlLmRhdGEuZGV0YWlsJyk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBTdGVsbGFyRmVkZXJhdGlvblVzZXJOb3RGb3VuZEVycm9yKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIHJlc29sdmUgYSBzdGVsbGFyIGFkZHJlc3MgaW50byBhIHN0ZWxsYXIgYWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyAtIHN0ZWxsYXIgYWRkcmVzcyB0byBsb29rIGZvclxuICAgKi9cbiAgZmVkZXJhdGlvbkxvb2t1cEJ5TmFtZShhZGRyZXNzOiBzdHJpbmcpOiBCbHVlYmlyZDxzdGVsbGFyLkZlZGVyYXRpb25TZXJ2ZXIuUmVjb3JkPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlci5SZWNvcmQ+KGZ1bmN0aW9uICooKSB7XG4gICAgICBpZiAoIWFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFN0ZWxsYXIgYWRkcmVzcycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5mZWRlcmF0aW9uTG9va3VwKHsgYWRkcmVzcyB9KTtcbiAgICB9KS5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gcmVzb2x2ZSBhbiBhY2NvdW50IGlkIGludG8gYSBzdGVsbGFyIGFjY291bnRcbiAgICogT25seSB3b3JrcyBmb3IgYWNjb3VudHMgdGhhdCBjYW4gYmUgcmVzb2x2ZWQgYnkgb3VyIGZlZGVyYXRpb24gc2VydmVyXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgLSBzdGVsbGFyIGFjY291bnQgaWRcbiAgICovXG4gIGZlZGVyYXRpb25Mb29rdXBCeUFjY291bnRJZChhY2NvdW50SWQ6IHN0cmluZyk6IEJsdWViaXJkPHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlci5SZWNvcmQ+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288c3RlbGxhci5GZWRlcmF0aW9uU2VydmVyLlJlY29yZD4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGlmICghYWNjb3VudElkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTdGVsbGFyIGFjY291bnQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmZlZGVyYXRpb25Mb29rdXAoeyBhY2NvdW50SWQgfSk7XG4gICAgfSkuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhZGRyZXNzIGlzIGEgdmFsaWQgWExNIGFkZHJlc3MsIGFuZCB0aGVuIG1ha2Ugc3VyZSBpdCBtYXRjaGVzIHRoZSByb290IGFkZHJlc3MuXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHtTdHJpbmd9IHRoZSBhZGRyZXNzIHRvIHZlcmlmeVxuICAgKiBAcGFyYW0gcm9vdEFkZHJlc3Mge1N0cmluZ30gdGhlIHdhbGxldCdzIHJvb3QgYWRkcmVzc1xuICAgKi9cbiAgdmVyaWZ5QWRkcmVzcyh7IGFkZHJlc3MsIHJvb3RBZGRyZXNzIH06IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3MpO1xuICAgIGNvbnN0IHJvb3RBZGRyZXNzRGV0YWlscyA9IHRoaXMuZ2V0QWRkcmVzc0RldGFpbHMocm9vdEFkZHJlc3MpO1xuXG4gICAgaWYgKGFkZHJlc3NEZXRhaWxzLmFkZHJlc3MgIT09IHJvb3RBZGRyZXNzRGV0YWlscy5hZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZEFkZHJlc3NFcnJvcihgYWRkcmVzcyB2YWxpZGF0aW9uIGZhaWx1cmU6ICR7YWRkcmVzc0RldGFpbHMuYWRkcmVzc30gdnMgJHtyb290QWRkcmVzc0RldGFpbHMuYWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZXh0cmEgcGFyYW1ldGVycyBmb3IgcHJlYnVpbGRpbmcgYSB0eFxuICAgKiBTZXQgZW1wdHkgcmVjaXBpZW50cyBhcnJheSBpbiB0cnVzdGxpbmUgdHhzXG4gICAqL1xuICBnZXRFeHRyYVByZWJ1aWxkUGFyYW1zKGJ1aWxkUGFyYW1zOiBFeHRyYVByZWJ1aWxkUGFyYW1zT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8QnVpbGRPcHRpb25zPik6IEJsdWViaXJkPEJ1aWxkT3B0aW9ucz4ge1xuICAgIGNvbnN0IHBhcmFtczogeyByZWNpcGllbnRzPzogb2JqZWN0W10gfSA9IHt9O1xuICAgIGlmIChidWlsZFBhcmFtcy50eXBlID09PSAndHJ1c3RsaW5lJykge1xuICAgICAgcGFyYW1zLnJlY2lwaWVudHMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUocGFyYW1zKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgU3RlbGxhciBrZXlwYWlycyBmcm9tIHRoZSB1c2VyIGtleSBhbmQgYmFja3VwIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBpbml0aWF0ZVJlY292ZXJ5KHBhcmFtczogUmVjb3ZlcnlPcHRpb25zKTogQmx1ZWJpcmQ8c3RlbGxhci5LZXlwYWlyW10+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288c3RlbGxhci5LZXlwYWlyW10+KGZ1bmN0aW9uICooKSB7XG4gICAgICBjb25zdCBrZXlzOiBzdGVsbGFyLktleXBhaXJbXSA9IFtdO1xuICAgICAgbGV0IHVzZXJLZXkgPSBwYXJhbXMudXNlcktleTtcbiAgICAgIGxldCBiYWNrdXBLZXkgPSBwYXJhbXMuYmFja3VwS2V5O1xuXG4gICAgICAvLyBTdGVsbGFyJ3MgRWQyNTUxOSBwdWJsaWMga2V5cyBzdGFydCB3aXRoIGEgRywgd2hpbGUgcHJpdmF0ZSBrZXlzIHN0YXJ0IHdpdGggYW4gU1xuICAgICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IGJhY2t1cEtleS5zdGFydHNXaXRoKCdHJykgJiYgIXVzZXJLZXkuc3RhcnRzV2l0aCgnRycpO1xuICAgICAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ0cnKSAmJiB1c2VyS2V5LnN0YXJ0c1dpdGgoJ0cnKTtcblxuXG4gICAgICBpZiAoaXNLcnNSZWNvdmVyeSAmJiBwYXJhbXMua3JzUHJvdmlkZXIgJiYgXy5pc1VuZGVmaW5lZChjb25maWcua3JzUHJvdmlkZXJzW3BhcmFtcy5rcnNQcm92aWRlcl0pKSB7XG4gICAgICAgIHRocm93IG5ldyBLZXlSZWNvdmVyeVNlcnZpY2VFcnJvcihgVW5rbm93biBrZXkgcmVjb3Zlcnkgc2VydmljZSBwcm92aWRlciAtICR7cGFyYW1zLmtyc1Byb3ZpZGVyfWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNLcnNSZWNvdmVyeSAmJiBwYXJhbXMua3JzUHJvdmlkZXIgJiYgIWNvbmZpZy5rcnNQcm92aWRlcnNbcGFyYW1zLmtyc1Byb3ZpZGVyXS5zdXBwb3J0ZWRDb2lucy5pbmNsdWRlcyhzZWxmLmdldEZhbWlseSgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgS2V5UmVjb3ZlcnlTZXJ2aWNlRXJyb3IoYFNwZWNpZmllZCBrZXkgcmVjb3Zlcnkgc2VydmljZSBkb2VzIG5vdCBzdXBwb3J0IHJlY292ZXJpZXMgZm9yICR7c2VsZi5nZXRDaGFpbigpfWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGYuaXNWYWxpZEFkZHJlc3MocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKCdJbnZhbGlkIGRlc3RpbmF0aW9uIGFkZHJlc3MhJyk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghdXNlcktleS5zdGFydHNXaXRoKCdTJykgJiYgIXVzZXJLZXkuc3RhcnRzV2l0aCgnRycpKSB7XG4gICAgICAgICAgdXNlcktleSA9IHNlbGYuYml0Z28uZGVjcnlwdCh7XG4gICAgICAgICAgICBpbnB1dDogdXNlcktleSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVzZXJLZXlQYWlyID0gaXNVbnNpZ25lZFN3ZWVwID9cbiAgICAgICAgICBzdGVsbGFyLktleXBhaXIuZnJvbVB1YmxpY0tleSh1c2VyS2V5KSA6XG4gICAgICAgICAgc3RlbGxhci5LZXlwYWlyLmZyb21TZWNyZXQodXNlcktleSk7XG4gICAgICAgIGtleXMucHVzaCh1c2VyS2V5UGFpcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgdXNlciBrZXkgd2l0aCBwYXNzY29kZSAtIHRyeSBhZ2FpbiEnKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFiYWNrdXBLZXkuc3RhcnRzV2l0aCgnUycpICYmICFpc0tyc1JlY292ZXJ5ICYmICFpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgICAgICBiYWNrdXBLZXkgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICAgICAgaW5wdXQ6IGJhY2t1cEtleSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0tyc1JlY292ZXJ5IHx8IGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICAgIGtleXMucHVzaChzdGVsbGFyLktleXBhaXIuZnJvbVB1YmxpY0tleShiYWNrdXBLZXkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXlzLnB1c2goc3RlbGxhci5LZXlwYWlyLmZyb21TZWNyZXQoYmFja3VwS2V5KSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVjcnlwdCBiYWNrdXAga2V5IHdpdGggcGFzc2NvZGUgLSB0cnkgYWdhaW4hJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHb1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gdXNlcktleTogW2VuY3J5cHRlZF0gU3RlbGxhciBwcml2YXRlIGtleVxuICAgKiAtIGJhY2t1cEtleTogW2VuY3J5cHRlZF0gU3RlbGxhciBwcml2YXRlIGtleSwgb3IgcHVibGljIGtleSBpZiB0aGUgcHJpdmF0ZSBrZXkgaXMgaGVsZCBieSBhIEtSUyBwcm92aWRlclxuICAgKiAtIHdhbGxldFBhc3NwaHJhc2U6IG5lY2Vzc2FyeSBpZiBvbmUgb2YgdGhlIHByaXZhdGUga2V5cyBpcyBlbmNyeXB0ZWRcbiAgICogLSByb290QWRkcmVzczogYmFzZSBhZGRyZXNzIG9mIHRoZSB3YWxsZXQgdG8gcmVjb3ZlciBmdW5kcyBmcm9tXG4gICAqIC0ga3JzUHJvdmlkZXI6IG5lY2Vzc2FyeSBpZiBiYWNrdXAga2V5IGlzIGhlbGQgYnkgS1JTXG4gICAqIC0gcmVjb3ZlcnlEZXN0aW5hdGlvbjogdGFyZ2V0IGFkZHJlc3MgdG8gc2VuZCByZWNvdmVyZWQgZnVuZHMgdG9cbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICByZWNvdmVyKHBhcmFtczogUmVjb3ZlcnlPcHRpb25zLCBjYWxsYmFjazogTm9kZUNhbGxiYWNrPFJlY292ZXJ5VHJhbnNhY3Rpb24+KTogQmx1ZWJpcmQ8UmVjb3ZlcnlUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxSZWNvdmVyeVRyYW5zYWN0aW9uPihmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgW3VzZXJLZXksIGJhY2t1cEtleV0gPSB5aWVsZCBzZWxmLmluaXRpYXRlUmVjb3ZlcnkocGFyYW1zKTtcbiAgICAgIGNvbnN0IGlzS3JzUmVjb3ZlcnkgPSBwYXJhbXMuYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ0cnKSAmJiAhcGFyYW1zLnVzZXJLZXkuc3RhcnRzV2l0aCgnRycpO1xuICAgICAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gcGFyYW1zLmJhY2t1cEtleS5zdGFydHNXaXRoKCdHJykgJiYgcGFyYW1zLnVzZXJLZXkuc3RhcnRzV2l0aCgnRycpO1xuXG4gICAgICBpZiAoIXBhcmFtcy5yb290QWRkcmVzcyB8fCAhc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkocGFyYW1zLnJvb3RBZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgd2FsbGV0IGFkZHJlc3M6ICR7cGFyYW1zLnJvb3RBZGRyZXNzfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhY2NvdW50RGF0YVVybCA9IGAke3NlbGYuZ2V0SG9yaXpvblVybCgpfS9hY2NvdW50cy8ke3BhcmFtcy5yb290QWRkcmVzc31gO1xuICAgICAgY29uc3QgZGVzdGluYXRpb25VcmwgPSBgJHtzZWxmLmdldEhvcml6b25VcmwoKX0vYWNjb3VudHMvJHtwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbn1gO1xuXG4gICAgICBsZXQgYWNjb3VudERhdGE7XG4gICAgICB0cnkge1xuICAgICAgICBhY2NvdW50RGF0YSA9IHlpZWxkIHJlcXVlc3QuZ2V0KGFjY291bnREYXRhVXJsKS5yZXN1bHQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcmVhY2ggdGhlIFN0ZWxsYXIgbmV0d29yayB2aWEgSG9yaXpvbi4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93IGNoZWNrIGlmIHRoZSBkZXN0aW5hdGlvbiBhY2NvdW50IGlzIGVtcHR5IG9yIG5vdFxuICAgICAgbGV0IHVuZnVuZGVkRGVzdGluYXRpb24gPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIHJlcXVlc3QuZ2V0KGRlc3RpbmF0aW9uVXJsKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVzdGluYXRpb24gYWNjb3VudCBkb2VzIG5vdCB5ZXQgZXhpc3QsIGhvcml6b24gcmVzcG9uZHMgd2l0aCA0MDRcbiAgICAgICAgICB1bmZ1bmRlZERlc3RpbmF0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWFjY291bnREYXRhLnNlcXVlbmNlIHx8ICFhY2NvdW50RGF0YS5iYWxhbmNlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hvcml6b24gc2VydmVyIGVycm9yIC0gdW5hYmxlIHRvIHJldHJpZXZlIHNlcXVlbmNlIElEIG9yIGFjY291bnQgYmFsYW5jZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhY2NvdW50ID0gbmV3IHN0ZWxsYXIuQWNjb3VudChwYXJhbXMucm9vdEFkZHJlc3MsIGFjY291bnREYXRhLnNlcXVlbmNlKTtcblxuICAgICAgLy8gU3RlbGxhciBzdXBwb3J0cyBtdWx0aXBsZSBhc3NldHMgb24gY2hhaW4sIHdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiB0aGUgYmFsYW5jZXMgZW50cnkgd2hvc2UgdHlwZSBpcyBcIm5hdGl2ZVwiIChYTE0pXG4gICAgICBjb25zdCBuYXRpdmVCYWxhbmNlSW5mbyA9IGFjY291bnREYXRhLmJhbGFuY2VzLmZpbmQoYXNzZXRCYWxhbmNlID0+IGFzc2V0QmFsYW5jZVsnYXNzZXRfdHlwZSddID09PSAnbmF0aXZlJyk7XG5cbiAgICAgIGlmICghbmF0aXZlQmFsYW5jZUluZm8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCB3YWxsZXQgaGFzIGEgYmFsYW5jZSBvZiAwIFhMTSwgcmVjb3ZlcnkgYWJvcnRlZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3YWxsZXRCYWxhbmNlID0gTnVtYmVyKHNlbGYuYmlnVW5pdHNUb0Jhc2VVbml0cyhuYXRpdmVCYWxhbmNlSW5mby5iYWxhbmNlKSk7XG4gICAgICBjb25zdCBtaW5pbXVtUmVzZXJ2ZTogbnVtYmVyID0geWllbGQgc2VsZi5nZXRNaW5pbXVtUmVzZXJ2ZSgpO1xuICAgICAgY29uc3QgYmFzZVR4RmVlOiBudW1iZXIgPSB5aWVsZCBzZWxmLmdldEJhc2VUcmFuc2FjdGlvbkZlZSgpO1xuICAgICAgY29uc3QgcmVjb3ZlcnlBbW91bnQgPSB3YWxsZXRCYWxhbmNlIC0gbWluaW11bVJlc2VydmUgLSBiYXNlVHhGZWU7XG4gICAgICBjb25zdCBmb3JtYXR0ZWRSZWNvdmVyeUFtb3VudCA9IHNlbGYuYmFzZVVuaXRzVG9CaWdVbml0cyhyZWNvdmVyeUFtb3VudCkudG9TdHJpbmcoKTtcblxuICAgICAgY29uc3QgdHhCdWlsZGVyID0gbmV3IHN0ZWxsYXIuVHJhbnNhY3Rpb25CdWlsZGVyKGFjY291bnQpO1xuICAgICAgY29uc3Qgb3BlcmF0aW9uID0gdW5mdW5kZWREZXN0aW5hdGlvbiA/XG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIGFjY291bnRcbiAgICAgICAgc3RlbGxhci5PcGVyYXRpb24uY3JlYXRlQWNjb3VudCh7XG4gICAgICAgICAgZGVzdGluYXRpb246IHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uLFxuICAgICAgICAgIHN0YXJ0aW5nQmFsYW5jZTogZm9ybWF0dGVkUmVjb3ZlcnlBbW91bnQsXG4gICAgICAgIH0pIDpcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIHRoZSBhY2NvdW50IGFscmVhZHkgZXhpc3RzLCB3ZSBkbyBhIG5vcm1hbCBzZW5kXG4gICAgICAgIHN0ZWxsYXIuT3BlcmF0aW9uLnBheW1lbnQoe1xuICAgICAgICAgIGRlc3RpbmF0aW9uOiBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbixcbiAgICAgICAgICBhc3NldDogc3RlbGxhci5Bc3NldC5uYXRpdmUoKSxcbiAgICAgICAgICBhbW91bnQ6IGZvcm1hdHRlZFJlY292ZXJ5QW1vdW50LFxuICAgICAgICB9KTtcbiAgICAgIGNvbnN0IHR4ID0gdHhCdWlsZGVyLmFkZE9wZXJhdGlvbihvcGVyYXRpb24pLmJ1aWxkKCk7XG5cbiAgICAgIGlmICghaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAgIHR4LnNpZ24odXNlcktleSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNLcnNSZWNvdmVyeSAmJiAhaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAgIHR4LnNpZ24oYmFja3VwS2V5KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHJhbnNhY3Rpb246IFJlY292ZXJ5VHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIHR4OiBYbG0udHhUb1N0cmluZyh0eCksXG4gICAgICAgIHJlY292ZXJ5QW1vdW50LFxuICAgICAgfTtcblxuICAgICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleTtcbiAgICAgICAgdHJhbnNhY3Rpb24uY29pbiA9IHNlbGYuZ2V0Q2hhaW4oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZCB7T2JqZWN0fSBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgcGxhdGZvcm1cbiAgICogQHBhcmFtIHBhcmFtcy5wcnYge1N0cmluZ30gdXNlciBwcnZcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtCbHVlYmlyZDxIYWxmU2lnbmVkVHJhbnNhY3Rpb24+fVxuICAgKi9cbiAgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8SGFsZlNpZ25lZFRyYW5zYWN0aW9uPik6IEJsdWViaXJkPEhhbGZTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiBjbzxIYWxmU2lnbmVkVHJhbnNhY3Rpb24+KGZ1bmN0aW9uICooKSB7XG4gICAgICBjb25zdCB7IHR4UHJlYnVpbGQsIHBydiB9ID0gcGFyYW1zO1xuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh0eFByZWJ1aWxkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdHhQcmVidWlsZCBwYXJhbWV0ZXInKTtcbiAgICAgIH1cbiAgICAgIGlmICghXy5pc09iamVjdCh0eFByZWJ1aWxkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHR4UHJlYnVpbGQgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCB0eXBlICR7dHlwZW9mIHR4UHJlYnVpbGR9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHBydikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBydiBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgICAgfVxuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBydikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcnYgbXVzdCBiZSBhIHN0cmluZywgZ290IHR5cGUgJHt0eXBlb2YgcHJ2fWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXlQYWlyID0gc3RlbGxhci5LZXlwYWlyLmZyb21TZWNyZXQocHJ2KTtcbiAgICAgIGNvbnN0IHR4ID0gbmV3IHN0ZWxsYXIuVHJhbnNhY3Rpb24odHhQcmVidWlsZC50eEJhc2U2NCk7XG4gICAgICB0eC5zaWduKGtleVBhaXIpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYWxmU2lnbmVkOiB7XG4gICAgICAgICAgdHhCYXNlNjQ6IFhsbS50eFRvU3RyaW5nKHR4KSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogRXh0ZW5kIHdhbGxldFBhcmFtcyB3aXRoIGV4dHJhIHBhcmFtcyByZXF1aXJlZCBmb3IgZ2VuZXJhdGluZyBhbiBYTE0gd2FsbGV0XG4gICAqXG4gICAqIFN0ZWxsYXIgd2FsbGV0cyBoYXZlIHRocmVlIGtleWNoYWlucyBvbiB0aGVtLiBUd28gYXJlIGdlbmVyYXRlZCBieSB0aGUgcGxhdGZvcm0sIGFuZCB0aGUgbGFzdCBpcyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXIuXG4gICAqIEluaXRpYWxseSwgd2UgbmVlZCBhIHJvb3QgcHJ2IHRvIGdlbmVyYXRlIHRoZSBhY2NvdW50LCB3aGljaCBtdXN0IGJlIGRpc3RpbmN0IGZyb20gYWxsIHRocmVlIGtleWNoYWlucyBvbiB0aGUgd2FsbGV0LlxuICAgKiBJZiBhIHJvb3QgcHJ2IGlzIG5vdCBwcm92aWRlZCwgYSByYW5kb20gb25lIGlzIGdlbmVyYXRlZC5cbiAgICovXG4gIHN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldCh3YWxsZXRQYXJhbXM6IFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMpOiBCbHVlYmlyZDxTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnM+KGZ1bmN0aW9uICooKSB7XG4gICAgICBsZXQgc2VlZDtcbiAgICAgIGNvbnN0IHJvb3RQcnYgPSB3YWxsZXRQYXJhbXMucm9vdFByaXZhdGVLZXk7XG4gICAgICBpZiAocm9vdFBydikge1xuICAgICAgICBpZiAoIXNlbGYuaXNWYWxpZFBydihyb290UHJ2KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncm9vdFByaXZhdGVLZXkgbmVlZHMgdG8gYmUgdmFsaWQgZWQyNTUxOSBzZWNyZXQgc2VlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHNlZWQgPSBzdGVsbGFyLlN0cktleS5kZWNvZGVFZDI1NTE5U2VjcmV0U2VlZChyb290UHJ2KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleVBhaXIgPSBzZWxmLmdlbmVyYXRlS2V5UGFpcihzZWVkKTtcbiAgICAgIC8vIGV4dGVuZCB0aGUgd2FsbGV0IGluaXRpYWxpemF0aW9uIHBhcmFtc1xuICAgICAgd2FsbGV0UGFyYW1zLnJvb3RQcml2YXRlS2V5ID0ga2V5UGFpci5wcnY7XG4gICAgICByZXR1cm4gd2FsbGV0UGFyYW1zO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBtZXNzYWdlIHdpdGggcHJpdmF0ZSBrZXlcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHNpZ25NZXNzYWdlKGtleTogS2V5UGFpciwgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxCdWZmZXI+KTogQmx1ZWJpcmQ8QnVmZmVyPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPEJ1ZmZlcj4oZnVuY3Rpb24qIGNvc2lnbk1lc3NhZ2UoKSB7XG4gICAgICBpZiAoIXNlbGYuaXNWYWxpZFBydihrZXkucHJ2KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgcHJ2OiAke2tleS5wcnZ9YCk7XG4gICAgICB9XG4gICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihtZXNzYWdlKSkge1xuICAgICAgICBtZXNzYWdlID0gQnVmZmVyLmZyb20obWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXlwYWlyID0gc3RlbGxhci5LZXlwYWlyLmZyb21TZWNyZXQoa2V5LnBydik7XG4gICAgICByZXR1cm4ga2V5cGFpci5zaWduKG1lc3NhZ2UpO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIGlmIHNpZ25hdHVyZSBmb3IgbWVzc2FnZSBpcyB2YWxpZC5cbiAgICpcbiAgICogQHBhcmFtIHB1YiBwdWJsaWMga2V5XG4gICAqIEBwYXJhbSBtZXNzYWdlIHNpZ25lZCBtZXNzYWdlXG4gICAqIEBwYXJhbSBzaWduYXR1cmUgc2lnbmF0dXJlIHRvIHZlcmlmeVxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHNpZ25hdHVyZSBpcyB2YWxpZC5cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZShwdWI6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyLCBzaWduYXR1cmU6IEJ1ZmZlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkUHViKHB1YikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBwdWI6ICR7cHVifWApO1xuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihtZXNzYWdlKSkge1xuICAgICAgbWVzc2FnZSA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBrZXlQYWlyID0gc3RlbGxhci5LZXlwYWlyLmZyb21QdWJsaWNLZXkocHViKTtcbiAgICByZXR1cm4ga2V5UGFpci52ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluL3BhcnNlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBleHBsYWluVHJhbnNhY3Rpb24ocGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPik6IEJsdWViaXJkPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IHsgdHhCYXNlNjQgfSA9IHBhcmFtcztcbiAgICAgIGxldCB0eDogc3RlbGxhci5UcmFuc2FjdGlvbjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdHggPSBuZXcgc3RlbGxhci5UcmFuc2FjdGlvbih0eEJhc2U2NCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHhCYXNlNjQgbmVlZHMgdG8gYmUgYSB2YWxpZCB0eCBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlkID0gdHguaGFzaCgpLnRvU3RyaW5nKCdoZXgnKTtcblxuICAgICAgLy8gSW4gYSBTdGVsbGFyIHR4LCB0aGUgX21lbW8gcHJvcGVydHkgaXMgYW4gb2JqZWN0IHdpdGggdGhlIG1ldGhvZHM6XG4gICAgICAvLyB2YWx1ZSgpIGFuZCBhcm0oKSB0aGF0IHByb3ZpZGUgbWVtbyB2YWx1ZSBhbmQgdHlwZSwgcmVzcGVjdGl2ZWx5LlxuICAgICAgY29uc3QgbWVtbzogVHJhbnNhY3Rpb25NZW1vID0gXy5yZXN1bHQodHgsICdfbWVtby52YWx1ZScpICYmIF8ucmVzdWx0KHR4LCAnX21lbW8uYXJtJykgP1xuICAgICAgICB7XG4gICAgICAgICAgdmFsdWU6IChfLnJlc3VsdCh0eCwgJ19tZW1vLnZhbHVlJykgYXMgYW55KS50b1N0cmluZygpLFxuICAgICAgICAgIHR5cGU6IF8ucmVzdWx0KHR4LCAnX21lbW8uYXJtJyksXG4gICAgICAgIH0gOiB7fTtcblxuICAgICAgbGV0IHNwZW5kQW1vdW50ID0gbmV3IEJpZ051bWJlcigwKTsgLy8gYW1vdW50IG9mIFhMTSB1c2VkIGluIFhMTS1vbmx5IHR4c1xuICAgICAgY29uc3Qgc3BlbmRBbW91bnRzID0ge307IC8vIHRyYWNrIGJvdGggeGxtIGFuZCB0b2tlbiBhbW91bnRzXG4gICAgICBpZiAoXy5pc0VtcHR5KHR4Lm9wZXJhdGlvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBvcGVyYXRpb25zJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG91dHB1dHM6IFRyYW5zYWN0aW9uT3V0cHV0W10gPSBbXTtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbnM6IFRyYW5zYWN0aW9uT3BlcmF0aW9uW10gPSBbXTsgLy8gbm9uLXBheW1lbnQgb3BlcmF0aW9uc1xuXG4gICAgICBfLmZvckVhY2godHgub3BlcmF0aW9ucywgb3AgPT4ge1xuICAgICAgICBpZiAob3AudHlwZSA9PT0gJ2NyZWF0ZUFjY291bnQnIHx8IG9wLnR5cGUgPT09ICdwYXltZW50Jykge1xuICAgICAgICAgIC8vIFRPRE8gUmVtb3ZlIG1lbW9JZCBmcm9tIGFkZHJlc3NcbiAgICAgICAgICAvLyBHZXQgbWVtbyB0byBhdHRhY2ggdG8gYWRkcmVzcywgaWYgdHlwZSBpcyAnaWQnXG4gICAgICAgICAgY29uc3QgbWVtb0lkID0gXy5nZXQobWVtbywgJ3R5cGUnKSA9PT0gJ2lkJyAmJiAhIF8uZ2V0KG1lbW8sICd2YWx1ZScpID9cbiAgICAgICAgICAgIGA/bWVtb0lkPSR7bWVtby52YWx1ZX1gIDpcbiAgICAgICAgICAgICcnO1xuICAgICAgICAgIGNvbnN0IGFzc2V0ID0gb3AudHlwZSA9PT0gJ3BheW1lbnQnID8gb3AuYXNzZXQgOiBzdGVsbGFyLkFzc2V0Lm5hdGl2ZSgpO1xuICAgICAgICAgIGNvbnN0IGNvaW4gPSBzZWxmLmdldFRva2VuTmFtZUZyb21TdGVsbGFyQXNzZXQoYXNzZXQpOyAvLyBjb2luIG9yIHRva2VuIGlkXG4gICAgICAgICAgY29uc3Qgb3V0cHV0OiBUcmFuc2FjdGlvbk91dHB1dCA9IHtcbiAgICAgICAgICAgIGFtb3VudDogc2VsZi5iaWdVbml0c1RvQmFzZVVuaXRzKFxuICAgICAgICAgICAgICAob3AgYXMgc3RlbGxhci5PcGVyYXRpb24uQ3JlYXRlQWNjb3VudCkuc3RhcnRpbmdCYWxhbmNlIHx8IChvcCBhcyBzdGVsbGFyLk9wZXJhdGlvbi5QYXltZW50KS5hbW91bnRcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBhZGRyZXNzOiBvcC5kZXN0aW5hdGlvbiArIG1lbW9JZCxcbiAgICAgICAgICAgIGNvaW4sXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChzcGVuZEFtb3VudHNbY29pbl0pKSB7XG4gICAgICAgICAgICBzcGVuZEFtb3VudHNbY29pbl0gPSBzcGVuZEFtb3VudHNbY29pbl0ucGx1cyhvdXRwdXQuYW1vdW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3BlbmRBbW91bnRzW2NvaW5dID0gbmV3IEJpZ051bWJlcihvdXRwdXQuYW1vdW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFzc2V0LmlzTmF0aXZlKCkpIHtcbiAgICAgICAgICAgIHNwZW5kQW1vdW50ID0gc3BlbmRBbW91bnQucGx1cyhvdXRwdXQuYW1vdW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0cy5wdXNoKG91dHB1dCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3AudHlwZSA9PT0gJ2NoYW5nZVRydXN0Jykge1xuICAgICAgICAgIG9wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBvcC50eXBlLFxuICAgICAgICAgICAgY29pbjogc2VsZi5nZXRUb2tlbk5hbWVGcm9tU3RlbGxhckFzc2V0KG9wLmxpbmUpLFxuICAgICAgICAgICAgYXNzZXQ6IG9wLmxpbmUsXG4gICAgICAgICAgICBsaW1pdDogc2VsZi5iaWdVbml0c1RvQmFzZVVuaXRzKG9wLmxpbWl0KSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG91dHB1dEFtb3VudCA9IHNwZW5kQW1vdW50LnRvRml4ZWQoMCk7XG4gICAgICBjb25zdCBvdXRwdXRBbW91bnRzID0gXy5tYXBWYWx1ZXMoc3BlbmRBbW91bnRzLCAoYW1vdW50OiBCaWdOdW1iZXIpID0+IGFtb3VudC50b0ZpeGVkKDApKTtcbiAgICAgIGNvbnN0IGZlZSA9IHtcbiAgICAgICAgZmVlOiB0eC5mZWUudG9GaXhlZCgwKSxcbiAgICAgICAgZmVlUmF0ZTogbnVsbCxcbiAgICAgICAgc2l6ZTogbnVsbCxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXlPcmRlcjogWydpZCcsICdvdXRwdXRBbW91bnQnLCAnb3V0cHV0QW1vdW50cycsICdjaGFuZ2VBbW91bnQnLCAnb3V0cHV0cycsICdjaGFuZ2VPdXRwdXRzJywgJ2ZlZScsICdtZW1vJywgJ29wZXJhdGlvbnMnXSxcbiAgICAgICAgaWQsXG4gICAgICAgIG91dHB1dHMsXG4gICAgICAgIG91dHB1dEFtb3VudCxcbiAgICAgICAgb3V0cHV0QW1vdW50cyxcbiAgICAgICAgY2hhbmdlT3V0cHV0czogW10sXG4gICAgICAgIGNoYW5nZUFtb3VudDogJzAnLFxuICAgICAgICBtZW1vLFxuICAgICAgICBmZWUsXG4gICAgICAgIG9wZXJhdGlvbnMsXG4gICAgICB9O1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgYSB0eCBwcmVidWlsZCdzIG9wZXJhdGlvbnMgY29tcGx5IHdpdGggdGhlIG9yaWdpbmFsIGludGVudGlvblxuICAgKiBAcGFyYW0ge3N0ZWxsYXIuT3BlcmF0aW9ufSBvcGVyYXRpb25zIC0gdHggb3BlcmF0aW9uc1xuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uUGFyYW1zfSB0eFBhcmFtcyAtIHBhcmFtcyB1c2VkIHRvIGJ1aWxkIHRoZSB0eFxuICAgKi9cbiAgdmVyaWZ5VHJ1c3RsaW5lVHhPcGVyYXRpb25zKG9wZXJhdGlvbnM6IHN0ZWxsYXIuT3BlcmF0aW9uW10sIHR4UGFyYW1zOiBUcmFuc2FjdGlvblBhcmFtcyk6IHZvaWQge1xuICAgIGNvbnN0IHRydXN0bGluZU9wZXJhdGlvbnMgPSBfLmZpbHRlcihvcGVyYXRpb25zLCBbJ3R5cGUnLCAnY2hhbmdlVHJ1c3QnXSkgYXMgc3RlbGxhci5PcGVyYXRpb24uQ2hhbmdlVHJ1c3RbXTtcbiAgICBpZiAodHJ1c3RsaW5lT3BlcmF0aW9ucy5sZW5ndGggIT09IF8uZ2V0KHR4UGFyYW1zLCAndHJ1c3RsaW5lcycsIFtdKS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgdHJ1c3RsaW5lIG9wZXJhdGlvbnMnKTtcbiAgICB9XG4gICAgXy5mb3JFYWNoKHRydXN0bGluZU9wZXJhdGlvbnMsIG9wID0+IHtcbiAgICAgIGNvbnN0IG9wVG9rZW4gPSB0aGlzLmdldFRva2VuTmFtZUZyb21TdGVsbGFyQXNzZXQob3AubGluZSk7XG4gICAgICBjb25zdCB0b2tlblRydXN0bGluZSA9IF8uZmluZCh0eFBhcmFtcy50cnVzdGxpbmVzLCB0cnVzdGxpbmUgPT4ge1xuICAgICAgICAvLyB0cnVzdGxpbmUgcGFyYW1zIHVzZSBsaW1pdHMgaW4gYmFzZSB1bml0c1xuICAgICAgICBjb25zdCBvcExpbWl0QmFzZVVuaXRzID0gdGhpcy5iaWdVbml0c1RvQmFzZVVuaXRzKG9wLmxpbWl0KTtcbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgY29uZGl0aW9ucyB0byBjaGVjayBmb3JcbiAgICAgICAgLy8gTGltaXQgd2lsbCBhbHdheXMgYmUgc2V0IGluIHRoZSBvcGVyYXRpb24sIGV2ZW4gaWYgaXQgd2FzIG9taXR0ZWQgZnJvbSB0eFBhcmFtcyBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxLiBBY3Rpb24gaXMgJ2FkZCcgLSBsaW1pdCBpcyBzZXQgdG8gWGxtLm1heFRydXN0bGluZUxpbWl0IGJ5IGRlZmF1bHRcbiAgICAgICAgLy8gMi4gQWN0aW9uIGlzICdyZW1vdmUnIC0gbGltaXQgaXMgc2V0IHRvICcwJ1xuICAgICAgICBjb25zdCBub0xpbWl0ID0gXy5pc1VuZGVmaW5lZCh0cnVzdGxpbmUubGltaXQpO1xuICAgICAgICBjb25zdCBhZGRUcnVzdGxpbmVXaXRoRGVmYXVsdExpbWl0ID0gKHRydXN0bGluZS5hY3Rpb24gPT09ICdhZGQnICYmIG9wTGltaXRCYXNlVW5pdHMgPT09IFhsbS5tYXhUcnVzdGxpbmVMaW1pdCk7XG4gICAgICAgIGNvbnN0IHJlbW92ZVRydXN0bGluZSA9ICh0cnVzdGxpbmUuYWN0aW9uID09PSAncmVtb3ZlJyAmJiBvcExpbWl0QmFzZVVuaXRzID09PSAnMCcpO1xuICAgICAgICByZXR1cm4gKHRydXN0bGluZS50b2tlbiA9PT0gb3BUb2tlbiAmJlxuICAgICAgICAgICh0cnVzdGxpbmUubGltaXQgPT09IG9wTGltaXRCYXNlVW5pdHMgfHwgKG5vTGltaXQgJiYgKGFkZFRydXN0bGluZVdpdGhEZWZhdWx0TGltaXQgfHwgcmVtb3ZlVHJ1c3RsaW5lKSkpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIGlmICghdG9rZW5UcnVzdGxpbmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBwcmVidWlsZCBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCB0cnVzdGxpbmUgdG9rZW5zJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgYSB0cmFuc2FjdGlvbiBwcmVidWlsZCBjb21wbGllcyB3aXRoIHRoZSBvcmlnaW5hbCBpbnRlbnRpb25cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMudHhQcmVidWlsZCBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgcGxhdGZvcm1cbiAgICogQHBhcmFtIG9wdGlvbnMudHhQcmVidWlsZC50eEJhc2U2NCBwcmVidWlsdCB0cmFuc2FjdGlvbiBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdcbiAgICogQHBhcmFtIG9wdGlvbnMud2FsbGV0IHdhbGxldCBvYmplY3QgdG8gb2J0YWluIGtleXMgdG8gdmVyaWZ5IGFnYWluc3RcbiAgICogQHBhcmFtIG9wdGlvbnMudmVyaWZpY2F0aW9uIHNwZWNpZnlpbmcgc29tZSB2ZXJpZmljYXRpb24gcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucy52ZXJpZmljYXRpb24uZGlzYWJsZU5ldHdvcmtpbmcgRGlzYWxsb3cgZmV0Y2hpbmcgYW55IGRhdGEgZnJvbSB0aGUgaW50ZXJuZXQgZm9yIHZlcmlmaWNhdGlvbiBwdXJwb3Nlc1xuICAgKiBAcGFyYW0gb3B0aW9ucy52ZXJpZmljYXRpb24ua2V5Y2hhaW5zIFBhc3Mga2V5Y2hhaW5zIG1hbnVhbGx5IHJhdGhlciB0aGFuIGZldGNoaW5nIHRoZW0gYnkgaWRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICB2ZXJpZnlUcmFuc2FjdGlvbihvcHRpb25zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGJvb2xlYW4+KTogQmx1ZWJpcmQ8Ym9vbGVhbj4ge1xuICAgIC8vIFRPRE8gQkctNTYwMCBBZGQgcGFyc2VUcmFuc2FjdGlvbiAvIGltcHJvdmUgdmVyaWZpY2F0aW9uXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPGJvb2xlYW4+KGZ1bmN0aW9uICooKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR4UGFyYW1zLFxuICAgICAgICB0eFByZWJ1aWxkLFxuICAgICAgICB3YWxsZXQsXG4gICAgICAgIHZlcmlmaWNhdGlvbiA9IHt9LFxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCBkaXNhYmxlTmV0d29ya2luZyA9ICEhdmVyaWZpY2F0aW9uLmRpc2FibGVOZXR3b3JraW5nO1xuXG4gICAgICBpZiAoIXR4UHJlYnVpbGQudHhCYXNlNjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR4IHByZWJ1aWxkIHByb3BlcnR5IHR4QmFzZTY0Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR4ID0gbmV3IHN0ZWxsYXIuVHJhbnNhY3Rpb24odHhQcmVidWlsZC50eEJhc2U2NCk7XG5cbiAgICAgIGlmICh0eFBhcmFtcy5yZWNpcGllbnRzICYmIHR4UGFyYW1zLnJlY2lwaWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzcGVjaWZ5IG1vcmUgdGhhbiAxIHJlY2lwaWVudCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGVsbGFyIHR4cyBhcmUgbWFkZSB1cCBvZiBvcGVyYXRpb25zLiBXZSBvbmx5IGNhcmUgYWJvdXQgQ3JlYXRlIEFjY291bnQgYW5kIFBheW1lbnQgZm9yIHNlbmRpbmcgZnVuZHMuXG4gICAgICBjb25zdCBvdXRwdXRPcGVyYXRpb25zID0gXy5maWx0ZXIodHgub3BlcmF0aW9ucywgb3BlcmF0aW9uID0+XG4gICAgICAgIG9wZXJhdGlvbi50eXBlID09PSAnY3JlYXRlQWNjb3VudCcgfHwgb3BlcmF0aW9uLnR5cGUgPT09ICdwYXltZW50J1xuICAgICAgKTtcblxuICAgICAgaWYgKHR4UGFyYW1zLnR5cGUgPT09ICd0cnVzdGxpbmUnKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5VHJ1c3RsaW5lVHhPcGVyYXRpb25zKHR4Lm9wZXJhdGlvbnMsIHR4UGFyYW1zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfLmlzRW1wdHkob3V0cHV0T3BlcmF0aW9ucykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IGhhdmUgYW55IG9wZXJhdGlvbnMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uZm9yRWFjaCh0eFBhcmFtcy5yZWNpcGllbnRzLCAoZXhwZWN0ZWRPdXRwdXQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRPdXRwdXRBZGRyZXNzID0gc2VsZi5nZXRBZGRyZXNzRGV0YWlscyhleHBlY3RlZE91dHB1dC5hZGRyZXNzKTtcbiAgICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRPcGVyYXRpb25zW2luZGV4XSBhcyAoc3RlbGxhci5PcGVyYXRpb24uUGF5bWVudCB8IHN0ZWxsYXIuT3BlcmF0aW9uLkNyZWF0ZUFjY291bnQpO1xuICAgICAgICAgIGlmIChvdXRwdXQuZGVzdGluYXRpb24gIT09IGV4cGVjdGVkT3V0cHV0QWRkcmVzcy5hZGRyZXNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHJlY2lwaWVudCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkT3V0cHV0QW1vdW50ID0gbmV3IEJpZ051bWJlcihleHBlY3RlZE91dHB1dC5hbW91bnQpO1xuICAgICAgICAgIC8vIFRoZSBvdXRwdXQgYW1vdW50IGlzIGV4cHJlc3NlZCBhcyBzdGFydGluZ0JhbGFuY2UgaW4gY3JlYXRlQWNjb3VudCBvcGVyYXRpb25zIGFuZCBhcyBhbW91bnQgaW4gcGF5bWVudCBvcGVyYXRpb25zLlxuICAgICAgICAgIGNvbnN0IG91dHB1dEFtb3VudFN0cmluZyA9IChvdXRwdXQudHlwZSA9PT0gJ2NyZWF0ZUFjY291bnQnKSA/IG91dHB1dC5zdGFydGluZ0JhbGFuY2UgOiBvdXRwdXQuYW1vdW50O1xuICAgICAgICAgIGNvbnN0IG91dHB1dEFtb3VudCA9IG5ldyBCaWdOdW1iZXIoc2VsZi5iaWdVbml0c1RvQmFzZVVuaXRzKG91dHB1dEFtb3VudFN0cmluZykpO1xuXG4gICAgICAgICAgaWYgKCFvdXRwdXRBbW91bnQuZXEoZXhwZWN0ZWRPdXRwdXRBbW91bnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIGFtb3VudCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcmlmeSB0aGUgdXNlciBzaWduYXR1cmUsIGlmIHRoZSB0eCBpcyBoYWxmLXNpZ25lZFxuICAgICAgaWYgKCFfLmlzRW1wdHkodHguc2lnbmF0dXJlcykpIHtcbiAgICAgICAgY29uc3QgdXNlclNpZ25hdHVyZSA9IHR4LnNpZ25hdHVyZXNbMF0uc2lnbmF0dXJlKCk7XG5cbiAgICAgICAgLy8gb2J0YWluIHRoZSBrZXljaGFpbnMgYW5kIGtleSBzaWduYXR1cmVzXG4gICAgICAgIGxldCBrZXljaGFpbnMgPSB2ZXJpZmljYXRpb24ua2V5Y2hhaW5zO1xuICAgICAgICBpZiAoIWtleWNoYWlucyAmJiBkaXNhYmxlTmV0d29ya2luZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGZldGNoIGtleWNoYWlucyB3aXRob3V0IG5ldHdvcmtpbmcnKTtcbiAgICAgICAgfSBlbHNlIGlmICgha2V5Y2hhaW5zKSB7XG4gICAgICAgICAga2V5Y2hhaW5zID0geWllbGQgQmx1ZWJpcmQucHJvcHMoe1xuICAgICAgICAgICAgdXNlcjogc2VsZi5rZXljaGFpbnMoKS5nZXQoeyBpZDogd2FsbGV0LmtleUlkcygpW0tleUluZGljZXMuVVNFUl0gfSksXG4gICAgICAgICAgICBiYWNrdXA6IHNlbGYua2V5Y2hhaW5zKCkuZ2V0KHsgaWQ6IHdhbGxldC5rZXlJZHMoKVtLZXlJbmRpY2VzLkJBQ0tVUF0gfSksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleWNoYWlucyB8fCAha2V5Y2hhaW5zLmJhY2t1cCB8fCAha2V5Y2hhaW5zLnVzZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleWNoYWlucyBhcmUgcmVxdWlyZWQsIGJ1dCBjb3VsZCBub3QgYmUgZmV0Y2hlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYudmVyaWZ5U2lnbmF0dXJlKGtleWNoYWlucy5iYWNrdXAucHViLCB0eC5oYXNoKCksIHVzZXJTaWduYXR1cmUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBzaWduZWQgd2l0aCB3cm9uZyBrZXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGYudmVyaWZ5U2lnbmF0dXJlKGtleWNoYWlucy51c2VyLnB1YiwgdHguaGFzaCgpLCB1c2VyU2lnbmF0dXJlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gc2lnbmF0dXJlIGludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcml2ZSBhIGhhcmRlbmVkIGNoaWxkIHB1YmxpYyBrZXkgZnJvbSBhIG1hc3RlciBrZXkgc2VlZCB1c2luZyBhbiBhZGRpdGlvbmFsIHNlZWQgZm9yIHJhbmRvbW5lc3MuXG4gICAqXG4gICAqIER1ZSB0byB0ZWNobmljYWwgZGlmZmVyZW5jZXMgYmV0d2VlbiBrZXlwYWlycyBvbiB0aGUgZWQyNTUxOSBjdXJ2ZSBhbmQgdGhlIHNlY3AyNTZrMSBjdXJ2ZSxcbiAgICogb25seSBoYXJkZW5lZCBwcml2YXRlIGtleSBkZXJpdmF0aW9uIGlzIHN1cHBvcnRlZC5cbiAgICpcbiAgICogQHBhcmFtIGtleSBzZWVkIGZvciB0aGUgbWFzdGVyIGtleS4gTm90ZTogTm90IHRoZSBwdWJsaWMga2V5IG9yIGVuY29kZWQgcHJpdmF0ZSBrZXkuIFRoaXMgaXMgdGhlIHJhdyBzZWVkLlxuICAgKiBAcGFyYW0gZW50cm9weVNlZWQgcmFuZG9tIHNlZWQgd2hpY2ggaXMgaGFzaGVkIHRvIGdlbmVyYXRlIHRoZSBkZXJpdmF0aW9uIHBhdGhcbiAgICovXG4gIGRlcml2ZUtleVdpdGhTZWVkKHsga2V5LCBzZWVkIH06IHsga2V5OiBzdHJpbmc7IHNlZWQ6IHN0cmluZyB9KTogeyBkZXJpdmF0aW9uUGF0aDogc3RyaW5nOyBrZXk6IHN0cmluZyB9IHtcbiAgICBjb25zdCBkZXJpdmF0aW9uUGF0aElucHV0ID0gYml0Y29pbi5jcnlwdG8uaGFzaDI1NihgJHtzZWVkfWApLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCBkZXJpdmF0aW9uUGF0aFBhcnRzID0gW1xuICAgICAgOTk5OTk5LFxuICAgICAgcGFyc2VJbnQoZGVyaXZhdGlvblBhdGhJbnB1dC5zbGljZSgwLCA3KSwgMTYpLFxuICAgICAgcGFyc2VJbnQoZGVyaXZhdGlvblBhdGhJbnB1dC5zbGljZSg3LCAxNCksIDE2KSxcbiAgICBdO1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoID0gJ20vJyArIGRlcml2YXRpb25QYXRoUGFydHNcbiAgICAgIC5tYXAoKHBhcnQpID0+IGAke3BhcnR9J2ApXG4gICAgICAuam9pbignLycpO1xuICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBFZDI1NTE5S2V5RGVyaXZlci5kZXJpdmVQYXRoKGRlcml2YXRpb25QYXRoLCBrZXkpLmtleTtcbiAgICBjb25zdCBrZXlwYWlyID0gc3RlbGxhci5LZXlwYWlyLmZyb21SYXdFZDI1NTE5U2VlZChkZXJpdmVkS2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBrZXlwYWlyLnB1YmxpY0tleSgpLFxuICAgICAgZGVyaXZhdGlvblBhdGgsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzdGVsbGFyLXNkayBoYXMgdHdvIG92ZXJsb2FkcyBmb3IgdG9YRFIsIGFuZCB0eXBlc2NyaXB0IGNhbid0IHNlZW0gdG8gZmlndXJlIG91dCB0aGVcbiAgICogY29ycmVjdCBvbmUgdG8gdXNlLCBzbyB3ZSBoYXZlIHRvIGJlIHZlcnkgZXhwbGljaXQgYXMgdG8gd2hpY2ggb25lIHdlIHdhbnQuXG4gICAqIEBwYXJhbSB0eCB0cmFuc2FjdGlvbiB0byBjb252ZXJ0XG4gICAqL1xuICBwcm90ZWN0ZWQgc3RhdGljIHR4VG9TdHJpbmcgPSAodHg6IHN0ZWxsYXIuVHJhbnNhY3Rpb24pOiBzdHJpbmcgPT4gKHR4LnRvRW52ZWxvcGUoKS50b1hEUiBhcyAoKF86IHN0cmluZykgPT4gc3RyaW5nKSkoJ2Jhc2U2NCcpO1xuXG4gIHBhcnNlVHJhbnNhY3Rpb24ocGFyYW1zOiBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8UGFyc2VkVHJhbnNhY3Rpb24+KTogQmx1ZWJpcmQ8UGFyc2VkVHJhbnNhY3Rpb24+IHtcbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZSh7fSkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cbn1cbiJdfQ==