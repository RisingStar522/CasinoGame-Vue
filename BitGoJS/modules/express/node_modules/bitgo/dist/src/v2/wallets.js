"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
var bitcoin = require("@bitgo/utxo-lib");
var common = require("../common");
var wallet_1 = require("./wallet");
var Bluebird = require("bluebird");
var _ = require("lodash");
var bitcoin_1 = require("../bitcoin");
var util_1 = require("./internal/util");
var co = Bluebird.coroutine;
var Wallets = /** @class */ (function () {
    function Wallets(bitgo, baseCoin) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
    }
    /**
     * Get a wallet by ID (proxy for getWallet)
     * @param params
     * @param callback
     */
    Wallets.prototype.get = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.getWallet(params, callback);
    };
    /**
     * List a user's wallets
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallets.prototype.list = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var queryObject, body;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        queryObject = {};
                        if (params.skip && params.prevId) {
                            throw new Error('cannot specify both skip and prevId');
                        }
                        if (params.getbalances) {
                            if (!_.isBoolean(params.getbalances)) {
                                throw new Error('invalid getbalances argument, expecting boolean');
                            }
                            queryObject.getbalances = params.getbalances;
                        }
                        if (params.prevId) {
                            if (!_.isString(params.prevId)) {
                                throw new Error('invalid prevId argument, expecting string');
                            }
                            queryObject.prevId = params.prevId;
                        }
                        if (params.limit) {
                            if (!_.isNumber(params.limit)) {
                                throw new Error('invalid limit argument, expecting number');
                            }
                            queryObject.limit = params.limit;
                        }
                        if (params.allTokens) {
                            if (!_.isBoolean(params.allTokens)) {
                                throw new Error('invalid allTokens argument, expecting boolean');
                            }
                            queryObject.allTokens = params.allTokens;
                        }
                        return [4 /*yield*/, self.bitgo
                                .get(self.baseCoin.url('/wallet'))
                                .query(queryObject)
                                .result()];
                    case 1:
                        body = _a.sent();
                        body.wallets = body.wallets.map(function (w) { return new wallet_1.Wallet(self.bitgo, self.baseCoin, w); });
                        return [2 /*return*/, body];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * add
     * Add a new wallet (advanced mode).
     * This allows you to manually submit the keys, type, m and n of the wallet
     * Parameters include:
     *    "label": label of the wallet to be shown in UI
     *    "m": number of keys required to unlock wallet (2)
     *    "n": number of keys available on the wallet (3)
     *    "keys": array of keychain ids
     */
    Wallets.prototype.add = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var walletParams, newWallet;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, [], ['label', 'enterprise', 'type'], callback);
                        // no need to pass keys for (single) custodial wallets
                        if (params.type !== 'custodial') {
                            if (Array.isArray(params.keys) === false || !_.isNumber(params.m) || !_.isNumber(params.n)) {
                                throw new Error('invalid argument');
                            }
                            // TODO: support more types of multisig
                            if (!self.baseCoin.isValidMofNSetup(params)) {
                                throw new Error('unsupported multi-sig type');
                            }
                        }
                        if (params.gasPrice && !_.isNumber(params.gasPrice)) {
                            throw new Error('invalid argument for gasPrice - number expected');
                        }
                        if (params.tags && Array.isArray(params.tags) === false) {
                            throw new Error('invalid argument for tags - array expected');
                        }
                        if (params.clientFlags && Array.isArray(params.clientFlags) === false) {
                            throw new Error('invalid argument for clientFlags - array expected');
                        }
                        if (params.isCold && !_.isBoolean(params.isCold)) {
                            throw new Error('invalid argument for isCold - boolean expected');
                        }
                        if (params.isCustodial && !_.isBoolean(params.isCustodial)) {
                            throw new Error('invalid argument for isCustodial - boolean expected');
                        }
                        if (params.address && (!_.isString(params.address) || !this.baseCoin.isValidAddress(params.address))) {
                            throw new Error('invalid argument for address - valid address string expected');
                        }
                        if (params.signingKeyId && !_.isString(params.signingKeyId)) {
                            throw new Error('invalid argument for signingKeyId - valid key id string expected');
                        }
                        walletParams = _.pick(params, [
                            'label',
                            'm',
                            'n',
                            'keys',
                            'enterprise',
                            'isCold',
                            'isCustodial',
                            'tags',
                            'clientFlags',
                            'type',
                            'address',
                            'signingKeyId',
                            'gasPrice',
                        ]);
                        // Additional params needed for xrp
                        if (params.rootPub) {
                            walletParams.rootPub = params.rootPub;
                        }
                        // In XLM this private key is used only for wallet creation purposes, once the wallet is initialized then we
                        // update its weight to 0 making it an invalid key.
                        // https://www.stellar.org/developers/guides/concepts/multi-sig.html#additional-signing-keys
                        if (params.rootPrivateKey) {
                            walletParams.rootPrivateKey = params.rootPrivateKey;
                        }
                        if (params.initializationTxs) {
                            walletParams.initializationTxs = params.initializationTxs;
                        }
                        if (params.disableTransactionNotifications) {
                            walletParams.disableTransactionNotifications = params.disableTransactionNotifications;
                        }
                        return [4 /*yield*/, self.bitgo
                                .post(self.baseCoin.url('/wallet'))
                                .send(walletParams)
                                .result()];
                    case 1:
                        newWallet = _a.sent();
                        return [2 /*return*/, {
                                wallet: new wallet_1.Wallet(self.bitgo, self.baseCoin, newWallet),
                            }];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Generate a new wallet
     * 1. Creates the user keychain locally on the client, and encrypts it with the provided passphrase
     * 2. If no pub was provided, creates the backup keychain locally on the client, and encrypts it with the provided passphrase
     * 3. Uploads the encrypted user and backup keychains to BitGo
     * 4. Creates the BitGo key on the service
     * 5. Creates the wallet on BitGo with the 3 public keys above
     * @param params
     * @param params.label
     * @param params.passphrase
     * @param params.userKey User xpub
     * @param params.backupXpub Backup xpub
     * @param params.backupXpubProvider
     * @param params.enterprise
     * @param params.disableTransactionNotifications
     * @param params.passcodeEncryptionCode
     * @param params.coldDerivationSeed
     * @param params.gasPrice
     * @param params.disableKRSEmail
     * @param callback
     * @returns {*}
     */
    Wallets.prototype.generateWallet = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var label, passphrase, canEncrypt, isCold, walletParams, hasBackupXpub, hasBackupXpubProvider, krsSpecific, derivationPath, reqId, userKeychainPromise, backupKeychainPromise, _a, userKeychain, backupKeychain, bitgoKeychain, prv, _b, _c, keychains, finalWalletParams, newWallet, result;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        common.validateParams(params, ['label'], ['passphrase', 'userKey', 'backupXpub'], callback);
                        if (!_.isString(params.label)) {
                            throw new Error('missing required string parameter label');
                        }
                        label = params.label;
                        passphrase = params.passphrase;
                        canEncrypt = !!passphrase && typeof passphrase === 'string';
                        isCold = !canEncrypt || !!params.userKey;
                        walletParams = {
                            label: label,
                            m: 2,
                            n: 3,
                            keys: [],
                            isCold: isCold,
                        };
                        hasBackupXpub = !!params.backupXpub;
                        hasBackupXpubProvider = !!params.backupXpubProvider;
                        if (hasBackupXpub && hasBackupXpubProvider) {
                            throw new Error('Cannot provide more than one backupXpub or backupXpubProvider flag');
                        }
                        if (!_.isUndefined(params.passcodeEncryptionCode)) {
                            if (!_.isString(params.passcodeEncryptionCode)) {
                                throw new Error('passcodeEncryptionCode must be a string');
                            }
                        }
                        if (!_.isUndefined(params.enterprise)) {
                            if (!_.isString(params.enterprise)) {
                                throw new Error('invalid enterprise argument, expecting string');
                            }
                            walletParams.enterprise = params.enterprise;
                        }
                        if (!_.isUndefined(params.disableTransactionNotifications)) {
                            if (!_.isBoolean(params.disableTransactionNotifications)) {
                                throw new Error('invalid disableTransactionNotifications argument, expecting boolean');
                            }
                            walletParams.disableTransactionNotifications = params.disableTransactionNotifications;
                        }
                        if (!_.isUndefined(params.gasPrice)) {
                            if (!_.isNumber(params.gasPrice)) {
                                throw new Error('invalid gas price argument, expecting number');
                            }
                            walletParams.gasPrice = params.gasPrice;
                        }
                        if (!_.isUndefined(params.disableKRSEmail)) {
                            if (!_.isBoolean(params.disableKRSEmail)) {
                                throw new Error('invalid disableKRSEmail argument, expecting boolean');
                            }
                            walletParams.disableKRSEmail = params.disableKRSEmail;
                        }
                        krsSpecific = params.krsSpecific;
                        if (!_.isUndefined(krsSpecific)) {
                            Object.keys(krsSpecific).forEach(function (key) {
                                var val = krsSpecific[key];
                                if (!_.isBoolean(val) && !_.isString(val) && !_.isNumber(val)) {
                                    throw new Error('krsSpecific object contains illegal values. values must be strings, booleans, or numbers');
                                }
                            });
                        }
                        derivationPath = undefined;
                        reqId = new util_1.RequestTracer();
                        userKeychainPromise = co(function () {
                            var userKeychainParams, userKeychain, derivation, newUserKeychain;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        // User provided user key
                                        if (params.userKey) {
                                            userKeychain = { pub: params.userKey };
                                            userKeychainParams = userKeychain;
                                            if (params.coldDerivationSeed) {
                                                derivation = self.baseCoin.deriveKeyWithSeed({
                                                    key: params.userKey,
                                                    seed: params.coldDerivationSeed,
                                                });
                                                derivationPath = derivation.derivationPath;
                                                userKeychain.pub = derivation.key;
                                            }
                                        }
                                        else {
                                            if (!canEncrypt) {
                                                throw new Error('cannot generate user keypair without passphrase');
                                            }
                                            // Create the user key.
                                            userKeychain = self.baseCoin.keychains().create();
                                            userKeychain.encryptedPrv = self.bitgo.encrypt({ password: passphrase, input: userKeychain.prv });
                                            userKeychainParams = {
                                                pub: userKeychain.pub,
                                                encryptedPrv: userKeychain.encryptedPrv,
                                                originalPasscodeEncryptionCode: params.passcodeEncryptionCode,
                                            };
                                        }
                                        userKeychainParams.reqId = reqId;
                                        return [4 /*yield*/, self.baseCoin.keychains().add(userKeychainParams)];
                                    case 1:
                                        newUserKeychain = _a.sent();
                                        return [2 /*return*/, _.extend({}, newUserKeychain, userKeychain)];
                                }
                            });
                        }).call(this);
                        backupKeychainPromise = co(function () {
                            return __generator(this, function (_a) {
                                if (params.backupXpubProvider || self.baseCoin.getFamily() === 'rmg') {
                                    // If requested, use a KRS or backup key provider
                                    return [2 /*return*/, self.baseCoin.keychains().createBackup({
                                            provider: params.backupXpubProvider || 'defaultRMGBackupProvider',
                                            disableKRSEmail: params.disableKRSEmail,
                                            krsSpecific: params.krsSpecific,
                                            type: self.baseCoin.getChain(),
                                            reqId: reqId,
                                        })];
                                }
                                // User provided backup xpub
                                if (params.backupXpub) {
                                    // user provided backup ethereum address
                                    return [2 /*return*/, self.baseCoin.keychains().add({
                                            pub: params.backupXpub,
                                            source: 'backup',
                                            reqId: reqId,
                                        })];
                                }
                                else {
                                    if (!canEncrypt) {
                                        throw new Error('cannot generate backup keypair without passphrase');
                                    }
                                    // No provided backup xpub or address, so default to creating one here
                                    return [2 /*return*/, self.baseCoin.keychains().createBackup({ reqId: reqId })];
                                }
                                return [2 /*return*/];
                            });
                        }).call(this);
                        return [4 /*yield*/, Bluebird.props({
                                userKeychain: userKeychainPromise,
                                backupKeychain: backupKeychainPromise,
                                bitgoKeychain: self.baseCoin.keychains().createBitGo({ enterprise: params.enterprise, reqId: reqId }),
                            })];
                    case 1:
                        _a = _d.sent(), userKeychain = _a.userKeychain, backupKeychain = _a.backupKeychain, bitgoKeychain = _a.bitgoKeychain;
                        walletParams.keys = [userKeychain.id, backupKeychain.id, bitgoKeychain.id];
                        walletParams.isCold = isCold;
                        prv = userKeychain.prv;
                        if (!_.isString(prv)) return [3 /*break*/, 4];
                        _b = walletParams;
                        _c = {};
                        return [4 /*yield*/, self.baseCoin.signMessage({ prv: prv }, backupKeychain.pub)];
                    case 2:
                        _c.backup = (_d.sent()).toString('hex');
                        return [4 /*yield*/, self.baseCoin.signMessage({ prv: prv }, bitgoKeychain.pub)];
                    case 3:
                        _b.keySignatures = (_c.bitgo = (_d.sent()).toString('hex'),
                            _c);
                        _d.label = 4;
                    case 4:
                        if (_.includes(['xrp', 'xlm'], self.baseCoin.getFamily()) && !_.isUndefined(params.rootPrivateKey)) {
                            walletParams.rootPrivateKey = params.rootPrivateKey;
                        }
                        keychains = {
                            userKeychain: userKeychain,
                            backupKeychain: backupKeychain,
                            bitgoKeychain: bitgoKeychain,
                        };
                        return [4 /*yield*/, self.baseCoin.supplementGenerateWallet(walletParams, keychains)];
                    case 5:
                        finalWalletParams = _d.sent();
                        self.bitgo.setRequestTracer(reqId);
                        return [4 /*yield*/, self.bitgo
                                .post(self.baseCoin.url('/wallet'))
                                .send(finalWalletParams)
                                .result()];
                    case 6:
                        newWallet = _d.sent();
                        result = {
                            wallet: new wallet_1.Wallet(self.bitgo, self.baseCoin, newWallet),
                            userKeychain: userKeychain,
                            backupKeychain: backupKeychain,
                            bitgoKeychain: bitgoKeychain,
                        };
                        if (!_.isUndefined(backupKeychain.prv)) {
                            result.warning = 'Be sure to backup the backup keychain -- it is not stored anywhere else!';
                        }
                        if (!_.isUndefined(derivationPath)) {
                            userKeychain.derivationPath = derivationPath;
                        }
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * List the user's wallet shares
     * @param params
     * @param callback
     */
    Wallets.prototype.listShares = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.bitgo
            .get(this.baseCoin.url('/walletshare'))
            .result()
            .asCallback(callback);
    };
    /**
     * Gets a wallet share information, including the encrypted sharing keychain. requires unlock if keychain is present.
     * @param params
     * @param params.walletShareId - the wallet share to get information on
     * @param callback
     */
    Wallets.prototype.getShare = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['walletShareId'], [], callback);
        return this.bitgo
            .get(this.baseCoin.url('/walletshare/' + params.walletShareId))
            .result()
            .nodeify(callback);
    };
    /**
     * Update a wallet share
     * @param params.walletShareId - the wallet share to update
     * @param params.state - the new state of the wallet share
     * @param params
     * @param callback
     */
    Wallets.prototype.updateShare = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['walletShareId'], [], callback);
        return this.bitgo
            .post(this.baseCoin.url('/walletshare/' + params.walletShareId))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Resend a wallet share invitation email
     * @param params
     * @param params.walletShareId - the wallet share whose invitiation should be resent
     * @param callback
     */
    Wallets.prototype.resendShareInvite = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var urlParts;
            return __generator(this, function (_a) {
                common.validateParams(params, ['walletShareId'], [], callback);
                urlParts = params.walletShareId + '/resendemail';
                return [2 /*return*/, self.bitgo.post(self.baseCoin.url('/walletshare/' + urlParts)).result()];
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Cancel a wallet share
     * @param params
     * @param params.walletShareId - the wallet share to update
     * @param callback
     */
    Wallets.prototype.cancelShare = function (params, callback) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['walletShareId'], [], callback);
        return this.bitgo
            .del(this.baseCoin.url('/walletshare/' + params.walletShareId))
            .send()
            .result()
            .nodeify(callback);
    };
    /**
     * Accepts a wallet share, adding the wallet to the user's list
     * Needs a user's password to decrypt the shared key
     *
     * @param params
     * @param params.walletShareId - the wallet share to accept
     * @param params.userPassword - (required if more a keychain was shared) user's password to decrypt the shared wallet
     * @param params.newWalletPassphrase - new wallet passphrase for saving the shared wallet prv.
     *                                     If left blank and a wallet with more than view permissions was shared,
     *                                     then the user's login password is used.
     * @param params.overrideEncryptedPrv - set only if the prv was received out-of-band.
     * @param callback
     */
    Wallets.prototype.acceptShare = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var encryptedPrv, walletShare, sharingKeychain, rootExtKey, privKey, secret, decryptedSharedWalletPrv, newWalletPassphrase, updateParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, ['walletShareId'], ['overrideEncryptedPrv', 'userPassword', 'newWalletPassphrase'], callback);
                        encryptedPrv = params.overrideEncryptedPrv;
                        return [4 /*yield*/, self.getShare({ walletShareId: params.walletShareId })];
                    case 1:
                        walletShare = _a.sent();
                        // Return right away if there is no keychain to decrypt, or if explicit encryptedPrv was provided
                        if (!walletShare.keychain || !walletShare.keychain.encryptedPrv || encryptedPrv) {
                            return [2 /*return*/, self.updateShare({
                                    walletShareId: params.walletShareId,
                                    state: 'accepted',
                                })];
                        }
                        // More than viewing was requested, so we need to process the wallet keys using the shared ecdh scheme
                        if (_.isUndefined(params.userPassword)) {
                            throw new Error('userPassword param must be provided to decrypt shared key');
                        }
                        return [4 /*yield*/, self.bitgo.getECDHSharingKeychain()];
                    case 2:
                        sharingKeychain = _a.sent();
                        if (_.isUndefined(sharingKeychain.encryptedXprv)) {
                            throw new Error('encryptedXprv was not found on sharing keychain');
                        }
                        // Now we have the sharing keychain, we can work out the secret used for sharing the wallet with us
                        sharingKeychain.prv = self.bitgo.decrypt({
                            password: params.userPassword,
                            input: sharingKeychain.encryptedXprv,
                        });
                        rootExtKey = bitcoin.HDNode.fromBase58(sharingKeychain.prv);
                        privKey = bitcoin_1.hdPath(rootExtKey).deriveKey(walletShare.keychain.path);
                        secret = self.bitgo.getECDHSecret({
                            eckey: privKey,
                            otherPubKeyHex: walletShare.keychain.fromPubKey,
                        });
                        decryptedSharedWalletPrv = self.bitgo.decrypt({
                            password: secret,
                            input: walletShare.keychain.encryptedPrv,
                        });
                        newWalletPassphrase = params.newWalletPassphrase || params.userPassword;
                        encryptedPrv = self.bitgo.encrypt({
                            password: newWalletPassphrase,
                            input: decryptedSharedWalletPrv,
                        });
                        updateParams = {
                            walletShareId: params.walletShareId,
                            state: 'accepted',
                        };
                        if (encryptedPrv) {
                            updateParams.encryptedPrv = encryptedPrv;
                        }
                        return [2 /*return*/, self.updateShare(updateParams)];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Get a wallet by its ID
     * @param params
     * @param params.id wallet id
     * @param callback
     * @returns {*}
     */
    Wallets.prototype.getWallet = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var query, wallet;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, ['id'], [], callback);
                        query = {};
                        if (params.allTokens) {
                            if (!_.isBoolean(params.allTokens)) {
                                throw new Error('invalid allTokens argument, expecting boolean');
                            }
                            query.allTokens = params.allTokens;
                        }
                        self.bitgo.setRequestTracer(params.reqId || new util_1.RequestTracer());
                        return [4 /*yield*/, self.bitgo
                                .get(self.baseCoin.url('/wallet/' + params.id))
                                .query(query)
                                .result()];
                    case 1:
                        wallet = _a.sent();
                        return [2 /*return*/, new wallet_1.Wallet(self.bitgo, self.baseCoin, wallet)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * Get a wallet by its address
     * @param params
     * @param params.address wallet address
     * @param callback
     * @returns {*}
     */
    Wallets.prototype.getWalletByAddress = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var wallet;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, ['address'], [], callback);
                        self.bitgo.setRequestTracer(params.reqId || new util_1.RequestTracer());
                        return [4 /*yield*/, self.bitgo.get(self.baseCoin.url('/wallet/address/' + params.address)).result()];
                    case 1:
                        wallet = _a.sent();
                        return [2 /*return*/, new wallet_1.Wallet(self.bitgo, self.baseCoin, wallet)];
                }
            });
        })
            .call(this)
            .asCallback(callback);
    };
    /**
     * For any given supported coin, get total balances for all wallets of that
     * coin type on the account.
     * @param params
     * @param callback
     * @returns {*}
     */
    Wallets.prototype.getTotalBalances = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.bitgo
            .get(this.baseCoin.url('/wallet/balances'))
            .result()
            .asCallback(callback);
    };
    return Wallets;
}());
exports.Wallets = Wallets;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy92Mi93YWxsZXRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0dBRUc7QUFDSCx5Q0FBMkM7QUFFM0Msa0NBQW9DO0FBR3BDLG1DQUFxRDtBQUNyRCxtQ0FBcUM7QUFDckMsMEJBQTRCO0FBQzVCLHNDQUFvQztBQUNwQyx3Q0FBZ0Q7QUFFaEQsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQXlFOUI7SUFJRSxpQkFBWSxLQUFZLEVBQUUsUUFBa0I7UUFDMUMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxxQkFBRyxHQUFILFVBQUksTUFBNkIsRUFBRSxRQUErQjtRQUE5RCx1QkFBQSxFQUFBLFdBQTZCO1FBQy9CLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsc0JBQUksR0FBSixVQUNFLE1BQThCLEVBQzlCLFFBQThDO1FBRDlDLHVCQUFBLEVBQUEsV0FBOEI7UUFHOUIsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE9BQU8sRUFBRSxDQUF3Qjs7Ozs7d0JBQ3pCLFdBQVcsR0FBc0IsRUFBRSxDQUFDO3dCQUUxQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTs0QkFDaEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO3lCQUN4RDt3QkFFRCxJQUFJLE1BQU0sQ0FBQyxXQUFXLEVBQUU7NEJBQ3RCLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRTtn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QzFCLENBQUM7SUFDSCxjQUFDO0FBQUQsQ0FBQyxBQWxuQkQsSUFrbkJDO0FBbG5CWSwwQkFBTyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCAqIGFzIGJpdGNvaW4gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCB7IEJpdEdvIH0gZnJvbSAnLi4vYml0Z28nO1xuaW1wb3J0ICogYXMgY29tbW9uIGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQgeyBCYXNlQ29pbiwgS2V5Y2hhaW5zVHJpcGxldCwgU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyB9IGZyb20gJy4vYmFzZUNvaW4nO1xuaW1wb3J0IHsgTm9kZUNhbGxiYWNrLCBSZXF1ZXN0VHJhY2VyIGFzIElSZXF1ZXN0VHJhY2VyIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBQYWdpbmF0aW9uT3B0aW9ucywgV2FsbGV0IH0gZnJvbSAnLi93YWxsZXQnO1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgaGRQYXRoIH0gZnJvbSAnLi4vYml0Y29pbic7XG5pbXBvcnQgeyBSZXF1ZXN0VHJhY2VyIH0gZnJvbSAnLi9pbnRlcm5hbC91dGlsJztcblxuY29uc3QgY28gPSBCbHVlYmlyZC5jb3JvdXRpbmU7XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2FsbGV0V2l0aEtleWNoYWlucyBleHRlbmRzIEtleWNoYWluc1RyaXBsZXQge1xuICB3YWxsZXQ6IFdhbGxldDtcbiAgd2FybmluZz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRXYWxsZXRPcHRpb25zIHtcbiAgYWxsVG9rZW5zPzogYm9vbGVhbjtcbiAgcmVxSWQ/OiBJUmVxdWVzdFRyYWNlcjtcbiAgaWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2VuZXJhdGVXYWxsZXRPcHRpb25zIHtcbiAgbGFiZWw/OiBzdHJpbmc7XG4gIHBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHVzZXJLZXk/OiBzdHJpbmc7XG4gIGJhY2t1cFhwdWI/OiBzdHJpbmc7XG4gIGJhY2t1cFhwdWJQcm92aWRlcj86IHN0cmluZztcbiAgcGFzc2NvZGVFbmNyeXB0aW9uQ29kZT86IHN0cmluZztcbiAgZW50ZXJwcmlzZT86IHN0cmluZztcbiAgZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucz86IHN0cmluZztcbiAgZ2FzUHJpY2U/OiBzdHJpbmc7XG4gIGRpc2FibGVLUlNFbWFpbD86IGJvb2xlYW47XG4gIGtyc1NwZWNpZmljPzoge1xuICAgIFtpbmRleDogc3RyaW5nXTogYm9vbGVhbiB8IHN0cmluZyB8IG51bWJlcjtcbiAgfTtcbiAgY29sZERlcml2YXRpb25TZWVkPzogc3RyaW5nO1xuICByb290UHJpdmF0ZUtleT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRXYWxsZXRCeUFkZHJlc3NPcHRpb25zIHtcbiAgYWRkcmVzcz86IHN0cmluZztcbiAgcmVxSWQ/OiBSZXF1ZXN0VHJhY2VyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZVNoYXJlT3B0aW9ucyB7XG4gIHdhbGxldFNoYXJlSWQ/OiBzdHJpbmc7XG4gIHN0YXRlPzogc3RyaW5nO1xuICBlbmNyeXB0ZWRQcnY/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWNjZXB0U2hhcmVPcHRpb25zIHtcbiAgb3ZlcnJpZGVFbmNyeXB0ZWRQcnY/OiBzdHJpbmc7XG4gIHdhbGxldFNoYXJlSWQ/OiBzdHJpbmc7XG4gIHVzZXJQYXNzd29yZD86IHN0cmluZztcbiAgbmV3V2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBZGRXYWxsZXRPcHRpb25zIHtcbiAgdHlwZT86IHN0cmluZztcbiAga2V5cz86IHN0cmluZ1tdO1xuICBtPzogbnVtYmVyO1xuICBuPzogbnVtYmVyO1xuICB0YWdzPzogc3RyaW5nW107XG4gIGNsaWVudEZsYWdzPzogc3RyaW5nW107XG4gIHNpZ25pbmdLZXlJZD86IHN0cmluZztcbiAgaXNDb2xkPzogYm9vbGVhbjtcbiAgaXNDdXN0b2RpYWw/OiBib29sZWFuO1xuICBhZGRyZXNzPzogc3RyaW5nO1xuICByb290UHViPzogc3RyaW5nO1xuICByb290UHJpdmF0ZUtleT86IHN0cmluZztcbiAgaW5pdGlhbGl6YXRpb25UeHM/OiBhbnk7XG4gIGRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnM/OiBib29sZWFuO1xuICBnYXNQcmljZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0V2FsbGV0T3B0aW9ucyBleHRlbmRzIFBhZ2luYXRpb25PcHRpb25zIHtcbiAgc2tpcD86IG51bWJlcjtcbiAgZ2V0YmFsYW5jZXM/OiBib29sZWFuO1xuICBhbGxUb2tlbnM/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgV2FsbGV0cyB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYml0Z286IEJpdEdvO1xuICBwcml2YXRlIHJlYWRvbmx5IGJhc2VDb2luOiBCYXNlQ29pbjtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R28sIGJhc2VDb2luOiBCYXNlQ29pbikge1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgICB0aGlzLmJhc2VDb2luID0gYmFzZUNvaW47XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgd2FsbGV0IGJ5IElEIChwcm94eSBmb3IgZ2V0V2FsbGV0KVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZ2V0KHBhcmFtczogR2V0V2FsbGV0T3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxXYWxsZXQ+KTogQmx1ZWJpcmQ8V2FsbGV0PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V2FsbGV0KHBhcmFtcywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgYSB1c2VyJ3Mgd2FsbGV0c1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGxpc3QoXG4gICAgcGFyYW1zOiBMaXN0V2FsbGV0T3B0aW9ucyA9IHt9LFxuICAgIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPHsgd2FsbGV0czogV2FsbGV0W10gfT5cbiAgKTogQmx1ZWJpcmQ8eyB3YWxsZXRzOiBXYWxsZXRbXSB9PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPHsgd2FsbGV0czogV2FsbGV0W10gfT4oZnVuY3Rpb24qKCkge1xuICAgICAgY29uc3QgcXVlcnlPYmplY3Q6IExpc3RXYWxsZXRPcHRpb25zID0ge307XG5cbiAgICAgIGlmIChwYXJhbXMuc2tpcCAmJiBwYXJhbXMucHJldklkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNwZWNpZnkgYm90aCBza2lwIGFuZCBwcmV2SWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5nZXRiYWxhbmNlcykge1xuICAgICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5nZXRiYWxhbmNlcykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZ2V0YmFsYW5jZXMgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcnlPYmplY3QuZ2V0YmFsYW5jZXMgPSBwYXJhbXMuZ2V0YmFsYW5jZXM7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnByZXZJZCkge1xuICAgICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnByZXZJZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJldklkIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcnlPYmplY3QucHJldklkID0gcGFyYW1zLnByZXZJZDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMubGltaXQpIHtcbiAgICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGltaXQgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBxdWVyeU9iamVjdC5saW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5hbGxUb2tlbnMpIHtcbiAgICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuYWxsVG9rZW5zKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhbGxUb2tlbnMgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcnlPYmplY3QuYWxsVG9rZW5zID0gcGFyYW1zLmFsbFRva2VucztcbiAgICAgIH1cblxuICAgICAgY29uc3QgYm9keSA9IHlpZWxkIHNlbGYuYml0Z29cbiAgICAgICAgLmdldChzZWxmLmJhc2VDb2luLnVybCgnL3dhbGxldCcpKVxuICAgICAgICAucXVlcnkocXVlcnlPYmplY3QpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICAgIGJvZHkud2FsbGV0cyA9IGJvZHkud2FsbGV0cy5tYXAodyA9PiBuZXcgV2FsbGV0KHNlbGYuYml0Z28sIHNlbGYuYmFzZUNvaW4sIHcpKTtcbiAgICAgIHJldHVybiBib2R5O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIGFkZFxuICAgKiBBZGQgYSBuZXcgd2FsbGV0IChhZHZhbmNlZCBtb2RlKS5cbiAgICogVGhpcyBhbGxvd3MgeW91IHRvIG1hbnVhbGx5IHN1Ym1pdCB0aGUga2V5cywgdHlwZSwgbSBhbmQgbiBvZiB0aGUgd2FsbGV0XG4gICAqIFBhcmFtZXRlcnMgaW5jbHVkZTpcbiAgICogICAgXCJsYWJlbFwiOiBsYWJlbCBvZiB0aGUgd2FsbGV0IHRvIGJlIHNob3duIGluIFVJXG4gICAqICAgIFwibVwiOiBudW1iZXIgb2Yga2V5cyByZXF1aXJlZCB0byB1bmxvY2sgd2FsbGV0ICgyKVxuICAgKiAgICBcIm5cIjogbnVtYmVyIG9mIGtleXMgYXZhaWxhYmxlIG9uIHRoZSB3YWxsZXQgKDMpXG4gICAqICAgIFwia2V5c1wiOiBhcnJheSBvZiBrZXljaGFpbiBpZHNcbiAgICovXG4gIGFkZChwYXJhbXM6IEFkZFdhbGxldE9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiooKSB7XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWydsYWJlbCcsICdlbnRlcnByaXNlJywgJ3R5cGUnXSwgY2FsbGJhY2spO1xuXG4gICAgICAvLyBubyBuZWVkIHRvIHBhc3Mga2V5cyBmb3IgKHNpbmdsZSkgY3VzdG9kaWFsIHdhbGxldHNcbiAgICAgIGlmIChwYXJhbXMudHlwZSAhPT0gJ2N1c3RvZGlhbCcpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1zLmtleXMpID09PSBmYWxzZSB8fCAhXy5pc051bWJlcihwYXJhbXMubSkgfHwgIV8uaXNOdW1iZXIocGFyYW1zLm4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IG1vcmUgdHlwZXMgb2YgbXVsdGlzaWdcbiAgICAgICAgaWYgKCFzZWxmLmJhc2VDb2luLmlzVmFsaWRNb2ZOU2V0dXAocGFyYW1zKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgbXVsdGktc2lnIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmdhc1ByaWNlICYmICFfLmlzTnVtYmVyKHBhcmFtcy5nYXNQcmljZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBnYXNQcmljZSAtIG51bWJlciBleHBlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLnRhZ3MgJiYgQXJyYXkuaXNBcnJheShwYXJhbXMudGFncykgPT09IGZhbHNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgdGFncyAtIGFycmF5IGV4cGVjdGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuY2xpZW50RmxhZ3MgJiYgQXJyYXkuaXNBcnJheShwYXJhbXMuY2xpZW50RmxhZ3MpID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGNsaWVudEZsYWdzIC0gYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5pc0NvbGQgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5pc0NvbGQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgaXNDb2xkIC0gYm9vbGVhbiBleHBlY3RlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmlzQ3VzdG9kaWFsICYmICFfLmlzQm9vbGVhbihwYXJhbXMuaXNDdXN0b2RpYWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgaXNDdXN0b2RpYWwgLSBib29sZWFuIGV4cGVjdGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMuYWRkcmVzcyAmJiAoIV8uaXNTdHJpbmcocGFyYW1zLmFkZHJlc3MpIHx8ICF0aGlzLmJhc2VDb2luLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5hZGRyZXNzKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBhZGRyZXNzIC0gdmFsaWQgYWRkcmVzcyBzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5zaWduaW5nS2V5SWQgJiYgIV8uaXNTdHJpbmcocGFyYW1zLnNpZ25pbmdLZXlJZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBzaWduaW5nS2V5SWQgLSB2YWxpZCBrZXkgaWQgc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdhbGxldFBhcmFtcyA9IF8ucGljayhwYXJhbXMsIFtcbiAgICAgICAgJ2xhYmVsJyxcbiAgICAgICAgJ20nLFxuICAgICAgICAnbicsXG4gICAgICAgICdrZXlzJyxcbiAgICAgICAgJ2VudGVycHJpc2UnLFxuICAgICAgICAnaXNDb2xkJyxcbiAgICAgICAgJ2lzQ3VzdG9kaWFsJyxcbiAgICAgICAgJ3RhZ3MnLFxuICAgICAgICAnY2xpZW50RmxhZ3MnLFxuICAgICAgICAndHlwZScsXG4gICAgICAgICdhZGRyZXNzJyxcbiAgICAgICAgJ3NpZ25pbmdLZXlJZCcsXG4gICAgICAgICdnYXNQcmljZScsXG4gICAgICBdKTtcblxuICAgICAgLy8gQWRkaXRpb25hbCBwYXJhbXMgbmVlZGVkIGZvciB4cnBcbiAgICAgIGlmIChwYXJhbXMucm9vdFB1Yikge1xuICAgICAgICB3YWxsZXRQYXJhbXMucm9vdFB1YiA9IHBhcmFtcy5yb290UHViO1xuICAgICAgfVxuXG4gICAgICAvLyBJbiBYTE0gdGhpcyBwcml2YXRlIGtleSBpcyB1c2VkIG9ubHkgZm9yIHdhbGxldCBjcmVhdGlvbiBwdXJwb3Nlcywgb25jZSB0aGUgd2FsbGV0IGlzIGluaXRpYWxpemVkIHRoZW4gd2VcbiAgICAgIC8vIHVwZGF0ZSBpdHMgd2VpZ2h0IHRvIDAgbWFraW5nIGl0IGFuIGludmFsaWQga2V5LlxuICAgICAgLy8gaHR0cHM6Ly93d3cuc3RlbGxhci5vcmcvZGV2ZWxvcGVycy9ndWlkZXMvY29uY2VwdHMvbXVsdGktc2lnLmh0bWwjYWRkaXRpb25hbC1zaWduaW5nLWtleXNcbiAgICAgIGlmIChwYXJhbXMucm9vdFByaXZhdGVLZXkpIHtcbiAgICAgICAgd2FsbGV0UGFyYW1zLnJvb3RQcml2YXRlS2V5ID0gcGFyYW1zLnJvb3RQcml2YXRlS2V5O1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zLmluaXRpYWxpemF0aW9uVHhzKSB7XG4gICAgICAgIHdhbGxldFBhcmFtcy5pbml0aWFsaXphdGlvblR4cyA9IHBhcmFtcy5pbml0aWFsaXphdGlvblR4cztcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5kaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zKSB7XG4gICAgICAgIHdhbGxldFBhcmFtcy5kaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zID0gcGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld1dhbGxldCA9IHlpZWxkIHNlbGYuYml0Z29cbiAgICAgICAgLnBvc3Qoc2VsZi5iYXNlQ29pbi51cmwoJy93YWxsZXQnKSlcbiAgICAgICAgLnNlbmQod2FsbGV0UGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3YWxsZXQ6IG5ldyBXYWxsZXQoc2VsZi5iaXRnbywgc2VsZi5iYXNlQ29pbiwgbmV3V2FsbGV0KSxcbiAgICAgIH07XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBuZXcgd2FsbGV0XG4gICAqIDEuIENyZWF0ZXMgdGhlIHVzZXIga2V5Y2hhaW4gbG9jYWxseSBvbiB0aGUgY2xpZW50LCBhbmQgZW5jcnlwdHMgaXQgd2l0aCB0aGUgcHJvdmlkZWQgcGFzc3BocmFzZVxuICAgKiAyLiBJZiBubyBwdWIgd2FzIHByb3ZpZGVkLCBjcmVhdGVzIHRoZSBiYWNrdXAga2V5Y2hhaW4gbG9jYWxseSBvbiB0aGUgY2xpZW50LCBhbmQgZW5jcnlwdHMgaXQgd2l0aCB0aGUgcHJvdmlkZWQgcGFzc3BocmFzZVxuICAgKiAzLiBVcGxvYWRzIHRoZSBlbmNyeXB0ZWQgdXNlciBhbmQgYmFja3VwIGtleWNoYWlucyB0byBCaXRHb1xuICAgKiA0LiBDcmVhdGVzIHRoZSBCaXRHbyBrZXkgb24gdGhlIHNlcnZpY2VcbiAgICogNS4gQ3JlYXRlcyB0aGUgd2FsbGV0IG9uIEJpdEdvIHdpdGggdGhlIDMgcHVibGljIGtleXMgYWJvdmVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmxhYmVsXG4gICAqIEBwYXJhbSBwYXJhbXMucGFzc3BocmFzZVxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJLZXkgVXNlciB4cHViXG4gICAqIEBwYXJhbSBwYXJhbXMuYmFja3VwWHB1YiBCYWNrdXAgeHB1YlxuICAgKiBAcGFyYW0gcGFyYW1zLmJhY2t1cFhwdWJQcm92aWRlclxuICAgKiBAcGFyYW0gcGFyYW1zLmVudGVycHJpc2VcbiAgICogQHBhcmFtIHBhcmFtcy5kaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zXG4gICAqIEBwYXJhbSBwYXJhbXMucGFzc2NvZGVFbmNyeXB0aW9uQ29kZVxuICAgKiBAcGFyYW0gcGFyYW1zLmNvbGREZXJpdmF0aW9uU2VlZFxuICAgKiBAcGFyYW0gcGFyYW1zLmdhc1ByaWNlXG4gICAqIEBwYXJhbSBwYXJhbXMuZGlzYWJsZUtSU0VtYWlsXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGdlbmVyYXRlV2FsbGV0KFxuICAgIHBhcmFtczogR2VuZXJhdGVXYWxsZXRPcHRpb25zID0ge30sXG4gICAgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8V2FsbGV0V2l0aEtleWNoYWlucz5cbiAgKTogQmx1ZWJpcmQ8V2FsbGV0V2l0aEtleWNoYWlucz4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxXYWxsZXRXaXRoS2V5Y2hhaW5zPihmdW5jdGlvbiooKSB7XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2xhYmVsJ10sIFsncGFzc3BocmFzZScsICd1c2VyS2V5JywgJ2JhY2t1cFhwdWInXSwgY2FsbGJhY2spO1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5sYWJlbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHN0cmluZyBwYXJhbWV0ZXIgbGFiZWwnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhYmVsID0gcGFyYW1zLmxhYmVsO1xuICAgICAgY29uc3QgcGFzc3BocmFzZSA9IHBhcmFtcy5wYXNzcGhyYXNlO1xuICAgICAgY29uc3QgY2FuRW5jcnlwdCA9ICEhcGFzc3BocmFzZSAmJiB0eXBlb2YgcGFzc3BocmFzZSA9PT0gJ3N0cmluZyc7XG4gICAgICBjb25zdCBpc0NvbGQgPSAhY2FuRW5jcnlwdCB8fCAhIXBhcmFtcy51c2VyS2V5O1xuXG4gICAgICBjb25zdCB3YWxsZXRQYXJhbXM6IFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMgPSB7XG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgbTogMixcbiAgICAgICAgbjogMyxcbiAgICAgICAga2V5czogW10sXG4gICAgICAgIGlzQ29sZCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGhhc0JhY2t1cFhwdWIgPSAhIXBhcmFtcy5iYWNrdXBYcHViO1xuICAgICAgY29uc3QgaGFzQmFja3VwWHB1YlByb3ZpZGVyID0gISFwYXJhbXMuYmFja3VwWHB1YlByb3ZpZGVyO1xuICAgICAgaWYgKGhhc0JhY2t1cFhwdWIgJiYgaGFzQmFja3VwWHB1YlByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHByb3ZpZGUgbW9yZSB0aGFuIG9uZSBiYWNrdXBYcHViIG9yIGJhY2t1cFhwdWJQcm92aWRlciBmbGFnJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMucGFzc2NvZGVFbmNyeXB0aW9uQ29kZSkpIHtcbiAgICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFzc2NvZGVFbmNyeXB0aW9uQ29kZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5lbnRlcnByaXNlKSkge1xuICAgICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmVudGVycHJpc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVudGVycHJpc2UgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICB3YWxsZXRQYXJhbXMuZW50ZXJwcmlzZSA9IHBhcmFtcy5lbnRlcnByaXNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMpKSB7XG4gICAgICAgIGlmICghXy5pc0Jvb2xlYW4ocGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgd2FsbGV0UGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMgPSBwYXJhbXMuZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucztcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5nYXNQcmljZSkpIHtcbiAgICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5nYXNQcmljZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZ2FzIHByaWNlIGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgd2FsbGV0UGFyYW1zLmdhc1ByaWNlID0gcGFyYW1zLmdhc1ByaWNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmRpc2FibGVLUlNFbWFpbCkpIHtcbiAgICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuZGlzYWJsZUtSU0VtYWlsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkaXNhYmxlS1JTRW1haWwgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgd2FsbGV0UGFyYW1zLmRpc2FibGVLUlNFbWFpbCA9IHBhcmFtcy5kaXNhYmxlS1JTRW1haWw7XG4gICAgICB9XG5cbiAgICAgIC8vIEVuc3VyZSBlYWNoIGtyc1NwZWNpZmljIHBhcmFtIGlzIGVpdGhlciBhIHN0cmluZywgYm9vbGVhbiwgb3IgbnVtYmVyXG4gICAgICBjb25zdCB7IGtyc1NwZWNpZmljIH0gPSBwYXJhbXM7XG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQoa3JzU3BlY2lmaWMpKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGtyc1NwZWNpZmljKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsID0ga3JzU3BlY2lmaWNba2V5XTtcbiAgICAgICAgICBpZiAoIV8uaXNCb29sZWFuKHZhbCkgJiYgIV8uaXNTdHJpbmcodmFsKSAmJiAhXy5pc051bWJlcih2YWwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2tyc1NwZWNpZmljIG9iamVjdCBjb250YWlucyBpbGxlZ2FsIHZhbHVlcy4gdmFsdWVzIG11c3QgYmUgc3RyaW5ncywgYm9vbGVhbnMsIG9yIG51bWJlcnMnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGVyaXZhdGlvblBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAgICAgY29uc3QgcmVxSWQgPSBuZXcgUmVxdWVzdFRyYWNlcigpO1xuXG4gICAgICAvLyBBZGQgdGhlIHVzZXIga2V5Y2hhaW5cbiAgICAgIGNvbnN0IHVzZXJLZXljaGFpblByb21pc2UgPSBjbyhmdW5jdGlvbiooKSB7XG4gICAgICAgIGxldCB1c2VyS2V5Y2hhaW5QYXJhbXM7XG4gICAgICAgIGxldCB1c2VyS2V5Y2hhaW47XG4gICAgICAgIC8vIFVzZXIgcHJvdmlkZWQgdXNlciBrZXlcbiAgICAgICAgaWYgKHBhcmFtcy51c2VyS2V5KSB7XG4gICAgICAgICAgdXNlcktleWNoYWluID0geyBwdWI6IHBhcmFtcy51c2VyS2V5IH07XG4gICAgICAgICAgdXNlcktleWNoYWluUGFyYW1zID0gdXNlcktleWNoYWluO1xuICAgICAgICAgIGlmIChwYXJhbXMuY29sZERlcml2YXRpb25TZWVkKSB7XG4gICAgICAgICAgICAvLyB0aGUgZGVyaXZhdGlvbiBvbmx5IG1ha2VzIHNlbnNlIHdoZW4gYSBrZXkgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgIGNvbnN0IGRlcml2YXRpb24gPSBzZWxmLmJhc2VDb2luLmRlcml2ZUtleVdpdGhTZWVkKHtcbiAgICAgICAgICAgICAga2V5OiBwYXJhbXMudXNlcktleSxcbiAgICAgICAgICAgICAgc2VlZDogcGFyYW1zLmNvbGREZXJpdmF0aW9uU2VlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVyaXZhdGlvblBhdGggPSBkZXJpdmF0aW9uLmRlcml2YXRpb25QYXRoO1xuICAgICAgICAgICAgdXNlcktleWNoYWluLnB1YiA9IGRlcml2YXRpb24ua2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWNhbkVuY3J5cHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdlbmVyYXRlIHVzZXIga2V5cGFpciB3aXRob3V0IHBhc3NwaHJhc2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ3JlYXRlIHRoZSB1c2VyIGtleS5cbiAgICAgICAgICB1c2VyS2V5Y2hhaW4gPSBzZWxmLmJhc2VDb2luLmtleWNoYWlucygpLmNyZWF0ZSgpO1xuICAgICAgICAgIHVzZXJLZXljaGFpbi5lbmNyeXB0ZWRQcnYgPSBzZWxmLmJpdGdvLmVuY3J5cHQoeyBwYXNzd29yZDogcGFzc3BocmFzZSwgaW5wdXQ6IHVzZXJLZXljaGFpbi5wcnYgfSk7XG4gICAgICAgICAgdXNlcktleWNoYWluUGFyYW1zID0ge1xuICAgICAgICAgICAgcHViOiB1c2VyS2V5Y2hhaW4ucHViLFxuICAgICAgICAgICAgZW5jcnlwdGVkUHJ2OiB1c2VyS2V5Y2hhaW4uZW5jcnlwdGVkUHJ2LFxuICAgICAgICAgICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlOiBwYXJhbXMucGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdXNlcktleWNoYWluUGFyYW1zLnJlcUlkID0gcmVxSWQ7XG4gICAgICAgIGNvbnN0IG5ld1VzZXJLZXljaGFpbiA9IHlpZWxkIHNlbGYuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuYWRkKHVzZXJLZXljaGFpblBhcmFtcyk7XG4gICAgICAgIHJldHVybiBfLmV4dGVuZCh7fSwgbmV3VXNlcktleWNoYWluLCB1c2VyS2V5Y2hhaW4pO1xuICAgICAgfSkuY2FsbCh0aGlzKTtcblxuICAgICAgY29uc3QgYmFja3VwS2V5Y2hhaW5Qcm9taXNlID0gY28oZnVuY3Rpb24qKCkge1xuICAgICAgICBpZiAocGFyYW1zLmJhY2t1cFhwdWJQcm92aWRlciB8fCBzZWxmLmJhc2VDb2luLmdldEZhbWlseSgpID09PSAncm1nJykge1xuICAgICAgICAgIC8vIElmIHJlcXVlc3RlZCwgdXNlIGEgS1JTIG9yIGJhY2t1cCBrZXkgcHJvdmlkZXJcbiAgICAgICAgICByZXR1cm4gc2VsZi5iYXNlQ29pbi5rZXljaGFpbnMoKS5jcmVhdGVCYWNrdXAoe1xuICAgICAgICAgICAgcHJvdmlkZXI6IHBhcmFtcy5iYWNrdXBYcHViUHJvdmlkZXIgfHwgJ2RlZmF1bHRSTUdCYWNrdXBQcm92aWRlcicsXG4gICAgICAgICAgICBkaXNhYmxlS1JTRW1haWw6IHBhcmFtcy5kaXNhYmxlS1JTRW1haWwsXG4gICAgICAgICAgICBrcnNTcGVjaWZpYzogcGFyYW1zLmtyc1NwZWNpZmljLFxuICAgICAgICAgICAgdHlwZTogc2VsZi5iYXNlQ29pbi5nZXRDaGFpbigpLFxuICAgICAgICAgICAgcmVxSWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2VyIHByb3ZpZGVkIGJhY2t1cCB4cHViXG4gICAgICAgIGlmIChwYXJhbXMuYmFja3VwWHB1Yikge1xuICAgICAgICAgIC8vIHVzZXIgcHJvdmlkZWQgYmFja3VwIGV0aGVyZXVtIGFkZHJlc3NcbiAgICAgICAgICByZXR1cm4gc2VsZi5iYXNlQ29pbi5rZXljaGFpbnMoKS5hZGQoe1xuICAgICAgICAgICAgcHViOiBwYXJhbXMuYmFja3VwWHB1YixcbiAgICAgICAgICAgIHNvdXJjZTogJ2JhY2t1cCcsXG4gICAgICAgICAgICByZXFJZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWNhbkVuY3J5cHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdlbmVyYXRlIGJhY2t1cCBrZXlwYWlyIHdpdGhvdXQgcGFzc3BocmFzZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBObyBwcm92aWRlZCBiYWNrdXAgeHB1YiBvciBhZGRyZXNzLCBzbyBkZWZhdWx0IHRvIGNyZWF0aW5nIG9uZSBoZXJlXG4gICAgICAgICAgcmV0dXJuIHNlbGYuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuY3JlYXRlQmFja3VwKHsgcmVxSWQgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhbGwodGhpcyk7XG5cbiAgICAgIGNvbnN0IHsgdXNlcktleWNoYWluLCBiYWNrdXBLZXljaGFpbiwgYml0Z29LZXljaGFpbiB9OiBLZXljaGFpbnNUcmlwbGV0ID0geWllbGQgQmx1ZWJpcmQucHJvcHMoe1xuICAgICAgICB1c2VyS2V5Y2hhaW46IHVzZXJLZXljaGFpblByb21pc2UsXG4gICAgICAgIGJhY2t1cEtleWNoYWluOiBiYWNrdXBLZXljaGFpblByb21pc2UsXG4gICAgICAgIGJpdGdvS2V5Y2hhaW46IHNlbGYuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuY3JlYXRlQml0R28oeyBlbnRlcnByaXNlOiBwYXJhbXMuZW50ZXJwcmlzZSwgcmVxSWQgfSksXG4gICAgICB9KTtcblxuICAgICAgd2FsbGV0UGFyYW1zLmtleXMgPSBbdXNlcktleWNoYWluLmlkLCBiYWNrdXBLZXljaGFpbi5pZCwgYml0Z29LZXljaGFpbi5pZF07XG5cbiAgICAgIHdhbGxldFBhcmFtcy5pc0NvbGQgPSBpc0NvbGQ7XG5cbiAgICAgIGNvbnN0IHsgcHJ2IH0gPSB1c2VyS2V5Y2hhaW47XG4gICAgICBpZiAoXy5pc1N0cmluZyhwcnYpKSB7XG4gICAgICAgIHdhbGxldFBhcmFtcy5rZXlTaWduYXR1cmVzID0ge1xuICAgICAgICAgIGJhY2t1cDogKHlpZWxkIHNlbGYuYmFzZUNvaW4uc2lnbk1lc3NhZ2UoeyBwcnYgfSwgYmFja3VwS2V5Y2hhaW4ucHViKSkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgIGJpdGdvOiAoeWllbGQgc2VsZi5iYXNlQ29pbi5zaWduTWVzc2FnZSh7IHBydiB9LCBiaXRnb0tleWNoYWluLnB1YikpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaW5jbHVkZXMoWyd4cnAnLCAneGxtJ10sIHNlbGYuYmFzZUNvaW4uZ2V0RmFtaWx5KCkpICYmICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5yb290UHJpdmF0ZUtleSkpIHtcbiAgICAgICAgd2FsbGV0UGFyYW1zLnJvb3RQcml2YXRlS2V5ID0gcGFyYW1zLnJvb3RQcml2YXRlS2V5O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXljaGFpbnMgPSB7XG4gICAgICAgIHVzZXJLZXljaGFpbixcbiAgICAgICAgYmFja3VwS2V5Y2hhaW4sXG4gICAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgICB9O1xuICAgICAgY29uc3QgZmluYWxXYWxsZXRQYXJhbXMgPSB5aWVsZCBzZWxmLmJhc2VDb2luLnN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldCh3YWxsZXRQYXJhbXMsIGtleWNoYWlucyk7XG4gICAgICBzZWxmLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocmVxSWQpO1xuICAgICAgY29uc3QgbmV3V2FsbGV0ID0geWllbGQgc2VsZi5iaXRnb1xuICAgICAgICAucG9zdChzZWxmLmJhc2VDb2luLnVybCgnL3dhbGxldCcpKVxuICAgICAgICAuc2VuZChmaW5hbFdhbGxldFBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuXG4gICAgICBjb25zdCByZXN1bHQ6IFdhbGxldFdpdGhLZXljaGFpbnMgPSB7XG4gICAgICAgIHdhbGxldDogbmV3IFdhbGxldChzZWxmLmJpdGdvLCBzZWxmLmJhc2VDb2luLCBuZXdXYWxsZXQpLFxuICAgICAgICB1c2VyS2V5Y2hhaW46IHVzZXJLZXljaGFpbixcbiAgICAgICAgYmFja3VwS2V5Y2hhaW46IGJhY2t1cEtleWNoYWluLFxuICAgICAgICBiaXRnb0tleWNoYWluOiBiaXRnb0tleWNoYWluLFxuICAgICAgfTtcblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKGJhY2t1cEtleWNoYWluLnBydikpIHtcbiAgICAgICAgcmVzdWx0Lndhcm5pbmcgPSAnQmUgc3VyZSB0byBiYWNrdXAgdGhlIGJhY2t1cCBrZXljaGFpbiAtLSBpdCBpcyBub3Qgc3RvcmVkIGFueXdoZXJlIGVsc2UhJztcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKGRlcml2YXRpb25QYXRoKSkge1xuICAgICAgICB1c2VyS2V5Y2hhaW4uZGVyaXZhdGlvblBhdGggPSBkZXJpdmF0aW9uUGF0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHRoZSB1c2VyJ3Mgd2FsbGV0IHNoYXJlc1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgbGlzdFNoYXJlcyhwYXJhbXM6IHt9ID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5iaXRnb1xuICAgICAgLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldHNoYXJlJykpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgd2FsbGV0IHNoYXJlIGluZm9ybWF0aW9uLCBpbmNsdWRpbmcgdGhlIGVuY3J5cHRlZCBzaGFyaW5nIGtleWNoYWluLiByZXF1aXJlcyB1bmxvY2sgaWYga2V5Y2hhaW4gaXMgcHJlc2VudC5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFNoYXJlSWQgLSB0aGUgd2FsbGV0IHNoYXJlIHRvIGdldCBpbmZvcm1hdGlvbiBvblxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGdldFNoYXJlKHBhcmFtczogeyB3YWxsZXRTaGFyZUlkPzogc3RyaW5nIH0gPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnd2FsbGV0U2hhcmVJZCddLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXMuYml0Z29cbiAgICAgIC5nZXQodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXRzaGFyZS8nICsgcGFyYW1zLndhbGxldFNoYXJlSWQpKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGEgd2FsbGV0IHNoYXJlXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0U2hhcmVJZCAtIHRoZSB3YWxsZXQgc2hhcmUgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSBwYXJhbXMuc3RhdGUgLSB0aGUgbmV3IHN0YXRlIG9mIHRoZSB3YWxsZXQgc2hhcmVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHVwZGF0ZVNoYXJlKHBhcmFtczogVXBkYXRlU2hhcmVPcHRpb25zID0ge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dhbGxldFNoYXJlSWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzLmJpdGdvXG4gICAgICAucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldHNoYXJlLycgKyBwYXJhbXMud2FsbGV0U2hhcmVJZCkpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNlbmQgYSB3YWxsZXQgc2hhcmUgaW52aXRhdGlvbiBlbWFpbFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0U2hhcmVJZCAtIHRoZSB3YWxsZXQgc2hhcmUgd2hvc2UgaW52aXRpYXRpb24gc2hvdWxkIGJlIHJlc2VudFxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHJlc2VuZFNoYXJlSW52aXRlKHBhcmFtczogeyB3YWxsZXRTaGFyZUlkPzogc3RyaW5nIH0gPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiooKSB7XG4gICAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dhbGxldFNoYXJlSWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICAgICAgY29uc3QgdXJsUGFydHMgPSBwYXJhbXMud2FsbGV0U2hhcmVJZCArICcvcmVzZW5kZW1haWwnO1xuICAgICAgcmV0dXJuIHNlbGYuYml0Z28ucG9zdChzZWxmLmJhc2VDb2luLnVybCgnL3dhbGxldHNoYXJlLycgKyB1cmxQYXJ0cykpLnJlc3VsdCgpO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCBhIHdhbGxldCBzaGFyZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0U2hhcmVJZCAtIHRoZSB3YWxsZXQgc2hhcmUgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgY2FuY2VsU2hhcmUocGFyYW1zOiB7IHdhbGxldFNoYXJlSWQ/OiBzdHJpbmcgfSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3YWxsZXRTaGFyZUlkJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcy5iaXRnb1xuICAgICAgLmRlbCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldHNoYXJlLycgKyBwYXJhbXMud2FsbGV0U2hhcmVJZCkpXG4gICAgICAuc2VuZCgpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRzIGEgd2FsbGV0IHNoYXJlLCBhZGRpbmcgdGhlIHdhbGxldCB0byB0aGUgdXNlcidzIGxpc3RcbiAgICogTmVlZHMgYSB1c2VyJ3MgcGFzc3dvcmQgdG8gZGVjcnlwdCB0aGUgc2hhcmVkIGtleVxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0U2hhcmVJZCAtIHRoZSB3YWxsZXQgc2hhcmUgdG8gYWNjZXB0XG4gICAqIEBwYXJhbSBwYXJhbXMudXNlclBhc3N3b3JkIC0gKHJlcXVpcmVkIGlmIG1vcmUgYSBrZXljaGFpbiB3YXMgc2hhcmVkKSB1c2VyJ3MgcGFzc3dvcmQgdG8gZGVjcnlwdCB0aGUgc2hhcmVkIHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zLm5ld1dhbGxldFBhc3NwaHJhc2UgLSBuZXcgd2FsbGV0IHBhc3NwaHJhc2UgZm9yIHNhdmluZyB0aGUgc2hhcmVkIHdhbGxldCBwcnYuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGxlZnQgYmxhbmsgYW5kIGEgd2FsbGV0IHdpdGggbW9yZSB0aGFuIHZpZXcgcGVybWlzc2lvbnMgd2FzIHNoYXJlZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiB0aGUgdXNlcidzIGxvZ2luIHBhc3N3b3JkIGlzIHVzZWQuXG4gICAqIEBwYXJhbSBwYXJhbXMub3ZlcnJpZGVFbmNyeXB0ZWRQcnYgLSBzZXQgb25seSBpZiB0aGUgcHJ2IHdhcyByZWNlaXZlZCBvdXQtb2YtYmFuZC5cbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBhY2NlcHRTaGFyZShwYXJhbXM6IEFjY2VwdFNoYXJlT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBbJ3dhbGxldFNoYXJlSWQnXSxcbiAgICAgICAgWydvdmVycmlkZUVuY3J5cHRlZFBydicsICd1c2VyUGFzc3dvcmQnLCAnbmV3V2FsbGV0UGFzc3BocmFzZSddLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcblxuICAgICAgbGV0IGVuY3J5cHRlZFBydiA9IHBhcmFtcy5vdmVycmlkZUVuY3J5cHRlZFBydjtcblxuICAgICAgY29uc3Qgd2FsbGV0U2hhcmUgPSB5aWVsZCBzZWxmLmdldFNoYXJlKHsgd2FsbGV0U2hhcmVJZDogcGFyYW1zLndhbGxldFNoYXJlSWQgfSk7XG5cbiAgICAgIC8vIFJldHVybiByaWdodCBhd2F5IGlmIHRoZXJlIGlzIG5vIGtleWNoYWluIHRvIGRlY3J5cHQsIG9yIGlmIGV4cGxpY2l0IGVuY3J5cHRlZFBydiB3YXMgcHJvdmlkZWRcbiAgICAgIGlmICghd2FsbGV0U2hhcmUua2V5Y2hhaW4gfHwgIXdhbGxldFNoYXJlLmtleWNoYWluLmVuY3J5cHRlZFBydiB8fCBlbmNyeXB0ZWRQcnYpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudXBkYXRlU2hhcmUoe1xuICAgICAgICAgIHdhbGxldFNoYXJlSWQ6IHBhcmFtcy53YWxsZXRTaGFyZUlkLFxuICAgICAgICAgIHN0YXRlOiAnYWNjZXB0ZWQnLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gTW9yZSB0aGFuIHZpZXdpbmcgd2FzIHJlcXVlc3RlZCwgc28gd2UgbmVlZCB0byBwcm9jZXNzIHRoZSB3YWxsZXQga2V5cyB1c2luZyB0aGUgc2hhcmVkIGVjZGggc2NoZW1lXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMudXNlclBhc3N3b3JkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZXJQYXNzd29yZCBwYXJhbSBtdXN0IGJlIHByb3ZpZGVkIHRvIGRlY3J5cHQgc2hhcmVkIGtleScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzaGFyaW5nS2V5Y2hhaW4gPSB5aWVsZCBzZWxmLmJpdGdvLmdldEVDREhTaGFyaW5nS2V5Y2hhaW4oKTtcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHNoYXJpbmdLZXljaGFpbi5lbmNyeXB0ZWRYcHJ2KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuY3J5cHRlZFhwcnYgd2FzIG5vdCBmb3VuZCBvbiBzaGFyaW5nIGtleWNoYWluJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdyB3ZSBoYXZlIHRoZSBzaGFyaW5nIGtleWNoYWluLCB3ZSBjYW4gd29yayBvdXQgdGhlIHNlY3JldCB1c2VkIGZvciBzaGFyaW5nIHRoZSB3YWxsZXQgd2l0aCB1c1xuICAgICAgc2hhcmluZ0tleWNoYWluLnBydiA9IHNlbGYuYml0Z28uZGVjcnlwdCh7XG4gICAgICAgIHBhc3N3b3JkOiBwYXJhbXMudXNlclBhc3N3b3JkLFxuICAgICAgICBpbnB1dDogc2hhcmluZ0tleWNoYWluLmVuY3J5cHRlZFhwcnYsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJvb3RFeHRLZXkgPSBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KHNoYXJpbmdLZXljaGFpbi5wcnYpO1xuXG4gICAgICAvLyBEZXJpdmUga2V5IGJ5IHBhdGggKHdoaWNoIGlzIHVzZWQgYmV0d2VlbiB0aGVzZSAyIHVzZXJzIG9ubHkpXG4gICAgICBjb25zdCBwcml2S2V5ID0gaGRQYXRoKHJvb3RFeHRLZXkpLmRlcml2ZUtleSh3YWxsZXRTaGFyZS5rZXljaGFpbi5wYXRoKTtcbiAgICAgIGNvbnN0IHNlY3JldCA9IHNlbGYuYml0Z28uZ2V0RUNESFNlY3JldCh7XG4gICAgICAgIGVja2V5OiBwcml2S2V5LFxuICAgICAgICBvdGhlclB1YktleUhleDogd2FsbGV0U2hhcmUua2V5Y2hhaW4uZnJvbVB1YktleSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBZZXMhIFdlIGdvdCB0aGUgc2VjcmV0IHN1Y2Nlc3NmdWxseSBoZXJlLCBub3cgZGVjcnlwdCB0aGUgc2hhcmVkIHdhbGxldCBwcnZcbiAgICAgIGNvbnN0IGRlY3J5cHRlZFNoYXJlZFdhbGxldFBydiA9IHNlbGYuYml0Z28uZGVjcnlwdCh7XG4gICAgICAgIHBhc3N3b3JkOiBzZWNyZXQsXG4gICAgICAgIGlucHV0OiB3YWxsZXRTaGFyZS5rZXljaGFpbi5lbmNyeXB0ZWRQcnYsXG4gICAgICB9KTtcblxuICAgICAgLy8gV2Ugd2lsbCBub3cgcmUtZW5jcnlwdCB0aGUgd2FsbGV0IHdpdGggb3VyIG93biBwYXNzd29yZFxuICAgICAgY29uc3QgbmV3V2FsbGV0UGFzc3BocmFzZSA9IHBhcmFtcy5uZXdXYWxsZXRQYXNzcGhyYXNlIHx8IHBhcmFtcy51c2VyUGFzc3dvcmQ7XG4gICAgICBlbmNyeXB0ZWRQcnYgPSBzZWxmLmJpdGdvLmVuY3J5cHQoe1xuICAgICAgICBwYXNzd29yZDogbmV3V2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgaW5wdXQ6IGRlY3J5cHRlZFNoYXJlZFdhbGxldFBydixcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdXBkYXRlUGFyYW1zOiBVcGRhdGVTaGFyZU9wdGlvbnMgPSB7XG4gICAgICAgIHdhbGxldFNoYXJlSWQ6IHBhcmFtcy53YWxsZXRTaGFyZUlkLFxuICAgICAgICBzdGF0ZTogJ2FjY2VwdGVkJyxcbiAgICAgIH07XG5cbiAgICAgIGlmIChlbmNyeXB0ZWRQcnYpIHtcbiAgICAgICAgdXBkYXRlUGFyYW1zLmVuY3J5cHRlZFBydiA9IGVuY3J5cHRlZFBydjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYudXBkYXRlU2hhcmUodXBkYXRlUGFyYW1zKTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB3YWxsZXQgYnkgaXRzIElEXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5pZCB3YWxsZXQgaWRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZ2V0V2FsbGV0KHBhcmFtczogR2V0V2FsbGV0T3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxXYWxsZXQ+KTogQmx1ZWJpcmQ8V2FsbGV0PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPFdhbGxldD4oZnVuY3Rpb24qKCkge1xuICAgICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCddLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgICBjb25zdCBxdWVyeTogR2V0V2FsbGV0T3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKHBhcmFtcy5hbGxUb2tlbnMpIHtcbiAgICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuYWxsVG9rZW5zKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhbGxUb2tlbnMgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcnkuYWxsVG9rZW5zID0gcGFyYW1zLmFsbFRva2VucztcbiAgICAgIH1cblxuICAgICAgc2VsZi5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHBhcmFtcy5yZXFJZCB8fCBuZXcgUmVxdWVzdFRyYWNlcigpKTtcblxuICAgICAgY29uc3Qgd2FsbGV0ID0geWllbGQgc2VsZi5iaXRnb1xuICAgICAgICAuZ2V0KHNlbGYuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyBwYXJhbXMuaWQpKVxuICAgICAgICAucXVlcnkocXVlcnkpXG4gICAgICAgIC5yZXN1bHQoKTtcbiAgICAgIHJldHVybiBuZXcgV2FsbGV0KHNlbGYuYml0Z28sIHNlbGYuYmFzZUNvaW4sIHdhbGxldCk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgd2FsbGV0IGJ5IGl0cyBhZGRyZXNzXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5hZGRyZXNzIHdhbGxldCBhZGRyZXNzXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGdldFdhbGxldEJ5QWRkcmVzcyhwYXJhbXM6IEdldFdhbGxldEJ5QWRkcmVzc09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8V2FsbGV0Pik6IEJsdWViaXJkPFdhbGxldD4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxXYWxsZXQ+KGZ1bmN0aW9uKigpIHtcbiAgICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnYWRkcmVzcyddLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgICBzZWxmLmJpdGdvLnNldFJlcXVlc3RUcmFjZXIocGFyYW1zLnJlcUlkIHx8IG5ldyBSZXF1ZXN0VHJhY2VyKCkpO1xuXG4gICAgICBjb25zdCB3YWxsZXQgPSB5aWVsZCBzZWxmLmJpdGdvLmdldChzZWxmLmJhc2VDb2luLnVybCgnL3dhbGxldC9hZGRyZXNzLycgKyBwYXJhbXMuYWRkcmVzcykpLnJlc3VsdCgpO1xuICAgICAgcmV0dXJuIG5ldyBXYWxsZXQoc2VsZi5iaXRnbywgc2VsZi5iYXNlQ29pbiwgd2FsbGV0KTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgYW55IGdpdmVuIHN1cHBvcnRlZCBjb2luLCBnZXQgdG90YWwgYmFsYW5jZXMgZm9yIGFsbCB3YWxsZXRzIG9mIHRoYXRcbiAgICogY29pbiB0eXBlIG9uIHRoZSBhY2NvdW50LlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGdldFRvdGFsQmFsYW5jZXMocGFyYW1zOiB7fSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYml0Z29cbiAgICAgIC5nZXQodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQvYmFsYW5jZXMnKSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuICB9XG59XG4iXX0=