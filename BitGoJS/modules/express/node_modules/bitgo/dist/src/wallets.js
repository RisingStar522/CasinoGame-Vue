"use strict";
/**
 * @hidden
 */
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 */
//
// Wallets Object
// BitGo accessor to a user's wallets.
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
var bitcoin = require("@bitgo/utxo-lib");
var bitcoin_1 = require("./bitcoin");
var common = require("./common");
var _ = require("lodash");
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var Wallet = require('./wallet');
//
// Constructor
//
var Wallets = function (bitgo) {
    this.bitgo = bitgo;
};
//
// list
// List the user's wallets
//
Wallets.prototype.list = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var args = [];
    if (params.skip && params.prevId) {
        throw new Error('cannot specify both skip and prevId');
    }
    if (params.limit) {
        if (!_.isNumber(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        args.push('limit=' + params.limit);
    }
    if (params.getbalances) {
        if (!_.isBoolean(params.getbalances)) {
            throw new Error('invalid getbalances argument, expecting boolean');
        }
        args.push('getbalances=' + params.getbalances);
    }
    if (params.skip) {
        if (!_.isNumber(params.skip)) {
            throw new Error('invalid skip argument, expecting number');
        }
        args.push('skip=' + params.skip);
    }
    else if (params.prevId) {
        args.push('prevId=' + params.prevId);
    }
    var query = '';
    if (args.length) {
        query = '?' + args.join('&');
    }
    var self = this;
    return this.bitgo.get(this.bitgo.url('/wallet' + query))
        .result()
        .then(function (body) {
        body.wallets = body.wallets.map(function (w) { return new Wallet(self.bitgo, w); });
        return body;
    })
        .nodeify(callback);
};
Wallets.prototype.getWallet = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    var self = this;
    var query = '';
    if (params.gpk) {
        query = '?gpk=1';
    }
    return this.bitgo.get(this.bitgo.url('/wallet/' + params.id + query))
        .result()
        .then(function (wallet) {
        return new Wallet(self.bitgo, wallet);
    })
        .nodeify(callback);
};
//
// listInvites
// List the invites on a user
//
Wallets.prototype.listInvites = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.get(this.bitgo.url('/walletinvite'))
        .result()
        .nodeify(callback);
};
//
// cancelInvite
// cancel a wallet invite that a user initiated
//
Wallets.prototype.cancelInvite = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletInviteId'], [], callback);
    return this.bitgo.del(this.bitgo.url('/walletinvite/' + params.walletInviteId))
        .result()
        .nodeify(callback);
};
//
// listShares
// List the user's wallet shares
//
Wallets.prototype.listShares = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.get(this.bitgo.url('/walletshare'))
        .result()
        .nodeify(callback);
};
//
// resendShareInvite
// Resend the invitation email which shares a wallet with another user
// Params:
//    walletShareId - the wallet share to get information on
//
Wallets.prototype.resendShareInvite = function (params, callback) {
    return co(function () {
        var urlParts;
        return __generator(this, function (_a) {
            params = params || {};
            common.validateParams(params, ['walletShareId'], [], callback);
            urlParts = params.walletShareId + '/resendemail';
            return [2 /*return*/, this.bitgo.post(this.bitgo.url('/walletshare/' + urlParts))
                    .result()];
        });
    }).call(this).asCallback(callback);
};
//
// getShare
// Gets a wallet share information, including the encrypted sharing keychain. requires unlock if keychain is present.
// Params:
//    walletShareId - the wallet share to get information on
//
Wallets.prototype.getShare = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletShareId'], [], callback);
    return this.bitgo.get(this.bitgo.url('/walletshare/' + params.walletShareId))
        .result()
        .nodeify(callback);
};
//
// updateShare
// updates a wallet share
// Params:
//    walletShareId - the wallet share to update
//    state - the new state of the wallet share
//
Wallets.prototype.updateShare = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletShareId'], [], callback);
    return this.bitgo.post(this.bitgo.url('/walletshare/' + params.walletShareId))
        .send(params)
        .result()
        .nodeify(callback);
};
//
// cancelShare
// cancels a wallet share
// Params:
//    walletShareId - the wallet share to update
//
Wallets.prototype.cancelShare = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletShareId'], [], callback);
    return this.bitgo.del(this.bitgo.url('/walletshare/' + params.walletShareId))
        .send()
        .result()
        .nodeify(callback);
};
//
// acceptShare
// Accepts a wallet share, adding the wallet to the user's list
// Needs a user's password to decrypt the shared key
// Params:
//    walletShareId - the wallet share to accept
//    userPassword - (required if more a keychain was shared) user's password to decrypt the shared wallet
//    newWalletPassphrase - new wallet passphrase for saving the shared wallet xprv.
//                          If left blank and a wallet with more than view permissions was shared, then the userpassword is used.
//    overrideEncryptedXprv - set only if the xprv was received out-of-band.
//
Wallets.prototype.acceptShare = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletShareId'], ['overrideEncryptedXprv'], callback);
    var self = this;
    var encryptedXprv = params.overrideEncryptedXprv;
    return this.getShare({ walletShareId: params.walletShareId })
        .then(function (walletShare) {
        // Return right away if there is no keychain to decrypt, or if explicit encryptedXprv was provided
        if (!walletShare.keychain || !walletShare.keychain.encryptedXprv || encryptedXprv) {
            return walletShare;
        }
        // More than viewing was requested, so we need to process the wallet keys using the shared ecdh scheme
        if (!params.userPassword) {
            throw new Error('userPassword param must be provided to decrypt shared key');
        }
        return self.bitgo.getECDHSharingKeychain()
            .then(function (sharingKeychain) {
            if (!sharingKeychain.encryptedXprv) {
                throw new Error('EncryptedXprv was not found on sharing keychain');
            }
            // Now we have the sharing keychain, we can work out the secret used for sharing the wallet with us
            sharingKeychain.xprv = self.bitgo.decrypt({ password: params.userPassword, input: sharingKeychain.encryptedXprv });
            var rootExtKey = bitcoin.HDNode.fromBase58(sharingKeychain.xprv);
            // Derive key by path (which is used between these 2 users only)
            var privKey = bitcoin_1.hdPath(rootExtKey).deriveKey(walletShare.keychain.path);
            var secret = self.bitgo.getECDHSecret({ eckey: privKey, otherPubKeyHex: walletShare.keychain.fromPubKey });
            // Yes! We got the secret successfully here, now decrypt the shared wallet xprv
            var decryptedSharedWalletXprv = self.bitgo.decrypt({ password: secret, input: walletShare.keychain.encryptedXprv });
            // We will now re-encrypt the wallet with our own password
            var newWalletPassphrase = params.newWalletPassphrase || params.userPassword;
            encryptedXprv = self.bitgo.encrypt({ password: newWalletPassphrase, input: decryptedSharedWalletXprv });
            // Carry on to the next block where we will post the acceptance of the share with the encrypted xprv
            return walletShare;
        });
    })
        .then(function (walletShare) {
        var updateParams = {
            walletShareId: params.walletShareId,
            state: 'accepted'
        };
        if (encryptedXprv) {
            updateParams.encryptedXprv = encryptedXprv;
        }
        return self.updateShare(updateParams);
    })
        .nodeify(callback);
};
//
// createKey
// Create a single bitcoin key.  This runs locally.
// Returns: {
//   address: <address>
//   key: <key, in WIF format>
// }
Wallets.prototype.createKey = function (params) {
    var key = bitcoin_1.makeRandomKey();
    return {
        address: key.getAddress(),
        key: key.toWIF()
    };
};
//
// createWalletWithKeychains
// Create a new 2-of-3 wallet and it's associated keychains.
// Returns the locally created keys with their encrypted xprvs.
// **WARNING: BE SURE TO BACKUP! NOT DOING SO CAN RESULT IN LOSS OF FUNDS!**
//
// 1. Creates the user keychain locally on the client, and encrypts it with the provided passphrase
// 2. If no xpub was provided, creates the backup keychain locally on the client, and encrypts it with the provided passphrase
// 3. Uploads the encrypted user and backup keychains to BitGo
// 4. Creates the BitGo key on the service
// 5. Creates the wallet on BitGo with the 3 public keys above
//
// Parameters include:
//   "passphrase": wallet passphrase to encrypt user and backup keys with
//   "label": wallet label, is shown in BitGo UI
//   "backupXpub": backup keychain xpub, it is HIGHLY RECOMMENDED you generate this on a separate machine!
//                 BITGO DOES NOT GUARANTEE SAFETY OF WALLETS WITH MULTIPLE KEYS CREATED ON THE SAME MACHINE **
//   "backupXpubProvider": Provision backup key from this provider (KRS), e.g. "keyternal".
//                         Setting this value will create an instant-capable wallet.
//   "passcodeEncryptionCode": the code used to encrypt the wallet passcode used in the recovery process
// Returns: {
//   wallet: newly created wallet model object
//   userKeychain: the newly created user keychain, which has an encrypted xprv stored on BitGo
//   backupKeychain: the newly created backup keychain
//
// ** BE SURE TO BACK UP THE ENCRYPTED USER AND BACKUP KEYCHAINS!**
//
// }
Wallets.prototype.createWalletWithKeychains = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['passphrase'], ['label', 'backupXpub', 'enterprise', 'passcodeEncryptionCode'], callback);
    var self = this;
    var label = params.label;
    // Create the user and backup key.
    var userKeychain = this.bitgo.keychains().create();
    userKeychain.encryptedXprv = this.bitgo.encrypt({ password: params.passphrase, input: userKeychain.xprv });
    var keychainData = {
        xpub: userKeychain.xpub,
        encryptedXprv: userKeychain.encryptedXprv
    };
    if (params.passcodeEncryptionCode) {
        keychainData.originalPasscodeEncryptionCode = params.passcodeEncryptionCode;
    }
    var hasBackupXpub = !!params.backupXpub;
    var hasBackupXpubProvider = !!params.backupXpubProvider;
    if (hasBackupXpub && hasBackupXpubProvider) {
        throw new Error('Cannot provide more than one backupXpub or backupXpubProvider flag');
    }
    if (params.disableTransactionNotifications !== undefined && !_.isBoolean(params.disableTransactionNotifications)) {
        throw new Error('Expected disableTransactionNotifications to be a boolean. ');
    }
    var backupKeychain;
    var bitgoKeychain;
    // Add the user keychain
    return self.bitgo.keychains().add(keychainData)
        .then(function () {
        // Add the backup keychain
        if (params.backupXpubProvider) {
            // If requested, use a KRS or backup key provider
            return self.bitgo.keychains().createBackup({
                provider: params.backupXpubProvider,
                disableKRSEmail: params.disableKRSEmail
            })
                .then(function (keychain) {
                backupKeychain = keychain;
            });
        }
        if (params.backupXpub) {
            // user provided backup xpub
            backupKeychain = { xpub: params.backupXpub };
        }
        else {
            // no provided xpub, so default to creating one here
            backupKeychain = self.bitgo.keychains().create();
        }
        return self.bitgo.keychains().add(backupKeychain);
    })
        .then(function () {
        return self.bitgo.keychains().createBitGo();
    })
        .then(function (keychain) {
        bitgoKeychain = keychain;
        var walletParams = {
            label: label,
            m: 2,
            n: 3,
            keychains: [
                { xpub: userKeychain.xpub },
                { xpub: backupKeychain.xpub },
                { xpub: bitgoKeychain.xpub }
            ]
        };
        if (params.enterprise) {
            walletParams.enterprise = params.enterprise;
        }
        if (params.disableTransactionNotifications) {
            walletParams.disableTransactionNotifications = params.disableTransactionNotifications;
        }
        return self.add(walletParams);
    })
        .then(function (newWallet) {
        var result = {
            wallet: newWallet,
            userKeychain: userKeychain,
            backupKeychain: backupKeychain,
            bitgoKeychain: bitgoKeychain
        };
        if (backupKeychain.xprv) {
            result.warning = 'Be sure to backup the backup keychain -- it is not stored anywhere else!';
        }
        return result;
    })
        .nodeify(callback);
};
//
// createForwardWallet
// Creates a forward wallet from a single private key.
// BitGo will watch the wallet and send any incoming transactions to a destination multi-sig wallet
// WARNING: THE PRIVATE KEY WILL BE SENT TO BITGO. YOU MUST CONTACT BITGO BEFORE USING THIS FEATURE!
// WE CANNOT GUARANTEE THE SECURITY OF SINGLE-SIG WALLETS AS CUSTODY IS UNCLEAR.
//
// Params:
//    privKey - the private key on a legacy single-signature wallet to be watched (WIF format)
//    sourceAddress - the bitcoin address to forward from (corresponds to the private key)
//    destinationWallet - the wallet object to send the destination coins to (when incoming transactions are detected)
//    label - label for the wallet
//
Wallets.prototype.createForwardWallet = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['privKey', 'sourceAddress'], ['label'], callback);
    if (!_.isObject(params.destinationWallet) || !params.destinationWallet.id) {
        throw new Error('expecting destinationWallet object');
    }
    var self = this;
    var newDestinationAddress;
    var addressFromPrivKey;
    try {
        var key = bitcoin.ECPair.fromWIF(params.privKey, bitcoin_1.getNetwork());
        addressFromPrivKey = key.getAddress();
    }
    catch (e) {
        throw new Error('expecting a valid privKey');
    }
    if (addressFromPrivKey !== params.sourceAddress) {
        throw new Error('privKey does not match source address - got ' + addressFromPrivKey + ' expected ' + params.sourceAddress);
    }
    return params.destinationWallet.createAddress()
        .then(function (result) {
        // Create new address on the destination wallet to receive coins
        newDestinationAddress = result.address;
        var walletParams = {
            type: 'forward',
            sourceAddress: params.sourceAddress,
            destinationAddress: newDestinationAddress,
            privKey: params.privKey,
            label: params.label
        };
        if (params.enterprise) {
            walletParams.enterprise = params.enterprise;
        }
        return self.bitgo.post(self.bitgo.url('/wallet'))
            .send(walletParams)
            .result()
            .nodeify(callback);
    });
};
/**
* Add a new wallet (advanced mode).
* This allows you to manually submit the keychains, type, m and n of the wallet
* @param {string} label label of the wallet to be shown in UI
* @param {number} m number of keys required to unlock wallet (2)
* @param {number} n number of keys available on the wallet (3)
* @param {array} keychains array of keychain xpubs
* @param {string} enterprise ID of the enterprise entity to create this wallet under.
* @param {boolean} disableTransactionNotifications When set to true disables notifications for transactions on this wallet.
*/
Wallets.prototype.add = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], ['label', 'enterprise'], callback);
    if (Array.isArray(params.keychains) === false || !_.isNumber(params.m) ||
        !_.isNumber(params.n)) {
        throw new Error('invalid argument');
    }
    // TODO: support more types of multisig
    if (params.m !== 2 || params.n !== 3) {
        throw new Error('unsupported multi-sig type');
    }
    var self = this;
    var keychains = params.keychains.map(function (k) { return { xpub: k.xpub }; });
    var walletParams = {
        label: params.label,
        m: params.m,
        n: params.n,
        keychains: keychains
    };
    if (params.enterprise) {
        walletParams.enterprise = params.enterprise;
    }
    if (params.disableTransactionNotifications) {
        walletParams.disableTransactionNotifications = params.disableTransactionNotifications;
    }
    return this.bitgo.post(this.bitgo.url('/wallet'))
        .send(walletParams)
        .result()
        .then(function (body) {
        return new Wallet(self.bitgo, body);
    })
        .nodeify(callback);
};
//
// get
// Shorthand to getWallet
// Parameters include:
//   id: the id of the wallet
//
Wallets.prototype.get = function (params, callback) {
    return this.getWallet(params, callback);
};
//
// remove
// Remove an existing wallet.
// Parameters include:
//   id: the id of the wallet
//
Wallets.prototype.remove = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    return this.bitgo.del(this.bitgo.url('/wallet/' + params.id))
        .result()
        .nodeify(callback);
};
module.exports = Wallets;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93YWxsZXRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7R0FFRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFSDtHQUNHO0FBQ0gsRUFBRTtBQUNGLGlCQUFpQjtBQUNqQixzQ0FBc0M7QUFDdEMsRUFBRTtBQUNGLG9EQUFvRDtBQUNwRCxFQUFFO0FBRUYseUNBQTJDO0FBQzNDLHFDQUE4RDtBQUM5RCxpQ0FBbUM7QUFDbkMsMEJBQTRCO0FBQzVCLG1DQUFxQztBQUNyQyxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO0FBQzlCLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUVuQyxFQUFFO0FBQ0YsY0FBYztBQUNkLEVBQUU7QUFDRixJQUFNLE9BQU8sR0FBRyxVQUFTLEtBQUs7SUFDNUIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDckIsQ0FBQyxDQUFDO0FBRUYsRUFBRTtBQUNGLE9BQU87QUFDUCwwQkFBMEI7QUFDMUIsRUFBRTtBQUNGLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHLFVBQVMsTUFBTSxFQUFFLFFBQVE7SUFDaEQsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFDdEIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUVoRCxJQUFNLElBQUksR0FBYSxFQUFFLENBQUM7SUFFMUIsSUFBSSxNQUFNLENBQUMsSUFBSSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7UUFDaEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO0tBQ3hEO0lBRUQsSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFO1FBQ2hCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FB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QztBQUVGLEVBQUU7QUFDRixNQUFNO0FBQ04seUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0Qiw2QkFBNkI7QUFDN0IsRUFBRTtBQUNGLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLFVBQVMsTUFBTSxFQUFFLFFBQVE7SUFDL0MsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztBQUMxQyxDQUFDLENBQUM7QUFFRixFQUFFO0FBQ0YsU0FBUztBQUNULDZCQUE2QjtBQUM3QixzQkFBc0I7QUFDdEIsNkJBQTZCO0FBQzdCLEVBQUU7QUFDRixPQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxVQUFTLE1BQU0sRUFBRSxRQUFRO0lBQ2xELE1BQU0sR0FBRyxNQUFNLElBQUksRUFBRSxDQUFDO0lBQ3RCLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBRXBELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUM1RCxNQUFNLEVBQUU7U0FDUixPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDckIsQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBoaWRkZW5cbiAqL1xuXG4vKipcbiAqL1xuLy9cbi8vIFdhbGxldHMgT2JqZWN0XG4vLyBCaXRHbyBhY2Nlc3NvciB0byBhIHVzZXIncyB3YWxsZXRzLlxuLy9cbi8vIENvcHlyaWdodCAyMDE0LCBCaXRHbywgSW5jLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG5cbmltcG9ydCAqIGFzIGJpdGNvaW4gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCB7IG1ha2VSYW5kb21LZXksIGhkUGF0aCwgZ2V0TmV0d29yayB9IGZyb20gJy4vYml0Y29pbic7XG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuY29uc3QgY28gPSBCbHVlYmlyZC5jb3JvdXRpbmU7XG5jb25zdCBXYWxsZXQgPSByZXF1aXJlKCcuL3dhbGxldCcpO1xuXG4vL1xuLy8gQ29uc3RydWN0b3Jcbi8vXG5jb25zdCBXYWxsZXRzID0gZnVuY3Rpb24oYml0Z28pIHtcbiAgdGhpcy5iaXRnbyA9IGJpdGdvO1xufTtcblxuLy9cbi8vIGxpc3Rcbi8vIExpc3QgdGhlIHVzZXIncyB3YWxsZXRzXG4vL1xuV2FsbGV0cy5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcblxuICBjb25zdCBhcmdzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGlmIChwYXJhbXMuc2tpcCAmJiBwYXJhbXMucHJldklkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3BlY2lmeSBib3RoIHNraXAgYW5kIHByZXZJZCcpO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubGltaXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGltaXQgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKCdsaW1pdD0nICsgcGFyYW1zLmxpbWl0KTtcbiAgfVxuICBpZiAocGFyYW1zLmdldGJhbGFuY2VzKSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuZ2V0YmFsYW5jZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZ2V0YmFsYW5jZXMgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgfVxuICAgIGFyZ3MucHVzaCgnZ2V0YmFsYW5jZXM9JyArIHBhcmFtcy5nZXRiYWxhbmNlcyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5za2lwKSB7XG4gICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5za2lwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNraXAgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKCdza2lwPScgKyBwYXJhbXMuc2tpcCk7XG4gIH0gZWxzZSBpZiAocGFyYW1zLnByZXZJZCkge1xuICAgIGFyZ3MucHVzaCgncHJldklkPScgKyBwYXJhbXMucHJldklkKTtcbiAgfVxuXG4gIGxldCBxdWVyeSA9ICcnO1xuICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIGFyZ3Muam9pbignJicpO1xuICB9XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLmJpdGdvLnVybCgnL3dhbGxldCcgKyBxdWVyeSkpXG4gIC5yZXN1bHQoKVxuICAudGhlbihmdW5jdGlvbihib2R5KSB7XG4gICAgYm9keS53YWxsZXRzID0gYm9keS53YWxsZXRzLm1hcChmdW5jdGlvbih3KSB7IHJldHVybiBuZXcgV2FsbGV0KHNlbGYuYml0Z28sIHcpOyB9KTtcbiAgICByZXR1cm4gYm9keTtcbiAgfSlcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuV2FsbGV0cy5wcm90b3R5cGUuZ2V0V2FsbGV0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICBjb25zdCBzZWxmID0gdGhpcztcblxuICBsZXQgcXVlcnkgPSAnJztcbiAgaWYgKHBhcmFtcy5ncGspIHtcbiAgICBxdWVyeSA9ICc/Z3BrPTEnO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMuYml0Z28udXJsKCcvd2FsbGV0LycgKyBwYXJhbXMuaWQgKyBxdWVyeSkpXG4gIC5yZXN1bHQoKVxuICAudGhlbihmdW5jdGlvbih3YWxsZXQpIHtcbiAgICByZXR1cm4gbmV3IFdhbGxldChzZWxmLmJpdGdvLCB3YWxsZXQpO1xuICB9KVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gbGlzdEludml0ZXNcbi8vIExpc3QgdGhlIGludml0ZXMgb24gYSB1c2VyXG4vL1xuV2FsbGV0cy5wcm90b3R5cGUubGlzdEludml0ZXMgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMuYml0Z28udXJsKCcvd2FsbGV0aW52aXRlJykpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gY2FuY2VsSW52aXRlXG4vLyBjYW5jZWwgYSB3YWxsZXQgaW52aXRlIHRoYXQgYSB1c2VyIGluaXRpYXRlZFxuLy9cbldhbGxldHMucHJvdG90eXBlLmNhbmNlbEludml0ZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dhbGxldEludml0ZUlkJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZGVsKHRoaXMuYml0Z28udXJsKCcvd2FsbGV0aW52aXRlLycgKyBwYXJhbXMud2FsbGV0SW52aXRlSWQpKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIGxpc3RTaGFyZXNcbi8vIExpc3QgdGhlIHVzZXIncyB3YWxsZXQgc2hhcmVzXG4vL1xuV2FsbGV0cy5wcm90b3R5cGUubGlzdFNoYXJlcyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcblxuICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy5iaXRnby51cmwoJy93YWxsZXRzaGFyZScpKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIHJlc2VuZFNoYXJlSW52aXRlXG4vLyBSZXNlbmQgdGhlIGludml0YXRpb24gZW1haWwgd2hpY2ggc2hhcmVzIGEgd2FsbGV0IHdpdGggYW5vdGhlciB1c2VyXG4vLyBQYXJhbXM6XG4vLyAgICB3YWxsZXRTaGFyZUlkIC0gdGhlIHdhbGxldCBzaGFyZSB0byBnZXQgaW5mb3JtYXRpb24gb25cbi8vXG5XYWxsZXRzLnByb3RvdHlwZS5yZXNlbmRTaGFyZUludml0ZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnd2FsbGV0U2hhcmVJZCddLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgY29uc3QgdXJsUGFydHMgPSBwYXJhbXMud2FsbGV0U2hhcmVJZCArICcvcmVzZW5kZW1haWwnO1xuICAgIHJldHVybiB0aGlzLmJpdGdvLnBvc3QodGhpcy5iaXRnby51cmwoJy93YWxsZXRzaGFyZS8nICsgdXJsUGFydHMpKVxuICAgIC5yZXN1bHQoKTtcbiAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBnZXRTaGFyZVxuLy8gR2V0cyBhIHdhbGxldCBzaGFyZSBpbmZvcm1hdGlvbiwgaW5jbHVkaW5nIHRoZSBlbmNyeXB0ZWQgc2hhcmluZyBrZXljaGFpbi4gcmVxdWlyZXMgdW5sb2NrIGlmIGtleWNoYWluIGlzIHByZXNlbnQuXG4vLyBQYXJhbXM6XG4vLyAgICB3YWxsZXRTaGFyZUlkIC0gdGhlIHdhbGxldCBzaGFyZSB0byBnZXQgaW5mb3JtYXRpb24gb25cbi8vXG5XYWxsZXRzLnByb3RvdHlwZS5nZXRTaGFyZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dhbGxldFNoYXJlSWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy5iaXRnby51cmwoJy93YWxsZXRzaGFyZS8nICsgcGFyYW1zLndhbGxldFNoYXJlSWQpKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIHVwZGF0ZVNoYXJlXG4vLyB1cGRhdGVzIGEgd2FsbGV0IHNoYXJlXG4vLyBQYXJhbXM6XG4vLyAgICB3YWxsZXRTaGFyZUlkIC0gdGhlIHdhbGxldCBzaGFyZSB0byB1cGRhdGVcbi8vICAgIHN0YXRlIC0gdGhlIG5ldyBzdGF0ZSBvZiB0aGUgd2FsbGV0IHNoYXJlXG4vL1xuV2FsbGV0cy5wcm90b3R5cGUudXBkYXRlU2hhcmUgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3YWxsZXRTaGFyZUlkJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLmJpdGdvLnVybCgnL3dhbGxldHNoYXJlLycgKyBwYXJhbXMud2FsbGV0U2hhcmVJZCkpXG4gIC5zZW5kKHBhcmFtcylcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBjYW5jZWxTaGFyZVxuLy8gY2FuY2VscyBhIHdhbGxldCBzaGFyZVxuLy8gUGFyYW1zOlxuLy8gICAgd2FsbGV0U2hhcmVJZCAtIHRoZSB3YWxsZXQgc2hhcmUgdG8gdXBkYXRlXG4vL1xuV2FsbGV0cy5wcm90b3R5cGUuY2FuY2VsU2hhcmUgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3YWxsZXRTaGFyZUlkJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZGVsKHRoaXMuYml0Z28udXJsKCcvd2FsbGV0c2hhcmUvJyArIHBhcmFtcy53YWxsZXRTaGFyZUlkKSlcbiAgLnNlbmQoKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIGFjY2VwdFNoYXJlXG4vLyBBY2NlcHRzIGEgd2FsbGV0IHNoYXJlLCBhZGRpbmcgdGhlIHdhbGxldCB0byB0aGUgdXNlcidzIGxpc3Rcbi8vIE5lZWRzIGEgdXNlcidzIHBhc3N3b3JkIHRvIGRlY3J5cHQgdGhlIHNoYXJlZCBrZXlcbi8vIFBhcmFtczpcbi8vICAgIHdhbGxldFNoYXJlSWQgLSB0aGUgd2FsbGV0IHNoYXJlIHRvIGFjY2VwdFxuLy8gICAgdXNlclBhc3N3b3JkIC0gKHJlcXVpcmVkIGlmIG1vcmUgYSBrZXljaGFpbiB3YXMgc2hhcmVkKSB1c2VyJ3MgcGFzc3dvcmQgdG8gZGVjcnlwdCB0aGUgc2hhcmVkIHdhbGxldFxuLy8gICAgbmV3V2FsbGV0UGFzc3BocmFzZSAtIG5ldyB3YWxsZXQgcGFzc3BocmFzZSBmb3Igc2F2aW5nIHRoZSBzaGFyZWQgd2FsbGV0IHhwcnYuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbGVmdCBibGFuayBhbmQgYSB3YWxsZXQgd2l0aCBtb3JlIHRoYW4gdmlldyBwZXJtaXNzaW9ucyB3YXMgc2hhcmVkLCB0aGVuIHRoZSB1c2VycGFzc3dvcmQgaXMgdXNlZC5cbi8vICAgIG92ZXJyaWRlRW5jcnlwdGVkWHBydiAtIHNldCBvbmx5IGlmIHRoZSB4cHJ2IHdhcyByZWNlaXZlZCBvdXQtb2YtYmFuZC5cbi8vXG5XYWxsZXRzLnByb3RvdHlwZS5hY2NlcHRTaGFyZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dhbGxldFNoYXJlSWQnXSwgWydvdmVycmlkZUVuY3J5cHRlZFhwcnYnXSwgY2FsbGJhY2spO1xuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICBsZXQgZW5jcnlwdGVkWHBydiA9IHBhcmFtcy5vdmVycmlkZUVuY3J5cHRlZFhwcnY7XG5cbiAgcmV0dXJuIHRoaXMuZ2V0U2hhcmUoeyB3YWxsZXRTaGFyZUlkOiBwYXJhbXMud2FsbGV0U2hhcmVJZCB9KVxuICAudGhlbihmdW5jdGlvbih3YWxsZXRTaGFyZSkge1xuICAgIC8vIFJldHVybiByaWdodCBhd2F5IGlmIHRoZXJlIGlzIG5vIGtleWNoYWluIHRvIGRlY3J5cHQsIG9yIGlmIGV4cGxpY2l0IGVuY3J5cHRlZFhwcnYgd2FzIHByb3ZpZGVkXG4gICAgaWYgKCF3YWxsZXRTaGFyZS5rZXljaGFpbiB8fCAhd2FsbGV0U2hhcmUua2V5Y2hhaW4uZW5jcnlwdGVkWHBydiB8fCBlbmNyeXB0ZWRYcHJ2KSB7XG4gICAgICByZXR1cm4gd2FsbGV0U2hhcmU7XG4gICAgfVxuXG4gICAgLy8gTW9yZSB0aGFuIHZpZXdpbmcgd2FzIHJlcXVlc3RlZCwgc28gd2UgbmVlZCB0byBwcm9jZXNzIHRoZSB3YWxsZXQga2V5cyB1c2luZyB0aGUgc2hhcmVkIGVjZGggc2NoZW1lXG4gICAgaWYgKCFwYXJhbXMudXNlclBhc3N3b3JkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZXJQYXNzd29yZCBwYXJhbSBtdXN0IGJlIHByb3ZpZGVkIHRvIGRlY3J5cHQgc2hhcmVkIGtleScpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLmJpdGdvLmdldEVDREhTaGFyaW5nS2V5Y2hhaW4oKVxuICAgIC50aGVuKGZ1bmN0aW9uKHNoYXJpbmdLZXljaGFpbikge1xuICAgICAgaWYgKCFzaGFyaW5nS2V5Y2hhaW4uZW5jcnlwdGVkWHBydikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRlZFhwcnYgd2FzIG5vdCBmb3VuZCBvbiBzaGFyaW5nIGtleWNoYWluJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdyB3ZSBoYXZlIHRoZSBzaGFyaW5nIGtleWNoYWluLCB3ZSBjYW4gd29yayBvdXQgdGhlIHNlY3JldCB1c2VkIGZvciBzaGFyaW5nIHRoZSB3YWxsZXQgd2l0aCB1c1xuICAgICAgc2hhcmluZ0tleWNoYWluLnhwcnYgPSBzZWxmLmJpdGdvLmRlY3J5cHQoeyBwYXNzd29yZDogcGFyYW1zLnVzZXJQYXNzd29yZCwgaW5wdXQ6IHNoYXJpbmdLZXljaGFpbi5lbmNyeXB0ZWRYcHJ2IH0pO1xuICAgICAgY29uc3Qgcm9vdEV4dEtleSA9IGJpdGNvaW4uSEROb2RlLmZyb21CYXNlNTgoc2hhcmluZ0tleWNoYWluLnhwcnYpO1xuXG4gICAgICAvLyBEZXJpdmUga2V5IGJ5IHBhdGggKHdoaWNoIGlzIHVzZWQgYmV0d2VlbiB0aGVzZSAyIHVzZXJzIG9ubHkpXG4gICAgICBjb25zdCBwcml2S2V5ID0gaGRQYXRoKHJvb3RFeHRLZXkpLmRlcml2ZUtleSh3YWxsZXRTaGFyZS5rZXljaGFpbi5wYXRoKTtcbiAgICAgIGNvbnN0IHNlY3JldCA9IHNlbGYuYml0Z28uZ2V0RUNESFNlY3JldCh7IGVja2V5OiBwcml2S2V5LCBvdGhlclB1YktleUhleDogd2FsbGV0U2hhcmUua2V5Y2hhaW4uZnJvbVB1YktleSB9KTtcblxuICAgICAgLy8gWWVzISBXZSBnb3QgdGhlIHNlY3JldCBzdWNjZXNzZnVsbHkgaGVyZSwgbm93IGRlY3J5cHQgdGhlIHNoYXJlZCB3YWxsZXQgeHBydlxuICAgICAgY29uc3QgZGVjcnlwdGVkU2hhcmVkV2FsbGV0WHBydiA9IHNlbGYuYml0Z28uZGVjcnlwdCh7IHBhc3N3b3JkOiBzZWNyZXQsIGlucHV0OiB3YWxsZXRTaGFyZS5rZXljaGFpbi5lbmNyeXB0ZWRYcHJ2IH0pO1xuXG4gICAgICAvLyBXZSB3aWxsIG5vdyByZS1lbmNyeXB0IHRoZSB3YWxsZXQgd2l0aCBvdXIgb3duIHBhc3N3b3JkXG4gICAgICBjb25zdCBuZXdXYWxsZXRQYXNzcGhyYXNlID0gcGFyYW1zLm5ld1dhbGxldFBhc3NwaHJhc2UgfHwgcGFyYW1zLnVzZXJQYXNzd29yZDtcbiAgICAgIGVuY3J5cHRlZFhwcnYgPSBzZWxmLmJpdGdvLmVuY3J5cHQoeyBwYXNzd29yZDogbmV3V2FsbGV0UGFzc3BocmFzZSwgaW5wdXQ6IGRlY3J5cHRlZFNoYXJlZFdhbGxldFhwcnYgfSk7XG5cbiAgICAgIC8vIENhcnJ5IG9uIHRvIHRoZSBuZXh0IGJsb2NrIHdoZXJlIHdlIHdpbGwgcG9zdCB0aGUgYWNjZXB0YW5jZSBvZiB0aGUgc2hhcmUgd2l0aCB0aGUgZW5jcnlwdGVkIHhwcnZcbiAgICAgIHJldHVybiB3YWxsZXRTaGFyZTtcbiAgICB9KTtcbiAgfSlcbiAgLnRoZW4oZnVuY3Rpb24od2FsbGV0U2hhcmUpIHtcbiAgICBjb25zdCB1cGRhdGVQYXJhbXM6IGFueSA9IHtcbiAgICAgIHdhbGxldFNoYXJlSWQ6IHBhcmFtcy53YWxsZXRTaGFyZUlkLFxuICAgICAgc3RhdGU6ICdhY2NlcHRlZCdcbiAgICB9O1xuXG4gICAgaWYgKGVuY3J5cHRlZFhwcnYpIHtcbiAgICAgIHVwZGF0ZVBhcmFtcy5lbmNyeXB0ZWRYcHJ2ID0gZW5jcnlwdGVkWHBydjtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi51cGRhdGVTaGFyZSh1cGRhdGVQYXJhbXMpO1xuICB9KVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gY3JlYXRlS2V5XG4vLyBDcmVhdGUgYSBzaW5nbGUgYml0Y29pbiBrZXkuICBUaGlzIHJ1bnMgbG9jYWxseS5cbi8vIFJldHVybnM6IHtcbi8vICAgYWRkcmVzczogPGFkZHJlc3M+XG4vLyAgIGtleTogPGtleSwgaW4gV0lGIGZvcm1hdD5cbi8vIH1cbldhbGxldHMucHJvdG90eXBlLmNyZWF0ZUtleSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBjb25zdCBrZXkgPSBtYWtlUmFuZG9tS2V5KCk7XG4gIHJldHVybiB7XG4gICAgYWRkcmVzczoga2V5LmdldEFkZHJlc3MoKSxcbiAgICBrZXk6IGtleS50b1dJRigpXG4gIH07XG59O1xuXG4vL1xuLy8gY3JlYXRlV2FsbGV0V2l0aEtleWNoYWluc1xuLy8gQ3JlYXRlIGEgbmV3IDItb2YtMyB3YWxsZXQgYW5kIGl0J3MgYXNzb2NpYXRlZCBrZXljaGFpbnMuXG4vLyBSZXR1cm5zIHRoZSBsb2NhbGx5IGNyZWF0ZWQga2V5cyB3aXRoIHRoZWlyIGVuY3J5cHRlZCB4cHJ2cy5cbi8vICoqV0FSTklORzogQkUgU1VSRSBUTyBCQUNLVVAhIE5PVCBET0lORyBTTyBDQU4gUkVTVUxUIElOIExPU1MgT0YgRlVORFMhKipcbi8vXG4vLyAxLiBDcmVhdGVzIHRoZSB1c2VyIGtleWNoYWluIGxvY2FsbHkgb24gdGhlIGNsaWVudCwgYW5kIGVuY3J5cHRzIGl0IHdpdGggdGhlIHByb3ZpZGVkIHBhc3NwaHJhc2Vcbi8vIDIuIElmIG5vIHhwdWIgd2FzIHByb3ZpZGVkLCBjcmVhdGVzIHRoZSBiYWNrdXAga2V5Y2hhaW4gbG9jYWxseSBvbiB0aGUgY2xpZW50LCBhbmQgZW5jcnlwdHMgaXQgd2l0aCB0aGUgcHJvdmlkZWQgcGFzc3BocmFzZVxuLy8gMy4gVXBsb2FkcyB0aGUgZW5jcnlwdGVkIHVzZXIgYW5kIGJhY2t1cCBrZXljaGFpbnMgdG8gQml0R29cbi8vIDQuIENyZWF0ZXMgdGhlIEJpdEdvIGtleSBvbiB0aGUgc2VydmljZVxuLy8gNS4gQ3JlYXRlcyB0aGUgd2FsbGV0IG9uIEJpdEdvIHdpdGggdGhlIDMgcHVibGljIGtleXMgYWJvdmVcbi8vXG4vLyBQYXJhbWV0ZXJzIGluY2x1ZGU6XG4vLyAgIFwicGFzc3BocmFzZVwiOiB3YWxsZXQgcGFzc3BocmFzZSB0byBlbmNyeXB0IHVzZXIgYW5kIGJhY2t1cCBrZXlzIHdpdGhcbi8vICAgXCJsYWJlbFwiOiB3YWxsZXQgbGFiZWwsIGlzIHNob3duIGluIEJpdEdvIFVJXG4vLyAgIFwiYmFja3VwWHB1YlwiOiBiYWNrdXAga2V5Y2hhaW4geHB1YiwgaXQgaXMgSElHSExZIFJFQ09NTUVOREVEIHlvdSBnZW5lcmF0ZSB0aGlzIG9uIGEgc2VwYXJhdGUgbWFjaGluZSFcbi8vICAgICAgICAgICAgICAgICBCSVRHTyBET0VTIE5PVCBHVUFSQU5URUUgU0FGRVRZIE9GIFdBTExFVFMgV0lUSCBNVUxUSVBMRSBLRVlTIENSRUFURUQgT04gVEhFIFNBTUUgTUFDSElORSAqKlxuLy8gICBcImJhY2t1cFhwdWJQcm92aWRlclwiOiBQcm92aXNpb24gYmFja3VwIGtleSBmcm9tIHRoaXMgcHJvdmlkZXIgKEtSUyksIGUuZy4gXCJrZXl0ZXJuYWxcIi5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGNyZWF0ZSBhbiBpbnN0YW50LWNhcGFibGUgd2FsbGV0LlxuLy8gICBcInBhc3Njb2RlRW5jcnlwdGlvbkNvZGVcIjogdGhlIGNvZGUgdXNlZCB0byBlbmNyeXB0IHRoZSB3YWxsZXQgcGFzc2NvZGUgdXNlZCBpbiB0aGUgcmVjb3ZlcnkgcHJvY2Vzc1xuLy8gUmV0dXJuczoge1xuLy8gICB3YWxsZXQ6IG5ld2x5IGNyZWF0ZWQgd2FsbGV0IG1vZGVsIG9iamVjdFxuLy8gICB1c2VyS2V5Y2hhaW46IHRoZSBuZXdseSBjcmVhdGVkIHVzZXIga2V5Y2hhaW4sIHdoaWNoIGhhcyBhbiBlbmNyeXB0ZWQgeHBydiBzdG9yZWQgb24gQml0R29cbi8vICAgYmFja3VwS2V5Y2hhaW46IHRoZSBuZXdseSBjcmVhdGVkIGJhY2t1cCBrZXljaGFpblxuLy9cbi8vICoqIEJFIFNVUkUgVE8gQkFDSyBVUCBUSEUgRU5DUllQVEVEIFVTRVIgQU5EIEJBQ0tVUCBLRVlDSEFJTlMhKipcbi8vXG4vLyB9XG5XYWxsZXRzLnByb3RvdHlwZS5jcmVhdGVXYWxsZXRXaXRoS2V5Y2hhaW5zID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsncGFzc3BocmFzZSddLCBbJ2xhYmVsJywgJ2JhY2t1cFhwdWInLCAnZW50ZXJwcmlzZScsICdwYXNzY29kZUVuY3J5cHRpb25Db2RlJ10sIGNhbGxiYWNrKTtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGNvbnN0IGxhYmVsID0gcGFyYW1zLmxhYmVsO1xuXG4gIC8vIENyZWF0ZSB0aGUgdXNlciBhbmQgYmFja3VwIGtleS5cbiAgY29uc3QgdXNlcktleWNoYWluID0gdGhpcy5iaXRnby5rZXljaGFpbnMoKS5jcmVhdGUoKTtcbiAgdXNlcktleWNoYWluLmVuY3J5cHRlZFhwcnYgPSB0aGlzLmJpdGdvLmVuY3J5cHQoeyBwYXNzd29yZDogcGFyYW1zLnBhc3NwaHJhc2UsIGlucHV0OiB1c2VyS2V5Y2hhaW4ueHBydiB9KTtcblxuICBjb25zdCBrZXljaGFpbkRhdGE6IGFueSA9IHtcbiAgICB4cHViOiB1c2VyS2V5Y2hhaW4ueHB1YixcbiAgICBlbmNyeXB0ZWRYcHJ2OiB1c2VyS2V5Y2hhaW4uZW5jcnlwdGVkWHBydlxuICB9O1xuXG4gIGlmIChwYXJhbXMucGFzc2NvZGVFbmNyeXB0aW9uQ29kZSkge1xuICAgIGtleWNoYWluRGF0YS5vcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGUgPSBwYXJhbXMucGFzc2NvZGVFbmNyeXB0aW9uQ29kZTtcbiAgfVxuXG4gIGNvbnN0IGhhc0JhY2t1cFhwdWIgPSAhIXBhcmFtcy5iYWNrdXBYcHViO1xuICBjb25zdCBoYXNCYWNrdXBYcHViUHJvdmlkZXIgPSAhIXBhcmFtcy5iYWNrdXBYcHViUHJvdmlkZXI7XG4gIGlmIChoYXNCYWNrdXBYcHViICYmIGhhc0JhY2t1cFhwdWJQcm92aWRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHByb3ZpZGUgbW9yZSB0aGFuIG9uZSBiYWNrdXBYcHViIG9yIGJhY2t1cFhwdWJQcm92aWRlciBmbGFnJyk7XG4gIH1cblxuICBpZiAocGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBkaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zIHRvIGJlIGEgYm9vbGVhbi4gJyk7XG4gIH1cblxuICBsZXQgYmFja3VwS2V5Y2hhaW47XG4gIGxldCBiaXRnb0tleWNoYWluO1xuXG4gIC8vIEFkZCB0aGUgdXNlciBrZXljaGFpblxuICByZXR1cm4gc2VsZi5iaXRnby5rZXljaGFpbnMoKS5hZGQoa2V5Y2hhaW5EYXRhKVxuICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAvLyBBZGQgdGhlIGJhY2t1cCBrZXljaGFpblxuICAgIGlmIChwYXJhbXMuYmFja3VwWHB1YlByb3ZpZGVyKSB7XG4gICAgICAvLyBJZiByZXF1ZXN0ZWQsIHVzZSBhIEtSUyBvciBiYWNrdXAga2V5IHByb3ZpZGVyXG4gICAgICByZXR1cm4gc2VsZi5iaXRnby5rZXljaGFpbnMoKS5jcmVhdGVCYWNrdXAoe1xuICAgICAgICBwcm92aWRlcjogcGFyYW1zLmJhY2t1cFhwdWJQcm92aWRlcixcbiAgICAgICAgZGlzYWJsZUtSU0VtYWlsOiBwYXJhbXMuZGlzYWJsZUtSU0VtYWlsXG4gICAgICB9KVxuICAgICAgLnRoZW4oZnVuY3Rpb24oa2V5Y2hhaW4pIHtcbiAgICAgICAgYmFja3VwS2V5Y2hhaW4gPSBrZXljaGFpbjtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuYmFja3VwWHB1Yikge1xuICAgICAgLy8gdXNlciBwcm92aWRlZCBiYWNrdXAgeHB1YlxuICAgICAgYmFja3VwS2V5Y2hhaW4gPSB7IHhwdWI6IHBhcmFtcy5iYWNrdXBYcHViIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIHByb3ZpZGVkIHhwdWIsIHNvIGRlZmF1bHQgdG8gY3JlYXRpbmcgb25lIGhlcmVcbiAgICAgIGJhY2t1cEtleWNoYWluID0gc2VsZi5iaXRnby5rZXljaGFpbnMoKS5jcmVhdGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi5iaXRnby5rZXljaGFpbnMoKS5hZGQoYmFja3VwS2V5Y2hhaW4pO1xuICB9KVxuICAudGhlbihmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5iaXRnby5rZXljaGFpbnMoKS5jcmVhdGVCaXRHbygpO1xuICB9KVxuICAudGhlbihmdW5jdGlvbihrZXljaGFpbikge1xuICAgIGJpdGdvS2V5Y2hhaW4gPSBrZXljaGFpbjtcbiAgICBjb25zdCB3YWxsZXRQYXJhbXM6IGFueSA9IHtcbiAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgIG06IDIsXG4gICAgICBuOiAzLFxuICAgICAga2V5Y2hhaW5zOiBbXG4gICAgICAgIHsgeHB1YjogdXNlcktleWNoYWluLnhwdWIgfSxcbiAgICAgICAgeyB4cHViOiBiYWNrdXBLZXljaGFpbi54cHViIH0sXG4gICAgICAgIHsgeHB1YjogYml0Z29LZXljaGFpbi54cHViIH1dXG4gICAgfTtcblxuICAgIGlmIChwYXJhbXMuZW50ZXJwcmlzZSkge1xuICAgICAgd2FsbGV0UGFyYW1zLmVudGVycHJpc2UgPSBwYXJhbXMuZW50ZXJwcmlzZTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMpIHtcbiAgICAgIHdhbGxldFBhcmFtcy5kaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zID0gcGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGYuYWRkKHdhbGxldFBhcmFtcyk7XG4gIH0pXG4gIC50aGVuKGZ1bmN0aW9uKG5ld1dhbGxldCkge1xuICAgIGNvbnN0IHJlc3VsdDogYW55ID0ge1xuICAgICAgd2FsbGV0OiBuZXdXYWxsZXQsXG4gICAgICB1c2VyS2V5Y2hhaW46IHVzZXJLZXljaGFpbixcbiAgICAgIGJhY2t1cEtleWNoYWluOiBiYWNrdXBLZXljaGFpbixcbiAgICAgIGJpdGdvS2V5Y2hhaW46IGJpdGdvS2V5Y2hhaW5cbiAgICB9O1xuXG4gICAgaWYgKGJhY2t1cEtleWNoYWluLnhwcnYpIHtcbiAgICAgIHJlc3VsdC53YXJuaW5nID0gJ0JlIHN1cmUgdG8gYmFja3VwIHRoZSBiYWNrdXAga2V5Y2hhaW4gLS0gaXQgaXMgbm90IHN0b3JlZCBhbnl3aGVyZSBlbHNlISc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSlcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIGNyZWF0ZUZvcndhcmRXYWxsZXRcbi8vIENyZWF0ZXMgYSBmb3J3YXJkIHdhbGxldCBmcm9tIGEgc2luZ2xlIHByaXZhdGUga2V5LlxuLy8gQml0R28gd2lsbCB3YXRjaCB0aGUgd2FsbGV0IGFuZCBzZW5kIGFueSBpbmNvbWluZyB0cmFuc2FjdGlvbnMgdG8gYSBkZXN0aW5hdGlvbiBtdWx0aS1zaWcgd2FsbGV0XG4vLyBXQVJOSU5HOiBUSEUgUFJJVkFURSBLRVkgV0lMTCBCRSBTRU5UIFRPIEJJVEdPLiBZT1UgTVVTVCBDT05UQUNUIEJJVEdPIEJFRk9SRSBVU0lORyBUSElTIEZFQVRVUkUhXG4vLyBXRSBDQU5OT1QgR1VBUkFOVEVFIFRIRSBTRUNVUklUWSBPRiBTSU5HTEUtU0lHIFdBTExFVFMgQVMgQ1VTVE9EWSBJUyBVTkNMRUFSLlxuLy9cbi8vIFBhcmFtczpcbi8vICAgIHByaXZLZXkgLSB0aGUgcHJpdmF0ZSBrZXkgb24gYSBsZWdhY3kgc2luZ2xlLXNpZ25hdHVyZSB3YWxsZXQgdG8gYmUgd2F0Y2hlZCAoV0lGIGZvcm1hdClcbi8vICAgIHNvdXJjZUFkZHJlc3MgLSB0aGUgYml0Y29pbiBhZGRyZXNzIHRvIGZvcndhcmQgZnJvbSAoY29ycmVzcG9uZHMgdG8gdGhlIHByaXZhdGUga2V5KVxuLy8gICAgZGVzdGluYXRpb25XYWxsZXQgLSB0aGUgd2FsbGV0IG9iamVjdCB0byBzZW5kIHRoZSBkZXN0aW5hdGlvbiBjb2lucyB0byAod2hlbiBpbmNvbWluZyB0cmFuc2FjdGlvbnMgYXJlIGRldGVjdGVkKVxuLy8gICAgbGFiZWwgLSBsYWJlbCBmb3IgdGhlIHdhbGxldFxuLy9cbldhbGxldHMucHJvdG90eXBlLmNyZWF0ZUZvcndhcmRXYWxsZXQgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydwcml2S2V5JywgJ3NvdXJjZUFkZHJlc3MnXSwgWydsYWJlbCddLCBjYWxsYmFjayk7XG5cbiAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcy5kZXN0aW5hdGlvbldhbGxldCkgfHwgIXBhcmFtcy5kZXN0aW5hdGlvbldhbGxldC5pZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIGRlc3RpbmF0aW9uV2FsbGV0IG9iamVjdCcpO1xuICB9XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgbGV0IG5ld0Rlc3RpbmF0aW9uQWRkcmVzcztcbiAgbGV0IGFkZHJlc3NGcm9tUHJpdktleTtcblxuICB0cnkge1xuICAgIGNvbnN0IGtleSA9IGJpdGNvaW4uRUNQYWlyLmZyb21XSUYocGFyYW1zLnByaXZLZXksIGdldE5ldHdvcmsoKSk7XG4gICAgYWRkcmVzc0Zyb21Qcml2S2V5ID0ga2V5LmdldEFkZHJlc3MoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIGEgdmFsaWQgcHJpdktleScpO1xuICB9XG5cbiAgaWYgKGFkZHJlc3NGcm9tUHJpdktleSAhPT0gcGFyYW1zLnNvdXJjZUFkZHJlc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByaXZLZXkgZG9lcyBub3QgbWF0Y2ggc291cmNlIGFkZHJlc3MgLSBnb3QgJyArIGFkZHJlc3NGcm9tUHJpdktleSArICcgZXhwZWN0ZWQgJyArIHBhcmFtcy5zb3VyY2VBZGRyZXNzKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXMuZGVzdGluYXRpb25XYWxsZXQuY3JlYXRlQWRkcmVzcygpXG4gIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIC8vIENyZWF0ZSBuZXcgYWRkcmVzcyBvbiB0aGUgZGVzdGluYXRpb24gd2FsbGV0IHRvIHJlY2VpdmUgY29pbnNcbiAgICBuZXdEZXN0aW5hdGlvbkFkZHJlc3MgPSByZXN1bHQuYWRkcmVzcztcblxuICAgIGNvbnN0IHdhbGxldFBhcmFtczogYW55ID0ge1xuICAgICAgdHlwZTogJ2ZvcndhcmQnLFxuICAgICAgc291cmNlQWRkcmVzczogcGFyYW1zLnNvdXJjZUFkZHJlc3MsXG4gICAgICBkZXN0aW5hdGlvbkFkZHJlc3M6IG5ld0Rlc3RpbmF0aW9uQWRkcmVzcyxcbiAgICAgIHByaXZLZXk6IHBhcmFtcy5wcml2S2V5LFxuICAgICAgbGFiZWw6IHBhcmFtcy5sYWJlbFxuICAgIH07XG5cbiAgICBpZiAocGFyYW1zLmVudGVycHJpc2UpIHtcbiAgICAgIHdhbGxldFBhcmFtcy5lbnRlcnByaXNlID0gcGFyYW1zLmVudGVycHJpc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGYuYml0Z28ucG9zdChzZWxmLmJpdGdvLnVybCgnL3dhbGxldCcpKVxuICAgIC5zZW5kKHdhbGxldFBhcmFtcylcbiAgICAucmVzdWx0KClcbiAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH0pO1xufTtcblxuLyoqXG4qIEFkZCBhIG5ldyB3YWxsZXQgKGFkdmFuY2VkIG1vZGUpLlxuKiBUaGlzIGFsbG93cyB5b3UgdG8gbWFudWFsbHkgc3VibWl0IHRoZSBrZXljaGFpbnMsIHR5cGUsIG0gYW5kIG4gb2YgdGhlIHdhbGxldFxuKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgbGFiZWwgb2YgdGhlIHdhbGxldCB0byBiZSBzaG93biBpbiBVSVxuKiBAcGFyYW0ge251bWJlcn0gbSBudW1iZXIgb2Yga2V5cyByZXF1aXJlZCB0byB1bmxvY2sgd2FsbGV0ICgyKVxuKiBAcGFyYW0ge251bWJlcn0gbiBudW1iZXIgb2Yga2V5cyBhdmFpbGFibGUgb24gdGhlIHdhbGxldCAoMylcbiogQHBhcmFtIHthcnJheX0ga2V5Y2hhaW5zIGFycmF5IG9mIGtleWNoYWluIHhwdWJzXG4qIEBwYXJhbSB7c3RyaW5nfSBlbnRlcnByaXNlIElEIG9mIHRoZSBlbnRlcnByaXNlIGVudGl0eSB0byBjcmVhdGUgdGhpcyB3YWxsZXQgdW5kZXIuXG4qIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucyBXaGVuIHNldCB0byB0cnVlIGRpc2FibGVzIG5vdGlmaWNhdGlvbnMgZm9yIHRyYW5zYWN0aW9ucyBvbiB0aGlzIHdhbGxldC5cbiovXG5XYWxsZXRzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsnbGFiZWwnLCAnZW50ZXJwcmlzZSddLCBjYWxsYmFjayk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1zLmtleWNoYWlucykgPT09IGZhbHNlIHx8ICFfLmlzTnVtYmVyKHBhcmFtcy5tKSB8fFxuICAgICFfLmlzTnVtYmVyKHBhcmFtcy5uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgLy8gVE9ETzogc3VwcG9ydCBtb3JlIHR5cGVzIG9mIG11bHRpc2lnXG4gIGlmIChwYXJhbXMubSAhPT0gMiB8fCBwYXJhbXMubiAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgbXVsdGktc2lnIHR5cGUnKTtcbiAgfVxuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICBjb25zdCBrZXljaGFpbnMgPSBwYXJhbXMua2V5Y2hhaW5zLm1hcChmdW5jdGlvbihrKSB7IHJldHVybiB7IHhwdWI6IGsueHB1YiB9OyB9KTtcbiAgY29uc3Qgd2FsbGV0UGFyYW1zOiBhbnkgPSB7XG4gICAgbGFiZWw6IHBhcmFtcy5sYWJlbCxcbiAgICBtOiBwYXJhbXMubSxcbiAgICBuOiBwYXJhbXMubixcbiAgICBrZXljaGFpbnM6IGtleWNoYWluc1xuICB9O1xuXG4gIGlmIChwYXJhbXMuZW50ZXJwcmlzZSkge1xuICAgIHdhbGxldFBhcmFtcy5lbnRlcnByaXNlID0gcGFyYW1zLmVudGVycHJpc2U7XG4gIH1cblxuICBpZiAocGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMpIHtcbiAgICB3YWxsZXRQYXJhbXMuZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucyA9IHBhcmFtcy5kaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLmJpdGdvLnVybCgnL3dhbGxldCcpKVxuICAuc2VuZCh3YWxsZXRQYXJhbXMpXG4gIC5yZXN1bHQoKVxuICAudGhlbihmdW5jdGlvbihib2R5KSB7XG4gICAgcmV0dXJuIG5ldyBXYWxsZXQoc2VsZi5iaXRnbywgYm9keSk7XG4gIH0pXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBnZXRcbi8vIFNob3J0aGFuZCB0byBnZXRXYWxsZXRcbi8vIFBhcmFtZXRlcnMgaW5jbHVkZTpcbi8vICAgaWQ6IHRoZSBpZCBvZiB0aGUgd2FsbGV0XG4vL1xuV2FsbGV0cy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5nZXRXYWxsZXQocGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gcmVtb3ZlXG4vLyBSZW1vdmUgYW4gZXhpc3Rpbmcgd2FsbGV0LlxuLy8gUGFyYW1ldGVycyBpbmNsdWRlOlxuLy8gICBpZDogdGhlIGlkIG9mIHRoZSB3YWxsZXRcbi8vXG5XYWxsZXRzLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCddLCBbXSwgY2FsbGJhY2spO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLmRlbCh0aGlzLmJpdGdvLnVybCgnL3dhbGxldC8nICsgcGFyYW1zLmlkKSlcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2FsbGV0cztcbiJdfQ==