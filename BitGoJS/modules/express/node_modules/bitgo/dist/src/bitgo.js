"use strict";
//
// BitGo JavaScript SDK
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var superagent = require("superagent");
var bitcoin = require("@bitgo/utxo-lib");
var bitcoin_1 = require("./bitcoin");
var bitcoinMessage = require("bitcoinjs-message");
var sanitizeHtml = require("sanitize-html");
var eol = require("eol");
var PendingApprovals = require('./pendingapprovals');
var shamir = require("secrets.js-grempe");
var sjcl = require("./vendor/sjcl.min.js");
var bs58 = require("bs58");
var common = require("./common");
var environments_1 = require("./v2/environments");
var util_1 = require("./v2/internal/util");
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var pjson = require("../package.json");
var moment = require("moment");
var _ = require("lodash");
var url = require("url");
var querystring = require("querystring");
var config = require("./config");
var crypto_1 = require("crypto");
var debugLib = require("debug");
var internal_1 = require("./v2/internal/internal");
var TransactionBuilder = require('./transactionBuilder');
var Blockchain = require('./blockchain');
var Keychains = require('./keychains');
var TravelRule = require('./travelRule');
var Wallet = require("./wallet");
var Wallets = require('./wallets');
var Markets = require('./markets');
var coinFactory_1 = require("./v2/coinFactory");
var debug = debugLib('bitgo:index');
if (!process.browser) {
    require('superagent-proxy')(superagent);
}
// Patch superagent to return bluebird promises
var _end = superagent.Request.prototype.end;
superagent.Request.prototype.end = function (cb) {
    var self = this;
    if (typeof cb === 'function') {
        return _end.call(self, cb);
    }
    return new Bluebird.Promise(function (resolve, reject) {
        var error;
        try {
            return _end.call(self, function (error, response) {
                if (error) {
                    return reject(error);
                }
                return resolve(response);
            });
        }
        catch (_error) {
            error = _error;
            return reject(error);
        }
    });
};
// Handle HTTP errors appropriately, returning the result body, or a named
// field from the body, if the optionalField parameter is provided.
superagent.Request.prototype.result = function (optionalField) {
    return this.then(handleResponseResult(optionalField), handleResponseError);
};
function handleResponseResult(optionalField) {
    return function (res) {
        if (_.isNumber(res.status) && res.status >= 200 && res.status < 300) {
            return optionalField ? res.body[optionalField] : res.body;
        }
        throw errFromResponse(res);
    };
}
function errFromResponse(res) {
    var errString = createResponseErrorString(res);
    var err = new Error(errString);
    err.status = res.status;
    if (res.body) {
        err.result = res.body;
    }
    if (_.has(res.header, 'x-auth-required') && (res.header['x-auth-required'] === 'true')) {
        err.invalidToken = true;
    }
    if (res.body.needsOTP) {
        err.needsOTP = true;
    }
    return err;
}
function handleResponseError(e) {
    if (e.response) {
        throw errFromResponse(e.response);
    }
    throw e;
}
/**
 * There are many ways a request can fail, and may ways information on that failure can be
 * communicated to the client. This function tries to handle those cases and create a sane error string
 * @param res Response from an HTTP request
 */
function createResponseErrorString(res) {
    var errString = res.status.toString(); // at the very least we'll have the status code
    if (res.body.error) {
        // this is the case we hope for, where the server gives us a nice error from the JSON body
        errString = res.body.error;
    }
    else {
        if (res.text) {
            // if the response came back as text, we try to parse it as HTML and remove all tags, leaving us
            // just the bare text, which we then trim of excessive newlines and limit to a certain length
            try {
                var sanitizedText = sanitizeHtml(res.text, { allowedTags: [] });
                sanitizedText = sanitizedText.trim();
                sanitizedText = eol.lf(sanitizedText); // use '\n' for all newlines
                sanitizedText = _.replace(sanitizedText, /\n[ |\t]{1,}\n/g, '\n\n'); // remove the spaces/tabs between newlines
                sanitizedText = _.replace(sanitizedText, /[\n]{3,}/g, '\n\n'); // have at most 2 consecutive newlines
                sanitizedText = sanitizedText.substring(0, 5000); // prevent message from getting too large
                errString = errString + '\n' + sanitizedText; // add it to our existing errString (at this point the more info the better!)
            }
            catch (e) {
                // do nothing, the response's HTML was too wacky to be parsed cleanly
            }
        }
    }
    return errString;
}
var BitGo = /** @class */ (function () {
    /**
     * Constructor for BitGo Object
     */
    function BitGo(params) {
        if (params === void 0) { params = {}; }
        this._hmacVerification = true;
        if (!common.validateParams(params, [], ['clientId', 'clientSecret', 'refreshToken', 'accessToken', 'userAgent', 'customRootURI', 'customBitcoinNetwork', 'serverXpub', 'stellarFederationServerUrl']) ||
            (params.useProduction && !_.isBoolean(params.useProduction))) {
            throw new Error('invalid argument');
        }
        if ((!params.clientId) !== (!params.clientSecret)) {
            throw new Error('invalid argument - must provide both client id and secret');
        }
        // By default, we operate on the test server.
        // Deprecate useProduction in the future
        var env;
        if (params.useProduction) {
            if (params.env && params.env !== 'prod') {
                throw new Error('cannot use useProduction when env=' + params.env);
            }
            env = 'prod';
        }
        else if (params.customRootURI ||
            params.customBitcoinNetwork ||
            params.customSigningAddress ||
            params.serverXpub ||
            process.env.BITGO_CUSTOM_ROOT_URI ||
            process.env.BITGO_CUSTOM_BITCOIN_NETWORK) {
            // for branch deploys, we want to be able to specify custom endpoints while still
            // maintaining the name of specified the environment
            env = params.env === 'branch' ? 'branch' : 'custom';
            if (params.customRootURI) {
                common.Environments[env].uri = params.customRootURI;
            }
            if (params.customBitcoinNetwork) {
                common.Environments[env].network = params.customBitcoinNetwork;
            }
            if (params.customSigningAddress) {
                common.Environments[env].customSigningAddress = params.customSigningAddress;
            }
            if (params.serverXpub) {
                common.Environments[env].serverXpub = params.serverXpub;
            }
            if (params.stellarFederationServerUrl) {
                common.Environments[env].stellarFederationServerUrl = params.stellarFederationServerUrl;
            }
        }
        else {
            env = params.env || process.env.BITGO_ENV;
        }
        // if this env is an alias, swap it out with the equivalent supported environment
        if (env in environments_1.AliasEnvironments) {
            env = environments_1.AliasEnvironments[env];
        }
        if (env === 'custom' && _.isUndefined(common.Environments[env].uri)) {
            throw new Error('must use --customrooturi or set the BITGO_CUSTOM_ROOT_URI environment variable when using the custom environment');
        }
        if (env) {
            if (common.Environments[env]) {
                this._baseUrl = common.Environments[env].uri;
            }
            else {
                throw new Error('invalid environment ' + env + '. Supported environments: prod, test, dev, latest');
            }
        }
        else {
            env = 'test';
            if (!BitGo._testnetWarningMessage) {
                BitGo._testnetWarningMessage = true;
                console.log('BitGo SDK env not set - defaulting to test at test.bitgo.com.');
            }
            this._baseUrl = common.Environments[env].uri;
        }
        this._env = this.env = env;
        if (params.etherscanApiToken) {
            common.Environments[env].etherscanApiToken = params.etherscanApiToken;
        }
        common.setNetwork(common.Environments[env].network);
        common.setRmgNetwork(common.Environments[env].rmgNetwork);
        this._baseApiUrl = this._baseUrl + '/api/v1';
        this._baseApiUrlV2 = this._baseUrl + '/api/v2';
        this._keychains = null;
        this._wallets = null;
        this._clientId = params.clientId;
        this._clientSecret = params.clientSecret;
        this._token = params.accessToken;
        this._refreshToken = params.refreshToken;
        this._userAgent = params.userAgent || 'BitGoJS/' + this.version();
        this._promise = Bluebird;
        this._reqId = undefined;
        if (!params.hmacVerification && params.hmacVerification !== undefined) {
            if (common.Environments[env].hmacVerificationEnforced) {
                throw new Error("Cannot disable request HMAC verification in environment " + this.getEnv());
            }
            debug('HMAC verification explicitly disabled by constructor option');
            this._hmacVerification = params.hmacVerification;
        }
        // whether to perform extra client-side validation for some things, such as
        // address validation or signature validation. defaults to true, but can be
        // turned off by setting to false. can also be overridden individually in the
        // functions that use it.
        this._validate = params.validate === undefined ? true : params.validate;
        // Create superagent methods specific to this BitGo instance.
        var methods = ['get', 'post', 'put', 'del', 'patch'];
        if (!params.proxy && process.env.BITGO_USE_PROXY) {
            params.proxy = process.env.BITGO_USE_PROXY;
        }
        if (process.browser && params.proxy) {
            throw new Error('cannot use https proxy params while in browser');
        }
        this._proxy = params.proxy;
        for (var index in methods) {
            var method = methods[index];
            this[method] = this.createPatch(method);
        }
        // capture outer stack so we have useful debug information if fetch constants fails
        var e = new Error();
        // Kick off first load of constants
        this.fetchConstants({}, function (err) {
            if (err) {
                // make sure an error does not terminate the entire script
                console.error('failed to fetch initial client constants from BitGo');
                debug(e.stack);
            }
        });
    }
    /**
     * This is a patching function which can apply our authorization
     * headers to any outbound request.
     * @param method
     */
    BitGo.prototype.createPatch = function (method) {
        var self = this;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var req = superagent[method].apply(null, args);
            if (self._proxy) {
                req = req.proxy(self._proxy);
            }
            // Patch superagent to return promises
            var prototypicalEnd = req.end;
            req.end = function () {
                var thisReq = this;
                // intercept a request before it's submitted to the server for v2 authentication (based on token)
                thisReq.set('BitGo-SDK-Version', self.version());
                if (!_.isUndefined(self._reqId)) {
                    thisReq.set('Request-ID', self._reqId.toString());
                    // increment after setting the header so the sequence numbers start at 0
                    self._reqId.inc();
                    // request ids must be set before each request instead of being kept
                    // inside the bitgo object. This is to prevent reentrancy issues where
                    // multiple simultaneous requests could cause incorrect reqIds to be used
                    delete self._reqId;
                }
                // if there is no token, and we're not logged in, the request cannot be v2 authenticated
                thisReq.isV2Authenticated = true;
                thisReq.authenticationToken = self._token;
                // some of the older tokens appear to be only 40 characters long
                if ((self._token && self._token.length !== 67 && self._token.indexOf('v2x') !== 0)
                    || req.forceV1Auth) {
                    // use the old method
                    thisReq.isV2Authenticated = false;
                    thisReq.set('Authorization', 'Bearer ' + self._token);
                    return prototypicalEnd.apply(thisReq, arguments);
                }
                thisReq.set('BitGo-Auth-Version', '2.0');
                // prevent IE from caching requests
                thisReq.set('If-Modified-Since', 'Mon, 26 Jul 1997 05:00:00 GMT');
                if (self._token) {
                    // do a localized data serialization process
                    var data = thisReq._data;
                    if (typeof data !== 'string') {
                        var contentType = thisReq.get('Content-Type');
                        // Parse out just the content type from the header (ignore the charset)
                        if (contentType) {
                            contentType = contentType.split(';')[0];
                        }
                        var serialize = superagent.serialize[contentType];
                        if (!serialize && /[\/+]json\b/.test(contentType)) {
                            serialize = superagent.serialize['application/json'];
                        }
                        if (serialize) {
                            data = serialize(data);
                        }
                    }
                    thisReq._data = data;
                    var urlDetails = url.parse(req.url);
                    var queryString = void 0;
                    var query = req._query;
                    var qs_1 = req.qs;
                    if (query && query.length > 0) {
                        // browser version
                        queryString = query.join('&');
                        req._query = [];
                    }
                    else if (qs_1) {
                        // node version
                        queryString = querystring.stringify(qs_1);
                        req.qs = null;
                    }
                    if (queryString) {
                        if (urlDetails.search) {
                            urlDetails.search += '&' + queryString;
                        }
                        else {
                            urlDetails.search = '?' + queryString;
                        }
                        req.url = url.format(urlDetails);
                    }
                    var requestProperties = self.calculateRequestHeaders({ url: req.url, token: self._token, text: data });
                    thisReq.set('Auth-Timestamp', requestProperties.timestamp.toString());
                    // we're not sending the actual token, but only its hash
                    thisReq.set('Authorization', 'Bearer ' + requestProperties.tokenHash);
                    // set the HMAC
                    thisReq.set('HMAC', requestProperties.hmac);
                }
                return prototypicalEnd.apply(thisReq, arguments);
            };
            // verify that the response received from the server is signed correctly
            // right now, it is very permissive with the timestamp variance
            req.verifyResponse = function (response) {
                if (!req.isV2Authenticated || !req.authenticationToken) {
                    return response;
                }
                // HMAC verification is only allowed to be skipped in certain environments.
                // This is checked in the constructor, but checking it again at request time
                // will help prevent against tampering of this property after the object is created
                if (!self._hmacVerification && !common.Environments[self.getEnv()].hmacVerificationEnforced) {
                    return response;
                }
                var verificationResponse = self.verifyResponse({
                    url: req.url,
                    hmac: response.header.hmac,
                    statusCode: response.status,
                    text: response.text,
                    timestamp: response.header.timestamp,
                    token: req.authenticationToken
                });
                if (!verificationResponse.isValid) {
                    // calculate the HMAC
                    var receivedHmac = response.header.hmac;
                    var expectedHmac = verificationResponse.expectedHmac;
                    var signatureSubject = verificationResponse.signatureSubject;
                    // Log only the first 10 characters of the token to ensure the full token isn't logged.
                    var partialBitgoToken = self._token ? self._token.substring(0, 10) : '';
                    var errorDetails = {
                        expectedHmac: expectedHmac,
                        receivedHmac: receivedHmac,
                        hmacInput: signatureSubject,
                        requestToken: req.authenticationToken,
                        bitgoToken: partialBitgoToken
                    };
                    debug('Invalid response HMAC: %O', errorDetails);
                    var error = new Error('invalid response HMAC, possible man-in-the-middle-attack');
                    error.result = errorDetails;
                    error.status = 511;
                    throw error;
                }
                return response;
            };
            var lastPromise = null;
            req.then = function () {
                if (!lastPromise) {
                    // cannot redefine end() to return a Bluebird<any>, even though
                    // that gets monkey patched in at runtime, so this cast is required
                    var reference = req.end()
                        .then(req.verifyResponse);
                    lastPromise = reference.then.apply(reference, arguments);
                }
                else {
                    lastPromise = lastPromise.then.apply(lastPromise, arguments);
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return lastPromise;
            };
            if (!process.browser) {
                // If not in the browser, set the User-Agent. Browsers don't allow
                // setting of User-Agent, so we must disable this when run in the
                // browser (browserify sets process.browser).
                req.set('User-Agent', self._userAgent);
            }
            // Set the request timeout to just above 5 minutes by default
            req.timeout(process.env.BITGO_TIMEOUT * 1000 || 305 * 1000);
            return req;
        };
    };
    /**
     * Calculate the HMAC for the given key and message
     * @param key {String} - the key to use for the HMAC
     * @param message {String} - the actual message to HMAC
     * @returns {*} - the result of the HMAC operation
     */
    BitGo.prototype.calculateHMAC = function (key, message) {
        return crypto_1.createHmac('sha256', key).update(message).digest('hex');
    };
    /**
     * Create a basecoin object
     * @param coinName
     */
    BitGo.prototype.coin = function (coinName) {
        return coinFactory_1.GlobalCoinFactory.getInstance(this, coinName);
    };
    /**
     * Create a basecoin object for a virtual token
     * @param tokenName
     * @param callback
     */
    BitGo.prototype.token = function (tokenName, callback) {
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.fetchConstants()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, self.coin(tokenName)];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     *
     */
    BitGo.prototype.getValidate = function () {
        return this._validate;
    };
    /**
     *
     */
    BitGo.prototype.setValidate = function (validate) {
        if (!_.isBoolean(validate)) {
            throw new Error('invalid argument');
        }
        this._validate = validate;
    };
    /**
     * Return the current BitGo environment
     */
    BitGo.prototype.getEnv = function () {
        return this._env;
    };
    /**
     * Clear out all state from this BitGo object, effectively logging out the current user.
     */
    BitGo.prototype.clear = function () {
        // TODO: are there any other fields which should be cleared?
        this._user = undefined;
        this._token = undefined;
        this._refreshToken = undefined;
        this._ecdhXprv = undefined;
    };
    /**
     * Helper function to return a rejected promise or call callback with error
     *
     * @deprecated
     */
    BitGo.prototype.reject = function (msg, callback) {
        return Bluebird.reject(new Error(msg)).nodeify(callback);
    };
    /**
     * Gets the version of the BitGoJS package
     */
    BitGo.prototype.version = function () {
        return pjson.version;
    };
    /**
     * Serialize this BitGo object to a JSON object.
     *
     * Caution: contains sensitive data
     */
    BitGo.prototype.toJSON = function () {
        return {
            user: this._user,
            token: this._token,
            extensionKey: this._extensionKey ? this._extensionKey.toWIF() : undefined,
        };
    };
    /**
     * Deserialize a JSON serialized BitGo object.
     *
     * Overwrites the properties on the current BitGo object with
     * those of the deserialzed object.
     *
     * @param json
     */
    BitGo.prototype.fromJSON = function (json) {
        this._user = json.user;
        this._token = json.token;
        if (json.extensionKey) {
            var network = common.Environments[this.getEnv()].network;
            this._extensionKey = bitcoin.ECPair.fromWIF(json.extensionKey, bitcoin.networks[network]);
        }
    };
    /**
     * Get the current user
     */
    BitGo.prototype.user = function () {
        return this._user;
    };
    /**
     * Verify a Bitcoin address is a valid base58 address
     * @deprecated
     */
    BitGo.prototype.verifyAddress = function (params) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['address'], []);
        if (!_.isString(params.address)) {
            throw new Error('missing required string address');
        }
        var address;
        try {
            address = bitcoin.address.fromBase58Check(params.address);
        }
        catch (e) {
            return false;
        }
        var networkName = common.Environments[this.getEnv()].network;
        var network = bitcoin.networks[networkName];
        return address.version === network.pubKeyHash || address.version === network.scriptHash;
    };
    /**
     */
    BitGo.prototype.verifyPassword = function (params, callback) {
        if (params === void 0) { params = {}; }
        if (!_.isString(params.password)) {
            throw new Error('missing required string password');
        }
        if (!this._user || !this._user.username) {
            throw new Error('no current user');
        }
        var hmacPassword = this.calculateHMAC(this._user.username, params.password);
        return this.post(this.url('/user/verifypassword'))
            .send({ password: hmacPassword })
            .result('valid')
            .nodeify(callback);
    };
    /**
     * Utility function to encrypt locally.
     */
    BitGo.prototype.encrypt = function (params) {
        if (params === void 0) { params = {}; }
        common.validateParams(params, ['input', 'password'], []);
        var randomSalt = crypto_1.randomBytes(8);
        var randomIV = crypto_1.randomBytes(16);
        var encryptOptions = {
            iter: 10000,
            ks: 256,
            salt: [
                internal_1.bytesToWord(randomSalt.slice(0, 4)),
                internal_1.bytesToWord(randomSalt.slice(4))
            ],
            iv: [
                internal_1.bytesToWord(randomIV.slice(0, 4)),
                internal_1.bytesToWord(randomIV.slice(4, 8)),
                internal_1.bytesToWord(randomIV.slice(8, 12)),
                internal_1.bytesToWord(randomIV.slice(12, 16))
            ]
        };
        return sjcl.encrypt(params.password, params.input, encryptOptions);
    };
    /**
     * Decrypt an encrypted string locally.
     */
    BitGo.prototype.decrypt = function (params) {
        if (params === void 0) { params = {}; }
        params = params || {};
        common.validateParams(params, ['input', 'password'], []);
        try {
            return sjcl.decrypt(params.password, params.input);
        }
        catch (error) {
            if (error.message.includes('ccm: tag doesn\'t match')) {
                error.message = 'password error - ' + error.message;
            }
            throw error;
        }
    };
    /**
     * Generate a random password
     * @param   {Number} numWords     Number of 32-bit words
     * @returns {String}          base58 random password
     */
    BitGo.prototype.generateRandomPassword = function (numWords) {
        if (numWords === void 0) { numWords = 5; }
        var bytes = sjcl.codec.bytes.fromBits(sjcl.random.randomWords(numWords));
        return bs58.encode(bytes);
    };
    /**
     * Split a secret into shards using Shamir Secret Sharing.
     * @param seed A hexadecimal secret to split
     * @param passwords An array of the passwords used to encrypt each share
     * @param m The threshold number of shards necessary to reconstitute the secret
     */
    BitGo.prototype.splitSecret = function (_a) {
        var _this = this;
        var seed = _a.seed, passwords = _a.passwords, m = _a.m;
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (!_.isInteger(m) || m < 2) {
            throw new Error('m must be a positive integer greater than or equal to 2');
        }
        if (passwords.length < m) {
            throw new Error('passwords array length cannot be less than m');
        }
        var n = passwords.length;
        var secrets = shamir.share(seed, n, m);
        var shards = _.zipWith(secrets, passwords, function (shard, password) {
            return _this.encrypt({ input: shard, password: password });
        });
        var node = bitcoin.HDNode.fromSeedHex(seed);
        return {
            xpub: node.neutered().toBase58(),
            m: m,
            n: n,
            seedShares: shards,
        };
    };
    /**
     * Reconstitute a secret which was sharded with `splitSecret`.
     * @param shards
     * @param passwords
     */
    BitGo.prototype.reconstituteSecret = function (_a) {
        var _this = this;
        var shards = _a.shards, passwords = _a.passwords;
        if (!Array.isArray(shards)) {
            throw new Error('shards must be an array');
        }
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (shards.length !== passwords.length) {
            throw new Error('shards and passwords arrays must have same length');
        }
        var secrets = _.zipWith(shards, passwords, function (shard, password) {
            return _this.decrypt({ input: shard, password: password });
        });
        var seed = shamir.combine(secrets);
        var node = bitcoin.HDNode.fromSeedHex(seed);
        return {
            xpub: node.neutered().toBase58(),
            xprv: node.toBase58(),
            seed: seed,
        };
    };
    /**
     *
     * @param shards
     * @param passwords
     * @param m
     * @param xpub Optional xpub to verify the results against
     */
    BitGo.prototype.verifyShards = function (_a) {
        var _this = this;
        var shards = _a.shards, passwords = _a.passwords, m = _a.m, xpub = _a.xpub;
        /**
         * Generate all possible combinations of a given array's values given subset size m
         * @param array The array whose values are to be arranged in all combinations
         * @param m The size of each subset
         * @param entryIndices Recursively trailing set of currently chosen array indices for the combination subset under construction
         * @returns {Array}
         */
        var generateCombinations = function (array, m, entryIndices) {
            if (entryIndices === void 0) { entryIndices = []; }
            var combinations = [];
            if (entryIndices.length === m) {
                var currentCombination = _.at(array, entryIndices);
                return [currentCombination];
            }
            // The highest index
            var entryIndex = _.last(entryIndices);
            // If there are currently no indices, assume -1
            if (_.isUndefined(entryIndex)) {
                entryIndex = -1;
            }
            for (var i = entryIndex + 1; i < array.length; i++) {
                // append the current index to the trailing indices
                var currentEntryIndices = entryIndices.concat([i]);
                var newCombinations = generateCombinations(array, m, currentEntryIndices);
                combinations = combinations.concat(newCombinations);
            }
            return combinations;
        };
        if (!Array.isArray(shards)) {
            throw new Error('shards must be an array');
        }
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (shards.length !== passwords.length) {
            throw new Error('shards and passwords arrays must have same length');
        }
        var secrets = _.zipWith(shards, passwords, function (shard, password) {
            return _this.decrypt({ input: shard, password: password });
        });
        var secretCombinations = generateCombinations(secrets, m);
        var seeds = secretCombinations.map(function (currentCombination) {
            return shamir.combine(currentCombination);
        });
        var uniqueSeeds = _.uniq(seeds);
        if (uniqueSeeds.length !== 1) {
            return false;
        }
        var seed = _.first(uniqueSeeds);
        var node = bitcoin.HDNode.fromSeedHex(seed);
        var restoredXpub = node.neutered().toBase58();
        if (!_.isUndefined(xpub)) {
            if (!_.isString(xpub)) {
                throw new Error('xpub must be a string');
            }
            if (restoredXpub !== xpub) {
                return false;
            }
        }
        return true;
    };
    /**
     * Construct an ECDH secret from a private key and other user's public key
     */
    BitGo.prototype.getECDHSecret = function (_a) {
        var otherPubKeyHex = _a.otherPubKeyHex, eckey = _a.eckey;
        if (!_.isString(otherPubKeyHex)) {
            throw new Error('otherPubKeyHex string required');
        }
        if (!_.isObject(eckey)) {
            throw new Error('eckey object required');
        }
        var otherKeyPub = bitcoin.ECPair.fromPublicKeyBuffer(Buffer.from(otherPubKeyHex, 'hex'));
        var secretPoint = otherKeyPub.Q.multiply(eckey.d);
        var secret = util_1.Util.bnToByteArrayUnsigned(secretPoint.affineX);
        return Buffer.from(secret).toString('hex');
    };
    /**
     * Gets the user's private keychain, used for receiving shares
     */
    BitGo.prototype.getECDHSharingKeychain = function (params, callback) {
        var self = this;
        return this.get(this.url('/user/settings'))
            .result()
            .then(function (result) {
            if (!result.settings.ecdhKeychain) {
                return self.reject('ecdh keychain not found for user', callback);
            }
            return self.keychains().get({ xpub: result.settings.ecdhKeychain });
        })
            .nodeify(callback);
    };
    /**
     * Get bitcoin market data
     */
    BitGo.prototype.markets = function () {
        if (!this._markets) {
            this._markets = new Markets(this);
        }
        return this._markets;
    };
    /**
     * Get the latest bitcoin prices
     * (Deprecated: Will be removed in the future) use `bitgo.markets().latest()`
     * @deprecated
     */
    BitGo.prototype.market = function (params, callback) {
        return this.get(this.url('/market/latest'))
            .result()
            .nodeify(callback);
    };
    /**
     * Get market data from yesterday
     * (Deprecated: Will be removed in the future) use bitgo.markets().yesterday()
     */
    BitGo.prototype.yesterday = function (params, callback) {
        return this.get(this.url('/market/yesterday'))
            .result()
            .nodeify(callback);
    };
    /**
     * Synchronous method for activating an access token.
     */
    BitGo.prototype.authenticateWithAccessToken = function (_a) {
        var accessToken = _a.accessToken;
        this._token = accessToken;
    };
    /**
     *
     * @param responseBody Response body object
     * @param password Password for the symmetric decryption
     */
    BitGo.prototype.handleTokenIssuance = function (responseBody, password) {
        // make sure the response body contains the necessary properties
        common.validateParams(responseBody, ['derivationPath'], ['encryptedECDHXprv']);
        var environment = this._env;
        var environmentConfig = common.Environments[environment];
        var serverXpub = environmentConfig.serverXpub;
        var ecdhXprv = this._ecdhXprv;
        if (!ecdhXprv) {
            if (!password || !responseBody.encryptedECDHXprv) {
                throw new Error('ecdhXprv property must be set or password and encrypted encryptedECDHXprv must be provided');
            }
            try {
                ecdhXprv = this.decrypt({
                    input: responseBody.encryptedECDHXprv,
                    password: password
                });
            }
            catch (e) {
                e.errorCode = 'ecdh_xprv_decryption_failure';
                console.error('Failed to decrypt encryptedECDHXprv.');
                throw e;
            }
        }
        // construct HDNode objects for client's xprv and server's xpub
        var clientHDNode = bitcoin.HDNode.fromBase58(ecdhXprv);
        var serverHDNode = bitcoin.HDNode.fromBase58(serverXpub);
        // BIP32 derivation path is applied to both client and server master keys
        var derivationPath = responseBody.derivationPath;
        var clientDerivedNode = bitcoin_1.hdPath(clientHDNode).derive(derivationPath);
        var serverDerivedNode = bitcoin_1.hdPath(serverHDNode).derive(derivationPath);
        // calculating one-time ECDH key
        var secretPoint = serverDerivedNode.keyPair.__Q.multiply(clientDerivedNode.keyPair.d);
        var secret = secretPoint.getEncoded().toString('hex');
        // decrypt token with symmetric ECDH key
        var response;
        try {
            response = {
                token: this.decrypt({
                    input: responseBody.encryptedToken,
                    password: secret
                })
            };
        }
        catch (e) {
            e.errorCode = 'token_decryption_failure';
            console.error('Failed to decrypt token.');
            throw e;
        }
        if (!this._ecdhXprv) {
            response.ecdhXprv = ecdhXprv;
        }
        return response;
    };
    /**
     * Calculate the string that is to be HMACed for a certain HTTP request or response
     * @param urlPath
     * @param text
     * @param timestamp
     * @param statusCode Only set for HTTP responses, leave blank for requests
     * @returns {string}
     */
    BitGo.prototype.calculateHMACSubject = function (_a) {
        var urlPath = _a.urlPath, text = _a.text, timestamp = _a.timestamp, statusCode = _a.statusCode;
        var urlDetails = url.parse(urlPath);
        var queryPath = (urlDetails.query && urlDetails.query.length > 0) ? urlDetails.path : urlDetails.pathname;
        if (!_.isUndefined(statusCode) && _.isInteger(statusCode) && _.isFinite(statusCode)) {
            return [timestamp, queryPath, statusCode, text].join('|');
        }
        return [timestamp, queryPath, text].join('|');
    };
    /**
     * Calculate the HMAC for an HTTP request
     */
    BitGo.prototype.calculateRequestHMAC = function (_a) {
        var urlPath = _a.url, text = _a.text, timestamp = _a.timestamp, token = _a.token;
        var signatureSubject = this.calculateHMACSubject({ urlPath: urlPath, text: text, timestamp: timestamp });
        // calculate the HMAC
        return this.calculateHMAC(token, signatureSubject);
    };
    /**
     * Calculate request headers with HMAC
     */
    BitGo.prototype.calculateRequestHeaders = function (_a) {
        var url = _a.url, text = _a.text, token = _a.token;
        var timestamp = Date.now();
        var hmac = this.calculateRequestHMAC({ url: url, text: text, timestamp: timestamp, token: token });
        // calculate the SHA256 hash of the token
        var hashDigest = sjcl.hash.sha256.hash(token);
        var tokenHash = sjcl.codec.hex.fromBits(hashDigest);
        return {
            hmac: hmac,
            timestamp: timestamp,
            tokenHash: tokenHash,
        };
    };
    /**
     * Verify the HMAC for an HTTP response
     */
    BitGo.prototype.verifyResponse = function (_a) {
        var urlPath = _a.url, statusCode = _a.statusCode, text = _a.text, timestamp = _a.timestamp, token = _a.token, hmac = _a.hmac;
        var signatureSubject = this.calculateHMACSubject({
            urlPath: urlPath,
            text: text,
            timestamp: timestamp,
            statusCode: statusCode,
        });
        // calculate the HMAC
        var expectedHmac = this.calculateHMAC(token, signatureSubject);
        // verify the HMAC and timestamp
        return {
            isValid: expectedHmac === hmac,
            expectedHmac: expectedHmac,
            signatureSubject: signatureSubject,
        };
    };
    /**
     * Process the username, password and otp into an object containing the username and hashed password, ready to
     * send to bitgo for authentication.
     */
    BitGo.prototype.preprocessAuthenticationParams = function (_a) {
        var username = _a.username, password = _a.password, otp = _a.otp, forceSMS = _a.forceSMS, extensible = _a.extensible, trust = _a.trust;
        if (!_.isString(username)) {
            throw new Error('expected string username');
        }
        if (!_.isString(password)) {
            throw new Error('expected string password');
        }
        var lowerName = username.toLowerCase();
        // Calculate the password HMAC so we don't send clear-text passwords
        var hmacPassword = this.calculateHMAC(lowerName, password);
        var authParams = {
            email: lowerName,
            password: hmacPassword,
            forceSMS: !!forceSMS,
        };
        if (otp) {
            authParams.otp = otp;
            if (trust) {
                authParams.trust = 1;
            }
        }
        if (extensible) {
            this._extensionKey = bitcoin_1.makeRandomKey();
            authParams.extensible = true;
            authParams.extensionAddress = this._extensionKey.getAddress();
        }
        return authParams;
    };
    /**
     * Login to the bitgo platform.
     */
    BitGo.prototype.authenticate = function (params, callback) {
        var self = this;
        return co(function () {
            var forceV1Auth, authParams, password, authUrl, request, response, body, encryptedXprv, responseDetails;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!_.isObject(params)) {
                            throw new Error('required object params');
                        }
                        if (callback && !_.isFunction(callback)) {
                            throw new Error('callback parameter must be a function');
                        }
                        if (!_.isString(params.password)) {
                            throw new Error('expected string password');
                        }
                        forceV1Auth = !!params.forceV1Auth;
                        authParams = self.preprocessAuthenticationParams(params);
                        password = params.password;
                        if (self._token) {
                            return [2 /*return*/, self.reject('already logged in', callback)];
                        }
                        authUrl = self.microservicesUrl('/api/auth/v1/session');
                        request = self.post(authUrl);
                        if (forceV1Auth) {
                            request.forceV1Auth = true;
                            // tell the server that the client was forced to downgrade the authentication protocol
                            authParams.forceV1Auth = true;
                        }
                        return [4 /*yield*/, request.send(authParams)];
                    case 1:
                        response = _a.sent();
                        body = response.body;
                        self._user = body.user;
                        if (body.access_token) {
                            self._token = body.access_token;
                            // if the downgrade was forced, adding a warning message might be prudent
                        }
                        else {
                            encryptedXprv = body.encryptedECDHXprv;
                            if (!encryptedXprv) {
                                throw new Error('Keychain needs encryptedXprv property');
                            }
                            responseDetails = self.handleTokenIssuance(response.body, password);
                            self._token = responseDetails.token;
                            self._ecdhXprv = responseDetails.ecdhXprv;
                            // verify the response's authenticity
                            request.verifyResponse(response);
                            // add the remaining component for easier access
                            response.body.access_token = self._token;
                        }
                        return [2 /*return*/, response];
                }
            });
        }).call(this)
            .then(handleResponseResult(), handleResponseError)
            .nodeify(callback);
    };
    /**
     * @param params
     * - operatingSystem: one of ios, android
     * - pushToken: hex-formatted token for the respective native push notification service
     * @param callback
     * @returns {*}
     * @deprecated
     */
    BitGo.prototype.registerPushToken = function (params, callback) {
        params = params || {};
        common.validateParams(params, ['pushToken', 'operatingSystem'], [], callback);
        if (!this._token) {
            // this device has to be registered to an extensible session
            return this.reject('not logged in', callback);
        }
        var postParams = _.pick(params, ['pushToken', 'operatingSystem']);
        return this.post(this.url('/devices'))
            .send(postParams)
            .result()
            .nodeify(callback);
    };
    /**
     *
     * @param params
     * - pushVerificationToken: the token received via push notification to confirm the device's mobility
     * @param callback
     * @deprecated
     */
    BitGo.prototype.verifyPushToken = function (params, callback) {
        var self = this;
        return co(function () {
            var postParams;
            return __generator(this, function (_a) {
                if (!_.isObject(params)) {
                    throw new Error('required object params');
                }
                if (!_.isString(params.pushVerificationToken)) {
                    throw new Error('required string pushVerificationToken');
                }
                if (!self._token) {
                    // this device has to be registered to an extensible session
                    throw new Error('not logged in');
                }
                postParams = _.pick(params, 'pushVerificationToken');
                return [2 /*return*/, self.post(self.url('/devices/verify'))
                        .send(postParams)
                        .result()];
            });
        }).call(this)
            .nodeify(callback);
    };
    /**
     * Login to the bitgo system using an authcode generated via Oauth
     */
    BitGo.prototype.authenticateWithAuthCode = function (params, callback) {
        var self = this;
        return co(function () {
            var authCode, request, body, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!_.isObject(params)) {
                            throw new Error('required object params');
                        }
                        if (!_.isString(params.authCode)) {
                            throw new Error('required string authCode');
                        }
                        if (!self._clientId || !self._clientSecret) {
                            throw new Error('Need client id and secret set first to use this');
                        }
                        authCode = params.authCode;
                        if (self._token) {
                            return [2 /*return*/, self.reject('already logged in', callback)];
                        }
                        request = self.post(self._baseUrl + '/oauth/token');
                        request.forceV1Auth = true; // OAuth currently only supports v1 authentication
                        return [4 /*yield*/, request
                                .send({
                                grant_type: 'authorization_code',
                                code: authCode,
                                client_id: self._clientId,
                                client_secret: self._clientSecret,
                            })
                                .result()];
                    case 1:
                        body = _b.sent();
                        self._token = body.access_token;
                        self._refreshToken = body.refresh_token;
                        _a = self;
                        return [4 /*yield*/, self.me()];
                    case 2:
                        _a._user = _b.sent();
                        return [2 /*return*/, body];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Use refresh token to get new access token.
     * If the refresh token is null/defined, then we use the stored token from auth
     */
    BitGo.prototype.refreshToken = function (params, callback) {
        if (params === void 0) { params = {}; }
        var self = this;
        return co(function () {
            var refreshToken, body;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        common.validateParams(params, [], ['refreshToken'], callback);
                        refreshToken = params.refreshToken || self._refreshToken;
                        if (!refreshToken) {
                            throw new Error('Must provide refresh token or have authenticated with Oauth before');
                        }
                        if (!self._clientId || !self._clientSecret) {
                            throw new Error('Need client id and secret set first to use this');
                        }
                        return [4 /*yield*/, self.post(self._baseUrl + '/oauth/token')
                                .send({
                                grant_type: 'refresh_token',
                                refresh_token: refreshToken,
                                client_id: self._clientId,
                                client_secret: self._clientSecret
                            })
                                .result()];
                    case 1:
                        body = _a.sent();
                        self._token = body.access_token;
                        self._refreshToken = body.refresh_token;
                        return [2 /*return*/, body];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     *
     * listAccessTokens
     * Get information on all of the BitGo access tokens on the user
     * @return {
     *  id: <id of the token>
     *  label: <the user-provided label for this token>
     *  user: <id of the user on the token>
     *  enterprise <id of the enterprise this token is valid for>
     *  client: <the auth client that this token belongs to>
     *  scope: <list of allowed OAuth scope values>
     *  created: <date the token was created>
     *  expires: <date the token will expire>
     *  origin: <the origin for which this token is valid>
     *  isExtensible: <flag indicating if the token can be extended>
     *  extensionAddress: <address whose private key's signature is necessary for extensions>
     *  unlock: <info for actions that require an unlock before firing>
     * }
     */
    BitGo.prototype.listAccessTokens = function (params, callback) {
        return this.get(this.url('/user/accesstoken'))
            .send()
            .result('accessTokens')
            .nodeify(callback);
    };
    /**
     * addAccessToken
     * Add a BitGo API Access Token to the current user account
     * @param params {
     *    otp: (required) <valid otp code>
     *    label: (required) <label for the token>
     *    duration: <length of time in seconds the token will be valid for>
     *    ipRestrict: <array of IP address strings to whitelist>
     *    txValueLimit: <number of outgoing satoshis allowed on this token>
     *    scope: (required) <authorization scope of the requested token>
     * }
     * @param callback
     * @return {
     *    id: <id of the token>
     *    token: <access token hex string to be used for BitGo API request verification>
     *    label: <user-provided label for this token>
     *    user: <id of the user on the token>
     *    enterprise <id of the enterprise this token is valid for>
     *    client: <the auth client that this token belongs to>
     *    scope: <list of allowed OAuth scope values>
     *    created: <date the token was created>
     *    expires: <date the token will expire>
     *    origin: <the origin for which this token is valid>
     *    isExtensible: <flag indicating if the token can be extended>
     *    extensionAddress: <address whose private key's signature is necessary for extensions>
     *    unlock: <info for actions that require an unlock before firing>
     * }
     */
    BitGo.prototype.addAccessToken = function (params, callback) {
        var self = this;
        return co(function () {
            var authUrl, request, response, responseDetails;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!_.isString(params.label)) {
                            throw new Error('required string label');
                        }
                        // check non-string params
                        if (params.duration) {
                            if (!_.isNumber(params.duration) || params.duration < 0) {
                                throw new Error('duration must be a non-negative number');
                            }
                        }
                        if (params.ipRestrict) {
                            if (!_.isArray(params.ipRestrict)) {
                                throw new Error('ipRestrict must be an array');
                            }
                            _.forEach(params.ipRestrict, function (ipAddr) {
                                if (!_.isString(ipAddr)) {
                                    throw new Error('ipRestrict must be an array of IP address strings');
                                }
                            });
                        }
                        if (params.txValueLimit) {
                            if (!_.isNumber(params.txValueLimit)) {
                                throw new Error('txValueLimit must be a number');
                            }
                            if (params.txValueLimit < 0) {
                                throw new Error('txValueLimit must be a non-negative number');
                            }
                        }
                        if (params.scope && params.scope.length > 0) {
                            if (!_.isArray(params.scope)) {
                                throw new Error('scope must be an array');
                            }
                        }
                        else {
                            throw new Error('must specify scope for token');
                        }
                        authUrl = self.microservicesUrl('/api/auth/v1/accesstoken');
                        request = self.post(authUrl);
                        if (!self._ecdhXprv) {
                            // without a private key, the user cannot decrypt the new access token the server will send
                            request.forceV1Auth = true;
                        }
                        return [4 /*yield*/, request.send(params)];
                    case 1:
                        response = _a.sent();
                        if (request.forceV1Auth) {
                            response.body.warning = 'A protocol downgrade has occurred because this is a legacy account.';
                            return [2 /*return*/, response];
                        }
                        // verify the authenticity of the server's response before proceeding any further
                        request.verifyResponse(response);
                        responseDetails = self.handleTokenIssuance(response.body);
                        response.body.token = responseDetails.token;
                        return [2 /*return*/, response];
                }
            });
        }).call(this)
            .then(handleResponseResult(), handleResponseError)
            .nodeify(callback);
    };
    /**
     * Sets the expire time of an access token matching either the id or label to the current date, effectively deleting it
     *
     * Params:
     * id: <id of the access token to be deleted>
     * label: <label of the access token to be deleted>
     *
     * Returns:
     * id: <id of the token>
     * label: <user-provided label for this token>
     * user: <id of the user on the token>
     * enterprise <id of the enterprise this token is valid for>
     * client: <the auth client that this token belongs to>
     * scope: <list of allowed OAuth scope values>
     * created: <date the token was created>
     * expires: <date the token will expire>
     * origin: <the origin for which this token is valid>
     * isExtensible: <flag indicating if the token can be extended>
     * extensionAddress: <address whose private key's signature is ne*cessary for extensions>
     * unlock: <info for actions that require an unlock before firing>
     * @param params
     * @param callback
     */
    BitGo.prototype.removeAccessToken = function (_a, callback) {
        var id = _a.id, label = _a.label;
        var self = this;
        return co(function () {
            var tokens, matchingTokens;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if ((!id && !label) || (id && label)) {
                            throw new Error('must provide exactly one of id or label');
                        }
                        if (id) {
                            return [2 /*return*/, self.del(self.url("/user/accesstoken/" + id))
                                    .send()
                                    .result()];
                        }
                        return [4 /*yield*/, self.listAccessTokens()];
                    case 1:
                        tokens = _a.sent();
                        if (!tokens) {
                            throw new Error('token with this label does not exist');
                        }
                        matchingTokens = _.filter(tokens, { label: label });
                        if (matchingTokens.length > 1) {
                            throw new Error('ambiguous call: multiple tokens matching this label');
                        }
                        if (matchingTokens.length === 0) {
                            throw new Error('token with this label does not exist');
                        }
                        return [2 /*return*/, self.del(self.url("/user/accesstoken/" + matchingTokens[0].id))
                                .send()
                                .result()];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Logout of BitGo
     * @param params
     * @param callback
     */
    BitGo.prototype.logout = function (params, callback) {
        var self = this;
        return co(function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, self.get(self.url('/user/logout')).result()];
                    case 1:
                        result = _a.sent();
                        self.clear();
                        return [2 /*return*/, result];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Get a user by ID (name/email only)
     * @param id
     * @param callback
     */
    BitGo.prototype.getUser = function (_a, callback) {
        var id = _a.id;
        return co(function () {
            return __generator(this, function (_a) {
                if (!_.isString(id)) {
                    throw new Error('expected string id');
                }
                return [2 /*return*/, this.get(this.url("/user/" + id)).result('user')];
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Change the password of the currently logged in user.
     * Also change all v1 and v2 keychain passwords if they match the
     * given oldPassword. Returns nothing on success.
     * @param oldPassword {String} - the current password
     * @param newPassword {String} - the new password
     * @param callback
     */
    BitGo.prototype.changePassword = function (_a, callback) {
        var oldPassword = _a.oldPassword, newPassword = _a.newPassword;
        var self = this;
        return co(function coChangePassword() {
            var user, validation, coin, updateKeychainPasswordParams, v1KeychainUpdatePWResult, v2Keychains, updatePasswordParams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!_.isString(oldPassword)) {
                            throw new Error('expected string oldPassword');
                        }
                        if (!_.isString(newPassword)) {
                            throw new Error('expected string newPassword');
                        }
                        user = self.user();
                        if (typeof user !== 'object' || !user.username) {
                            throw new Error('missing required object user');
                        }
                        return [4 /*yield*/, self.verifyPassword({ password: oldPassword })];
                    case 1:
                        validation = _a.sent();
                        if (!validation) {
                            throw new Error('the provided oldPassword is incorrect');
                        }
                        coin = common.Environments[self.getEnv()].network === 'bitcoin' ? 'btc' : 'tbtc';
                        updateKeychainPasswordParams = { oldPassword: oldPassword, newPassword: newPassword };
                        return [4 /*yield*/, self.keychains().updatePassword(updateKeychainPasswordParams)];
                    case 2:
                        v1KeychainUpdatePWResult = _a.sent();
                        return [4 /*yield*/, self.coin(coin).keychains().updatePassword(updateKeychainPasswordParams)];
                    case 3:
                        v2Keychains = _a.sent();
                        updatePasswordParams = {
                            keychains: v1KeychainUpdatePWResult.keychains,
                            v2_keychains: v2Keychains,
                            version: v1KeychainUpdatePWResult.version,
                            oldPassword: self.calculateHMAC(user.username, oldPassword),
                            password: self.calculateHMAC(user.username, newPassword)
                        };
                        return [2 /*return*/, self.post(self.url('/user/changepassword'))
                                .send(updatePasswordParams)
                                .result()];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Get the current logged in user
     * @param params
     * @param callback
     */
    BitGo.prototype.me = function (params, callback) {
        return this.getUser({ id: 'me' }, callback);
    };
    /**
     * Unlock the session by providing OTP
     * @param {string} otp Required OTP code for the account.
     * @param {number} duration Desired duration of the unlock in seconds (default=600, max=3600).
     * @param callback
     */
    BitGo.prototype.unlock = function (_a, callback) {
        var otp = _a.otp, duration = _a.duration;
        var self = this;
        return co(function () {
            return __generator(this, function (_a) {
                if (otp && !_.isString(otp)) {
                    throw new Error('expected string or undefined otp');
                }
                return [2 /*return*/, self.post(self.url('/user/unlock'))
                        .send({ otp: otp, duration: duration })
                        .result()];
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Lock the session
     * @param params
     * @param callback
     */
    BitGo.prototype.lock = function (params, callback) {
        return this.post(this.url('/user/lock'))
            .result()
            .nodeify(callback);
    };
    /**
     * Get the current session
     */
    BitGo.prototype.session = function (params, callback) {
        return this.get(this.url('/user/session'))
            .result('session')
            .nodeify(callback);
    };
    /**
     * Trigger a push/sms for the OTP code
     * @param {boolean} params.forceSMS If set to true, will use SMS to send the OTP to the user even if they have other 2FA method set up.
     * @deprecated
     */
    BitGo.prototype.sendOTP = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.post(this.url('/user/sendotp'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Extend token, provided the current token is extendable
     * @param params
     * - duration: duration in seconds by which to extend the token, starting at the current time
     * @param callback
     */
    BitGo.prototype.extendToken = function (params, callback) {
        if (params === void 0) { params = {}; }
        if (!this._extensionKey) {
            throw new Error('missing required property _extensionKey');
        }
        var timestamp = Date.now();
        var duration = params.duration;
        var message = timestamp + '|' + this._token + '|' + duration;
        var privateKey = this._extensionKey.d.toBuffer(32);
        var isCompressed = this._extensionKey.compressed;
        var prefix = bitcoin.networks.bitcoin.messagePrefix;
        var signature = bitcoinMessage.sign(message, privateKey, isCompressed, prefix).toString('hex');
        return this.post(this.url('/user/extendtoken'))
            .send(params)
            .set('timestamp', timestamp.toString())
            .set('signature', signature)
            .result()
            .nodeify(callback);
    };
    /**
     * Get a key for sharing a wallet with a user
     * @param email email of user to share wallet with
     * @param callback
     */
    BitGo.prototype.getSharingKey = function (_a, callback) {
        var email = _a.email;
        if (!_.isString(email)) {
            throw new Error('required string email');
        }
        return this.post(this.url('/user/sharingkey'))
            .send({ email: email })
            .result()
            .nodeify(callback);
    };
    /**
     * Test connectivity to the server
     * @param params
     * @param callback
     */
    BitGo.prototype.ping = function (_a, callback) {
        var reqId = (_a === void 0 ? {} : _a).reqId;
        if (reqId) {
            this._reqId = reqId;
        }
        return this.get(this.url('/ping'))
            .result()
            .nodeify(callback);
    };
    /**
     * Get the blockchain object.
     * @deprecated
     */
    BitGo.prototype.blockchain = function () {
        if (!this._blockchain) {
            this._blockchain = new Blockchain(this);
        }
        return this._blockchain;
    };
    /**
     * Get the user's keychains object.
     * @deprecated
     */
    BitGo.prototype.keychains = function () {
        if (!this._keychains) {
            this._keychains = new Keychains(this);
        }
        return this._keychains;
    };
    /**
     * Get the user's wallets object.
     * @deprecated
     */
    BitGo.prototype.wallets = function () {
        if (!this._wallets) {
            this._wallets = new Wallets(this);
        }
        return this._wallets;
    };
    /**
     * Get the travel rule object
     * @deprecated
     */
    BitGo.prototype.travelRule = function () {
        if (!this._travelRule) {
            this._travelRule = new TravelRule(this);
        }
        return this._travelRule;
    };
    /**
     * Get pending approvals that can be approved/ or rejected
     * @deprecated
     */
    BitGo.prototype.pendingApprovals = function () {
        if (!this._pendingApprovals) {
            this._pendingApprovals = new PendingApprovals(this);
        }
        return this._pendingApprovals;
    };
    /**
     * A factory method to create a new Wallet object, initialized with the wallet params
     * Can be used to reconstitute a wallet from cached data
     * @param walletParams
     * @deprecated
     */
    BitGo.prototype.newWalletObject = function (walletParams) {
        return new Wallet(this, walletParams);
    };
    /**
     * Create a url for calling BitGo platform APIs
     * @param path
     * @param version
     */
    BitGo.prototype.url = function (path, version) {
        if (version === void 0) { version = 1; }
        var baseUrl = version === 2 ? this._baseApiUrlV2 : this._baseApiUrl;
        return baseUrl + path;
    };
    /**
     * Create a url for calling BitGo microservice APIs
     */
    BitGo.prototype.microservicesUrl = function (path) {
        return this._baseUrl + path;
    };
    /**
     * Get all the address labels on all of the user's wallets
     */
    BitGo.prototype.labels = function (params, callback) {
        return this.get(this.url('/labels'))
            .result('labels')
            .nodeify(callback);
    };
    /**
     * Estimates approximate fee per kb needed for a tx to get into a block
     * @param {number} params.numBlocks target blocks for the transaction to be confirmed
     * @param {number} params.maxFee maximum fee willing to be paid (for safety)
     * @param {array[string]} params.inputs list of unconfirmed txIds from which this transaction uses inputs
     * @param {number} params.txSize estimated transaction size in bytes, optional parameter used for CPFP estimation.
     * @param {boolean} params.cpfpAware flag indicating fee should take into account CPFP
     * @deprecated
     */
    BitGo.prototype.estimateFee = function (params, callback) {
        if (params === void 0) { params = {}; }
        var queryParams = { version: 12 };
        if (params.numBlocks) {
            if (!_.isNumber(params.numBlocks)) {
                throw new Error('invalid argument');
            }
            queryParams.numBlocks = params.numBlocks;
        }
        if (params.maxFee) {
            if (!_.isNumber(params.maxFee)) {
                throw new Error('invalid argument');
            }
            queryParams.maxFee = params.maxFee;
        }
        if (params.inputs) {
            if (!Array.isArray(params.inputs)) {
                throw new Error('invalid argument');
            }
            queryParams.inputs = params.inputs;
        }
        if (params.txSize) {
            if (!_.isNumber(params.txSize)) {
                throw new Error('invalid argument');
            }
            queryParams.txSize = params.txSize;
        }
        if (params.cpfpAware) {
            if (!_.isBoolean(params.cpfpAware)) {
                throw new Error('invalid argument');
            }
            queryParams.cpfpAware = params.cpfpAware;
        }
        return this.get(this.url('/tx/fee'))
            .query(queryParams)
            .result()
            .nodeify(callback);
    };
    /**
     * Get BitGo's guarantee using an instant id
     * @param params
     * @param callback
     * @deprecated
     */
    BitGo.prototype.instantGuarantee = function (params, callback) {
        var self = this;
        return co(function () {
            var body, signingAddress, signatureBuffer, prefix, isValidSignature;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!_.isString(params.id)) {
                            throw new Error('required string id');
                        }
                        return [4 /*yield*/, self.get(self.url('/instant/' + params.id)).result()];
                    case 1:
                        body = _a.sent();
                        if (!body.guarantee) {
                            throw new Error('no guarantee found in response body');
                        }
                        if (!body.signature) {
                            throw new Error('no signature found in guarantee response body');
                        }
                        signingAddress = common.Environments[self.getEnv()].signingAddress;
                        signatureBuffer = Buffer.from(body.signature, 'hex');
                        prefix = bitcoin.networks[common.Environments[self.getEnv()].network].messagePrefix;
                        isValidSignature = bitcoinMessage.verify(body.guarantee, signingAddress, signatureBuffer, prefix);
                        if (!isValidSignature) {
                            throw new Error('incorrect signature');
                        }
                        return [2 /*return*/, body];
                }
            });
        })
            .call(this)
            .nodeify(callback);
    };
    /**
     * Get a target address for payment of a BitGo fee
     * @param params
     * @param callback
     * @deprecated
     */
    BitGo.prototype.getBitGoFeeAddress = function (params, callback) {
        return this.post(this.url('/billing/address'))
            .send({})
            .result()
            .nodeify(callback);
    };
    /**
     * Gets an address object (including the wallet id) for a given address.
     * @param {string} params.address The address to look up.
     * @deprecated
     */
    BitGo.prototype.getWalletAddress = function (_a, callback) {
        var address = _a.address;
        return this.get(this.url("/walletaddress/" + address))
            .result()
            .nodeify(callback);
    };
    /**
     * Fetch list of user webhooks
     *
     * @param callback
     * @returns {*}
     * @deprecated
     */
    BitGo.prototype.listWebhooks = function (callback) {
        return this.get(this.url('/webhooks'))
            .result()
            .nodeify(callback);
    };
    /**
     * Add new user webhook
     *
     * @param params
     * @param callback
     * @returns {*}
     * @deprecated
     */
    BitGo.prototype.addWebhook = function (params, callback) {
        if (!_.isString(params.url)) {
            throw new Error('required string url');
        }
        if (!_.isString(params.type)) {
            throw new Error('required string type');
        }
        return this.post(this.url('/webhooks'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Remove user webhook
     *
     * @param params
     * @param callback
     * @returns {*}
     * @deprecated
     */
    BitGo.prototype.removeWebhook = function (params, callback) {
        if (!_.isString(params.url)) {
            throw new Error('required string url');
        }
        if (!_.isString(params.type)) {
            throw new Error('required string type');
        }
        return this.del(this.url('/webhooks'))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Fetch list of webhook notifications for the user
     *
     * @param params
     * @param callback
     * @returns {*}
     */
    BitGo.prototype.listWebhookNotifications = function (params, callback) {
        if (params === void 0) { params = {}; }
        var query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        return this.get(this.url('/webhooks/notifications'))
            .query(query)
            .result()
            .nodeify(callback);
    };
    /**
     * Simulate a user webhook
     *
     * @param params
     * @param callback
     * @returns {*}
     */
    BitGo.prototype.simulateWebhook = function (params, callback) {
        common.validateParams(params, ['webhookId', 'blockId'], [], callback);
        if (!_.isString(params.webhookId)) {
            throw new Error('required string webhookId');
        }
        if (!_.isString(params.blockId)) {
            throw new Error('required string blockId');
        }
        return this.post(this.url("/webhooks/" + params.webhookId + "/simulate"))
            .send(params)
            .result()
            .nodeify(callback);
    };
    /**
     * Receives a TTL and refetches as necessary
     * @param params
     * @param callback
     */
    BitGo.prototype.fetchConstants = function (params, callback) {
        var self = this;
        return co(function () {
            var env, resultPromise, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        env = self.getEnv();
                        if (!BitGo._constants) {
                            BitGo._constants = {};
                        }
                        if (!BitGo._constantsExpire) {
                            BitGo._constantsExpire = {};
                        }
                        if (BitGo._constants[env] && BitGo._constantsExpire[env] && new Date() < BitGo._constantsExpire[env]) {
                            return [2 /*return*/, BitGo._constants[env]];
                        }
                        resultPromise = superagent.get(self.url('/client/constants'));
                        return [4 /*yield*/, (self._proxy ? resultPromise.proxy(self._proxy) : resultPromise)];
                    case 1:
                        result = _a.sent();
                        BitGo._constants[env] = result.body.constants;
                        BitGo._constantsExpire[env] = moment.utc().add(result.body.ttl, 'second').toDate();
                        return [2 /*return*/, BitGo._constants[env]];
                }
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Synchronously get constants which are relevant to the client.
     *
     * Note: This function has a known race condition. It may return different values over time,
     * especially if called shortly after creation of the BitGo object.
     *
     * New code should call fetchConstants() directly instead.
     *
     * @deprecated
     * @param params
     * @return {Object} The client constants object
     */
    BitGo.prototype.getConstants = function (params) {
        // kick off a fresh request for the client constants
        this.fetchConstants(params, function (err) {
            if (err) {
                // make sure an error does not terminate the entire script
                console.error('failed to fetch client constants from BitGo');
                console.trace(err);
            }
        });
        // use defaultConstants as the backup for keys that are not set in this._constants
        return _.merge({}, config.defaultConstants(this.getEnv()), BitGo._constants[this.getEnv()]);
    };
    /**
     * V1 method for calculating miner fee amounts, given the number and
     * type of transaction inputs, along with a fee rate in satoshis per vkB.
     *
     * This method should not be used for new code.
     *
     * @deprecated
     * @param params
     * @param callback
     * @return {any}
     */
    BitGo.prototype.calculateMinerFeeInfo = function (params, callback) {
        return co(function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, TransactionBuilder.calculateMinerFeeInfo(params)];
            });
        }).call(this).asCallback(callback);
    };
    /**
     * Set a request tracer to provide request IDs during multi-request workflows
     */
    BitGo.prototype.setRequestTracer = function (reqTracer) {
        if (reqTracer) {
            this._reqId = reqTracer;
        }
    };
    BitGo._testnetWarningMessage = false;
    return BitGo;
}());
exports.BitGo = BitGo;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYml0Z28uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYml0Z28udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLEVBQUU7QUFDRix1QkFBdUI7QUFDdkIsRUFBRTtBQUNGLG9EQUFvRDtBQUNwRCxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVGLHVDQUF5QztBQUN6Qyx5Q0FBMkM7QUFDM0MscUNBQWtEO0FBQ2xELGtEQUFxRDtBQUNyRCw0Q0FBK0M7QUFDL0MseUJBQTRCO0FBRTVCLElBQU0sZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDdkQsMENBQTZDO0FBQzdDLDJDQUE4QztBQUM5QywyQkFBOEI7QUFDOUIsaUNBQW1DO0FBQ25DLGtEQUF1RTtBQUV2RSwyQ0FBMEM7QUFDMUMsbUNBQXFDO0FBQ3JDLElBQU8sRUFBRSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7QUFDL0IsdUNBQTBDO0FBQzFDLCtCQUFrQztBQUNsQywwQkFBNEI7QUFDNUIseUJBQTJCO0FBQzNCLHlDQUEyQztBQUMzQyxpQ0FBbUM7QUFDbkMsaUNBQWlEO0FBQ2pELGdDQUFrQztBQUNsQyxtREFBcUQ7QUFFckQsSUFBTSxrQkFBa0IsR0FBRyxPQUFPLENBQUMsc0JBQXNCLENBQUMsQ0FBQztBQUMzRCxJQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDM0MsSUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3pDLElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUMzQyxpQ0FBb0M7QUFDcEMsSUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ3JDLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUNyQyxnREFBcUQ7QUFFckQsSUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFD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LElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDakMsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2FBQ3JDO1lBQ0QsV0FBVyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDO1NBQzFDO1FBQ0QsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2FBQ3JDO1lBQ0QsV0FBVyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQ3BDO1FBQ0QsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDakMsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2FBQ3JDO1lBQ0QsV0FBVyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQ3BDO1FBQ0QsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2FBQ3JDO1lBQ0QsV0FBVyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQ3BDO1FBQ0QsSUFBSSxNQUFNLENBQUMsU0FBUyxFQUFFO1lBQ3BCLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDbEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2FBQ3JDO1lBQ0QsV0FBVyxDQUFDLFNBQVMsR0FBRyxN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QixDQUFDLHFCQUFxQixDQUFDLE1BQU0sQ0FBQyxFQUFDOztTQUN6RCxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxnQ0FBZ0IsR0FBaEIsVUFBaUIsU0FBeUI7UUFDeEMsSUFBSSxTQUFTLEVBQUU7WUFDYixJQUFJLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQztTQUN6QjtJQUNILENBQUM7SUExM0RjLDRCQUFzQixHQUFHLEtBQUssQ0FBQztJQTIzRGhELFlBQUM7Q0FBQSxBQTUzREQsSUE0M0RDO0FBNTNEWSxzQkFBSyIsInNvdXJjZXNDb250ZW50IjpbIi8vXG4vLyBCaXRHbyBKYXZhU2NyaXB0IFNES1xuLy9cbi8vIENvcHlyaWdodCAyMDE0LCBCaXRHbywgSW5jLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG5cbmltcG9ydCAqIGFzIHN1cGVyYWdlbnQgZnJvbSAnc3VwZXJhZ2VudCc7XG5pbXBvcnQgKiBhcyBiaXRjb2luIGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgeyBtYWtlUmFuZG9tS2V5LCBoZFBhdGggfSBmcm9tICcuL2JpdGNvaW4nO1xuaW1wb3J0IGJpdGNvaW5NZXNzYWdlID0gcmVxdWlyZSgnYml0Y29pbmpzLW1lc3NhZ2UnKTtcbmltcG9ydCBzYW5pdGl6ZUh0bWwgPSByZXF1aXJlKCdzYW5pdGl6ZS1odG1sJyk7XG5pbXBvcnQgZW9sID0gcmVxdWlyZSgnZW9sJyk7XG5pbXBvcnQgeyBCYXNlQ29pbiB9IGZyb20gJy4vdjIvYmFzZUNvaW4nO1xuY29uc3QgUGVuZGluZ0FwcHJvdmFscyA9IHJlcXVpcmUoJy4vcGVuZGluZ2FwcHJvdmFscycpO1xuaW1wb3J0IHNoYW1pciA9IHJlcXVpcmUoJ3NlY3JldHMuanMtZ3JlbXBlJyk7XG5pbXBvcnQgc2pjbCA9IHJlcXVpcmUoJy4vdmVuZG9yL3NqY2wubWluLmpzJyk7XG5pbXBvcnQgYnM1OCA9IHJlcXVpcmUoJ2JzNTgnKTtcbmltcG9ydCAqIGFzIGNvbW1vbiBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBFbnZpcm9ubWVudE5hbWUsIEFsaWFzRW52aXJvbm1lbnRzIH0gZnJvbSAnLi92Mi9lbnZpcm9ubWVudHMnO1xuaW1wb3J0IHsgTm9kZUNhbGxiYWNrLCBSZXF1ZXN0VHJhY2VyIGFzIElSZXF1ZXN0VHJhY2VyLCBWMU5ldHdvcmsgfSBmcm9tICcuL3YyL3R5cGVzJztcbmltcG9ydCB7IFV0aWwgfSBmcm9tICcuL3YyL2ludGVybmFsL3V0aWwnO1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IGNvID0gQmx1ZWJpcmQuY29yb3V0aW5lO1xuaW1wb3J0IHBqc29uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG5pbXBvcnQgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyB1cmwgZnJvbSAndXJsJztcbmltcG9ydCAqIGFzIHF1ZXJ5c3RyaW5nIGZyb20gJ3F1ZXJ5c3RyaW5nJztcbmltcG9ydCAqIGFzIGNvbmZpZyBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyBjcmVhdGVIbWFjLCByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgKiBhcyBkZWJ1Z0xpYiBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgeyBieXRlc1RvV29yZCB9IGZyb20gJy4vdjIvaW50ZXJuYWwvaW50ZXJuYWwnO1xuXG5jb25zdCBUcmFuc2FjdGlvbkJ1aWxkZXIgPSByZXF1aXJlKCcuL3RyYW5zYWN0aW9uQnVpbGRlcicpO1xuY29uc3QgQmxvY2tjaGFpbiA9IHJlcXVpcmUoJy4vYmxvY2tjaGFpbicpO1xuY29uc3QgS2V5Y2hhaW5zID0gcmVxdWlyZSgnLi9rZXljaGFpbnMnKTtcbmNvbnN0IFRyYXZlbFJ1bGUgPSByZXF1aXJlKCcuL3RyYXZlbFJ1bGUnKTtcbmltcG9ydCBXYWxsZXQgPSByZXF1aXJlKCcuL3dhbGxldCcpO1xuY29uc3QgV2FsbGV0cyA9IHJlcXVpcmUoJy4vd2FsbGV0cycpO1xuY29uc3QgTWFya2V0cyA9IHJlcXVpcmUoJy4vbWFya2V0cycpO1xuaW1wb3J0IHsgR2xvYmFsQ29pbkZhY3RvcnkgfSBmcm9tICcuL3YyL2NvaW5GYWN0b3J5JztcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0xpYignYml0Z286aW5kZXgnKTtcblxuaWYgKCEocHJvY2VzcyBhcyBhbnkpLmJyb3dzZXIpIHtcbiAgcmVxdWlyZSgnc3VwZXJhZ2VudC1wcm94eScpKHN1cGVyYWdlbnQpO1xufVxuXG4vLyBQYXRjaCBzdXBlcmFnZW50IHRvIHJldHVybiBibHVlYmlyZCBwcm9taXNlc1xuY29uc3QgX2VuZCA9IChzdXBlcmFnZW50IGFzIGFueSkuUmVxdWVzdC5wcm90b3R5cGUuZW5kO1xuKHN1cGVyYWdlbnQgYXMgYW55KS5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihjYikge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBfZW5kLmNhbGwoc2VsZiwgY2IpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBCbHVlYmlyZC5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxldCBlcnJvcjtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIF9lbmQuY2FsbChzZWxmLCBmdW5jdGlvbihlcnJvciwgcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICBlcnJvciA9IF9lcnJvcjtcbiAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBIYW5kbGUgSFRUUCBlcnJvcnMgYXBwcm9wcmlhdGVseSwgcmV0dXJuaW5nIHRoZSByZXN1bHQgYm9keSwgb3IgYSBuYW1lZFxuLy8gZmllbGQgZnJvbSB0aGUgYm9keSwgaWYgdGhlIG9wdGlvbmFsRmllbGQgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLlxuKHN1cGVyYWdlbnQgYXMgYW55KS5SZXF1ZXN0LnByb3RvdHlwZS5yZXN1bHQgPSBmdW5jdGlvbihvcHRpb25hbEZpZWxkPzogc3RyaW5nKSB7XG4gIHJldHVybiB0aGlzLnRoZW4oaGFuZGxlUmVzcG9uc2VSZXN1bHQob3B0aW9uYWxGaWVsZCksIGhhbmRsZVJlc3BvbnNlRXJyb3IpO1xufTtcblxuZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2VSZXN1bHQob3B0aW9uYWxGaWVsZD86IHN0cmluZyk6IChyZXM6IHN1cGVyYWdlbnQuUmVzcG9uc2UpID0+IGFueSB7XG4gIHJldHVybiBmdW5jdGlvbihyZXM6IHN1cGVyYWdlbnQuUmVzcG9uc2UpIHtcbiAgICBpZiAoXy5pc051bWJlcihyZXMuc3RhdHVzKSAmJiByZXMuc3RhdHVzID49IDIwMCAmJiByZXMuc3RhdHVzIDwgMzAwKSB7XG4gICAgICByZXR1cm4gb3B0aW9uYWxGaWVsZCA/IHJlcy5ib2R5W29wdGlvbmFsRmllbGRdIDogcmVzLmJvZHk7XG4gICAgfVxuICAgIHRocm93IGVyckZyb21SZXNwb25zZShyZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBlcnJGcm9tUmVzcG9uc2UocmVzOiBzdXBlcmFnZW50LlJlc3BvbnNlKTogRXJyb3Ige1xuICBjb25zdCBlcnJTdHJpbmcgPSBjcmVhdGVSZXNwb25zZUVycm9yU3RyaW5nKHJlcyk7XG4gIGNvbnN0IGVycjogYW55ID0gbmV3IEVycm9yKGVyclN0cmluZyk7XG5cbiAgZXJyLnN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gIGlmIChyZXMuYm9keSkge1xuICAgIGVyci5yZXN1bHQgPSByZXMuYm9keTtcbiAgfVxuICBpZiAoXy5oYXMocmVzLmhlYWRlciwgJ3gtYXV0aC1yZXF1aXJlZCcpICYmIChyZXMuaGVhZGVyWyd4LWF1dGgtcmVxdWlyZWQnXSA9PT0gJ3RydWUnKSkge1xuICAgIGVyci5pbnZhbGlkVG9rZW4gPSB0cnVlO1xuICB9XG4gIGlmIChyZXMuYm9keS5uZWVkc09UUCkge1xuICAgIGVyci5uZWVkc09UUCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGVycjtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2VFcnJvcihlKTogbmV2ZXIge1xuICBpZiAoZS5yZXNwb25zZSkge1xuICAgIHRocm93IGVyckZyb21SZXNwb25zZShlLnJlc3BvbnNlKTtcbiAgfVxuICB0aHJvdyBlO1xufVxuXG4vKipcbiAqIFRoZXJlIGFyZSBtYW55IHdheXMgYSByZXF1ZXN0IGNhbiBmYWlsLCBhbmQgbWF5IHdheXMgaW5mb3JtYXRpb24gb24gdGhhdCBmYWlsdXJlIGNhbiBiZVxuICogY29tbXVuaWNhdGVkIHRvIHRoZSBjbGllbnQuIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gaGFuZGxlIHRob3NlIGNhc2VzIGFuZCBjcmVhdGUgYSBzYW5lIGVycm9yIHN0cmluZ1xuICogQHBhcmFtIHJlcyBSZXNwb25zZSBmcm9tIGFuIEhUVFAgcmVxdWVzdFxuICovXG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZUVycm9yU3RyaW5nKHJlczogc3VwZXJhZ2VudC5SZXNwb25zZSk6IHN0cmluZyB7XG4gIGxldCBlcnJTdHJpbmcgPSByZXMuc3RhdHVzLnRvU3RyaW5nKCk7IC8vIGF0IHRoZSB2ZXJ5IGxlYXN0IHdlJ2xsIGhhdmUgdGhlIHN0YXR1cyBjb2RlXG4gIGlmIChyZXMuYm9keS5lcnJvcikge1xuICAgIC8vIHRoaXMgaXMgdGhlIGNhc2Ugd2UgaG9wZSBmb3IsIHdoZXJlIHRoZSBzZXJ2ZXIgZ2l2ZXMgdXMgYSBuaWNlIGVycm9yIGZyb20gdGhlIEpTT04gYm9keVxuICAgIGVyclN0cmluZyA9IHJlcy5ib2R5LmVycm9yO1xuICB9IGVsc2Uge1xuICAgIGlmIChyZXMudGV4dCkge1xuICAgICAgLy8gaWYgdGhlIHJlc3BvbnNlIGNhbWUgYmFjayBhcyB0ZXh0LCB3ZSB0cnkgdG8gcGFyc2UgaXQgYXMgSFRNTCBhbmQgcmVtb3ZlIGFsbCB0YWdzLCBsZWF2aW5nIHVzXG4gICAgICAvLyBqdXN0IHRoZSBiYXJlIHRleHQsIHdoaWNoIHdlIHRoZW4gdHJpbSBvZiBleGNlc3NpdmUgbmV3bGluZXMgYW5kIGxpbWl0IHRvIGEgY2VydGFpbiBsZW5ndGhcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBzYW5pdGl6ZWRUZXh0ID0gc2FuaXRpemVIdG1sKHJlcy50ZXh0LCB7IGFsbG93ZWRUYWdzOiBbXSB9KTtcbiAgICAgICAgc2FuaXRpemVkVGV4dCA9IHNhbml0aXplZFRleHQudHJpbSgpO1xuICAgICAgICBzYW5pdGl6ZWRUZXh0ID0gZW9sLmxmKHNhbml0aXplZFRleHQpOyAvLyB1c2UgJ1xcbicgZm9yIGFsbCBuZXdsaW5lc1xuICAgICAgICBzYW5pdGl6ZWRUZXh0ID0gXy5yZXBsYWNlKHNhbml0aXplZFRleHQsIC9cXG5bIHxcXHRdezEsfVxcbi9nLCAnXFxuXFxuJyk7IC8vIHJlbW92ZSB0aGUgc3BhY2VzL3RhYnMgYmV0d2VlbiBuZXdsaW5lc1xuICAgICAgICBzYW5pdGl6ZWRUZXh0ID0gXy5yZXBsYWNlKHNhbml0aXplZFRleHQsIC9bXFxuXXszLH0vZywgJ1xcblxcbicpOyAvLyBoYXZlIGF0IG1vc3QgMiBjb25zZWN1dGl2ZSBuZXdsaW5lc1xuICAgICAgICBzYW5pdGl6ZWRUZXh0ID0gc2FuaXRpemVkVGV4dC5zdWJzdHJpbmcoMCwgNTAwMCk7IC8vIHByZXZlbnQgbWVzc2FnZSBmcm9tIGdldHRpbmcgdG9vIGxhcmdlXG4gICAgICAgIGVyclN0cmluZyA9IGVyclN0cmluZyArICdcXG4nICsgc2FuaXRpemVkVGV4dDsgLy8gYWRkIGl0IHRvIG91ciBleGlzdGluZyBlcnJTdHJpbmcgKGF0IHRoaXMgcG9pbnQgdGhlIG1vcmUgaW5mbyB0aGUgYmV0dGVyISlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZywgdGhlIHJlc3BvbnNlJ3MgSFRNTCB3YXMgdG9vIHdhY2t5IHRvIGJlIHBhcnNlZCBjbGVhbmx5XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVyclN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCaXRHb09wdGlvbnMge1xuICBlbnY/OiBFbnZpcm9ubWVudE5hbWU7XG4gIGNsaWVudElkPzogc3RyaW5nO1xuICBjbGllbnRTZWNyZXQ/OiBzdHJpbmc7XG4gIGFjY2Vzc1Rva2VuPzogc3RyaW5nO1xuICB1c2VyQWdlbnQ/OiBzdHJpbmc7XG4gIGN1c3RvbVJvb3RVUkk/OiBzdHJpbmc7XG4gIGN1c3RvbUJpdGNvaW5OZXR3b3JrPzogVjFOZXR3b3JrO1xuICBjdXN0b21TaWduaW5nQWRkcmVzcz86IHN0cmluZztcbiAgc2VydmVyWHB1Yj86IHN0cmluZztcbiAgc3RlbGxhckZlZGVyYXRpb25TZXJ2ZXJVcmw/OiBzdHJpbmc7XG4gIHVzZVByb2R1Y3Rpb24/OiBib29sZWFuO1xuICByZWZyZXNoVG9rZW4/OiBzdHJpbmc7XG4gIHZhbGlkYXRlPzogYm9vbGVhbjtcbiAgcHJveHk/OiBzdHJpbmc7XG4gIGV0aGVyc2NhbkFwaVRva2VuPzogc3RyaW5nO1xuICBobWFjVmVyaWZpY2F0aW9uPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VyIHtcbiAgdXNlcm5hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCaXRHb0pzb24ge1xuICB1c2VyPzogVXNlcjtcbiAgdG9rZW4/OiBzdHJpbmc7XG4gIGV4dGVuc2lvbktleT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgaW50ZXJmYWNlIERlcHJlY2F0ZWRWZXJpZnlBZGRyZXNzT3B0aW9ucyB7XG4gIGFkZHJlc3M/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZ5UGFzc3dvcmRPcHRpb25zIHtcbiAgcGFzc3dvcmQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW5jcnlwdE9wdGlvbnMge1xuICBpbnB1dD86IHN0cmluZztcbiAgcGFzc3dvcmQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVjcnlwdE9wdGlvbnMge1xuICBpbnB1dD86IHN0cmluZztcbiAgcGFzc3dvcmQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3BsaXRTZWNyZXRPcHRpb25zIHtcbiAgc2VlZDogc3RyaW5nO1xuICBwYXNzd29yZHM6IHN0cmluZ1tdO1xuICBtOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3BsaXRTZWNyZXQge1xuICB4cHViOiBzdHJpbmc7XG4gIG06IG51bWJlcjtcbiAgbjogbnVtYmVyO1xuICBzZWVkU2hhcmVzOiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjb25zdGl0dXRlU2VjcmV0T3B0aW9ucyB7XG4gIHNoYXJkczogc3RyaW5nW107XG4gIHBhc3N3b3Jkczogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjb25zdGl0dXRlZFNlY3JldCB7XG4gIHhwdWI6IHN0cmluZztcbiAgeHBydjogc3RyaW5nO1xuICBzZWVkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZ5U2hhcmRzT3B0aW9ucyB7XG4gIHNoYXJkczogc3RyaW5nW107XG4gIHBhc3N3b3Jkczogc3RyaW5nW107XG4gIG06IG51bWJlcjtcbiAgeHB1Yjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldEVjZGhTZWNyZXRPcHRpb25zIHtcbiAgb3RoZXJQdWJLZXlIZXg6IHN0cmluZztcbiAgZWNrZXk6IGJpdGNvaW4uRUNQYWlyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFjY2Vzc1Rva2VuT3B0aW9ucyB7XG4gIGFjY2Vzc1Rva2VuOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9rZW5Jc3N1YW5jZVJlc3BvbnNlIHtcbiAgZGVyaXZhdGlvblBhdGg6IHN0cmluZztcbiAgZW5jcnlwdGVkVG9rZW46IHN0cmluZztcbiAgZW5jcnlwdGVkRUNESFhwcnY/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9rZW5Jc3N1YW5jZSB7XG4gIHRva2VuOiBzdHJpbmc7XG4gIGVjZGhYcHJ2Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhbGN1bGF0ZUhtYWNTdWJqZWN0T3B0aW9ucyB7XG4gIHVybFBhdGg6IHN0cmluZztcbiAgdGV4dDogc3RyaW5nO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgc3RhdHVzQ29kZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWxjdWxhdGVSZXF1ZXN0SG1hY09wdGlvbnMge1xuICB1cmw6IHN0cmluZztcbiAgdGV4dDogc3RyaW5nO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgdG9rZW46IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWxjdWxhdGVSZXF1ZXN0SGVhZGVyc09wdGlvbnMge1xuICB1cmw6IHN0cmluZztcbiAgdGV4dDogc3RyaW5nO1xuICB0b2tlbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlcXVlc3RIZWFkZXJzIHtcbiAgaG1hYzogc3RyaW5nO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgdG9rZW5IYXNoOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZ5UmVzcG9uc2VPcHRpb25zIGV4dGVuZHMgQ2FsY3VsYXRlUmVxdWVzdEhlYWRlcnNPcHRpb25zIHtcbiAgaG1hYzogc3RyaW5nO1xuICB1cmw6IHN0cmluZztcbiAgdGV4dDogc3RyaW5nO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgc3RhdHVzQ29kZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdXRoZW50aWNhdGVPcHRpb25zIHtcbiAgdXNlcm5hbWU6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbiAgb3RwPzogc3RyaW5nO1xuICB0cnVzdD86IG51bWJlcjtcbiAgZm9yY2VTTVM/OiBib29sZWFuO1xuICBleHRlbnNpYmxlPzogYm9vbGVhbjtcbiAgZm9yY2VWMUF1dGg/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2Nlc3NlZEF1dGhlbnRpY2F0aW9uT3B0aW9ucyB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIHBhc3N3b3JkOiBzdHJpbmc7XG4gIGZvcmNlU01TOiBib29sZWFuO1xuICBvdHA/OiBzdHJpbmc7XG4gIHRydXN0PzogbnVtYmVyO1xuICBleHRlbnNpYmxlPzogYm9vbGVhbjtcbiAgZXh0ZW5zaW9uQWRkcmVzcz86IHN0cmluZztcbiAgZm9yY2VWMUF1dGg/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkZEFjY2Vzc1Rva2VuT3B0aW9ucyB7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIG90cD86IHN0cmluZztcbiAgZHVyYXRpb24/OiBudW1iZXI7XG4gIGlwUmVzdHJpY3Q/OiBzdHJpbmdbXTtcbiAgdHhWYWx1ZUxpbWl0PzogbnVtYmVyO1xuICBzY29wZTogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVtb3ZlQWNjZXNzVG9rZW5PcHRpb25zIHtcbiAgaWQ/OiBzdHJpbmc7XG4gIGxhYmVsPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldFVzZXJPcHRpb25zIHtcbiAgaWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGFuZ2VQYXNzd29yZE9wdGlvbnMge1xuICBvbGRQYXNzd29yZDogc3RyaW5nO1xuICBuZXdQYXNzd29yZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVubG9ja09wdGlvbnMge1xuICBvdHA/OiBzdHJpbmc7XG4gIGR1cmF0aW9uPzogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXh0ZW5kVG9rZW5PcHRpb25zIHtcbiAgZHVyYXRpb24/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0U2hhcmluZ0tleU9wdGlvbnMge1xuICBlbWFpbDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBpbmdPcHRpb25zIHtcbiAgcmVxSWQ/OiBJUmVxdWVzdFRyYWNlcjtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVzdGltYXRlRmVlT3B0aW9ucyB7XG4gIG51bUJsb2Nrcz86IG51bWJlcjtcbiAgbWF4RmVlPzogbnVtYmVyO1xuICBpbnB1dHM/OiBzdHJpbmdbXTtcbiAgdHhTaXplPzogbnVtYmVyO1xuICBjcGZwQXdhcmU/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV2ViaG9va09wdGlvbnMge1xuICB1cmw6IHN0cmluZztcbiAgdHlwZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpc3RXZWJob29rTm90aWZpY2F0aW9uc09wdGlvbnMge1xuICBwcmV2SWQ/OiBzdHJpbmc7XG4gIGxpbWl0PzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJpdEdvU2ltdWxhdGVXZWJob29rT3B0aW9ucyB7XG4gIHdlYmhvb2tJZDogc3RyaW5nO1xuICBibG9ja0lkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0aGVudGljYXRlV2l0aEF1dGhDb2RlT3B0aW9ucyB7XG4gIGF1dGhDb2RlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWZXJpZnlQdXNoVG9rZW5PcHRpb25zIHtcbiAgcHVzaFZlcmlmaWNhdGlvblRva2VuOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQml0R29SZXF1ZXN0IGV4dGVuZHMgc3VwZXJhZ2VudC5SZXF1ZXN0IHtcbiAgcmVzdWx0OiAob3B0aW9uYWxGaWVsZD86IHN0cmluZykgPT4gQmx1ZWJpcmQ8YW55PjtcbiAgZW5kOiAoY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8c3VwZXJhZ2VudC5SZXNwb25zZT4pID0+IEJsdWViaXJkPHN1cGVyYWdlbnQuUmVzcG9uc2U+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJpdEdvIHtcbiAgZ2V0KHVybDogc3RyaW5nLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxzdXBlcmFnZW50LlJlc3BvbnNlPik6IEJpdEdvUmVxdWVzdDtcbiAgcG9zdCh1cmw6IHN0cmluZywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8c3VwZXJhZ2VudC5SZXNwb25zZT4pOiBCaXRHb1JlcXVlc3Q7XG4gIHB1dCh1cmw6IHN0cmluZywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8c3VwZXJhZ2VudC5SZXNwb25zZT4pOiBCaXRHb1JlcXVlc3Q7XG4gIGRlbCh1cmw6IHN0cmluZywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8c3VwZXJhZ2VudC5SZXNwb25zZT4pOiBCaXRHb1JlcXVlc3Q7XG4gIHBhdGNoKHVybDogc3RyaW5nLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxzdXBlcmFnZW50LlJlc3BvbnNlPik6IEJpdEdvUmVxdWVzdDtcbn1cblxuZXhwb3J0IGNsYXNzIEJpdEdvIHtcbiAgcHJpdmF0ZSBzdGF0aWMgX3Rlc3RuZXRXYXJuaW5nTWVzc2FnZSA9IGZhbHNlO1xuICBwcml2YXRlIHN0YXRpYyBfY29uc3RhbnRzOiBhbnk7XG4gIHByaXZhdGUgc3RhdGljIF9jb25zdGFudHNFeHBpcmU6IGFueTtcbiAgcHJpdmF0ZSByZWFkb25seSBfZW52OiBFbnZpcm9ubWVudE5hbWU7XG4gIC8qKlxuICAgKiBFeHBvc2UgZW52IHByb3BlcnR5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGVudjogRW52aXJvbm1lbnROYW1lO1xuICBwcml2YXRlIHJlYWRvbmx5IF9iYXNlVXJsOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgX2Jhc2VBcGlVcmw6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBfYmFzZUFwaVVybFYyOiBzdHJpbmc7XG4gIHByaXZhdGUgX3VzZXI/OiBVc2VyO1xuICBwcml2YXRlIF9rZXljaGFpbnM6IGFueTtcbiAgcHJpdmF0ZSBfd2FsbGV0czogYW55O1xuICBwcml2YXRlIHJlYWRvbmx5IF9jbGllbnRJZD86IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBfY2xpZW50U2VjcmV0Pzogc3RyaW5nO1xuICBwcml2YXRlIF90b2tlbj86IHN0cmluZztcbiAgcHJpdmF0ZSBfcmVmcmVzaFRva2VuPzogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IF91c2VyQWdlbnQ6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBfcHJvbWlzZTogdHlwZW9mIEJsdWViaXJkO1xuICBwcml2YXRlIF92YWxpZGF0ZTogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBfcHJveHk/OiBzdHJpbmc7XG4gIHByaXZhdGUgX3JlcUlkPzogSVJlcXVlc3RUcmFjZXI7XG4gIHByaXZhdGUgX2VjZGhYcHJ2Pzogc3RyaW5nO1xuICBwcml2YXRlIF9leHRlbnNpb25LZXk/OiBiaXRjb2luLkVDUGFpcjtcbiAgcHJpdmF0ZSBfbWFya2V0cz86IGFueTtcbiAgcHJpdmF0ZSBfYmxvY2tjaGFpbj86IGFueTtcbiAgcHJpdmF0ZSBfdHJhdmVsUnVsZT86IGFueTtcbiAgcHJpdmF0ZSBfcGVuZGluZ0FwcHJvdmFscz86IGFueTtcbiAgcHJpdmF0ZSBfaG1hY1ZlcmlmaWNhdGlvbjogYm9vbGVhbiA9IHRydWU7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmb3IgQml0R28gT2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbXM6IEJpdEdvT3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWydjbGllbnRJZCcsICdjbGllbnRTZWNyZXQnLCAncmVmcmVzaFRva2VuJywgJ2FjY2Vzc1Rva2VuJywgJ3VzZXJBZ2VudCcsICdjdXN0b21Sb290VVJJJywgJ2N1c3RvbUJpdGNvaW5OZXR3b3JrJywgJ3NlcnZlclhwdWInLCAnc3RlbGxhckZlZGVyYXRpb25TZXJ2ZXJVcmwnXSkgfHxcbiAgICAgIChwYXJhbXMudXNlUHJvZHVjdGlvbiAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLnVzZVByb2R1Y3Rpb24pKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKCghcGFyYW1zLmNsaWVudElkKSAhPT0gKCFwYXJhbXMuY2xpZW50U2VjcmV0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IC0gbXVzdCBwcm92aWRlIGJvdGggY2xpZW50IGlkIGFuZCBzZWNyZXQnKTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSBvcGVyYXRlIG9uIHRoZSB0ZXN0IHNlcnZlci5cbiAgICAvLyBEZXByZWNhdGUgdXNlUHJvZHVjdGlvbiBpbiB0aGUgZnV0dXJlXG4gICAgbGV0IGVudjogRW52aXJvbm1lbnROYW1lO1xuXG4gICAgaWYgKHBhcmFtcy51c2VQcm9kdWN0aW9uKSB7XG4gICAgICBpZiAocGFyYW1zLmVudiAmJiBwYXJhbXMuZW52ICE9PSAncHJvZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgdXNlIHVzZVByb2R1Y3Rpb24gd2hlbiBlbnY9JyArIHBhcmFtcy5lbnYpO1xuICAgICAgfVxuICAgICAgZW52ID0gJ3Byb2QnO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLmN1c3RvbVJvb3RVUkkgfHxcbiAgICAgIHBhcmFtcy5jdXN0b21CaXRjb2luTmV0d29yayB8fFxuICAgICAgcGFyYW1zLmN1c3RvbVNpZ25pbmdBZGRyZXNzIHx8XG4gICAgICBwYXJhbXMuc2VydmVyWHB1YiB8fFxuICAgICAgcHJvY2Vzcy5lbnYuQklUR09fQ1VTVE9NX1JPT1RfVVJJIHx8XG4gICAgICBwcm9jZXNzLmVudi5CSVRHT19DVVNUT01fQklUQ09JTl9ORVRXT1JLKSB7XG4gICAgICAvLyBmb3IgYnJhbmNoIGRlcGxveXMsIHdlIHdhbnQgdG8gYmUgYWJsZSB0byBzcGVjaWZ5IGN1c3RvbSBlbmRwb2ludHMgd2hpbGUgc3RpbGxcbiAgICAgIC8vIG1haW50YWluaW5nIHRoZSBuYW1lIG9mIHNwZWNpZmllZCB0aGUgZW52aXJvbm1lbnRcbiAgICAgIGVudiA9ICBwYXJhbXMuZW52ID09PSAnYnJhbmNoJyA/ICdicmFuY2gnIDogJ2N1c3RvbSc7XG4gICAgICBpZiAocGFyYW1zLmN1c3RvbVJvb3RVUkkpIHtcbiAgICAgICAgY29tbW9uLkVudmlyb25tZW50c1tlbnZdLnVyaSA9IHBhcmFtcy5jdXN0b21Sb290VVJJO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5jdXN0b21CaXRjb2luTmV0d29yaykge1xuICAgICAgICBjb21tb24uRW52aXJvbm1lbnRzW2Vudl0ubmV0d29yayA9IHBhcmFtcy5jdXN0b21CaXRjb2luTmV0d29yaztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuY3VzdG9tU2lnbmluZ0FkZHJlc3MpIHtcbiAgICAgICAgKGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XSBhcyBhbnkpLmN1c3RvbVNpZ25pbmdBZGRyZXNzID0gcGFyYW1zLmN1c3RvbVNpZ25pbmdBZGRyZXNzO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5zZXJ2ZXJYcHViKSB7XG4gICAgICAgIGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS5zZXJ2ZXJYcHViID0gcGFyYW1zLnNlcnZlclhwdWI7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnN0ZWxsYXJGZWRlcmF0aW9uU2VydmVyVXJsKSB7XG4gICAgICAgIGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS5zdGVsbGFyRmVkZXJhdGlvblNlcnZlclVybCA9IHBhcmFtcy5zdGVsbGFyRmVkZXJhdGlvblNlcnZlclVybDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW52ID0gcGFyYW1zLmVudiB8fCBwcm9jZXNzLmVudi5CSVRHT19FTlYgYXMgRW52aXJvbm1lbnROYW1lO1xuICAgIH1cblxuICAgIC8vIGlmIHRoaXMgZW52IGlzIGFuIGFsaWFzLCBzd2FwIGl0IG91dCB3aXRoIHRoZSBlcXVpdmFsZW50IHN1cHBvcnRlZCBlbnZpcm9ubWVudFxuICAgIGlmIChlbnYgaW4gQWxpYXNFbnZpcm9ubWVudHMpIHtcbiAgICAgIGVudiA9IEFsaWFzRW52aXJvbm1lbnRzW2Vudl07XG4gICAgfVxuXG4gICAgaWYgKGVudiA9PT0gJ2N1c3RvbScgJiYgXy5pc1VuZGVmaW5lZChjb21tb24uRW52aXJvbm1lbnRzW2Vudl0udXJpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHVzZSAtLWN1c3RvbXJvb3R1cmkgb3Igc2V0IHRoZSBCSVRHT19DVVNUT01fUk9PVF9VUkkgZW52aXJvbm1lbnQgdmFyaWFibGUgd2hlbiB1c2luZyB0aGUgY3VzdG9tIGVudmlyb25tZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGVudikge1xuICAgICAgaWYgKGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XSkge1xuICAgICAgICB0aGlzLl9iYXNlVXJsID0gY29tbW9uLkVudmlyb25tZW50c1tlbnZdLnVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBlbnZpcm9ubWVudCAnICsgZW52ICsgJy4gU3VwcG9ydGVkIGVudmlyb25tZW50czogcHJvZCwgdGVzdCwgZGV2LCBsYXRlc3QnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW52ID0gJ3Rlc3QnO1xuICAgICAgaWYgKCFCaXRHby5fdGVzdG5ldFdhcm5pbmdNZXNzYWdlKSB7XG4gICAgICAgIEJpdEdvLl90ZXN0bmV0V2FybmluZ01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmxvZygnQml0R28gU0RLIGVudiBub3Qgc2V0IC0gZGVmYXVsdGluZyB0byB0ZXN0IGF0IHRlc3QuYml0Z28uY29tLicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYmFzZVVybCA9IGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS51cmk7XG4gICAgfVxuICAgIHRoaXMuX2VudiA9IHRoaXMuZW52ID0gZW52O1xuXG4gICAgaWYgKHBhcmFtcy5ldGhlcnNjYW5BcGlUb2tlbikge1xuICAgICAgY29tbW9uLkVudmlyb25tZW50c1tlbnZdLmV0aGVyc2NhbkFwaVRva2VuID0gcGFyYW1zLmV0aGVyc2NhbkFwaVRva2VuO1xuICAgIH1cblxuICAgIGNvbW1vbi5zZXROZXR3b3JrKGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS5uZXR3b3JrKTtcbiAgICBjb21tb24uc2V0Um1nTmV0d29yayhjb21tb24uRW52aXJvbm1lbnRzW2Vudl0ucm1nTmV0d29yayk7XG5cbiAgICB0aGlzLl9iYXNlQXBpVXJsID0gdGhpcy5fYmFzZVVybCArICcvYXBpL3YxJztcbiAgICB0aGlzLl9iYXNlQXBpVXJsVjIgPSB0aGlzLl9iYXNlVXJsICsgJy9hcGkvdjInO1xuICAgIHRoaXMuX2tleWNoYWlucyA9IG51bGw7XG4gICAgdGhpcy5fd2FsbGV0cyA9IG51bGw7XG4gICAgdGhpcy5fY2xpZW50SWQgPSBwYXJhbXMuY2xpZW50SWQ7XG4gICAgdGhpcy5fY2xpZW50U2VjcmV0ID0gcGFyYW1zLmNsaWVudFNlY3JldDtcbiAgICB0aGlzLl90b2tlbiA9IHBhcmFtcy5hY2Nlc3NUb2tlbjtcbiAgICB0aGlzLl9yZWZyZXNoVG9rZW4gPSBwYXJhbXMucmVmcmVzaFRva2VuO1xuICAgIHRoaXMuX3VzZXJBZ2VudCA9IHBhcmFtcy51c2VyQWdlbnQgfHwgJ0JpdEdvSlMvJyArIHRoaXMudmVyc2lvbigpO1xuICAgIHRoaXMuX3Byb21pc2UgPSBCbHVlYmlyZDtcbiAgICB0aGlzLl9yZXFJZCA9IHVuZGVmaW5lZDtcblxuICAgIGlmICghcGFyYW1zLmhtYWNWZXJpZmljYXRpb24gJiYgcGFyYW1zLmhtYWNWZXJpZmljYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS5obWFjVmVyaWZpY2F0aW9uRW5mb3JjZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGlzYWJsZSByZXF1ZXN0IEhNQUMgdmVyaWZpY2F0aW9uIGluIGVudmlyb25tZW50ICR7dGhpcy5nZXRFbnYoKX1gKTtcbiAgICAgIH1cbiAgICAgIGRlYnVnKCdITUFDIHZlcmlmaWNhdGlvbiBleHBsaWNpdGx5IGRpc2FibGVkIGJ5IGNvbnN0cnVjdG9yIG9wdGlvbicpO1xuICAgICAgdGhpcy5faG1hY1ZlcmlmaWNhdGlvbiA9IHBhcmFtcy5obWFjVmVyaWZpY2F0aW9uO1xuICAgIH1cblxuICAgIC8vIHdoZXRoZXIgdG8gcGVyZm9ybSBleHRyYSBjbGllbnQtc2lkZSB2YWxpZGF0aW9uIGZvciBzb21lIHRoaW5ncywgc3VjaCBhc1xuICAgIC8vIGFkZHJlc3MgdmFsaWRhdGlvbiBvciBzaWduYXR1cmUgdmFsaWRhdGlvbi4gZGVmYXVsdHMgdG8gdHJ1ZSwgYnV0IGNhbiBiZVxuICAgIC8vIHR1cm5lZCBvZmYgYnkgc2V0dGluZyB0byBmYWxzZS4gY2FuIGFsc28gYmUgb3ZlcnJpZGRlbiBpbmRpdmlkdWFsbHkgaW4gdGhlXG4gICAgLy8gZnVuY3Rpb25zIHRoYXQgdXNlIGl0LlxuICAgIHRoaXMuX3ZhbGlkYXRlID0gcGFyYW1zLnZhbGlkYXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogcGFyYW1zLnZhbGlkYXRlO1xuXG4gICAgLy8gQ3JlYXRlIHN1cGVyYWdlbnQgbWV0aG9kcyBzcGVjaWZpYyB0byB0aGlzIEJpdEdvIGluc3RhbmNlLlxuICAgIGNvbnN0IG1ldGhvZHMgPSBbJ2dldCcsICdwb3N0JywgJ3B1dCcsICdkZWwnLCAncGF0Y2gnXTtcblxuICAgIGlmICghcGFyYW1zLnByb3h5ICYmIHByb2Nlc3MuZW52LkJJVEdPX1VTRV9QUk9YWSkge1xuICAgICAgcGFyYW1zLnByb3h5ID0gcHJvY2Vzcy5lbnYuQklUR09fVVNFX1BST1hZO1xuICAgIH1cblxuICAgIGlmICgocHJvY2VzcyBhcyBhbnkpLmJyb3dzZXIgJiYgcGFyYW1zLnByb3h5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCB1c2UgaHR0cHMgcHJveHkgcGFyYW1zIHdoaWxlIGluIGJyb3dzZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcm94eSA9IHBhcmFtcy5wcm94eTtcblxuICAgIGZvciAoY29uc3QgaW5kZXggaW4gbWV0aG9kcykge1xuICAgICAgY29uc3QgbWV0aG9kID0gbWV0aG9kc1tpbmRleF07XG4gICAgICB0aGlzW21ldGhvZF0gPSB0aGlzLmNyZWF0ZVBhdGNoKG1ldGhvZCk7XG4gICAgfVxuXG4gICAgLy8gY2FwdHVyZSBvdXRlciBzdGFjayBzbyB3ZSBoYXZlIHVzZWZ1bCBkZWJ1ZyBpbmZvcm1hdGlvbiBpZiBmZXRjaCBjb25zdGFudHMgZmFpbHNcbiAgICBjb25zdCBlID0gbmV3IEVycm9yKCk7XG5cbiAgICAvLyBLaWNrIG9mZiBmaXJzdCBsb2FkIG9mIGNvbnN0YW50c1xuICAgIHRoaXMuZmV0Y2hDb25zdGFudHMoe30sIGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBtYWtlIHN1cmUgYW4gZXJyb3IgZG9lcyBub3QgdGVybWluYXRlIHRoZSBlbnRpcmUgc2NyaXB0XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCB0byBmZXRjaCBpbml0aWFsIGNsaWVudCBjb25zdGFudHMgZnJvbSBCaXRHbycpO1xuICAgICAgICBkZWJ1ZyhlLnN0YWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgcGF0Y2hpbmcgZnVuY3Rpb24gd2hpY2ggY2FuIGFwcGx5IG91ciBhdXRob3JpemF0aW9uXG4gICAqIGhlYWRlcnMgdG8gYW55IG91dGJvdW5kIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBtZXRob2RcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlUGF0Y2gobWV0aG9kOiBzdHJpbmcpOiAodXJsOiBzdHJpbmcsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPHN1cGVyYWdlbnQuUmVzcG9uc2U+KSA9PiBzdXBlcmFnZW50LlJlcXVlc3Qge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBsZXQgcmVxOiBzdXBlcmFnZW50LlN1cGVyQWdlbnRSZXF1ZXN0ID0gc3VwZXJhZ2VudFttZXRob2RdLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgaWYgKHNlbGYuX3Byb3h5KSB7XG4gICAgICAgIHJlcSA9IHJlcS5wcm94eShzZWxmLl9wcm94eSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhdGNoIHN1cGVyYWdlbnQgdG8gcmV0dXJuIHByb21pc2VzXG4gICAgICBjb25zdCBwcm90b3R5cGljYWxFbmQgPSByZXEuZW5kO1xuICAgICAgcmVxLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB0aGlzUmVxOiBzdXBlcmFnZW50LlN1cGVyQWdlbnRSZXF1ZXN0ID0gdGhpcztcbiAgICAgICAgLy8gaW50ZXJjZXB0IGEgcmVxdWVzdCBiZWZvcmUgaXQncyBzdWJtaXR0ZWQgdG8gdGhlIHNlcnZlciBmb3IgdjIgYXV0aGVudGljYXRpb24gKGJhc2VkIG9uIHRva2VuKVxuICAgICAgICB0aGlzUmVxLnNldCgnQml0R28tU0RLLVZlcnNpb24nLCBzZWxmLnZlcnNpb24oKSk7XG5cbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHNlbGYuX3JlcUlkKSkge1xuICAgICAgICAgIHRoaXNSZXEuc2V0KCdSZXF1ZXN0LUlEJywgc2VsZi5fcmVxSWQudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICAvLyBpbmNyZW1lbnQgYWZ0ZXIgc2V0dGluZyB0aGUgaGVhZGVyIHNvIHRoZSBzZXF1ZW5jZSBudW1iZXJzIHN0YXJ0IGF0IDBcbiAgICAgICAgICBzZWxmLl9yZXFJZC5pbmMoKTtcblxuICAgICAgICAgIC8vIHJlcXVlc3QgaWRzIG11c3QgYmUgc2V0IGJlZm9yZSBlYWNoIHJlcXVlc3QgaW5zdGVhZCBvZiBiZWluZyBrZXB0XG4gICAgICAgICAgLy8gaW5zaWRlIHRoZSBiaXRnbyBvYmplY3QuIFRoaXMgaXMgdG8gcHJldmVudCByZWVudHJhbmN5IGlzc3VlcyB3aGVyZVxuICAgICAgICAgIC8vIG11bHRpcGxlIHNpbXVsdGFuZW91cyByZXF1ZXN0cyBjb3VsZCBjYXVzZSBpbmNvcnJlY3QgcmVxSWRzIHRvIGJlIHVzZWRcbiAgICAgICAgICBkZWxldGUgc2VsZi5fcmVxSWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyB0b2tlbiwgYW5kIHdlJ3JlIG5vdCBsb2dnZWQgaW4sIHRoZSByZXF1ZXN0IGNhbm5vdCBiZSB2MiBhdXRoZW50aWNhdGVkXG4gICAgICAgIHRoaXNSZXEuaXNWMkF1dGhlbnRpY2F0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzUmVxLmF1dGhlbnRpY2F0aW9uVG9rZW4gPSBzZWxmLl90b2tlbjtcbiAgICAgICAgLy8gc29tZSBvZiB0aGUgb2xkZXIgdG9rZW5zIGFwcGVhciB0byBiZSBvbmx5IDQwIGNoYXJhY3RlcnMgbG9uZ1xuICAgICAgICBpZiAoKHNlbGYuX3Rva2VuICYmIHNlbGYuX3Rva2VuLmxlbmd0aCAhPT0gNjcgJiYgc2VsZi5fdG9rZW4uaW5kZXhPZigndjJ4JykgIT09IDApXG4gICAgICAgICAgfHwgcmVxLmZvcmNlVjFBdXRoKSB7XG4gICAgICAgICAgLy8gdXNlIHRoZSBvbGQgbWV0aG9kXG4gICAgICAgICAgdGhpc1JlcS5pc1YyQXV0aGVudGljYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgdGhpc1JlcS5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyICcgKyBzZWxmLl90b2tlbik7XG4gICAgICAgICAgcmV0dXJuIHByb3RvdHlwaWNhbEVuZC5hcHBseSh0aGlzUmVxLCBhcmd1bWVudHMgYXMgYW55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNSZXEuc2V0KCdCaXRHby1BdXRoLVZlcnNpb24nLCAnMi4wJyk7XG4gICAgICAgIC8vIHByZXZlbnQgSUUgZnJvbSBjYWNoaW5nIHJlcXVlc3RzXG4gICAgICAgIHRoaXNSZXEuc2V0KCdJZi1Nb2RpZmllZC1TaW5jZScsICdNb24sIDI2IEp1bCAxOTk3IDA1OjAwOjAwIEdNVCcpO1xuICAgICAgICBpZiAoc2VsZi5fdG9rZW4pIHtcblxuICAgICAgICAgIC8vIGRvIGEgbG9jYWxpemVkIGRhdGEgc2VyaWFsaXphdGlvbiBwcm9jZXNzXG4gICAgICAgICAgbGV0IGRhdGEgPSAodGhpc1JlcSBhcyBhbnkpLl9kYXRhO1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgICAgbGV0IGNvbnRlbnRUeXBlID0gdGhpc1JlcS5nZXQoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgICAgLy8gUGFyc2Ugb3V0IGp1c3QgdGhlIGNvbnRlbnQgdHlwZSBmcm9tIHRoZSBoZWFkZXIgKGlnbm9yZSB0aGUgY2hhcnNldClcbiAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2VyaWFsaXplID0gc3VwZXJhZ2VudC5zZXJpYWxpemVbY29udGVudFR5cGVdO1xuICAgICAgICAgICAgaWYgKCFzZXJpYWxpemUgJiYgL1tcXC8rXWpzb25cXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICAgICAgICAgIHNlcmlhbGl6ZSA9IHN1cGVyYWdlbnQuc2VyaWFsaXplWydhcHBsaWNhdGlvbi9qc29uJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBzZXJpYWxpemUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgICh0aGlzUmVxIGFzIGFueSkuX2RhdGEgPSBkYXRhO1xuXG4gICAgICAgICAgY29uc3QgdXJsRGV0YWlscyA9IHVybC5wYXJzZShyZXEudXJsKTtcblxuICAgICAgICAgIGxldCBxdWVyeVN0cmluZzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnN0IHF1ZXJ5OiBzdHJpbmdbXSA9IChyZXEgYXMgYW55KS5fcXVlcnk7XG4gICAgICAgICAgY29uc3QgcXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSAocmVxIGFzIGFueSkucXM7XG4gICAgICAgICAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIGJyb3dzZXIgdmVyc2lvblxuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeS5qb2luKCcmJyk7XG4gICAgICAgICAgICAocmVxIGFzIGFueSkuX3F1ZXJ5ID0gW107XG4gICAgICAgICAgfSBlbHNlIGlmIChxcykge1xuICAgICAgICAgICAgLy8gbm9kZSB2ZXJzaW9uXG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShxcyk7XG4gICAgICAgICAgICAocmVxIGFzIGFueSkucXMgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChxdWVyeVN0cmluZykge1xuICAgICAgICAgICAgaWYgKHVybERldGFpbHMuc2VhcmNoKSB7XG4gICAgICAgICAgICAgIHVybERldGFpbHMuc2VhcmNoICs9ICcmJyArIHF1ZXJ5U3RyaW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdXJsRGV0YWlscy5zZWFyY2ggPSAnPycgKyBxdWVyeVN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcS51cmwgPSB1cmwuZm9ybWF0KHVybERldGFpbHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlcXVlc3RQcm9wZXJ0aWVzID0gc2VsZi5jYWxjdWxhdGVSZXF1ZXN0SGVhZGVycyh7IHVybDogcmVxLnVybCwgdG9rZW46IHNlbGYuX3Rva2VuLCB0ZXh0OiBkYXRhIH0pO1xuICAgICAgICAgIHRoaXNSZXEuc2V0KCdBdXRoLVRpbWVzdGFtcCcsIHJlcXVlc3RQcm9wZXJ0aWVzLnRpbWVzdGFtcC50b1N0cmluZygpKTtcblxuICAgICAgICAgIC8vIHdlJ3JlIG5vdCBzZW5kaW5nIHRoZSBhY3R1YWwgdG9rZW4sIGJ1dCBvbmx5IGl0cyBoYXNoXG4gICAgICAgICAgdGhpc1JlcS5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyICcgKyByZXF1ZXN0UHJvcGVydGllcy50b2tlbkhhc2gpO1xuXG4gICAgICAgICAgLy8gc2V0IHRoZSBITUFDXG4gICAgICAgICAgdGhpc1JlcS5zZXQoJ0hNQUMnLCByZXF1ZXN0UHJvcGVydGllcy5obWFjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm90b3R5cGljYWxFbmQuYXBwbHkodGhpc1JlcSwgYXJndW1lbnRzIGFzIGFueSk7XG4gICAgICB9O1xuXG4gICAgICAvLyB2ZXJpZnkgdGhhdCB0aGUgcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIGlzIHNpZ25lZCBjb3JyZWN0bHlcbiAgICAgIC8vIHJpZ2h0IG5vdywgaXQgaXMgdmVyeSBwZXJtaXNzaXZlIHdpdGggdGhlIHRpbWVzdGFtcCB2YXJpYW5jZVxuICAgICAgcmVxLnZlcmlmeVJlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKCFyZXEuaXNWMkF1dGhlbnRpY2F0ZWQgfHwgIXJlcS5hdXRoZW50aWNhdGlvblRva2VuKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSE1BQyB2ZXJpZmljYXRpb24gaXMgb25seSBhbGxvd2VkIHRvIGJlIHNraXBwZWQgaW4gY2VydGFpbiBlbnZpcm9ubWVudHMuXG4gICAgICAgIC8vIFRoaXMgaXMgY2hlY2tlZCBpbiB0aGUgY29uc3RydWN0b3IsIGJ1dCBjaGVja2luZyBpdCBhZ2FpbiBhdCByZXF1ZXN0IHRpbWVcbiAgICAgICAgLy8gd2lsbCBoZWxwIHByZXZlbnQgYWdhaW5zdCB0YW1wZXJpbmcgb2YgdGhpcyBwcm9wZXJ0eSBhZnRlciB0aGUgb2JqZWN0IGlzIGNyZWF0ZWRcbiAgICAgICAgaWYgKCFzZWxmLl9obWFjVmVyaWZpY2F0aW9uICYmICFjb21tb24uRW52aXJvbm1lbnRzW3NlbGYuZ2V0RW52KCldLmhtYWNWZXJpZmljYXRpb25FbmZvcmNlZCkge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZlcmlmaWNhdGlvblJlc3BvbnNlID0gc2VsZi52ZXJpZnlSZXNwb25zZSh7XG4gICAgICAgICAgdXJsOiByZXEudXJsLFxuICAgICAgICAgIGhtYWM6IHJlc3BvbnNlLmhlYWRlci5obWFjLFxuICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICB0ZXh0OiByZXNwb25zZS50ZXh0LFxuICAgICAgICAgIHRpbWVzdGFtcDogcmVzcG9uc2UuaGVhZGVyLnRpbWVzdGFtcCxcbiAgICAgICAgICB0b2tlbjogcmVxLmF1dGhlbnRpY2F0aW9uVG9rZW5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF2ZXJpZmljYXRpb25SZXNwb25zZS5pc1ZhbGlkKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBITUFDXG4gICAgICAgICAgY29uc3QgcmVjZWl2ZWRIbWFjID0gcmVzcG9uc2UuaGVhZGVyLmhtYWM7XG4gICAgICAgICAgY29uc3QgZXhwZWN0ZWRIbWFjID0gdmVyaWZpY2F0aW9uUmVzcG9uc2UuZXhwZWN0ZWRIbWFjO1xuICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZVN1YmplY3QgPSB2ZXJpZmljYXRpb25SZXNwb25zZS5zaWduYXR1cmVTdWJqZWN0O1xuICAgICAgICAgIC8vIExvZyBvbmx5IHRoZSBmaXJzdCAxMCBjaGFyYWN0ZXJzIG9mIHRoZSB0b2tlbiB0byBlbnN1cmUgdGhlIGZ1bGwgdG9rZW4gaXNuJ3QgbG9nZ2VkLlxuICAgICAgICAgIGNvbnN0IHBhcnRpYWxCaXRnb1Rva2VuID0gc2VsZi5fdG9rZW4gPyBzZWxmLl90b2tlbi5zdWJzdHJpbmcoMCwgMTApIDogJyc7XG4gICAgICAgICAgY29uc3QgZXJyb3JEZXRhaWxzID0ge1xuICAgICAgICAgICAgZXhwZWN0ZWRIbWFjLFxuICAgICAgICAgICAgcmVjZWl2ZWRIbWFjLFxuICAgICAgICAgICAgaG1hY0lucHV0OiBzaWduYXR1cmVTdWJqZWN0LFxuICAgICAgICAgICAgcmVxdWVzdFRva2VuOiByZXEuYXV0aGVudGljYXRpb25Ub2tlbixcbiAgICAgICAgICAgIGJpdGdvVG9rZW46IHBhcnRpYWxCaXRnb1Rva2VuXG4gICAgICAgICAgfTtcbiAgICAgICAgICBkZWJ1ZygnSW52YWxpZCByZXNwb25zZSBITUFDOiAlTycsIGVycm9yRGV0YWlscyk7XG4gICAgICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcignaW52YWxpZCByZXNwb25zZSBITUFDLCBwb3NzaWJsZSBtYW4taW4tdGhlLW1pZGRsZS1hdHRhY2snKTtcbiAgICAgICAgICBlcnJvci5yZXN1bHQgPSBlcnJvckRldGFpbHM7XG4gICAgICAgICAgZXJyb3Iuc3RhdHVzID0gNTExO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH07XG5cbiAgICAgIGxldCBsYXN0UHJvbWlzZTogQmx1ZWJpcmQ8YW55PiB8IG51bGwgPSBudWxsO1xuICAgICAgcmVxLnRoZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFsYXN0UHJvbWlzZSkge1xuICAgICAgICAgIC8vIGNhbm5vdCByZWRlZmluZSBlbmQoKSB0byByZXR1cm4gYSBCbHVlYmlyZDxhbnk+LCBldmVuIHRob3VnaFxuICAgICAgICAgIC8vIHRoYXQgZ2V0cyBtb25rZXkgcGF0Y2hlZCBpbiBhdCBydW50aW1lLCBzbyB0aGlzIGNhc3QgaXMgcmVxdWlyZWRcbiAgICAgICAgICBjb25zdCByZWZlcmVuY2U6IEJsdWViaXJkPGFueT4gPSAocmVxLmVuZCgpIGFzIHVua25vd24gYXMgQmx1ZWJpcmQ8YW55PilcbiAgICAgICAgICAgIC50aGVuKHJlcS52ZXJpZnlSZXNwb25zZSk7XG4gICAgICAgICAgbGFzdFByb21pc2UgPSByZWZlcmVuY2UudGhlbi5hcHBseShyZWZlcmVuY2UsIGFyZ3VtZW50cyBhcyBhbnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RQcm9taXNlID0gbGFzdFByb21pc2UudGhlbi5hcHBseShsYXN0UHJvbWlzZSwgYXJndW1lbnRzIGFzIGFueSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICByZXR1cm4gbGFzdFByb21pc2UhO1xuICAgICAgfTtcblxuICAgICAgaWYgKCEocHJvY2VzcyBhcyBhbnkpLmJyb3dzZXIpIHtcbiAgICAgICAgLy8gSWYgbm90IGluIHRoZSBicm93c2VyLCBzZXQgdGhlIFVzZXItQWdlbnQuIEJyb3dzZXJzIGRvbid0IGFsbG93XG4gICAgICAgIC8vIHNldHRpbmcgb2YgVXNlci1BZ2VudCwgc28gd2UgbXVzdCBkaXNhYmxlIHRoaXMgd2hlbiBydW4gaW4gdGhlXG4gICAgICAgIC8vIGJyb3dzZXIgKGJyb3dzZXJpZnkgc2V0cyBwcm9jZXNzLmJyb3dzZXIpLlxuICAgICAgICByZXEuc2V0KCdVc2VyLUFnZW50Jywgc2VsZi5fdXNlckFnZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgdG8ganVzdCBhYm92ZSA1IG1pbnV0ZXMgYnkgZGVmYXVsdFxuICAgICAgcmVxLnRpbWVvdXQoKHByb2Nlc3MuZW52LkJJVEdPX1RJTUVPVVQgYXMgYW55KSAqIDEwMDAgfHwgMzA1ICogMTAwMCk7XG4gICAgICByZXR1cm4gcmVxO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBITUFDIGZvciB0aGUgZ2l2ZW4ga2V5IGFuZCBtZXNzYWdlXG4gICAqIEBwYXJhbSBrZXkge1N0cmluZ30gLSB0aGUga2V5IHRvIHVzZSBmb3IgdGhlIEhNQUNcbiAgICogQHBhcmFtIG1lc3NhZ2Uge1N0cmluZ30gLSB0aGUgYWN0dWFsIG1lc3NhZ2UgdG8gSE1BQ1xuICAgKiBAcmV0dXJucyB7Kn0gLSB0aGUgcmVzdWx0IG9mIHRoZSBITUFDIG9wZXJhdGlvblxuICAgKi9cbiAgY2FsY3VsYXRlSE1BQyhrZXk6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gY3JlYXRlSG1hYygnc2hhMjU2Jywga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCdoZXgnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBiYXNlY29pbiBvYmplY3RcbiAgICogQHBhcmFtIGNvaW5OYW1lXG4gICAqL1xuICBjb2luKGNvaW5OYW1lOiBzdHJpbmcpOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIEdsb2JhbENvaW5GYWN0b3J5LmdldEluc3RhbmNlKHRoaXMsIGNvaW5OYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBiYXNlY29pbiBvYmplY3QgZm9yIGEgdmlydHVhbCB0b2tlblxuICAgKiBAcGFyYW0gdG9rZW5OYW1lXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgdG9rZW4odG9rZW5OYW1lOiBzdHJpbmcsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPEJhc2VDb2luPik6IEJsdWViaXJkPEJhc2VDb2luPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvPEJhc2VDb2luPihmdW5jdGlvbiAqKCkge1xuICAgICAgeWllbGQgc2VsZi5mZXRjaENvbnN0YW50cygpO1xuICAgICAgcmV0dXJuIHNlbGYuY29pbih0b2tlbk5hbWUpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIGdldFZhbGlkYXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgc2V0VmFsaWRhdGUodmFsaWRhdGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKHZhbGlkYXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIHRoaXMuX3ZhbGlkYXRlID0gdmFsaWRhdGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IEJpdEdvIGVudmlyb25tZW50XG4gICAqL1xuICBnZXRFbnYoKTogRW52aXJvbm1lbnROYW1lIHtcbiAgICByZXR1cm4gdGhpcy5fZW52O1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIG91dCBhbGwgc3RhdGUgZnJvbSB0aGlzIEJpdEdvIG9iamVjdCwgZWZmZWN0aXZlbHkgbG9nZ2luZyBvdXQgdGhlIGN1cnJlbnQgdXNlci5cbiAgICovXG4gIGNsZWFyKCk6IHZvaWQge1xuICAgIC8vIFRPRE86IGFyZSB0aGVyZSBhbnkgb3RoZXIgZmllbGRzIHdoaWNoIHNob3VsZCBiZSBjbGVhcmVkP1xuICAgIHRoaXMuX3VzZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVmcmVzaFRva2VuID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2VjZGhYcHJ2ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byByZXR1cm4gYSByZWplY3RlZCBwcm9taXNlIG9yIGNhbGwgY2FsbGJhY2sgd2l0aCBlcnJvclxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgcmVqZWN0KG1zZzogc3RyaW5nLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxuZXZlcj4pOiBCbHVlYmlyZDxuZXZlcj4ge1xuICAgIHJldHVybiBCbHVlYmlyZC5yZWplY3QobmV3IEVycm9yKG1zZykpLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZlcnNpb24gb2YgdGhlIEJpdEdvSlMgcGFja2FnZVxuICAgKi9cbiAgdmVyc2lvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiBwanNvbi52ZXJzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGlzIEJpdEdvIG9iamVjdCB0byBhIEpTT04gb2JqZWN0LlxuICAgKlxuICAgKiBDYXV0aW9uOiBjb250YWlucyBzZW5zaXRpdmUgZGF0YVxuICAgKi9cbiAgdG9KU09OKCk6IEJpdEdvSnNvbiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXI6IHRoaXMuX3VzZXIsXG4gICAgICB0b2tlbjogdGhpcy5fdG9rZW4sXG4gICAgICBleHRlbnNpb25LZXk6IHRoaXMuX2V4dGVuc2lvbktleSA/IHRoaXMuX2V4dGVuc2lvbktleS50b1dJRigpIDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgYSBKU09OIHNlcmlhbGl6ZWQgQml0R28gb2JqZWN0LlxuICAgKlxuICAgKiBPdmVyd3JpdGVzIHRoZSBwcm9wZXJ0aWVzIG9uIHRoZSBjdXJyZW50IEJpdEdvIG9iamVjdCB3aXRoXG4gICAqIHRob3NlIG9mIHRoZSBkZXNlcmlhbHplZCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSBqc29uXG4gICAqL1xuICBmcm9tSlNPTihqc29uOiBCaXRHb0pzb24pOiB2b2lkIHtcbiAgICB0aGlzLl91c2VyID0ganNvbi51c2VyO1xuICAgIHRoaXMuX3Rva2VuID0ganNvbi50b2tlbjtcbiAgICBpZiAoanNvbi5leHRlbnNpb25LZXkpIHtcbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuZ2V0RW52KCldLm5ldHdvcms7XG4gICAgICB0aGlzLl9leHRlbnNpb25LZXkgPSBiaXRjb2luLkVDUGFpci5mcm9tV0lGKFxuICAgICAgICBqc29uLmV4dGVuc2lvbktleSxcbiAgICAgICAgYml0Y29pbi5uZXR3b3Jrc1tuZXR3b3JrXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHVzZXJcbiAgICovXG4gIHVzZXIoKTogVXNlciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IGEgQml0Y29pbiBhZGRyZXNzIGlzIGEgdmFsaWQgYmFzZTU4IGFkZHJlc3NcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHZlcmlmeUFkZHJlc3MocGFyYW1zOiBEZXByZWNhdGVkVmVyaWZ5QWRkcmVzc09wdGlvbnMgPSB7fSk6IGJvb2xlYW4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnYWRkcmVzcyddLCBbXSk7XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgc3RyaW5nIGFkZHJlc3MnKTtcbiAgICB9XG5cbiAgICBsZXQgYWRkcmVzcztcbiAgICB0cnkge1xuICAgICAgYWRkcmVzcyA9IGJpdGNvaW4uYWRkcmVzcy5mcm9tQmFzZTU4Q2hlY2socGFyYW1zLmFkZHJlc3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXR3b3JrTmFtZSA9IGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5nZXRFbnYoKV0ubmV0d29yaztcbiAgICBjb25zdCBuZXR3b3JrID0gYml0Y29pbi5uZXR3b3Jrc1tuZXR3b3JrTmFtZV07XG4gICAgcmV0dXJuIGFkZHJlc3MudmVyc2lvbiA9PT0gbmV0d29yay5wdWJLZXlIYXNoIHx8IGFkZHJlc3MudmVyc2lvbiA9PT0gbmV0d29yay5zY3JpcHRIYXNoO1xuICB9XG5cbiAgLyoqXG4gICAqL1xuICB2ZXJpZnlQYXNzd29yZChwYXJhbXM6IFZlcmlmeVBhc3N3b3JkT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KSB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wYXNzd29yZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBzdHJpbmcgcGFzc3dvcmQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3VzZXIgfHwgIXRoaXMuX3VzZXIudXNlcm5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gY3VycmVudCB1c2VyJyk7XG4gICAgfVxuICAgIGNvbnN0IGhtYWNQYXNzd29yZCA9IHRoaXMuY2FsY3VsYXRlSE1BQyh0aGlzLl91c2VyLnVzZXJuYW1lLCBwYXJhbXMucGFzc3dvcmQpO1xuXG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybCgnL3VzZXIvdmVyaWZ5cGFzc3dvcmQnKSlcbiAgICAgIC5zZW5kKHsgcGFzc3dvcmQ6IGhtYWNQYXNzd29yZCB9KVxuICAgICAgLnJlc3VsdCgndmFsaWQnKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZW5jcnlwdCBsb2NhbGx5LlxuICAgKi9cbiAgZW5jcnlwdChwYXJhbXM6IEVuY3J5cHRPcHRpb25zID0ge30pOiBzdHJpbmcge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnaW5wdXQnLCAncGFzc3dvcmQnXSwgW10pO1xuXG4gICAgY29uc3QgcmFuZG9tU2FsdCA9IHJhbmRvbUJ5dGVzKDgpO1xuICAgIGNvbnN0IHJhbmRvbUlWID0gcmFuZG9tQnl0ZXMoMTYpO1xuICAgIGNvbnN0IGVuY3J5cHRPcHRpb25zID0ge1xuICAgICAgaXRlcjogMTAwMDAsXG4gICAgICBrczogMjU2LFxuICAgICAgc2FsdDogW1xuICAgICAgICBieXRlc1RvV29yZChyYW5kb21TYWx0LnNsaWNlKDAsIDQpKSxcbiAgICAgICAgYnl0ZXNUb1dvcmQocmFuZG9tU2FsdC5zbGljZSg0KSlcbiAgICAgIF0sXG4gICAgICBpdjogW1xuICAgICAgICBieXRlc1RvV29yZChyYW5kb21JVi5zbGljZSgwLCA0KSksXG4gICAgICAgIGJ5dGVzVG9Xb3JkKHJhbmRvbUlWLnNsaWNlKDQsIDgpKSxcbiAgICAgICAgYnl0ZXNUb1dvcmQocmFuZG9tSVYuc2xpY2UoOCwgMTIpKSxcbiAgICAgICAgYnl0ZXNUb1dvcmQocmFuZG9tSVYuc2xpY2UoMTIsIDE2KSlcbiAgICAgIF1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHNqY2wuZW5jcnlwdChwYXJhbXMucGFzc3dvcmQsIHBhcmFtcy5pbnB1dCwgZW5jcnlwdE9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY3J5cHQgYW4gZW5jcnlwdGVkIHN0cmluZyBsb2NhbGx5LlxuICAgKi9cbiAgZGVjcnlwdChwYXJhbXM6IERlY3J5cHRPcHRpb25zID0ge30pOiBzdHJpbmcge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2lucHV0JywgJ3Bhc3N3b3JkJ10sIFtdKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHNqY2wuZGVjcnlwdChwYXJhbXMucGFzc3dvcmQsIHBhcmFtcy5pbnB1dCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdjY206IHRhZyBkb2VzblxcJ3QgbWF0Y2gnKSkge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gJ3Bhc3N3b3JkIGVycm9yIC0gJyArIGVycm9yLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSByYW5kb20gcGFzc3dvcmRcbiAgICogQHBhcmFtICAge051bWJlcn0gbnVtV29yZHMgICAgIE51bWJlciBvZiAzMi1iaXQgd29yZHNcbiAgICogQHJldHVybnMge1N0cmluZ30gICAgICAgICAgYmFzZTU4IHJhbmRvbSBwYXNzd29yZFxuICAgKi9cbiAgZ2VuZXJhdGVSYW5kb21QYXNzd29yZChudW1Xb3JkczogbnVtYmVyID0gNSk6IHN0cmluZyB7XG4gICAgY29uc3QgYnl0ZXMgPSBzamNsLmNvZGVjLmJ5dGVzLmZyb21CaXRzKHNqY2wucmFuZG9tLnJhbmRvbVdvcmRzKG51bVdvcmRzKSk7XG4gICAgcmV0dXJuIGJzNTguZW5jb2RlKGJ5dGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCBhIHNlY3JldCBpbnRvIHNoYXJkcyB1c2luZyBTaGFtaXIgU2VjcmV0IFNoYXJpbmcuXG4gICAqIEBwYXJhbSBzZWVkIEEgaGV4YWRlY2ltYWwgc2VjcmV0IHRvIHNwbGl0XG4gICAqIEBwYXJhbSBwYXNzd29yZHMgQW4gYXJyYXkgb2YgdGhlIHBhc3N3b3JkcyB1c2VkIHRvIGVuY3J5cHQgZWFjaCBzaGFyZVxuICAgKiBAcGFyYW0gbSBUaGUgdGhyZXNob2xkIG51bWJlciBvZiBzaGFyZHMgbmVjZXNzYXJ5IHRvIHJlY29uc3RpdHV0ZSB0aGUgc2VjcmV0XG4gICAqL1xuICBzcGxpdFNlY3JldCh7IHNlZWQsIHBhc3N3b3JkcywgbSB9OiBTcGxpdFNlY3JldE9wdGlvbnMpOiBTcGxpdFNlY3JldCB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhc3N3b3JkcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFzc3dvcmRzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICB9XG4gICAgaWYgKCFfLmlzSW50ZWdlcihtKSB8fCBtIDwgMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAyJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhc3N3b3Jkcy5sZW5ndGggPCBtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3N3b3JkcyBhcnJheSBsZW5ndGggY2Fubm90IGJlIGxlc3MgdGhhbiBtJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbiA9IHBhc3N3b3Jkcy5sZW5ndGg7XG4gICAgY29uc3Qgc2VjcmV0czogc3RyaW5nW10gPSBzaGFtaXIuc2hhcmUoc2VlZCwgbiwgbSk7XG4gICAgY29uc3Qgc2hhcmRzID0gXy56aXBXaXRoKHNlY3JldHMsIHBhc3N3b3JkcywgKHNoYXJkLCBwYXNzd29yZCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdCh7IGlucHV0OiBzaGFyZCwgcGFzc3dvcmQgfSk7XG4gICAgfSk7XG4gICAgY29uc3Qgbm9kZSA9IGJpdGNvaW4uSEROb2RlLmZyb21TZWVkSGV4KHNlZWQpO1xuICAgIHJldHVybiB7XG4gICAgICB4cHViOiBub2RlLm5ldXRlcmVkKCkudG9CYXNlNTgoKSxcbiAgICAgIG0sXG4gICAgICBuLFxuICAgICAgc2VlZFNoYXJlczogc2hhcmRzLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVjb25zdGl0dXRlIGEgc2VjcmV0IHdoaWNoIHdhcyBzaGFyZGVkIHdpdGggYHNwbGl0U2VjcmV0YC5cbiAgICogQHBhcmFtIHNoYXJkc1xuICAgKiBAcGFyYW0gcGFzc3dvcmRzXG4gICAqL1xuICByZWNvbnN0aXR1dGVTZWNyZXQoeyBzaGFyZHMsIHBhc3N3b3JkcyB9OiBSZWNvbnN0aXR1dGVTZWNyZXRPcHRpb25zKTogUmVjb25zdGl0dXRlZFNlY3JldCB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNoYXJkcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2hhcmRzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhc3N3b3JkcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFzc3dvcmRzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICB9XG5cbiAgICBpZiAoc2hhcmRzLmxlbmd0aCAhPT0gcGFzc3dvcmRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGFyZHMgYW5kIHBhc3N3b3JkcyBhcnJheXMgbXVzdCBoYXZlIHNhbWUgbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VjcmV0cyA9IF8uemlwV2l0aChzaGFyZHMsIHBhc3N3b3JkcywgKHNoYXJkLCBwYXNzd29yZCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdCh7IGlucHV0OiBzaGFyZCwgcGFzc3dvcmQgfSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VlZDogc3RyaW5nID0gc2hhbWlyLmNvbWJpbmUoc2VjcmV0cyk7XG4gICAgY29uc3Qgbm9kZSA9IGJpdGNvaW4uSEROb2RlLmZyb21TZWVkSGV4KHNlZWQpO1xuICAgIHJldHVybiB7XG4gICAgICB4cHViOiBub2RlLm5ldXRlcmVkKCkudG9CYXNlNTgoKSBhcyBzdHJpbmcsXG4gICAgICB4cHJ2OiBub2RlLnRvQmFzZTU4KCkgYXMgc3RyaW5nLFxuICAgICAgc2VlZCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBzaGFyZHNcbiAgICogQHBhcmFtIHBhc3N3b3Jkc1xuICAgKiBAcGFyYW0gbVxuICAgKiBAcGFyYW0geHB1YiBPcHRpb25hbCB4cHViIHRvIHZlcmlmeSB0aGUgcmVzdWx0cyBhZ2FpbnN0XG4gICAqL1xuICB2ZXJpZnlTaGFyZHMoeyBzaGFyZHMsIHBhc3N3b3JkcywgbSwgeHB1YiB9OiBWZXJpZnlTaGFyZHNPcHRpb25zKTogYm9vbGVhbiB7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYWxsIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBvZiBhIGdpdmVuIGFycmF5J3MgdmFsdWVzIGdpdmVuIHN1YnNldCBzaXplIG1cbiAgICAgKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5IHdob3NlIHZhbHVlcyBhcmUgdG8gYmUgYXJyYW5nZWQgaW4gYWxsIGNvbWJpbmF0aW9uc1xuICAgICAqIEBwYXJhbSBtIFRoZSBzaXplIG9mIGVhY2ggc3Vic2V0XG4gICAgICogQHBhcmFtIGVudHJ5SW5kaWNlcyBSZWN1cnNpdmVseSB0cmFpbGluZyBzZXQgb2YgY3VycmVudGx5IGNob3NlbiBhcnJheSBpbmRpY2VzIGZvciB0aGUgY29tYmluYXRpb24gc3Vic2V0IHVuZGVyIGNvbnN0cnVjdGlvblxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBjb25zdCBnZW5lcmF0ZUNvbWJpbmF0aW9ucyA9IChhcnJheTogc3RyaW5nW10sIG06IG51bWJlciwgZW50cnlJbmRpY2VzOiBudW1iZXJbXSA9IFtdKTogc3RyaW5nW11bXSA9PiB7XG4gICAgICBsZXQgY29tYmluYXRpb25zOiBzdHJpbmdbXVtdID0gW107XG5cbiAgICAgIGlmIChlbnRyeUluZGljZXMubGVuZ3RoID09PSBtKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb21iaW5hdGlvbiA9IF8uYXQoYXJyYXksIGVudHJ5SW5kaWNlcyk7XG4gICAgICAgIHJldHVybiBbY3VycmVudENvbWJpbmF0aW9uXTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGhpZ2hlc3QgaW5kZXhcbiAgICAgIGxldCBlbnRyeUluZGV4ID0gXy5sYXN0KGVudHJ5SW5kaWNlcyk7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgY3VycmVudGx5IG5vIGluZGljZXMsIGFzc3VtZSAtMVxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoZW50cnlJbmRleCkpIHtcbiAgICAgICAgZW50cnlJbmRleCA9IC0xO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IGVudHJ5SW5kZXggKyAxOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBjdXJyZW50IGluZGV4IHRvIHRoZSB0cmFpbGluZyBpbmRpY2VzXG4gICAgICAgIGNvbnN0IGN1cnJlbnRFbnRyeUluZGljZXMgPSBbLi4uZW50cnlJbmRpY2VzLCBpXTtcbiAgICAgICAgY29uc3QgbmV3Q29tYmluYXRpb25zID0gZ2VuZXJhdGVDb21iaW5hdGlvbnMoYXJyYXksIG0sIGN1cnJlbnRFbnRyeUluZGljZXMpO1xuICAgICAgICBjb21iaW5hdGlvbnMgPSBbLi4uY29tYmluYXRpb25zLCAuLi5uZXdDb21iaW5hdGlvbnNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tYmluYXRpb25zO1xuICAgIH07XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2hhcmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGFyZHMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFzc3dvcmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzd29yZHMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cblxuICAgIGlmIChzaGFyZHMubGVuZ3RoICE9PSBwYXNzd29yZHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXJkcyBhbmQgcGFzc3dvcmRzIGFycmF5cyBtdXN0IGhhdmUgc2FtZSBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWNyZXRzID0gXy56aXBXaXRoKHNoYXJkcywgcGFzc3dvcmRzLCAoc2hhcmQsIHBhc3N3b3JkKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNyeXB0KHsgaW5wdXQ6IHNoYXJkLCBwYXNzd29yZCB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBzZWNyZXRDb21iaW5hdGlvbnMgPSBnZW5lcmF0ZUNvbWJpbmF0aW9ucyhzZWNyZXRzLCBtKTtcbiAgICBjb25zdCBzZWVkcyA9IHNlY3JldENvbWJpbmF0aW9ucy5tYXAoY3VycmVudENvbWJpbmF0aW9uID0+IHtcbiAgICAgIHJldHVybiBzaGFtaXIuY29tYmluZShjdXJyZW50Q29tYmluYXRpb24pO1xuICAgIH0pO1xuICAgIGNvbnN0IHVuaXF1ZVNlZWRzID0gXy51bmlxKHNlZWRzKTtcbiAgICBpZiAodW5pcXVlU2VlZHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHNlZWQgPSBfLmZpcnN0KHVuaXF1ZVNlZWRzKTtcbiAgICBjb25zdCBub2RlID0gYml0Y29pbi5IRE5vZGUuZnJvbVNlZWRIZXgoc2VlZCk7XG4gICAgY29uc3QgcmVzdG9yZWRYcHViID0gbm9kZS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCk7XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoeHB1YikpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyh4cHViKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3hwdWIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3RvcmVkWHB1YiAhPT0geHB1Yikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGFuIEVDREggc2VjcmV0IGZyb20gYSBwcml2YXRlIGtleSBhbmQgb3RoZXIgdXNlcidzIHB1YmxpYyBrZXlcbiAgICovXG4gIGdldEVDREhTZWNyZXQoeyBvdGhlclB1YktleUhleCwgZWNrZXkgfTogR2V0RWNkaFNlY3JldE9wdGlvbnMpIHtcbiAgICBpZiAoIV8uaXNTdHJpbmcob3RoZXJQdWJLZXlIZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ290aGVyUHViS2V5SGV4IHN0cmluZyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoIV8uaXNPYmplY3QoZWNrZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Vja2V5IG9iamVjdCByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IG90aGVyS2V5UHViID0gYml0Y29pbi5FQ1BhaXIuZnJvbVB1YmxpY0tleUJ1ZmZlcihCdWZmZXIuZnJvbShvdGhlclB1YktleUhleCwgJ2hleCcpKTtcbiAgICBjb25zdCBzZWNyZXRQb2ludCA9IG90aGVyS2V5UHViLlEubXVsdGlwbHkoKGVja2V5IGFzIGJpdGNvaW4uRUNQYWlyKS5kKTtcbiAgICBjb25zdCBzZWNyZXQgPSBVdGlsLmJuVG9CeXRlQXJyYXlVbnNpZ25lZChzZWNyZXRQb2ludC5hZmZpbmVYKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcmV0KS50b1N0cmluZygnaGV4Jyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdXNlcidzIHByaXZhdGUga2V5Y2hhaW4sIHVzZWQgZm9yIHJlY2VpdmluZyBzaGFyZXNcbiAgICovXG4gIGdldEVDREhTaGFyaW5nS2V5Y2hhaW4ocGFyYW1zPzoge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy91c2VyL3NldHRpbmdzJykpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICBpZiAoIXJlc3VsdC5zZXR0aW5ncy5lY2RoS2V5Y2hhaW4pIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5yZWplY3QoJ2VjZGgga2V5Y2hhaW4gbm90IGZvdW5kIGZvciB1c2VyJywgY2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGYua2V5Y2hhaW5zKCkuZ2V0KHsgeHB1YjogcmVzdWx0LnNldHRpbmdzLmVjZGhLZXljaGFpbiB9KTtcbiAgICAgIH0pXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGJpdGNvaW4gbWFya2V0IGRhdGFcbiAgICovXG4gIG1hcmtldHMoKSB7XG4gICAgaWYgKCF0aGlzLl9tYXJrZXRzKSB7XG4gICAgICB0aGlzLl9tYXJrZXRzID0gbmV3IE1hcmtldHModGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9tYXJrZXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGF0ZXN0IGJpdGNvaW4gcHJpY2VzXG4gICAqIChEZXByZWNhdGVkOiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSkgdXNlIGBiaXRnby5tYXJrZXRzKCkubGF0ZXN0KClgXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBtYXJrZXQocGFyYW1zPzoge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy9tYXJrZXQvbGF0ZXN0JykpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbWFya2V0IGRhdGEgZnJvbSB5ZXN0ZXJkYXlcbiAgICogKERlcHJlY2F0ZWQ6IFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlKSB1c2UgYml0Z28ubWFya2V0cygpLnllc3RlcmRheSgpXG4gICAqL1xuICB5ZXN0ZXJkYXkocGFyYW1zPzoge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy9tYXJrZXQveWVzdGVyZGF5JykpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbm91cyBtZXRob2QgZm9yIGFjdGl2YXRpbmcgYW4gYWNjZXNzIHRva2VuLlxuICAgKi9cbiAgYXV0aGVudGljYXRlV2l0aEFjY2Vzc1Rva2VuKHsgYWNjZXNzVG9rZW4gfTogQWNjZXNzVG9rZW5PcHRpb25zKTogdm9pZCB7XG4gICAgdGhpcy5fdG9rZW4gPSBhY2Nlc3NUb2tlbjtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gcmVzcG9uc2VCb2R5IFJlc3BvbnNlIGJvZHkgb2JqZWN0XG4gICAqIEBwYXJhbSBwYXNzd29yZCBQYXNzd29yZCBmb3IgdGhlIHN5bW1ldHJpYyBkZWNyeXB0aW9uXG4gICAqL1xuICBoYW5kbGVUb2tlbklzc3VhbmNlKHJlc3BvbnNlQm9keTogVG9rZW5Jc3N1YW5jZVJlc3BvbnNlLCBwYXNzd29yZD86IHN0cmluZyk6IFRva2VuSXNzdWFuY2Uge1xuICAgIC8vIG1ha2Ugc3VyZSB0aGUgcmVzcG9uc2UgYm9keSBjb250YWlucyB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocmVzcG9uc2VCb2R5LCBbJ2Rlcml2YXRpb25QYXRoJ10sIFsnZW5jcnlwdGVkRUNESFhwcnYnXSk7XG5cbiAgICBjb25zdCBlbnZpcm9ubWVudCA9IHRoaXMuX2VudjtcbiAgICBjb25zdCBlbnZpcm9ubWVudENvbmZpZyA9IGNvbW1vbi5FbnZpcm9ubWVudHNbZW52aXJvbm1lbnRdO1xuICAgIGNvbnN0IHNlcnZlclhwdWIgPSBlbnZpcm9ubWVudENvbmZpZy5zZXJ2ZXJYcHViO1xuICAgIGxldCBlY2RoWHBydiA9IHRoaXMuX2VjZGhYcHJ2O1xuICAgIGlmICghZWNkaFhwcnYpIHtcbiAgICAgIGlmICghcGFzc3dvcmQgfHwgIXJlc3BvbnNlQm9keS5lbmNyeXB0ZWRFQ0RIWHBydikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VjZGhYcHJ2IHByb3BlcnR5IG11c3QgYmUgc2V0IG9yIHBhc3N3b3JkIGFuZCBlbmNyeXB0ZWQgZW5jcnlwdGVkRUNESFhwcnYgbXVzdCBiZSBwcm92aWRlZCcpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgZWNkaFhwcnYgPSB0aGlzLmRlY3J5cHQoe1xuICAgICAgICAgIGlucHV0OiByZXNwb25zZUJvZHkuZW5jcnlwdGVkRUNESFhwcnYsXG4gICAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlLmVycm9yQ29kZSA9ICdlY2RoX3hwcnZfZGVjcnlwdGlvbl9mYWlsdXJlJztcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgZW5jcnlwdGVkRUNESFhwcnYuJyk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29uc3RydWN0IEhETm9kZSBvYmplY3RzIGZvciBjbGllbnQncyB4cHJ2IGFuZCBzZXJ2ZXIncyB4cHViXG4gICAgY29uc3QgY2xpZW50SEROb2RlID0gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OChlY2RoWHBydik7XG4gICAgY29uc3Qgc2VydmVySEROb2RlID0gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OChzZXJ2ZXJYcHViKTtcblxuICAgIC8vIEJJUDMyIGRlcml2YXRpb24gcGF0aCBpcyBhcHBsaWVkIHRvIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXIgbWFzdGVyIGtleXNcbiAgICBjb25zdCBkZXJpdmF0aW9uUGF0aCA9IHJlc3BvbnNlQm9keS5kZXJpdmF0aW9uUGF0aDtcbiAgICBjb25zdCBjbGllbnREZXJpdmVkTm9kZSA9IGhkUGF0aChjbGllbnRIRE5vZGUpLmRlcml2ZShkZXJpdmF0aW9uUGF0aCk7XG4gICAgY29uc3Qgc2VydmVyRGVyaXZlZE5vZGUgPSBoZFBhdGgoc2VydmVySEROb2RlKS5kZXJpdmUoZGVyaXZhdGlvblBhdGgpO1xuXG4gICAgLy8gY2FsY3VsYXRpbmcgb25lLXRpbWUgRUNESCBrZXlcbiAgICBjb25zdCBzZWNyZXRQb2ludCA9IHNlcnZlckRlcml2ZWROb2RlLmtleVBhaXIuX19RLm11bHRpcGx5KGNsaWVudERlcml2ZWROb2RlLmtleVBhaXIuZCk7XG4gICAgY29uc3Qgc2VjcmV0ID0gc2VjcmV0UG9pbnQuZ2V0RW5jb2RlZCgpLnRvU3RyaW5nKCdoZXgnKTtcblxuICAgIC8vIGRlY3J5cHQgdG9rZW4gd2l0aCBzeW1tZXRyaWMgRUNESCBrZXlcbiAgICBsZXQgcmVzcG9uc2U6IFRva2VuSXNzdWFuY2U7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICB0b2tlbjogdGhpcy5kZWNyeXB0KHtcbiAgICAgICAgICBpbnB1dDogcmVzcG9uc2VCb2R5LmVuY3J5cHRlZFRva2VuLFxuICAgICAgICAgIHBhc3N3b3JkOiBzZWNyZXRcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5lcnJvckNvZGUgPSAndG9rZW5fZGVjcnlwdGlvbl9mYWlsdXJlJztcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkZWNyeXB0IHRva2VuLicpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9lY2RoWHBydikge1xuICAgICAgcmVzcG9uc2UuZWNkaFhwcnYgPSBlY2RoWHBydjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgc3RyaW5nIHRoYXQgaXMgdG8gYmUgSE1BQ2VkIGZvciBhIGNlcnRhaW4gSFRUUCByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gICAqIEBwYXJhbSB1cmxQYXRoXG4gICAqIEBwYXJhbSB0ZXh0XG4gICAqIEBwYXJhbSB0aW1lc3RhbXBcbiAgICogQHBhcmFtIHN0YXR1c0NvZGUgT25seSBzZXQgZm9yIEhUVFAgcmVzcG9uc2VzLCBsZWF2ZSBibGFuayBmb3IgcmVxdWVzdHNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGNhbGN1bGF0ZUhNQUNTdWJqZWN0KHsgdXJsUGF0aCwgdGV4dCwgdGltZXN0YW1wLCBzdGF0dXNDb2RlIH06IENhbGN1bGF0ZUhtYWNTdWJqZWN0T3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3QgdXJsRGV0YWlscyA9IHVybC5wYXJzZSh1cmxQYXRoKTtcbiAgICBjb25zdCBxdWVyeVBhdGggPSAodXJsRGV0YWlscy5xdWVyeSAmJiB1cmxEZXRhaWxzLnF1ZXJ5Lmxlbmd0aCA+IDApID8gdXJsRGV0YWlscy5wYXRoIDogdXJsRGV0YWlscy5wYXRobmFtZTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoc3RhdHVzQ29kZSkgJiYgXy5pc0ludGVnZXIoc3RhdHVzQ29kZSkgJiYgXy5pc0Zpbml0ZShzdGF0dXNDb2RlKSkge1xuICAgICAgcmV0dXJuIFt0aW1lc3RhbXAsIHF1ZXJ5UGF0aCwgc3RhdHVzQ29kZSwgdGV4dF0uam9pbignfCcpO1xuICAgIH1cbiAgICByZXR1cm4gW3RpbWVzdGFtcCwgcXVlcnlQYXRoLCB0ZXh0XS5qb2luKCd8Jyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBITUFDIGZvciBhbiBIVFRQIHJlcXVlc3RcbiAgICovXG4gIGNhbGN1bGF0ZVJlcXVlc3RITUFDKHsgdXJsOiB1cmxQYXRoLCB0ZXh0LCB0aW1lc3RhbXAsIHRva2VuIH06IENhbGN1bGF0ZVJlcXVlc3RIbWFjT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3Qgc2lnbmF0dXJlU3ViamVjdCA9IHRoaXMuY2FsY3VsYXRlSE1BQ1N1YmplY3QoeyB1cmxQYXRoLCB0ZXh0LCB0aW1lc3RhbXAgfSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIEhNQUNcbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVITUFDKHRva2VuLCBzaWduYXR1cmVTdWJqZWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgcmVxdWVzdCBoZWFkZXJzIHdpdGggSE1BQ1xuICAgKi9cbiAgY2FsY3VsYXRlUmVxdWVzdEhlYWRlcnMoeyB1cmwsIHRleHQsIHRva2VuIH06IENhbGN1bGF0ZVJlcXVlc3RIZWFkZXJzT3B0aW9ucyk6IFJlcXVlc3RIZWFkZXJzIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGhtYWMgPSB0aGlzLmNhbGN1bGF0ZVJlcXVlc3RITUFDKHsgdXJsLCB0ZXh0LCB0aW1lc3RhbXAsIHRva2VuIH0pO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBTSEEyNTYgaGFzaCBvZiB0aGUgdG9rZW5cbiAgICBjb25zdCBoYXNoRGlnZXN0ID0gc2pjbC5oYXNoLnNoYTI1Ni5oYXNoKHRva2VuKTtcbiAgICBjb25zdCB0b2tlbkhhc2ggPSBzamNsLmNvZGVjLmhleC5mcm9tQml0cyhoYXNoRGlnZXN0KTtcbiAgICByZXR1cm4ge1xuICAgICAgaG1hYyxcbiAgICAgIHRpbWVzdGFtcCxcbiAgICAgIHRva2VuSGFzaCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGUgSE1BQyBmb3IgYW4gSFRUUCByZXNwb25zZVxuICAgKi9cbiAgdmVyaWZ5UmVzcG9uc2UoeyB1cmw6IHVybFBhdGgsIHN0YXR1c0NvZGUsIHRleHQsIHRpbWVzdGFtcCwgdG9rZW4sIGhtYWMgfTogVmVyaWZ5UmVzcG9uc2VPcHRpb25zKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlU3ViamVjdCA9IHRoaXMuY2FsY3VsYXRlSE1BQ1N1YmplY3Qoe1xuICAgICAgdXJsUGF0aCxcbiAgICAgIHRleHQsXG4gICAgICB0aW1lc3RhbXAsXG4gICAgICBzdGF0dXNDb2RlLFxuICAgIH0pO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBITUFDXG4gICAgY29uc3QgZXhwZWN0ZWRIbWFjID0gdGhpcy5jYWxjdWxhdGVITUFDKHRva2VuLCBzaWduYXR1cmVTdWJqZWN0KTtcblxuICAgIC8vIHZlcmlmeSB0aGUgSE1BQyBhbmQgdGltZXN0YW1wXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGV4cGVjdGVkSG1hYyA9PT0gaG1hYyxcbiAgICAgIGV4cGVjdGVkSG1hYyxcbiAgICAgIHNpZ25hdHVyZVN1YmplY3QsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSB1c2VybmFtZSwgcGFzc3dvcmQgYW5kIG90cCBpbnRvIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB1c2VybmFtZSBhbmQgaGFzaGVkIHBhc3N3b3JkLCByZWFkeSB0b1xuICAgKiBzZW5kIHRvIGJpdGdvIGZvciBhdXRoZW50aWNhdGlvbi5cbiAgICovXG4gIHByZXByb2Nlc3NBdXRoZW50aWNhdGlvblBhcmFtcyh7IHVzZXJuYW1lLCBwYXNzd29yZCwgb3RwLCBmb3JjZVNNUywgZXh0ZW5zaWJsZSwgdHJ1c3QgfTogQXV0aGVudGljYXRlT3B0aW9ucyk6IFByb2Nlc3NlZEF1dGhlbnRpY2F0aW9uT3B0aW9ucyB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHVzZXJuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgdXNlcm5hbWUnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFzc3dvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBwYXNzd29yZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvd2VyTmFtZSA9IHVzZXJuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwYXNzd29yZCBITUFDIHNvIHdlIGRvbid0IHNlbmQgY2xlYXItdGV4dCBwYXNzd29yZHNcbiAgICBjb25zdCBobWFjUGFzc3dvcmQgPSB0aGlzLmNhbGN1bGF0ZUhNQUMobG93ZXJOYW1lLCBwYXNzd29yZCk7XG5cbiAgICBjb25zdCBhdXRoUGFyYW1zOiBQcm9jZXNzZWRBdXRoZW50aWNhdGlvbk9wdGlvbnMgPSB7XG4gICAgICBlbWFpbDogbG93ZXJOYW1lLFxuICAgICAgcGFzc3dvcmQ6IGhtYWNQYXNzd29yZCxcbiAgICAgIGZvcmNlU01TOiAhIWZvcmNlU01TLFxuICAgIH07XG5cbiAgICBpZiAob3RwKSB7XG4gICAgICBhdXRoUGFyYW1zLm90cCA9IG90cDtcbiAgICAgIGlmICh0cnVzdCkge1xuICAgICAgICBhdXRoUGFyYW1zLnRydXN0ID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaWJsZSkge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uS2V5ID0gbWFrZVJhbmRvbUtleSgpO1xuICAgICAgYXV0aFBhcmFtcy5leHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgIGF1dGhQYXJhbXMuZXh0ZW5zaW9uQWRkcmVzcyA9IHRoaXMuX2V4dGVuc2lvbktleS5nZXRBZGRyZXNzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF1dGhQYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogTG9naW4gdG8gdGhlIGJpdGdvIHBsYXRmb3JtLlxuICAgKi9cbiAgYXV0aGVudGljYXRlKHBhcmFtczogQXV0aGVudGljYXRlT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbzxzdXBlcmFnZW50LlJlc3BvbnNlPihmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBvYmplY3QgcGFyYW1zJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWxsYmFjayAmJiAhXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIHBhcmFtZXRlciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wYXNzd29yZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgcGFzc3dvcmQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9yY2VWMUF1dGggPSAhIXBhcmFtcy5mb3JjZVYxQXV0aDtcbiAgICAgIGNvbnN0IGF1dGhQYXJhbXMgPSBzZWxmLnByZXByb2Nlc3NBdXRoZW50aWNhdGlvblBhcmFtcyhwYXJhbXMpO1xuICAgICAgY29uc3QgcGFzc3dvcmQgPSBwYXJhbXMucGFzc3dvcmQ7XG5cbiAgICAgIGlmIChzZWxmLl90b2tlbikge1xuICAgICAgICByZXR1cm4gc2VsZi5yZWplY3QoJ2FscmVhZHkgbG9nZ2VkIGluJywgY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdXRoVXJsID0gc2VsZi5taWNyb3NlcnZpY2VzVXJsKCcvYXBpL2F1dGgvdjEvc2Vzc2lvbicpO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IHNlbGYucG9zdChhdXRoVXJsKTtcblxuICAgICAgaWYgKGZvcmNlVjFBdXRoKSB7XG4gICAgICAgIChyZXF1ZXN0IGFzIGFueSkuZm9yY2VWMUF1dGggPSB0cnVlO1xuICAgICAgICAvLyB0ZWxsIHRoZSBzZXJ2ZXIgdGhhdCB0aGUgY2xpZW50IHdhcyBmb3JjZWQgdG8gZG93bmdyYWRlIHRoZSBhdXRoZW50aWNhdGlvbiBwcm90b2NvbFxuICAgICAgICBhdXRoUGFyYW1zLmZvcmNlVjFBdXRoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlOiBzdXBlcmFnZW50LlJlc3BvbnNlID0geWllbGQgcmVxdWVzdC5zZW5kKGF1dGhQYXJhbXMpO1xuICAgICAgLy8gZXh0cmFjdCBib2R5IGFuZCB1c2VyIGluZm9ybWF0aW9uXG4gICAgICBjb25zdCBib2R5ID0gcmVzcG9uc2UuYm9keTtcbiAgICAgIHNlbGYuX3VzZXIgPSBib2R5LnVzZXI7XG5cbiAgICAgIGlmIChib2R5LmFjY2Vzc190b2tlbikge1xuICAgICAgICBzZWxmLl90b2tlbiA9IGJvZHkuYWNjZXNzX3Rva2VuO1xuICAgICAgICAvLyBpZiB0aGUgZG93bmdyYWRlIHdhcyBmb3JjZWQsIGFkZGluZyBhIHdhcm5pbmcgbWVzc2FnZSBtaWdodCBiZSBwcnVkZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjaGVjayB0aGUgcHJlc2VuY2Ugb2YgYW4gZW5jcnlwdGVkIEVDREggeHBydlxuICAgICAgICAvLyBpZiBub3QgcHJlc2VudCwgbGVnYWN5IGFjY291bnRcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkWHBydiA9IGJvZHkuZW5jcnlwdGVkRUNESFhwcnY7XG4gICAgICAgIGlmICghZW5jcnlwdGVkWHBydikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5Y2hhaW4gbmVlZHMgZW5jcnlwdGVkWHBydiBwcm9wZXJ0eScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2VEZXRhaWxzID0gc2VsZi5oYW5kbGVUb2tlbklzc3VhbmNlKHJlc3BvbnNlLmJvZHksIHBhc3N3b3JkKTtcbiAgICAgICAgc2VsZi5fdG9rZW4gPSByZXNwb25zZURldGFpbHMudG9rZW47XG4gICAgICAgIHNlbGYuX2VjZGhYcHJ2ID0gcmVzcG9uc2VEZXRhaWxzLmVjZGhYcHJ2O1xuXG4gICAgICAgIC8vIHZlcmlmeSB0aGUgcmVzcG9uc2UncyBhdXRoZW50aWNpdHlcbiAgICAgICAgcmVxdWVzdC52ZXJpZnlSZXNwb25zZShyZXNwb25zZSk7XG5cbiAgICAgICAgLy8gYWRkIHRoZSByZW1haW5pbmcgY29tcG9uZW50IGZvciBlYXNpZXIgYWNjZXNzXG4gICAgICAgIHJlc3BvbnNlLmJvZHkuYWNjZXNzX3Rva2VuID0gc2VsZi5fdG9rZW47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KS5jYWxsKHRoaXMpXG4gICAgICAudGhlbihoYW5kbGVSZXNwb25zZVJlc3VsdCgpLCBoYW5kbGVSZXNwb25zZUVycm9yKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSBvcGVyYXRpbmdTeXN0ZW06IG9uZSBvZiBpb3MsIGFuZHJvaWRcbiAgICogLSBwdXNoVG9rZW46IGhleC1mb3JtYXR0ZWQgdG9rZW4gZm9yIHRoZSByZXNwZWN0aXZlIG5hdGl2ZSBwdXNoIG5vdGlmaWNhdGlvbiBzZXJ2aWNlXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHJlZ2lzdGVyUHVzaFRva2VuKHBhcmFtcywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3B1c2hUb2tlbicsICdvcGVyYXRpbmdTeXN0ZW0nXSwgW10sIGNhbGxiYWNrKTtcblxuICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgIC8vIHRoaXMgZGV2aWNlIGhhcyB0byBiZSByZWdpc3RlcmVkIHRvIGFuIGV4dGVuc2libGUgc2Vzc2lvblxuICAgICAgcmV0dXJuIHRoaXMucmVqZWN0KCdub3QgbG9nZ2VkIGluJywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGNvbnN0IHBvc3RQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBbJ3B1c2hUb2tlbicsICdvcGVyYXRpbmdTeXN0ZW0nXSk7XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvZGV2aWNlcycpKVxuICAgICAgLnNlbmQocG9zdFBhcmFtcylcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHB1c2hWZXJpZmljYXRpb25Ub2tlbjogdGhlIHRva2VuIHJlY2VpdmVkIHZpYSBwdXNoIG5vdGlmaWNhdGlvbiB0byBjb25maXJtIHRoZSBkZXZpY2UncyBtb2JpbGl0eVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHZlcmlmeVB1c2hUb2tlbihwYXJhbXM6IFZlcmlmeVB1c2hUb2tlbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGlmICghXy5pc09iamVjdChwYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgb2JqZWN0IHBhcmFtcycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnB1c2hWZXJpZmljYXRpb25Ub2tlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgcHVzaFZlcmlmaWNhdGlvblRva2VuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5fdG9rZW4pIHtcbiAgICAgICAgLy8gdGhpcyBkZXZpY2UgaGFzIHRvIGJlIHJlZ2lzdGVyZWQgdG8gYW4gZXh0ZW5zaWJsZSBzZXNzaW9uXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGxvZ2dlZCBpbicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwb3N0UGFyYW1zID0gXy5waWNrKHBhcmFtcywgJ3B1c2hWZXJpZmljYXRpb25Ub2tlbicpO1xuXG4gICAgICByZXR1cm4gc2VsZi5wb3N0KHNlbGYudXJsKCcvZGV2aWNlcy92ZXJpZnknKSlcbiAgICAgICAgLnNlbmQocG9zdFBhcmFtcylcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH0pLmNhbGwodGhpcylcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dpbiB0byB0aGUgYml0Z28gc3lzdGVtIHVzaW5nIGFuIGF1dGhjb2RlIGdlbmVyYXRlZCB2aWEgT2F1dGhcbiAgICovXG4gIGF1dGhlbnRpY2F0ZVdpdGhBdXRoQ29kZShwYXJhbXM6IEF1dGhlbnRpY2F0ZVdpdGhBdXRoQ29kZU9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGlmICghXy5pc09iamVjdChwYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgb2JqZWN0IHBhcmFtcycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmF1dGhDb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyBhdXRoQ29kZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGYuX2NsaWVudElkIHx8ICFzZWxmLl9jbGllbnRTZWNyZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIGNsaWVudCBpZCBhbmQgc2VjcmV0IHNldCBmaXJzdCB0byB1c2UgdGhpcycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdXRoQ29kZSA9IHBhcmFtcy5hdXRoQ29kZTtcblxuICAgICAgaWYgKHNlbGYuX3Rva2VuKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJlamVjdCgnYWxyZWFkeSBsb2dnZWQgaW4nLCBjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzZWxmLnBvc3Qoc2VsZi5fYmFzZVVybCArICcvb2F1dGgvdG9rZW4nKTtcbiAgICAgIHJlcXVlc3QuZm9yY2VWMUF1dGggPSB0cnVlOyAvLyBPQXV0aCBjdXJyZW50bHkgb25seSBzdXBwb3J0cyB2MSBhdXRoZW50aWNhdGlvblxuICAgICAgY29uc3QgYm9keSA9IHlpZWxkIHJlcXVlc3RcbiAgICAgICAgLnNlbmQoe1xuICAgICAgICAgIGdyYW50X3R5cGU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxuICAgICAgICAgIGNvZGU6IGF1dGhDb2RlLFxuICAgICAgICAgIGNsaWVudF9pZDogc2VsZi5fY2xpZW50SWQsXG4gICAgICAgICAgY2xpZW50X3NlY3JldDogc2VsZi5fY2xpZW50U2VjcmV0LFxuICAgICAgICB9KVxuICAgICAgICAucmVzdWx0KCk7XG5cbiAgICAgIHNlbGYuX3Rva2VuID0gYm9keS5hY2Nlc3NfdG9rZW47XG4gICAgICBzZWxmLl9yZWZyZXNoVG9rZW4gPSBib2R5LnJlZnJlc2hfdG9rZW47XG4gICAgICBzZWxmLl91c2VyID0geWllbGQgc2VsZi5tZSgpO1xuICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVXNlIHJlZnJlc2ggdG9rZW4gdG8gZ2V0IG5ldyBhY2Nlc3MgdG9rZW4uXG4gICAqIElmIHRoZSByZWZyZXNoIHRva2VuIGlzIG51bGwvZGVmaW5lZCwgdGhlbiB3ZSB1c2UgdGhlIHN0b3JlZCB0b2tlbiBmcm9tIGF1dGhcbiAgICovXG4gIHJlZnJlc2hUb2tlbihwYXJhbXM6IHsgcmVmcmVzaFRva2VuPzogc3RyaW5nIH0gPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsncmVmcmVzaFRva2VuJ10sIGNhbGxiYWNrKTtcblxuICAgICAgY29uc3QgcmVmcmVzaFRva2VuID0gcGFyYW1zLnJlZnJlc2hUb2tlbiB8fCBzZWxmLl9yZWZyZXNoVG9rZW47XG5cbiAgICAgIGlmICghcmVmcmVzaFRva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIHJlZnJlc2ggdG9rZW4gb3IgaGF2ZSBhdXRoZW50aWNhdGVkIHdpdGggT2F1dGggYmVmb3JlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5fY2xpZW50SWQgfHwgIXNlbGYuX2NsaWVudFNlY3JldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgY2xpZW50IGlkIGFuZCBzZWNyZXQgc2V0IGZpcnN0IHRvIHVzZSB0aGlzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJvZHkgPSB5aWVsZCBzZWxmLnBvc3Qoc2VsZi5fYmFzZVVybCArICcvb2F1dGgvdG9rZW4nKVxuICAgICAgICAuc2VuZCh7XG4gICAgICAgICAgZ3JhbnRfdHlwZTogJ3JlZnJlc2hfdG9rZW4nLFxuICAgICAgICAgIHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbixcbiAgICAgICAgICBjbGllbnRfaWQ6IHNlbGYuX2NsaWVudElkLFxuICAgICAgICAgIGNsaWVudF9zZWNyZXQ6IHNlbGYuX2NsaWVudFNlY3JldFxuICAgICAgICB9KVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgICBzZWxmLl90b2tlbiA9IGJvZHkuYWNjZXNzX3Rva2VuO1xuICAgICAgc2VsZi5fcmVmcmVzaFRva2VuID0gYm9keS5yZWZyZXNoX3Rva2VuO1xuICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfSlcbiAgICAuY2FsbCh0aGlzKVxuICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBsaXN0QWNjZXNzVG9rZW5zXG4gICAqIEdldCBpbmZvcm1hdGlvbiBvbiBhbGwgb2YgdGhlIEJpdEdvIGFjY2VzcyB0b2tlbnMgb24gdGhlIHVzZXJcbiAgICogQHJldHVybiB7XG4gICAqICBpZDogPGlkIG9mIHRoZSB0b2tlbj5cbiAgICogIGxhYmVsOiA8dGhlIHVzZXItcHJvdmlkZWQgbGFiZWwgZm9yIHRoaXMgdG9rZW4+XG4gICAqICB1c2VyOiA8aWQgb2YgdGhlIHVzZXIgb24gdGhlIHRva2VuPlxuICAgKiAgZW50ZXJwcmlzZSA8aWQgb2YgdGhlIGVudGVycHJpc2UgdGhpcyB0b2tlbiBpcyB2YWxpZCBmb3I+XG4gICAqICBjbGllbnQ6IDx0aGUgYXV0aCBjbGllbnQgdGhhdCB0aGlzIHRva2VuIGJlbG9uZ3MgdG8+XG4gICAqICBzY29wZTogPGxpc3Qgb2YgYWxsb3dlZCBPQXV0aCBzY29wZSB2YWx1ZXM+XG4gICAqICBjcmVhdGVkOiA8ZGF0ZSB0aGUgdG9rZW4gd2FzIGNyZWF0ZWQ+XG4gICAqICBleHBpcmVzOiA8ZGF0ZSB0aGUgdG9rZW4gd2lsbCBleHBpcmU+XG4gICAqICBvcmlnaW46IDx0aGUgb3JpZ2luIGZvciB3aGljaCB0aGlzIHRva2VuIGlzIHZhbGlkPlxuICAgKiAgaXNFeHRlbnNpYmxlOiA8ZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSB0b2tlbiBjYW4gYmUgZXh0ZW5kZWQ+XG4gICAqICBleHRlbnNpb25BZGRyZXNzOiA8YWRkcmVzcyB3aG9zZSBwcml2YXRlIGtleSdzIHNpZ25hdHVyZSBpcyBuZWNlc3NhcnkgZm9yIGV4dGVuc2lvbnM+XG4gICAqICB1bmxvY2s6IDxpbmZvIGZvciBhY3Rpb25zIHRoYXQgcmVxdWlyZSBhbiB1bmxvY2sgYmVmb3JlIGZpcmluZz5cbiAgICogfVxuICAgKi9cbiAgbGlzdEFjY2Vzc1Rva2VucyhwYXJhbXM/OiB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3VzZXIvYWNjZXNzdG9rZW4nKSlcbiAgICAgIC5zZW5kKClcbiAgICAgIC5yZXN1bHQoJ2FjY2Vzc1Rva2VucycpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogYWRkQWNjZXNzVG9rZW5cbiAgICogQWRkIGEgQml0R28gQVBJIEFjY2VzcyBUb2tlbiB0byB0aGUgY3VycmVudCB1c2VyIGFjY291bnRcbiAgICogQHBhcmFtIHBhcmFtcyB7XG4gICAqICAgIG90cDogKHJlcXVpcmVkKSA8dmFsaWQgb3RwIGNvZGU+XG4gICAqICAgIGxhYmVsOiAocmVxdWlyZWQpIDxsYWJlbCBmb3IgdGhlIHRva2VuPlxuICAgKiAgICBkdXJhdGlvbjogPGxlbmd0aCBvZiB0aW1lIGluIHNlY29uZHMgdGhlIHRva2VuIHdpbGwgYmUgdmFsaWQgZm9yPlxuICAgKiAgICBpcFJlc3RyaWN0OiA8YXJyYXkgb2YgSVAgYWRkcmVzcyBzdHJpbmdzIHRvIHdoaXRlbGlzdD5cbiAgICogICAgdHhWYWx1ZUxpbWl0OiA8bnVtYmVyIG9mIG91dGdvaW5nIHNhdG9zaGlzIGFsbG93ZWQgb24gdGhpcyB0b2tlbj5cbiAgICogICAgc2NvcGU6IChyZXF1aXJlZCkgPGF1dGhvcml6YXRpb24gc2NvcGUgb2YgdGhlIHJlcXVlc3RlZCB0b2tlbj5cbiAgICogfVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7XG4gICAqICAgIGlkOiA8aWQgb2YgdGhlIHRva2VuPlxuICAgKiAgICB0b2tlbjogPGFjY2VzcyB0b2tlbiBoZXggc3RyaW5nIHRvIGJlIHVzZWQgZm9yIEJpdEdvIEFQSSByZXF1ZXN0IHZlcmlmaWNhdGlvbj5cbiAgICogICAgbGFiZWw6IDx1c2VyLXByb3ZpZGVkIGxhYmVsIGZvciB0aGlzIHRva2VuPlxuICAgKiAgICB1c2VyOiA8aWQgb2YgdGhlIHVzZXIgb24gdGhlIHRva2VuPlxuICAgKiAgICBlbnRlcnByaXNlIDxpZCBvZiB0aGUgZW50ZXJwcmlzZSB0aGlzIHRva2VuIGlzIHZhbGlkIGZvcj5cbiAgICogICAgY2xpZW50OiA8dGhlIGF1dGggY2xpZW50IHRoYXQgdGhpcyB0b2tlbiBiZWxvbmdzIHRvPlxuICAgKiAgICBzY29wZTogPGxpc3Qgb2YgYWxsb3dlZCBPQXV0aCBzY29wZSB2YWx1ZXM+XG4gICAqICAgIGNyZWF0ZWQ6IDxkYXRlIHRoZSB0b2tlbiB3YXMgY3JlYXRlZD5cbiAgICogICAgZXhwaXJlczogPGRhdGUgdGhlIHRva2VuIHdpbGwgZXhwaXJlPlxuICAgKiAgICBvcmlnaW46IDx0aGUgb3JpZ2luIGZvciB3aGljaCB0aGlzIHRva2VuIGlzIHZhbGlkPlxuICAgKiAgICBpc0V4dGVuc2libGU6IDxmbGFnIGluZGljYXRpbmcgaWYgdGhlIHRva2VuIGNhbiBiZSBleHRlbmRlZD5cbiAgICogICAgZXh0ZW5zaW9uQWRkcmVzczogPGFkZHJlc3Mgd2hvc2UgcHJpdmF0ZSBrZXkncyBzaWduYXR1cmUgaXMgbmVjZXNzYXJ5IGZvciBleHRlbnNpb25zPlxuICAgKiAgICB1bmxvY2s6IDxpbmZvIGZvciBhY3Rpb25zIHRoYXQgcmVxdWlyZSBhbiB1bmxvY2sgYmVmb3JlIGZpcmluZz5cbiAgICogfVxuICAgKi9cbiAgYWRkQWNjZXNzVG9rZW4ocGFyYW1zOiBBZGRBY2Nlc3NUb2tlbk9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY288c3VwZXJhZ2VudC5SZXNwb25zZT4oZnVuY3Rpb24gKigpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMubGFiZWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIGxhYmVsJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIG5vbi1zdHJpbmcgcGFyYW1zXG4gICAgICBpZiAocGFyYW1zLmR1cmF0aW9uKSB7XG4gICAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMuZHVyYXRpb24pIHx8IHBhcmFtcy5kdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2R1cmF0aW9uIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuaXBSZXN0cmljdCkge1xuICAgICAgICBpZiAoIV8uaXNBcnJheShwYXJhbXMuaXBSZXN0cmljdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwUmVzdHJpY3QgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIF8uZm9yRWFjaChwYXJhbXMuaXBSZXN0cmljdCwgZnVuY3Rpb24oaXBBZGRyKSB7XG4gICAgICAgICAgaWYgKCFfLmlzU3RyaW5nKGlwQWRkcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBSZXN0cmljdCBtdXN0IGJlIGFuIGFycmF5IG9mIElQIGFkZHJlc3Mgc3RyaW5ncycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnR4VmFsdWVMaW1pdCkge1xuICAgICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLnR4VmFsdWVMaW1pdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4VmFsdWVMaW1pdCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy50eFZhbHVlTGltaXQgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eFZhbHVlTGltaXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5zY29wZSAmJiBwYXJhbXMuc2NvcGUubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoIV8uaXNBcnJheShwYXJhbXMuc2NvcGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY29wZSBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzcGVjaWZ5IHNjb3BlIGZvciB0b2tlbicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdXRoVXJsID0gc2VsZi5taWNyb3NlcnZpY2VzVXJsKCcvYXBpL2F1dGgvdjEvYWNjZXNzdG9rZW4nKTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzZWxmLnBvc3QoYXV0aFVybCk7XG5cbiAgICAgIGlmICghc2VsZi5fZWNkaFhwcnYpIHtcbiAgICAgICAgLy8gd2l0aG91dCBhIHByaXZhdGUga2V5LCB0aGUgdXNlciBjYW5ub3QgZGVjcnlwdCB0aGUgbmV3IGFjY2VzcyB0b2tlbiB0aGUgc2VydmVyIHdpbGwgc2VuZFxuICAgICAgICByZXF1ZXN0LmZvcmNlVjFBdXRoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCByZXF1ZXN0LnNlbmQocGFyYW1zKTtcbiAgICAgIGlmIChyZXF1ZXN0LmZvcmNlVjFBdXRoKSB7XG4gICAgICAgIHJlc3BvbnNlLmJvZHkud2FybmluZyA9ICdBIHByb3RvY29sIGRvd25ncmFkZSBoYXMgb2NjdXJyZWQgYmVjYXVzZSB0aGlzIGlzIGEgbGVnYWN5IGFjY291bnQuJztcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfVxuXG4gICAgICAvLyB2ZXJpZnkgdGhlIGF1dGhlbnRpY2l0eSBvZiB0aGUgc2VydmVyJ3MgcmVzcG9uc2UgYmVmb3JlIHByb2NlZWRpbmcgYW55IGZ1cnRoZXJcbiAgICAgIHJlcXVlc3QudmVyaWZ5UmVzcG9uc2UocmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCByZXNwb25zZURldGFpbHMgPSBzZWxmLmhhbmRsZVRva2VuSXNzdWFuY2UocmVzcG9uc2UuYm9keSk7XG4gICAgICByZXNwb25zZS5ib2R5LnRva2VuID0gcmVzcG9uc2VEZXRhaWxzLnRva2VuO1xuXG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSkuY2FsbCh0aGlzKVxuICAgICAgLnRoZW4oaGFuZGxlUmVzcG9uc2VSZXN1bHQoKSwgaGFuZGxlUmVzcG9uc2VFcnJvcilcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBleHBpcmUgdGltZSBvZiBhbiBhY2Nlc3MgdG9rZW4gbWF0Y2hpbmcgZWl0aGVyIHRoZSBpZCBvciBsYWJlbCB0byB0aGUgY3VycmVudCBkYXRlLCBlZmZlY3RpdmVseSBkZWxldGluZyBpdFxuICAgKlxuICAgKiBQYXJhbXM6XG4gICAqIGlkOiA8aWQgb2YgdGhlIGFjY2VzcyB0b2tlbiB0byBiZSBkZWxldGVkPlxuICAgKiBsYWJlbDogPGxhYmVsIG9mIHRoZSBhY2Nlc3MgdG9rZW4gdG8gYmUgZGVsZXRlZD5cbiAgICpcbiAgICogUmV0dXJuczpcbiAgICogaWQ6IDxpZCBvZiB0aGUgdG9rZW4+XG4gICAqIGxhYmVsOiA8dXNlci1wcm92aWRlZCBsYWJlbCBmb3IgdGhpcyB0b2tlbj5cbiAgICogdXNlcjogPGlkIG9mIHRoZSB1c2VyIG9uIHRoZSB0b2tlbj5cbiAgICogZW50ZXJwcmlzZSA8aWQgb2YgdGhlIGVudGVycHJpc2UgdGhpcyB0b2tlbiBpcyB2YWxpZCBmb3I+XG4gICAqIGNsaWVudDogPHRoZSBhdXRoIGNsaWVudCB0aGF0IHRoaXMgdG9rZW4gYmVsb25ncyB0bz5cbiAgICogc2NvcGU6IDxsaXN0IG9mIGFsbG93ZWQgT0F1dGggc2NvcGUgdmFsdWVzPlxuICAgKiBjcmVhdGVkOiA8ZGF0ZSB0aGUgdG9rZW4gd2FzIGNyZWF0ZWQ+XG4gICAqIGV4cGlyZXM6IDxkYXRlIHRoZSB0b2tlbiB3aWxsIGV4cGlyZT5cbiAgICogb3JpZ2luOiA8dGhlIG9yaWdpbiBmb3Igd2hpY2ggdGhpcyB0b2tlbiBpcyB2YWxpZD5cbiAgICogaXNFeHRlbnNpYmxlOiA8ZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSB0b2tlbiBjYW4gYmUgZXh0ZW5kZWQ+XG4gICAqIGV4dGVuc2lvbkFkZHJlc3M6IDxhZGRyZXNzIHdob3NlIHByaXZhdGUga2V5J3Mgc2lnbmF0dXJlIGlzIG5lKmNlc3NhcnkgZm9yIGV4dGVuc2lvbnM+XG4gICAqIHVubG9jazogPGluZm8gZm9yIGFjdGlvbnMgdGhhdCByZXF1aXJlIGFuIHVubG9jayBiZWZvcmUgZmlyaW5nPlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgcmVtb3ZlQWNjZXNzVG9rZW4oeyBpZCwgbGFiZWwgfTogUmVtb3ZlQWNjZXNzVG9rZW5PcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uKigpIHtcbiAgICAgIGlmICgoIWlkICYmICFsYWJlbCkgfHwgKGlkICYmIGxhYmVsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgcHJvdmlkZSBleGFjdGx5IG9uZSBvZiBpZCBvciBsYWJlbCcpO1xuICAgICAgfVxuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmRlbChzZWxmLnVybChgL3VzZXIvYWNjZXNzdG9rZW4vJHtpZH1gKSlcbiAgICAgICAgICAuc2VuZCgpXG4gICAgICAgICAgLnJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b2tlbnMgPSB5aWVsZCBzZWxmLmxpc3RBY2Nlc3NUb2tlbnMoKTtcblxuICAgICAgaWYgKCF0b2tlbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b2tlbiB3aXRoIHRoaXMgbGFiZWwgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWF0Y2hpbmdUb2tlbnM6IGFueSA9IF8uZmlsdGVyKHRva2VucywgeyBsYWJlbCB9KTtcbiAgICAgIGlmIChtYXRjaGluZ1Rva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYW1iaWd1b3VzIGNhbGw6IG11bHRpcGxlIHRva2VucyBtYXRjaGluZyB0aGlzIGxhYmVsJyk7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2hpbmdUb2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndG9rZW4gd2l0aCB0aGlzIGxhYmVsIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmRlbChzZWxmLnVybChgL3VzZXIvYWNjZXNzdG9rZW4vJHttYXRjaGluZ1Rva2Vuc1swXS5pZH1gKSlcbiAgICAgICAgLnNlbmQoKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogTG9nb3V0IG9mIEJpdEdvXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBsb2dvdXQocGFyYW1zPzoge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHNlbGYuZ2V0KHNlbGYudXJsKCcvdXNlci9sb2dvdXQnKSkucmVzdWx0KCk7XG4gICAgICBzZWxmLmNsZWFyKCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHVzZXIgYnkgSUQgKG5hbWUvZW1haWwgb25seSlcbiAgICogQHBhcmFtIGlkXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZ2V0VXNlcih7IGlkIH06IEdldFVzZXJPcHRpb25zLCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uKigpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhpZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgaWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybChgL3VzZXIvJHtpZH1gKSkucmVzdWx0KCd1c2VyJyk7XG4gICAgfSlcbiAgICAgIC5jYWxsKHRoaXMpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBwYXNzd29yZCBvZiB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLlxuICAgKiBBbHNvIGNoYW5nZSBhbGwgdjEgYW5kIHYyIGtleWNoYWluIHBhc3N3b3JkcyBpZiB0aGV5IG1hdGNoIHRoZVxuICAgKiBnaXZlbiBvbGRQYXNzd29yZC4gUmV0dXJucyBub3RoaW5nIG9uIHN1Y2Nlc3MuXG4gICAqIEBwYXJhbSBvbGRQYXNzd29yZCB7U3RyaW5nfSAtIHRoZSBjdXJyZW50IHBhc3N3b3JkXG4gICAqIEBwYXJhbSBuZXdQYXNzd29yZCB7U3RyaW5nfSAtIHRoZSBuZXcgcGFzc3dvcmRcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBjaGFuZ2VQYXNzd29yZCh7IG9sZFBhc3N3b3JkLCBuZXdQYXNzd29yZCB9OiBDaGFuZ2VQYXNzd29yZE9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gY28oZnVuY3Rpb24gKmNvQ2hhbmdlUGFzc3dvcmQoKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcob2xkUGFzc3dvcmQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgc3RyaW5nIG9sZFBhc3N3b3JkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghXy5pc1N0cmluZyhuZXdQYXNzd29yZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgbmV3UGFzc3dvcmQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXNlciA9IHNlbGYudXNlcigpO1xuICAgICAgaWYgKHR5cGVvZiB1c2VyICE9PSAnb2JqZWN0JyB8fCAhdXNlci51c2VybmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgb2JqZWN0IHVzZXInKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHlpZWxkIHNlbGYudmVyaWZ5UGFzc3dvcmQoeyBwYXNzd29yZDogb2xkUGFzc3dvcmQgfSk7XG4gICAgICBpZiAoIXZhbGlkYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgcHJvdmlkZWQgb2xkUGFzc3dvcmQgaXMgaW5jb3JyZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGl0IGRvZXNuJ3QgbWF0dGVyIHdoaWNoIGNvaW4gd2UgY2hvb3NlIGJlY2F1c2UgdGhlIHYyIHVwZGF0ZVBhc3N3b3JkIGZ1bmN0aW9ucyB1cGRhdGVzIGFsbCB2MiBrZXljaGFpbnNcbiAgICAgIC8vIHdlIGp1c3QgbmVlZCB0byBjaG9vc2UgYSBjb2luIHRoYXQgZXhpc3RzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50XG4gICAgICBjb25zdCBjb2luID0gY29tbW9uLkVudmlyb25tZW50c1tzZWxmLmdldEVudigpXS5uZXR3b3JrID09PSAnYml0Y29pbicgPyAnYnRjJyA6ICd0YnRjJztcblxuICAgICAgY29uc3QgdXBkYXRlS2V5Y2hhaW5QYXNzd29yZFBhcmFtcyA9IHsgb2xkUGFzc3dvcmQsIG5ld1Bhc3N3b3JkIH07XG4gICAgICBjb25zdCB2MUtleWNoYWluVXBkYXRlUFdSZXN1bHQgPSB5aWVsZCBzZWxmLmtleWNoYWlucygpLnVwZGF0ZVBhc3N3b3JkKHVwZGF0ZUtleWNoYWluUGFzc3dvcmRQYXJhbXMpO1xuICAgICAgY29uc3QgdjJLZXljaGFpbnMgPSB5aWVsZCBzZWxmLmNvaW4oY29pbikua2V5Y2hhaW5zKCkudXBkYXRlUGFzc3dvcmQodXBkYXRlS2V5Y2hhaW5QYXNzd29yZFBhcmFtcyk7XG5cbiAgICAgIGNvbnN0IHVwZGF0ZVBhc3N3b3JkUGFyYW1zID0ge1xuICAgICAgICBrZXljaGFpbnM6IHYxS2V5Y2hhaW5VcGRhdGVQV1Jlc3VsdC5rZXljaGFpbnMsXG4gICAgICAgIHYyX2tleWNoYWluczogdjJLZXljaGFpbnMsXG4gICAgICAgIHZlcnNpb246IHYxS2V5Y2hhaW5VcGRhdGVQV1Jlc3VsdC52ZXJzaW9uLFxuICAgICAgICBvbGRQYXNzd29yZDogc2VsZi5jYWxjdWxhdGVITUFDKHVzZXIudXNlcm5hbWUsIG9sZFBhc3N3b3JkKSxcbiAgICAgICAgcGFzc3dvcmQ6IHNlbGYuY2FsY3VsYXRlSE1BQyh1c2VyLnVzZXJuYW1lLCBuZXdQYXNzd29yZClcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBzZWxmLnBvc3Qoc2VsZi51cmwoJy91c2VyL2NoYW5nZXBhc3N3b3JkJykpXG4gICAgICAgIC5zZW5kKHVwZGF0ZVBhc3N3b3JkUGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgbG9nZ2VkIGluIHVzZXJcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIG1lKHBhcmFtcz86IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VXNlcih7IGlkOiAnbWUnIH0sIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbmxvY2sgdGhlIHNlc3Npb24gYnkgcHJvdmlkaW5nIE9UUFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3RwIFJlcXVpcmVkIE9UUCBjb2RlIGZvciB0aGUgYWNjb3VudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIERlc2lyZWQgZHVyYXRpb24gb2YgdGhlIHVubG9jayBpbiBzZWNvbmRzIChkZWZhdWx0PTYwMCwgbWF4PTM2MDApLlxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHVubG9jayh7IG90cCwgZHVyYXRpb24gfTogVW5sb2NrT3B0aW9ucywgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKG90cCAmJiAhXy5pc1N0cmluZyhvdHApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgc3RyaW5nIG9yIHVuZGVmaW5lZCBvdHAnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLnBvc3Qoc2VsZi51cmwoJy91c2VyL3VubG9jaycpKVxuICAgICAgICAuc2VuZCh7IG90cCwgZHVyYXRpb24gfSlcbiAgICAgICAgLnJlc3VsdCgpO1xuICAgIH0pXG4gICAgICAuY2FsbCh0aGlzKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIExvY2sgdGhlIHNlc3Npb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGxvY2socGFyYW1zPzoge30sIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci9sb2NrJykpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc2Vzc2lvblxuICAgKi9cbiAgc2Vzc2lvbihwYXJhbXM/OiB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3VzZXIvc2Vzc2lvbicpKVxuICAgICAgLnJlc3VsdCgnc2Vzc2lvbicpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciBhIHB1c2gvc21zIGZvciB0aGUgT1RQIGNvZGVcbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuZm9yY2VTTVMgSWYgc2V0IHRvIHRydWUsIHdpbGwgdXNlIFNNUyB0byBzZW5kIHRoZSBPVFAgdG8gdGhlIHVzZXIgZXZlbiBpZiB0aGV5IGhhdmUgb3RoZXIgMkZBIG1ldGhvZCBzZXQgdXAuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzZW5kT1RQKHBhcmFtczogeyBmb3JjZVNNUz86IGJvb2xlYW4gfSA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybCgnL3VzZXIvc2VuZG90cCcpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogRXh0ZW5kIHRva2VuLCBwcm92aWRlZCB0aGUgY3VycmVudCB0b2tlbiBpcyBleHRlbmRhYmxlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSBkdXJhdGlvbjogZHVyYXRpb24gaW4gc2Vjb25kcyBieSB3aGljaCB0byBleHRlbmQgdGhlIHRva2VuLCBzdGFydGluZyBhdCB0aGUgY3VycmVudCB0aW1lXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgZXh0ZW5kVG9rZW4ocGFyYW1zOiBFeHRlbmRUb2tlbk9wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGlmICghdGhpcy5fZXh0ZW5zaW9uS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgX2V4dGVuc2lvbktleScpO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgY29uc3QgZHVyYXRpb24gPSBwYXJhbXMuZHVyYXRpb247XG4gICAgY29uc3QgbWVzc2FnZSA9IHRpbWVzdGFtcCArICd8JyArIHRoaXMuX3Rva2VuICsgJ3wnICsgZHVyYXRpb247XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IHRoaXMuX2V4dGVuc2lvbktleS5kLnRvQnVmZmVyKDMyKTtcbiAgICBjb25zdCBpc0NvbXByZXNzZWQgPSB0aGlzLl9leHRlbnNpb25LZXkuY29tcHJlc3NlZDtcbiAgICBjb25zdCBwcmVmaXggPSBiaXRjb2luLm5ldHdvcmtzLmJpdGNvaW4ubWVzc2FnZVByZWZpeDtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBiaXRjb2luTWVzc2FnZS5zaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCwgcHJlZml4KS50b1N0cmluZygnaGV4Jyk7XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci9leHRlbmR0b2tlbicpKVxuICAgICAgLnNlbmQocGFyYW1zKVxuICAgICAgLnNldCgndGltZXN0YW1wJywgdGltZXN0YW1wLnRvU3RyaW5nKCkpXG4gICAgICAuc2V0KCdzaWduYXR1cmUnLCBzaWduYXR1cmUpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBrZXkgZm9yIHNoYXJpbmcgYSB3YWxsZXQgd2l0aCBhIHVzZXJcbiAgICogQHBhcmFtIGVtYWlsIGVtYWlsIG9mIHVzZXIgdG8gc2hhcmUgd2FsbGV0IHdpdGhcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBnZXRTaGFyaW5nS2V5KHsgZW1haWwgfTogR2V0U2hhcmluZ0tleU9wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcoZW1haWwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyBlbWFpbCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy91c2VyL3NoYXJpbmdrZXknKSlcbiAgICAgIC5zZW5kKHsgZW1haWwgfSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgY29ubmVjdGl2aXR5IHRvIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIHBpbmcoeyByZXFJZCB9OiBQaW5nT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgaWYgKHJlcUlkKSB7XG4gICAgICB0aGlzLl9yZXFJZCA9IHJlcUlkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3BpbmcnKSlcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYmxvY2tjaGFpbiBvYmplY3QuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBibG9ja2NoYWluKCk6IGFueSB7XG4gICAgaWYgKCF0aGlzLl9ibG9ja2NoYWluKSB7XG4gICAgICB0aGlzLl9ibG9ja2NoYWluID0gbmV3IEJsb2NrY2hhaW4odGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ibG9ja2NoYWluO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlcidzIGtleWNoYWlucyBvYmplY3QuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBrZXljaGFpbnMoKTogYW55IHtcbiAgICBpZiAoIXRoaXMuX2tleWNoYWlucykge1xuICAgICAgdGhpcy5fa2V5Y2hhaW5zID0gbmV3IEtleWNoYWlucyh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2tleWNoYWlucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIncyB3YWxsZXRzIG9iamVjdC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHdhbGxldHMoKSB7XG4gICAgaWYgKCF0aGlzLl93YWxsZXRzKSB7XG4gICAgICB0aGlzLl93YWxsZXRzID0gbmV3IFdhbGxldHModGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93YWxsZXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHJhdmVsIHJ1bGUgb2JqZWN0XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICB0cmF2ZWxSdWxlKCk6IGFueSB7XG4gICAgaWYgKCF0aGlzLl90cmF2ZWxSdWxlKSB7XG4gICAgICB0aGlzLl90cmF2ZWxSdWxlID0gbmV3IFRyYXZlbFJ1bGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90cmF2ZWxSdWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwZW5kaW5nIGFwcHJvdmFscyB0aGF0IGNhbiBiZSBhcHByb3ZlZC8gb3IgcmVqZWN0ZWRcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHBlbmRpbmdBcHByb3ZhbHMoKTogYW55IHtcbiAgICBpZiAoIXRoaXMuX3BlbmRpbmdBcHByb3ZhbHMpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdBcHByb3ZhbHMgPSBuZXcgUGVuZGluZ0FwcHJvdmFscyh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbHM7XG4gIH1cblxuICAvKipcbiAgICogQSBmYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgV2FsbGV0IG9iamVjdCwgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgd2FsbGV0IHBhcmFtc1xuICAgKiBDYW4gYmUgdXNlZCB0byByZWNvbnN0aXR1dGUgYSB3YWxsZXQgZnJvbSBjYWNoZWQgZGF0YVxuICAgKiBAcGFyYW0gd2FsbGV0UGFyYW1zXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBuZXdXYWxsZXRPYmplY3Qod2FsbGV0UGFyYW1zKTogYW55IHtcbiAgICByZXR1cm4gbmV3IFdhbGxldCh0aGlzLCB3YWxsZXRQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHVybCBmb3IgY2FsbGluZyBCaXRHbyBwbGF0Zm9ybSBBUElzXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwYXJhbSB2ZXJzaW9uXG4gICAqL1xuICB1cmwocGF0aDogc3RyaW5nLCB2ZXJzaW9uID0gMSk6IHN0cmluZyB7XG4gICAgY29uc3QgYmFzZVVybCA9IHZlcnNpb24gPT09IDIgPyB0aGlzLl9iYXNlQXBpVXJsVjIgOiB0aGlzLl9iYXNlQXBpVXJsO1xuICAgIHJldHVybiBiYXNlVXJsICsgcGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB1cmwgZm9yIGNhbGxpbmcgQml0R28gbWljcm9zZXJ2aWNlIEFQSXNcbiAgICovXG4gIG1pY3Jvc2VydmljZXNVcmwocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzZVVybCArIHBhdGg7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgYWRkcmVzcyBsYWJlbHMgb24gYWxsIG9mIHRoZSB1c2VyJ3Mgd2FsbGV0c1xuICAgKi9cbiAgbGFiZWxzKHBhcmFtcz86IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKCcvbGFiZWxzJykpXG4gICAgICAucmVzdWx0KCdsYWJlbHMnKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzdGltYXRlcyBhcHByb3hpbWF0ZSBmZWUgcGVyIGtiIG5lZWRlZCBmb3IgYSB0eCB0byBnZXQgaW50byBhIGJsb2NrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubnVtQmxvY2tzIHRhcmdldCBibG9ja3MgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBjb25maXJtZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tYXhGZWUgbWF4aW11bSBmZWUgd2lsbGluZyB0byBiZSBwYWlkIChmb3Igc2FmZXR5KVxuICAgKiBAcGFyYW0ge2FycmF5W3N0cmluZ119IHBhcmFtcy5pbnB1dHMgbGlzdCBvZiB1bmNvbmZpcm1lZCB0eElkcyBmcm9tIHdoaWNoIHRoaXMgdHJhbnNhY3Rpb24gdXNlcyBpbnB1dHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy50eFNpemUgZXN0aW1hdGVkIHRyYW5zYWN0aW9uIHNpemUgaW4gYnl0ZXMsIG9wdGlvbmFsIHBhcmFtZXRlciB1c2VkIGZvciBDUEZQIGVzdGltYXRpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmNwZnBBd2FyZSBmbGFnIGluZGljYXRpbmcgZmVlIHNob3VsZCB0YWtlIGludG8gYWNjb3VudCBDUEZQXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBlc3RpbWF0ZUZlZShwYXJhbXM6IEVzdGltYXRlRmVlT3B0aW9ucyA9IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgY29uc3QgcXVlcnlQYXJhbXM6IGFueSA9IHsgdmVyc2lvbjogMTIgfTtcbiAgICBpZiAocGFyYW1zLm51bUJsb2Nrcykge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5udW1CbG9ja3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgfVxuICAgICAgcXVlcnlQYXJhbXMubnVtQmxvY2tzID0gcGFyYW1zLm51bUJsb2NrcztcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5tYXhGZWUpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubWF4RmVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5UGFyYW1zLm1heEZlZSA9IHBhcmFtcy5tYXhGZWU7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuaW5wdXRzKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLmlucHV0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICB9XG4gICAgICBxdWVyeVBhcmFtcy5pbnB1dHMgPSBwYXJhbXMuaW5wdXRzO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnR4U2l6ZSkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy50eFNpemUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgfVxuICAgICAgcXVlcnlQYXJhbXMudHhTaXplID0gcGFyYW1zLnR4U2l6ZTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jcGZwQXdhcmUpIHtcbiAgICAgIGlmICghXy5pc0Jvb2xlYW4ocGFyYW1zLmNwZnBBd2FyZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICB9XG4gICAgICBxdWVyeVBhcmFtcy5jcGZwQXdhcmUgPSBwYXJhbXMuY3BmcEF3YXJlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3R4L2ZlZScpKVxuICAgICAgLnF1ZXJ5KHF1ZXJ5UGFyYW1zKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IEJpdEdvJ3MgZ3VhcmFudGVlIHVzaW5nIGFuIGluc3RhbnQgaWRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGluc3RhbnRHdWFyYW50ZWUocGFyYW1zOiB7IGlkOiBzdHJpbmcgfSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5pZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgaWQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYm9keSA9IHlpZWxkIHNlbGYuZ2V0KHNlbGYudXJsKCcvaW5zdGFudC8nICsgcGFyYW1zLmlkKSkucmVzdWx0KCk7XG4gICAgICBpZiAoIWJvZHkuZ3VhcmFudGVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gZ3VhcmFudGVlIGZvdW5kIGluIHJlc3BvbnNlIGJvZHknKTtcbiAgICAgIH1cbiAgICAgIGlmICghYm9keS5zaWduYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBzaWduYXR1cmUgZm91bmQgaW4gZ3VhcmFudGVlIHJlc3BvbnNlIGJvZHknKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZ25pbmdBZGRyZXNzID0gY29tbW9uLkVudmlyb25tZW50c1tzZWxmLmdldEVudigpXS5zaWduaW5nQWRkcmVzcztcbiAgICAgIGNvbnN0IHNpZ25hdHVyZUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJvZHkuc2lnbmF0dXJlLCAnaGV4Jyk7XG4gICAgICBjb25zdCBwcmVmaXggPSBiaXRjb2luLm5ldHdvcmtzW2NvbW1vbi5FbnZpcm9ubWVudHNbc2VsZi5nZXRFbnYoKV0ubmV0d29ya10ubWVzc2FnZVByZWZpeDtcbiAgICAgIGNvbnN0IGlzVmFsaWRTaWduYXR1cmUgPSBiaXRjb2luTWVzc2FnZS52ZXJpZnkoYm9keS5ndWFyYW50ZWUsIHNpZ25pbmdBZGRyZXNzLCBzaWduYXR1cmVCdWZmZXIsIHByZWZpeCk7XG4gICAgICBpZiAoIWlzVmFsaWRTaWduYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmNvcnJlY3Qgc2lnbmF0dXJlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9KVxuICAgICAgLmNhbGwodGhpcylcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSB0YXJnZXQgYWRkcmVzcyBmb3IgcGF5bWVudCBvZiBhIEJpdEdvIGZlZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZ2V0Qml0R29GZWVBZGRyZXNzKHBhcmFtcz86IHt9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybCgnL2JpbGxpbmcvYWRkcmVzcycpKVxuICAgICAgLnNlbmQoe30pXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGFkZHJlc3Mgb2JqZWN0IChpbmNsdWRpbmcgdGhlIHdhbGxldCBpZCkgZm9yIGEgZ2l2ZW4gYWRkcmVzcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5hZGRyZXNzIFRoZSBhZGRyZXNzIHRvIGxvb2sgdXAuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBnZXRXYWxsZXRBZGRyZXNzKHsgYWRkcmVzcyB9OiB7IGFkZHJlc3M6IHN0cmluZyB9LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKGAvd2FsbGV0YWRkcmVzcy8ke2FkZHJlc3N9YCkpXG4gICAgICAucmVzdWx0KClcbiAgICAgIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBsaXN0IG9mIHVzZXIgd2ViaG9va3NcbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgbGlzdFdlYmhvb2tzKGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy93ZWJob29rcycpKVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIG5ldyB1c2VyIHdlYmhvb2tcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhZGRXZWJob29rKHBhcmFtczogV2ViaG9va09wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnVybCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIHVybCcpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMudHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIHR5cGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvd2ViaG9va3MnKSlcbiAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB1c2VyIHdlYmhvb2tcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICByZW1vdmVXZWJob29rKHBhcmFtczogV2ViaG9va09wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy51cmwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyB1cmwnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyB0eXBlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGVsKHRoaXMudXJsKCcvd2ViaG9va3MnKSlcbiAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGxpc3Qgb2Ygd2ViaG9vayBub3RpZmljYXRpb25zIGZvciB0aGUgdXNlclxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGxpc3RXZWJob29rTm90aWZpY2F0aW9ucyhwYXJhbXM6IExpc3RXZWJob29rTm90aWZpY2F0aW9uc09wdGlvbnMgPSB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHF1ZXJ5OiBhbnkgPSB7fTtcbiAgICBpZiAocGFyYW1zLnByZXZJZCkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcmV2SWQgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnByZXZJZCA9IHBhcmFtcy5wcmV2SWQ7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubGltaXQpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubGltaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgcXVlcnkubGltaXQgPSBwYXJhbXMubGltaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKCcvd2ViaG9va3Mvbm90aWZpY2F0aW9ucycpKVxuICAgICAgLnF1ZXJ5KHF1ZXJ5KVxuICAgICAgLnJlc3VsdCgpXG4gICAgICAubm9kZWlmeShjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU2ltdWxhdGUgYSB1c2VyIHdlYmhvb2tcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBzaW11bGF0ZVdlYmhvb2socGFyYW1zOiBCaXRHb1NpbXVsYXRlV2ViaG9va09wdGlvbnMsIGNhbGxiYWNrPzogTm9kZUNhbGxiYWNrPGFueT4pOiBCbHVlYmlyZDxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dlYmhvb2tJZCcsICdibG9ja0lkJ10sIFtdLCBjYWxsYmFjayk7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy53ZWJob29rSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyB3ZWJob29rSWQnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmJsb2NrSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyBibG9ja0lkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybChgL3dlYmhvb2tzLyR7cGFyYW1zLndlYmhvb2tJZH0vc2ltdWxhdGVgKSlcbiAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgIC5yZXN1bHQoKVxuICAgICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY2VpdmVzIGEgVFRMIGFuZCByZWZldGNoZXMgYXMgbmVjZXNzYXJ5XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBmZXRjaENvbnN0YW50cyhwYXJhbXM/OiB7fSwgY2FsbGJhY2s/OiBOb2RlQ2FsbGJhY2s8YW55Pik6IEJsdWViaXJkPGFueT4ge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgICAgY29uc3QgZW52ID0gc2VsZi5nZXRFbnYoKTtcblxuICAgICAgaWYgKCFCaXRHby5fY29uc3RhbnRzKSB7XG4gICAgICAgIEJpdEdvLl9jb25zdGFudHMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmICghQml0R28uX2NvbnN0YW50c0V4cGlyZSkge1xuICAgICAgICBCaXRHby5fY29uc3RhbnRzRXhwaXJlID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChCaXRHby5fY29uc3RhbnRzW2Vudl0gJiYgQml0R28uX2NvbnN0YW50c0V4cGlyZVtlbnZdICYmIG5ldyBEYXRlKCkgPCBCaXRHby5fY29uc3RhbnRzRXhwaXJlW2Vudl0pIHtcbiAgICAgICAgcmV0dXJuIEJpdEdvLl9jb25zdGFudHNbZW52XTtcbiAgICAgIH1cblxuICAgICAgLy8gY2xpZW50IGNvbnN0YW50cyBjYWxsIGNhbm5vdCBiZSBhdXRoZW50aWNhdGVkIHVzaW5nIHRoZSBub3JtYWwgSE1BQyB2YWxpZGF0aW9uXG4gICAgICAvLyBzY2hlbWUsIHNvIHdlIG5lZWQgdG8gdXNlIGEgcmF3IHN1cGVyYWdlbnQgaW5zdGFuY2UgdG8gZG8gdGhpcyByZXF1ZXN0LlxuICAgICAgLy8gUHJveHkgc2V0dGluZ3MgbXVzdCBzdGlsbCBiZSByZXNwZWN0ZWQgaG93ZXZlclxuICAgICAgY29uc3QgcmVzdWx0UHJvbWlzZSA9IHN1cGVyYWdlbnQuZ2V0KHNlbGYudXJsKCcvY2xpZW50L2NvbnN0YW50cycpKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIChzZWxmLl9wcm94eSA/IHJlc3VsdFByb21pc2UucHJveHkoc2VsZi5fcHJveHkpIDogcmVzdWx0UHJvbWlzZSk7XG4gICAgICBCaXRHby5fY29uc3RhbnRzW2Vudl0gPSByZXN1bHQuYm9keS5jb25zdGFudHM7XG5cbiAgICAgIEJpdEdvLl9jb25zdGFudHNFeHBpcmVbZW52XSA9IG1vbWVudC51dGMoKS5hZGQocmVzdWx0LmJvZHkudHRsLCAnc2Vjb25kJykudG9EYXRlKCk7XG4gICAgICByZXR1cm4gQml0R28uX2NvbnN0YW50c1tlbnZdO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU3luY2hyb25vdXNseSBnZXQgY29uc3RhbnRzIHdoaWNoIGFyZSByZWxldmFudCB0byB0aGUgY2xpZW50LlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGhhcyBhIGtub3duIHJhY2UgY29uZGl0aW9uLiBJdCBtYXkgcmV0dXJuIGRpZmZlcmVudCB2YWx1ZXMgb3ZlciB0aW1lLFxuICAgKiBlc3BlY2lhbGx5IGlmIGNhbGxlZCBzaG9ydGx5IGFmdGVyIGNyZWF0aW9uIG9mIHRoZSBCaXRHbyBvYmplY3QuXG4gICAqXG4gICAqIE5ldyBjb2RlIHNob3VsZCBjYWxsIGZldGNoQ29uc3RhbnRzKCkgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbGllbnQgY29uc3RhbnRzIG9iamVjdFxuICAgKi9cbiAgZ2V0Q29uc3RhbnRzKHBhcmFtcz86IHt9KSB7XG4gICAgLy8ga2ljayBvZmYgYSBmcmVzaCByZXF1ZXN0IGZvciB0aGUgY2xpZW50IGNvbnN0YW50c1xuICAgIHRoaXMuZmV0Y2hDb25zdGFudHMocGFyYW1zLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIGFuIGVycm9yIGRvZXMgbm90IHRlcm1pbmF0ZSB0aGUgZW50aXJlIHNjcmlwdFxuICAgICAgICBjb25zb2xlLmVycm9yKCdmYWlsZWQgdG8gZmV0Y2ggY2xpZW50IGNvbnN0YW50cyBmcm9tIEJpdEdvJyk7XG4gICAgICAgIGNvbnNvbGUudHJhY2UoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHVzZSBkZWZhdWx0Q29uc3RhbnRzIGFzIHRoZSBiYWNrdXAgZm9yIGtleXMgdGhhdCBhcmUgbm90IHNldCBpbiB0aGlzLl9jb25zdGFudHNcbiAgICByZXR1cm4gXy5tZXJnZSh7fSwgY29uZmlnLmRlZmF1bHRDb25zdGFudHModGhpcy5nZXRFbnYoKSksIEJpdEdvLl9jb25zdGFudHNbdGhpcy5nZXRFbnYoKV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFYxIG1ldGhvZCBmb3IgY2FsY3VsYXRpbmcgbWluZXIgZmVlIGFtb3VudHMsIGdpdmVuIHRoZSBudW1iZXIgYW5kXG4gICAqIHR5cGUgb2YgdHJhbnNhY3Rpb24gaW5wdXRzLCBhbG9uZyB3aXRoIGEgZmVlIHJhdGUgaW4gc2F0b3NoaXMgcGVyIHZrQi5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkIGZvciBuZXcgY29kZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgY2FsY3VsYXRlTWluZXJGZWVJbmZvKHBhcmFtczogYW55LCBjYWxsYmFjaz86IE5vZGVDYWxsYmFjazxhbnk+KTogQmx1ZWJpcmQ8YW55PiB7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgICByZXR1cm4gVHJhbnNhY3Rpb25CdWlsZGVyLmNhbGN1bGF0ZU1pbmVyRmVlSW5mbyhwYXJhbXMpO1xuICAgIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgcmVxdWVzdCB0cmFjZXIgdG8gcHJvdmlkZSByZXF1ZXN0IElEcyBkdXJpbmcgbXVsdGktcmVxdWVzdCB3b3JrZmxvd3NcbiAgICovXG4gIHNldFJlcXVlc3RUcmFjZXIocmVxVHJhY2VyOiBJUmVxdWVzdFRyYWNlcikge1xuICAgIGlmIChyZXFUcmFjZXIpIHtcbiAgICAgIHRoaXMuX3JlcUlkID0gcmVxVHJhY2VyO1xuICAgIH1cbiAgfVxufVxuIl19