"use strict";
/**
 * @hidden
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 */
//
// TransactionBuilder
// A utility for building and signing transactions
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
var Bluebird = require("bluebird");
var bitcoin = require("@bitgo/utxo-lib");
var _ = require("lodash");
var unspents_1 = require("@bitgo/unspents");
var bitcoin_1 = require("./bitcoin");
var debugLib = require("debug");
var debug = debugLib('bitgo:v1:txb');
var common = require("./common");
//
// TransactionBuilder
// @params:
//   wallet:  a wallet object to send from
//   recipients: array of recipient objects and the amount to send to each e.g. [{address: '38BKDNZbPcLogvVbcx2ekJ9E6Vv94DqDqw', amount: 1500}, {address: '36eL8yQqCn1HMRmVFFo49t2PJ3pai8wQam', amount: 2000}]
//   fee: the fee to use with this transaction.  if not provided, a default, minimum fee will be used.
//   feeRate: the amount of fee per kilobyte - optional - specify either fee, feeRate, or feeTxConfirmTarget but not more than one
//   feeTxConfirmTarget: calculate the fees per kilobyte such that the transaction will be confirmed in this number of blocks
//   maxFeeRate: The maximum fee per kb to use in satoshis, for safety purposes when using dynamic fees
//   minConfirms: the minimum confirmations an output must have before spending
//   forceChangeAtEnd: force the change address to be the last output
//   changeAddress: specify the change address rather than generate a new one
//   noSplitChange: set to true to disable automatic change splitting for purposes of unspent management
//   targetWalletUnspents: specify a number of target unspents to maintain in the wallet (currently defaulted to 8 by the server)
//   validate: extra verification of the change addresses, which is always done server-side and is redundant client-side (defaults true)
//   minUnspentSize: The minimum size in satoshis of unspent to use (to prevent spending unspents worth less than fee added). Defaults to 0.
//   feeSingleKeySourceAddress: Use this single key address to pay fees
//   feeSingleKeyWIF: Use the address based on this private key to pay fees
//   unspentsFetchParams: Extra parameters to use for fetching unspents for this transaction
exports.createTransaction = function (params) {
    var minConfirms = params.minConfirms || 0;
    var validate = params.validate === undefined ? true : params.validate;
    var recipients = [];
    var opReturns = [];
    var extraChangeAmounts = [];
    var estTxSize;
    var travelInfos;
    // Sanity check the arguments passed in
    if (!_.isObject(params.wallet) ||
        (params.fee && !_.isNumber(params.fee)) ||
        (params.feeRate && !_.isNumber(params.feeRate)) ||
        !_.isInteger(minConfirms) ||
        (params.forceChangeAtEnd && !_.isBoolean(params.forceChangeAtEnd)) ||
        (params.changeAddress && !_.isString(params.changeAddress)) ||
        (params.noSplitChange && !_.isBoolean(params.noSplitChange)) ||
        (params.targetWalletUnspents && !_.isInteger(params.targetWalletUnspents)) ||
        (validate && !_.isBoolean(validate)) ||
        (params.enforceMinConfirmsForChange && !_.isBoolean(params.enforceMinConfirmsForChange)) ||
        (params.minUnspentSize && !_.isNumber(params.minUnspentSize)) ||
        (params.maxFeeRate && !_.isNumber(params.maxFeeRate)) ||
        // this should be an array and its length must be at least 1
        (params.unspents && (!Array.isArray(params.unspents) || params.unspents.length < 1)) ||
        (params.feeTxConfirmTarget && !_.isInteger(params.feeTxConfirmTarget)) ||
        (params.instant && !_.isBoolean(params.instant)) ||
        (params.bitgoFee && !_.isObject(params.bitgoFee)) ||
        (params.unspentsFetchParams && !_.isObject(params.unspentsFetchParams))) {
        throw new Error('invalid argument');
    }
    var bitgo = params.wallet.bitgo;
    var constants = bitgo.getConstants();
    var network = bitcoin_1.getNetwork(common.Environments[bitgo.getEnv()].network);
    // The user can specify a seperate, single-key wallet for the purposes of paying miner's fees
    // When creating a transaction this can be specified as an input address or the private key in WIF
    var feeSingleKeySourceAddress;
    var feeSingleKeyInputAmount = 0;
    if (params.feeSingleKeySourceAddress) {
        try {
            bitcoin.address.fromBase58Check(params.feeSingleKeySourceAddress);
            feeSingleKeySourceAddress = params.feeSingleKeySourceAddress;
        }
        catch (e) {
            throw new Error('invalid bitcoin address: ' + params.feeSingleKeySourceAddress);
        }
    }
    if (params.feeSingleKeyWIF) {
        var feeSingleKey = bitcoin.ECPair.fromWIF(params.feeSingleKeyWIF, network);
        feeSingleKeySourceAddress = feeSingleKey.getAddress();
        // If the user specifies both, check to make sure the feeSingleKeySourceAddress corresponds to the address of feeSingleKeyWIF
        if (params.feeSingleKeySourceAddress &&
            params.feeSingleKeySourceAddress !== feeSingleKeySourceAddress) {
            throw new Error('feeSingleKeySourceAddress: ' + params.feeSingleKeySourceAddress +
                ' did not correspond to address of feeSingleKeyWIF: ' + feeSingleKeySourceAddress);
        }
    }
    if (!_.isObject(params.recipients)) {
        throw new Error('recipients must be array of { address: abc, amount: 100000 } objects');
    }
    var feeParamsDefined = 0;
    if (!_.isUndefined(params.fee)) {
        feeParamsDefined++;
    }
    if (!_.isUndefined(params.feeRate)) {
        feeParamsDefined++;
    }
    if (!_.isUndefined(params.feeTxConfirmTarget)) {
        feeParamsDefined++;
    }
    if (feeParamsDefined > 1) {
        throw new Error('cannot specify more than one of fee, feeRate and feeTxConfirmTarget');
    }
    if (_.isUndefined(params.maxFeeRate)) {
        params.maxFeeRate = constants.maxFeeRate;
    }
    // Convert the old format of params.recipients (dictionary of address:amount) to new format: { destinationAddress, amount }
    if (!(params.recipients instanceof Array)) {
        recipients = [];
        Object.keys(params.recipients).forEach(function (destinationAddress) {
            var amount = params.recipients[destinationAddress];
            recipients.push({ address: destinationAddress, amount: amount });
        });
    }
    else {
        recipients = params.recipients;
    }
    if (params.opReturns) {
        if (!(params.opReturns instanceof Array)) {
            opReturns = [];
            Object.keys(params.opReturns).forEach(function (message) {
                var amount = params.opReturns[message];
                opReturns.push({ message: message, amount: amount });
            });
        }
        else {
            opReturns = params.opReturns;
        }
    }
    if (recipients.length === 0 && opReturns.length === 0) {
        throw new Error('must have at least one recipient');
    }
    var fee = params.fee;
    var feeRate = params.feeRate;
    // Flag indicating whether this class will compute the fee
    var shouldComputeBestFee = (_.isUndefined(fee));
    var totalOutputAmount = 0;
    recipients.forEach(function (recipient) {
        if (_.isString(recipient.address)) {
            try {
                bitcoin.address.fromBase58Check(recipient.address);
            }
            catch (e) {
                throw new Error('invalid bitcoin address: ' + recipient.address);
            }
            if (!!recipient.script) {
                // A script was provided as well - validate that the address corresponds to that
                if (bitcoin.address.toOutputScript(recipient.address, network).toString('hex') !== recipient.script) {
                    throw new Error('both script and address provided but they did not match: ' + recipient.address + ' ' + recipient.script);
                }
            }
        }
        if (!_.isInteger(recipient.amount) || recipient.amount < 0) {
            throw new Error('invalid amount for ' + recipient.address + ': ' + recipient.amount);
        }
        totalOutputAmount += recipient.amount;
    });
    opReturns.forEach(function (opReturn) {
        totalOutputAmount += opReturn.amount;
    });
    var bitgoFeeInfo = params.bitgoFee;
    if (bitgoFeeInfo &&
        (!_.isInteger(bitgoFeeInfo.amount) || !_.isString(bitgoFeeInfo.address))) {
        throw new Error('invalid bitgoFeeInfo');
    }
    // The total amount needed for this transaction.
    var totalAmount = totalOutputAmount + (fee || 0);
    // The list of unspent transactions being used in this transaction.
    var unspents;
    // the total number of unspents on this wallet
    var totalUnspentsCount;
    // the number of unspents we fetched from the server, before filtering
    var fetchedUnspentsCount;
    // The list of unspent transactions being used with zero-confirmations
    var zeroConfUnspentTxIds;
    // The sum of the input values for this transaction.
    var inputAmount;
    var changeOutputs = [];
    // The transaction.
    var transaction = new bitcoin.TransactionBuilder(network);
    var getBitGoFee = function () {
        return Bluebird.try(function () {
            if (bitgoFeeInfo) {
                return;
            }
            return params.wallet.getBitGoFee({ amount: totalOutputAmount, instant: params.instant })
                .then(function (result) {
                if (result && result.fee > 0) {
                    bitgoFeeInfo = {
                        amount: result.fee
                    };
                }
            });
        })
            .then(function () {
            if (bitgoFeeInfo && bitgoFeeInfo.amount > 0) {
                totalAmount += bitgoFeeInfo.amount;
            }
        });
    };
    var getBitGoFeeAddress = function () {
        return Bluebird.try(function () {
            // If we don't have bitgoFeeInfo, or address is already set, don't get a new one
            if (!bitgoFeeInfo || bitgoFeeInfo.address) {
                return;
            }
            return bitgo.getBitGoFeeAddress()
                .then(function (result) {
                bitgoFeeInfo.address = result.address;
            });
        });
    };
    // Get a dynamic fee estimate from the BitGo server if feeTxConfirmTarget
    // is specified or if no fee-related params are specified
    var getDynamicFeeRateEstimate = function () {
        if (params.feeTxConfirmTarget || !feeParamsDefined) {
            return bitgo.estimateFee({
                numBlocks: params.feeTxConfirmTarget,
                maxFee: params.maxFeeRate,
                inputs: zeroConfUnspentTxIds,
                txSize: estTxSize,
                cpfpAware: true
            })
                .then(function (result) {
                var estimatedFeeRate = result.cpfpFeePerKb;
                var minimum = params.instant ? Math.max(constants.minFeeRate, constants.minInstantFeeRate) : constants.minFeeRate;
                // 5 satoshis per byte
                // it is worth noting that the padding only applies when the threshold is crossed, but not when the delta is less than the padding
                var padding = 5000;
                if (estimatedFeeRate < minimum) {
                    console.log(new Date() + ': Error when estimating fee for send from ' + params.wallet.id() + ', it was too low - ' + estimatedFeeRate);
                    feeRate = minimum + padding;
                }
                else if (estimatedFeeRate > params.maxFeeRate) {
                    feeRate = params.maxFeeRate - padding;
                }
                else {
                    feeRate = estimatedFeeRate;
                }
                return feeRate;
            })
                .catch(function (e) {
                // sanity check failed on tx size
                if (_.includes(e.message, 'invalid txSize')) {
                    return Bluebird.reject(e);
                }
                else {
                    // couldn't estimate the fee, proceed using the default
                    feeRate = constants.fallbackFeeRate;
                    console.log('Error estimating fee for send from ' + params.wallet.id() + ': ' + e.message);
                    return Bluebird.resolve();
                }
            });
        }
    };
    // Get the unspents for the sending wallet.
    var getUnspents = function () {
        if (params.unspents) { // we just wanna use custom unspents
            unspents = params.unspents;
            return;
        }
        // Get enough unspents for the requested amount
        var options = _.merge({}, params.unspentsFetchParams || {}, {
            target: totalAmount,
            minSize: params.minUnspentSize || 0,
            instant: params.instant,
            targetWalletUnspents: params.targetWalletUnspents
        });
        if (params.instant) {
            options.instant = params.instant; // insist on instant unspents only
        }
        return params.wallet.unspentsPaged(options)
            .then(function (results) {
            totalUnspentsCount = results.total;
            fetchedUnspentsCount = results.count;
            unspents = results.unspents.filter(function (u) {
                var confirms = u.confirmations || 0;
                if (!params.enforceMinConfirmsForChange && u.isChange) {
                    return true;
                }
                return confirms >= minConfirms;
            });
            // abort early if there's no viable unspents, because it won't be possible to create the txn later
            if (unspents.length === 0) {
                throw Error('0 unspents available for transaction creation');
            }
            // create array of unconfirmed unspent ID strings of the form "txHash:outputIndex"
            zeroConfUnspentTxIds = _(results.unspents).filter(function (u) {
                return !u.confirmations;
            }).map(function (u) {
                return u.tx_hash + ':' + u.tx_output_n;
            }).value();
            if (_.isEmpty(zeroConfUnspentTxIds)) {
                // we don't want to pass an empty array of inputs to the server, because it assumes if the
                // inputs arguments exists, it contains values
                zeroConfUnspentTxIds = undefined;
            }
            // For backwards compatibility, respect the old splitChangeSize=0 parameter
            if (!params.noSplitChange && params.splitChangeSize !== 0) {
                extraChangeAmounts = results.extraChangeAmounts || [];
            }
        });
    };
    // Get the unspents for the single key fee address
    var feeSingleKeyUnspents = [];
    var getUnspentsForSingleKey = function () {
        if (feeSingleKeySourceAddress) {
            var feeTarget = 0.01e8;
            if (params.instant) {
                feeTarget += totalAmount * 0.001;
            }
            return bitgo.get(bitgo.url('/address/' + feeSingleKeySourceAddress + '/unspents?target=' + feeTarget))
                .then(function (response) {
                if (response.body.total <= 0) {
                    throw new Error('No unspents available in single key fee source');
                }
                feeSingleKeyUnspents = response.body.unspents;
            });
        }
    };
    var minerFeeInfo = {};
    var txInfo = {};
    // Iterate unspents, sum the inputs, and save _inputs with the total
    // input amount and final list of inputs to use with the transaction.
    var feeSingleKeyUnspentsUsed = [];
    var collectInputs = function () {
        if (!unspents.length) {
            throw new Error('no unspents available on wallet');
        }
        inputAmount = 0;
        // Calculate the cost of spending a single input, i.e. the smallest economical unspent value
        return Bluebird.try(function () {
            if (_.isNumber(params.feeRate) || _.isNumber(params.originalFeeRate)) {
                return (!_.isUndefined(params.feeRate) ? params.feeRate : params.originalFeeRate);
            }
            else {
                return bitgo.estimateFee({
                    numBlocks: params.feeTxConfirmTarget,
                    maxFee: params.maxFeeRate
                })
                    .then(function (feeRateEstimate) {
                    return feeRateEstimate.feePerKb;
                });
            }
        }).then(function (feeRate) {
            // Don't spend inputs that cannot pay for their own cost.
            var minInputValue = 0;
            if (_.isInteger(params.minUnspentSize)) {
                minInputValue = params.minUnspentSize;
            }
            var prunedUnspentCount = 0;
            var originalUnspentCount = unspents.length;
            unspents = _.filter(unspents, function (unspent) {
                var isSegwitInput = !!unspent.witnessScript;
                var currentInputSize = isSegwitInput ? unspents_1.VirtualSizes.txP2shP2wshInputSize : unspents_1.VirtualSizes.txP2shInputSize;
                var feeBasedMinInputValue = (feeRate * currentInputSize) / 1000;
                var currentMinInputValue = Math.max(minInputValue, feeBasedMinInputValue);
                if (currentMinInputValue > unspent.value) {
                    // pruning unspent
                    var pruneDetails = {
                        generalMinInputValue: minInputValue,
                        feeBasedMinInputValue: feeBasedMinInputValue,
                        currentMinInputValue: currentMinInputValue,
                        feeRate: feeRate,
                        inputSize: currentInputSize,
                        unspent: unspent
                    };
                    console.log("pruning unspent: " + JSON.stringify(pruneDetails, null, 4));
                    prunedUnspentCount++;
                    return false;
                }
                return true;
            });
            if (prunedUnspentCount > 0) {
                console.log("pruned " + prunedUnspentCount + " out of " + originalUnspentCount + " unspents");
            }
            if (unspents.length === 0) {
                throw new Error('insufficient funds');
            }
            var segwitInputCount = 0;
            unspents.every(function (unspent) {
                if (unspent.witnessScript) {
                    segwitInputCount++;
                }
                inputAmount += unspent.value;
                transaction.addInput(unspent.tx_hash, unspent.tx_output_n, 0xffffffff);
                return (inputAmount < (feeSingleKeySourceAddress ? totalOutputAmount : totalAmount));
            });
            // if paying fees from an external single key wallet, add the inputs
            if (feeSingleKeySourceAddress) {
                // collect the amount used in the fee inputs so we can get change later
                feeSingleKeyInputAmount = 0;
                feeSingleKeyUnspentsUsed = [];
                feeSingleKeyUnspents.every(function (unspent) {
                    feeSingleKeyInputAmount += unspent.value;
                    inputAmount += unspent.value;
                    transaction.addInput(unspent.tx_hash, unspent.tx_output_n);
                    feeSingleKeyUnspentsUsed.push(unspent);
                    // use the fee wallet to pay miner fees and potentially instant fees
                    return (feeSingleKeyInputAmount < (fee + (bitgoFeeInfo ? bitgoFeeInfo.amount : 0)));
                });
            }
            txInfo = {
                nP2shInputs: transaction.tx.ins.length - (feeSingleKeySourceAddress ? 1 : 0) - segwitInputCount,
                nP2shP2wshInputs: segwitInputCount,
                nP2pkhInputs: feeSingleKeySourceAddress ? 1 : 0,
                nOutputs: (recipients.length + 1 + // recipients and change
                    extraChangeAmounts.length + // extra change splitting
                    (bitgoFeeInfo && bitgoFeeInfo.amount > 0 ? 1 : 0) + // add output for bitgo fee
                    (feeSingleKeySourceAddress ? 1 : 0) // add single key source address change
                )
            };
            estTxSize = estimateTransactionSize({
                nP2shInputs: txInfo.nP2shInputs,
                nP2shP2wshInputs: txInfo.nP2shP2wshInputs,
                nP2pkhInputs: txInfo.nP2pkhInputs,
                nOutputs: txInfo.nOutputs
            });
        }).then(getDynamicFeeRateEstimate)
            .then(function () {
            minerFeeInfo = exports.calculateMinerFeeInfo({
                bitgo: params.wallet.bitgo,
                feeRate: feeRate,
                nP2shInputs: txInfo.nP2shInputs,
                nP2shP2wshInputs: txInfo.nP2shP2wshInputs,
                nP2pkhInputs: txInfo.nP2pkhInputs,
                nOutputs: txInfo.nOutputs
            });
            if (shouldComputeBestFee) {
                var approximateFee = minerFeeInfo.fee;
                var shouldRecurse = _.isUndefined(fee) || approximateFee > fee;
                fee = approximateFee;
                // Recompute totalAmount from scratch
                totalAmount = fee + totalOutputAmount;
                if (bitgoFeeInfo) {
                    totalAmount += bitgoFeeInfo.amount;
                }
                if (shouldRecurse) {
                    // if fee changed, re-collect inputs
                    inputAmount = 0;
                    transaction = new bitcoin.TransactionBuilder(network);
                    return collectInputs();
                }
            }
            var totalFee = fee + (bitgoFeeInfo ? bitgoFeeInfo.amount : 0);
            if (feeSingleKeySourceAddress) {
                var summedSingleKeyUnspents = _.sumBy(feeSingleKeyUnspents, 'value');
                if (totalFee > summedSingleKeyUnspents) {
                    var err = new Error('Insufficient fee amount available in single key fee source: ' + summedSingleKeyUnspents);
                    err.result = {
                        fee: fee,
                        feeRate: feeRate,
                        estimatedSize: minerFeeInfo.size,
                        available: inputAmount,
                        bitgoFee: bitgoFeeInfo,
                        txInfo: txInfo
                    };
                    return Bluebird.reject(err);
                }
            }
            if (inputAmount < (feeSingleKeySourceAddress ? totalOutputAmount : totalAmount)) {
                // The unspents we're using for inputs do not have sufficient value on them to
                // satisfy the user's requested spend amount. That may be because the wallet's balance
                // is simply too low, or it might be that the wallet's balance is sufficient but
                // we didn't fetch enough unspents. Too few unspents could result from the wallet
                // having many small unspents and we hit our limit on the number of inputs we can use
                // in a txn, or it might have been that the filters the user passed in (like minConfirms)
                // disqualified too many of the unspents
                var err = void 0;
                if (totalUnspentsCount === fetchedUnspentsCount) {
                    // we fetched every unspent the wallet had, but it still wasn't enough
                    err = new Error('Insufficient funds');
                }
                else {
                    // we weren't able to fetch all the unspents on the wallet
                    err = new Error("Transaction size too large due to too many unspents. Can send only " + inputAmount + " satoshis in this transaction");
                }
                err.result = {
                    fee: fee,
                    feeRate: feeRate,
                    estimatedSize: minerFeeInfo.size,
                    available: inputAmount,
                    bitgoFee: bitgoFeeInfo,
                    txInfo: txInfo
                };
                return Bluebird.reject(err);
            }
        });
    };
    // Add the outputs for this transaction.
    var collectOutputs = function () {
        if (minerFeeInfo.size >= 90000) {
            throw new Error('transaction too large: estimated size ' + minerFeeInfo.size + ' bytes');
        }
        var outputs = [];
        recipients.forEach(function (recipient) {
            var script;
            if (_.isString(recipient.address)) {
                script = bitcoin.address.toOutputScript(recipient.address, network);
            }
            else if (_.isObject(recipient.script)) {
                script = recipient.script;
            }
            else {
                throw new Error('neither recipient address nor script was provided');
            }
            // validate travelInfo if it exists
            var travelInfo;
            if (!_.isEmpty(recipient.travelInfo)) {
                travelInfo = recipient.travelInfo;
                // Better to avoid trouble now, before tx is created
                bitgo.travelRule().validateTravelInfo(travelInfo);
            }
            outputs.push({
                script: script,
                amount: recipient.amount,
                travelInfo: travelInfo
            });
        });
        opReturns.forEach(function (_a) {
            var message = _a.message, amount = _a.amount;
            var script = bitcoin.script.fromASM('OP_RETURN ' + Buffer.from(message).toString('hex'));
            outputs.push({ script: script, amount: amount });
        });
        var getChangeOutputs = function (changeAmount) {
            if (changeAmount < 0) {
                throw new Error('negative change amount: ' + changeAmount);
            }
            var result = [];
            // if we paid fees from a single key wallet, return the fee change first
            if (feeSingleKeySourceAddress) {
                var feeSingleKeyWalletChangeAmount = feeSingleKeyInputAmount - (fee + (bitgoFeeInfo ? bitgoFeeInfo.amount : 0));
                if (feeSingleKeyWalletChangeAmount >= constants.minOutputSize) {
                    result.push({ address: feeSingleKeySourceAddress, amount: feeSingleKeyWalletChangeAmount });
                    changeAmount = changeAmount - feeSingleKeyWalletChangeAmount;
                }
            }
            if (changeAmount < constants.minOutputSize) {
                // Give it to the miners
                return result;
            }
            if (params.wallet.type() === 'safe') {
                return params.wallet.addresses()
                    .then(function (response) {
                    result.push({ address: response.addresses[0].address, amount: changeAmount });
                    return result;
                });
            }
            var extraChangeTotal = _.sum(extraChangeAmounts);
            // Sanity check
            if (extraChangeTotal > changeAmount) {
                extraChangeAmounts = [];
                extraChangeTotal = 0;
            }
            // copy and add remaining change amount
            var allChangeAmounts = extraChangeAmounts.slice(0);
            allChangeAmounts.push(changeAmount - extraChangeTotal);
            // Recursive async func to add all change outputs
            var addChangeOutputs = function () {
                var thisAmount = allChangeAmounts.shift();
                if (!thisAmount) {
                    return result;
                }
                return Bluebird.try(function () {
                    if (params.changeAddress) {
                        // If user passed a change address, use it for all outputs
                        return params.changeAddress;
                    }
                    else {
                        // Otherwise create a new address per output, for privacy
                        // determine if segwit or not
                        var changeChain = params.wallet.getChangeChain(params);
                        return params.wallet.createAddress({ chain: changeChain, validate: validate })
                            .then(function (result) {
                            return result.address;
                        });
                    }
                })
                    .then(function (address) {
                    result.push({ address: address, amount: thisAmount });
                    return addChangeOutputs();
                });
            };
            return addChangeOutputs();
        };
        // Add change output(s) and instant fee output if applicable
        return Bluebird.try(function () {
            return getChangeOutputs(inputAmount - totalAmount);
        })
            .then(function (result) {
            changeOutputs = result;
            var extraOutputs = changeOutputs.concat([]); // copy the array
            if (bitgoFeeInfo && bitgoFeeInfo.amount > 0) {
                extraOutputs.push(bitgoFeeInfo);
            }
            extraOutputs.forEach(function (output) {
                if (output.address) {
                    output.script =
                        bitcoin.address.toOutputScript(output.address, network);
                }
                // decide where to put the outputs - default is to randomize unless forced to end
                var outputIndex = params.forceChangeAtEnd ? outputs.length : _.random(0, outputs.length);
                outputs.splice(outputIndex, 0, output);
            });
            // Add all outputs to the transaction
            outputs.forEach(function (output) {
                transaction.addOutput(output.script, output.amount);
            });
            travelInfos = _(outputs).map(function (output, index) {
                var result = output.travelInfo;
                if (!result) {
                    return undefined;
                }
                result.outputIndex = index;
                return result;
            })
                .filter()
                .value();
        });
    };
    // Serialize the transaction, returning what is needed to sign it
    var serialize = function () {
        // only need to return the unspents that were used and just the chainPath, redeemScript, and instant flag
        var pickedUnspents = _.map(unspents, function (unspent) {
            return _.pick(unspent, ['chainPath', 'redeemScript', 'instant', 'witnessScript', 'script', 'value']);
        });
        var prunedUnspents = _.slice(pickedUnspents, 0, transaction.tx.ins.length - feeSingleKeyUnspentsUsed.length);
        _.each(feeSingleKeyUnspentsUsed, function (feeUnspent) {
            prunedUnspents.push({ redeemScript: false, chainPath: false }); // mark as false to signify a non-multisig address
        });
        var result = {
            transactionHex: transaction.buildIncomplete().toHex(),
            unspents: prunedUnspents,
            fee: fee,
            changeAddresses: changeOutputs.map(function (co) {
                return _.pick(co, ['address', 'path', 'amount']);
            }),
            walletId: params.wallet.id(),
            walletKeychains: params.wallet.keychains,
            feeRate: feeRate,
            instant: params.instant,
            bitgoFee: bitgoFeeInfo,
            estimatedSize: minerFeeInfo.size,
            txInfo: txInfo,
            travelInfos: travelInfos
        };
        // Add for backwards compatibility
        if (result.instant && bitgoFeeInfo) {
            result.instantFee = _.pick(bitgoFeeInfo, ['amount', 'address']);
        }
        return result;
    };
    return Bluebird.try(function () {
        return getBitGoFee();
    })
        .then(function () {
        return Bluebird.all([getBitGoFeeAddress(), getUnspents(), getUnspentsForSingleKey()]);
    })
        .then(collectInputs)
        .then(collectOutputs)
        .then(serialize);
};
/**
 * Estimate the size of a transaction in bytes based on the number of
 * inputs and outputs present.
 * @params params {
 *   nP2shInputs: number of P2SH (multisig) inputs
 *   nP2pkhInputs: number of P2PKH (single sig) inputs
 *   nOutputs: number of outputs
 * }
 *
 * @returns size: estimated size of the transaction in bytes
 */
var estimateTransactionSize = function (params) {
    if (!_.isInteger(params.nP2shInputs) || params.nP2shInputs < 0) {
        throw new Error('expecting positive nP2shInputs');
    }
    if (!_.isInteger(params.nP2pkhInputs) || params.nP2pkhInputs < 0) {
        throw new Error('expecting positive nP2pkhInputs to be numeric');
    }
    if (!_.isInteger(params.nP2shP2wshInputs) || params.nP2shP2wshInputs < 0) {
        throw new Error('expecting positive nP2shP2wshInputs to be numeric');
    }
    if ((params.nP2shInputs + params.nP2shP2wshInputs) < 1) {
        throw new Error('expecting at least one nP2shInputs or nP2shP2wshInputs');
    }
    if (!_.isInteger(params.nOutputs) || params.nOutputs < 1) {
        throw new Error('expecting positive nOutputs');
    }
    var estimatedSize = unspents_1.VirtualSizes.txP2shInputSize * params.nP2shInputs +
        unspents_1.VirtualSizes.txP2shP2wshInputSize * (params.nP2shP2wshInputs || 0) +
        unspents_1.VirtualSizes.txP2pkhInputSizeUncompressedKey * (params.nP2pkhInputs || 0) +
        unspents_1.VirtualSizes.txP2pkhOutputSize * params.nOutputs +
        // if the tx contains at least one segwit input, the tx overhead is increased by 1
        unspents_1.VirtualSizes.txOverheadSize + (params.nP2shP2wshInputs > 0 ? 1 : 0);
    return estimatedSize;
};
/**
 * Calculate the fee and estimated size in bytes for a transaction.
 * @params params {
 *   bitgo: bitgo object
 *   feeRate: satoshis per kilobyte
 *   nP2shInputs: number of P2SH (multisig) inputs
 *   nP2pkhInputs: number of P2PKH (single sig) inputs
 *   nOutputs: number of outputs
 * }
 *
 * @returns {
 *   size: estimated size of the transaction in bytes
 *   fee: estimated fee in satoshis for the transaction
 *   feeRate: fee rate that was used to estimate the fee for the transaction
 * }
 */
exports.calculateMinerFeeInfo = function (params) {
    var feeRateToUse = params.feeRate || params.bitgo.getConstants().fallbackFeeRate;
    var estimatedSize = estimateTransactionSize(params);
    return {
        size: estimatedSize,
        fee: Math.ceil(estimatedSize * feeRateToUse / 1000),
        feeRate: feeRateToUse
    };
};
/*
 * Given a transaction hex, unspent information (chain path and redeem scripts), and the keychain xprv,
 * perform key derivation and sign the inputs in the transaction based on the unspent information provided
 *
 * @params:
 *  transactionHex serialized form of the transaction in hex
 *  unspents array of unspent information, where each unspent is a chainPath and redeemScript with the same
 *  index as the inputs in the transactionHex
 *  keychain Keychain containing the xprv to sign with. For legacy support of safe wallets, keychain can
 also be a WIF private key.
 *  signingKey private key in WIF for safe wallets, when keychain is unavailable
 *  validate client-side signature verification - can be disabled for improved performance (signatures
 *           are still validated server-side).
 *  feeSingleKeyWIF Use the address based on this private key to pay fees
 * @returns {*}
 */
exports.signTransaction = function (params) {
    var keychain = params.keychain; // duplicate so as to not mutate below
    var validate = (params.validate === undefined) ? true : params.validate;
    var privKey;
    if (!_.isString(params.transactionHex)) {
        throw new Error('expecting the transaction hex as a string');
    }
    if (!Array.isArray(params.unspents)) {
        throw new Error('expecting the unspents array');
    }
    if (!_.isBoolean(validate)) {
        throw new Error('expecting validate to be a boolean');
    }
    var network = bitcoin_1.getNetwork();
    var enableBCH = (_.isBoolean(params.forceBCH) && params.forceBCH === true);
    if (!_.isObject(keychain) || !_.isString(keychain.xprv)) {
        if (_.isString(params.signingKey)) {
            privKey = bitcoin.ECPair.fromWIF(params.signingKey, network);
            keychain = undefined;
        }
        else {
            throw new Error('expecting the keychain object with xprv');
        }
    }
    var feeSingleKey;
    if (params.feeSingleKeyWIF) {
        feeSingleKey = bitcoin.ECPair.fromWIF(params.feeSingleKeyWIF, network);
    }
    debug('Network: %O', network);
    if (enableBCH) {
        debug('Enabling BCHâ€¦');
        network = _.extend({}, network, { coin: 'bch' });
        debug('New network: %O', network);
    }
    var transaction = bitcoin.Transaction.fromHex(params.transactionHex, network);
    if (transaction.ins.length !== params.unspents.length) {
        throw new Error('length of unspents array should equal to the number of transaction inputs');
    }
    // decorate transaction with input values for TransactionBuilder instantiation
    var isUtxoTx = _.isObject(transaction) && Array.isArray(transaction.ins);
    var areValidUnspents = _.isObject(params) && Array.isArray(params.unspents);
    if (isUtxoTx && areValidUnspents) {
        // extend the transaction inputs with the values
        var inputValues_1 = _.map(params.unspents, (function (u) { return _.pick(u, 'value'); }));
        transaction.ins.map(function (currentItem, index) { return _.extend(currentItem, inputValues_1[index]); });
    }
    var rootExtKeyPath;
    var rootExtKey;
    if (keychain) {
        rootExtKey = bitcoin.HDNode.fromBase58(keychain.xprv);
        rootExtKeyPath = bitcoin_1.hdPath(rootExtKey);
    }
    var txb = bitcoin.TransactionBuilder.fromTransaction(transaction, network);
    for (var index = 0; index < txb.tx.ins.length; ++index) {
        var currentUnspent = params.unspents[index];
        if (currentUnspent.redeemScript === false) {
            // this is the input from a single key fee address
            if (!feeSingleKey) {
                throw new Error('single key address used in input but feeSingleKeyWIF not provided');
            }
            if (enableBCH) {
                feeSingleKey.network = network;
            }
            txb.sign(index, feeSingleKey);
            continue;
        }
        var chainPath = currentUnspent.chainPath;
        if (rootExtKeyPath) {
            var subPath = keychain.walletSubPath || '/0/0';
            var path = keychain.path + subPath + chainPath;
            privKey = rootExtKeyPath.deriveKey(path);
        }
        privKey.network = network;
        var isSegwitInput = !!currentUnspent.witnessScript;
        // subscript is the part of the output script after the OP_CODESEPARATOR.
        // Since we are only ever signing p2sh outputs, which do not have
        // OP_CODESEPARATORS, it is always the output script.
        var subscript = Buffer.from(currentUnspent.redeemScript, 'hex');
        currentUnspent.validationScript = subscript;
        // In order to sign with bitcoinjs-lib, we must use its transaction
        // builder, confusingly named the same exact thing as our transaction
        // builder, but with inequivalent behavior.
        try {
            if (isSegwitInput) {
                debug('Signing segwit input #%d', index);
                if (enableBCH) {
                    throw new Error('BCH does not support segwit inputs');
                }
                var signatures = _.cloneDeep(txb.inputs[index].signatures);
                var witnessScript = Buffer.from(currentUnspent.witnessScript, 'hex');
                currentUnspent.validationScript = witnessScript;
                debug('Current unspent value: %d', currentUnspent.value);
                txb.sign(index, privKey, subscript, bitcoin.Transaction.SIGHASH_ALL, currentUnspent.value, witnessScript);
                if (Array.isArray(signatures)) {
                    // for segwit inputs, if they are partially signed, bitcoinjs-lib overrides previous signatures
                    // this workaround forces them to be preserved
                    signatures = signatures.filter(function (sig) { return !!sig; });
                    // Last, override builder's signatures property to an array including previous signatures, if there are any.
                    var builderSignatures = txb.inputs[index].signatures;
                    var nonEmptySignatures = _.remove(builderSignatures, function (sig) { return !!sig; });
                    signatures.push.apply(signatures, nonEmptySignatures);
                    txb.inputs[index].signatures = signatures;
                }
            }
            else {
                debug('Signing non-segwit input #%d', index);
                // only if bitcoin cash is enabled, which should only be in unit tests anyway
                var bchParameter = enableBCH ? currentUnspent.value : undefined;
                var sigHashType = bitcoin.Transaction.SIGHASH_ALL;
                if (enableBCH) {
                    sigHashType |= bitcoin.Transaction.SIGHASH_BITCOINCASHBIP143;
                }
                debug('BCH parameter: %d', bchParameter);
                debug('Sighash type: %d', sigHashType);
                txb.sign(index, privKey, subscript, sigHashType, bchParameter);
            }
        }
        catch (e) {
            // we need to know what's causing this
            e.result = {
                unspent: currentUnspent
            };
            e.message = "Failed to sign input #" + index + " - " + e.message + " - " + JSON.stringify(e.result, null, 4) + " - \n" + e.stack;
            debug('input sign failed: %s', e.message);
            return Bluebird.reject(e);
        }
    }
    // reserialize transaction
    transaction = txb.build();
    for (var index = 0; index < transaction.ins.length; ++index) {
        // bitcoinjs-lib adds one more OP_0 than we need. It creates one OP_0 for
        // every n public keys in an m-of-n multisig, and replaces the OP_0s with
        // the signature of the nth public key, then removes any remaining OP_0s
        // at the end. This behavior is not incorrect and valid for some use
        // cases, particularly if you do not know which keys will be signing the
        // transaction and the signatures may be added to the transaction in any
        // chronological order, but is not compatible with the BitGo API, which
        // assumes m OP_0s for m-of-n multisig (or m-1 after the first signature
        // is created). Thus we need to remove the superfluous OP_0.
        var currentUnspent = params.unspents[index];
        // The signatures are validated server side and on the bitcoin network, so
        // the signature validation is optional and can be disabled by setting:
        // validate = false
        if (validate) {
            var signatureCount = exports.verifyInputSignatures(transaction, index, currentUnspent.validationScript, false, currentUnspent.value, enableBCH);
            // TODO: figure out something smarter for half-signed
            // if params.fullLocalSigning is set to true, we allow custom non-zero values
            // otherwise, the signature count has to be -1
            var fullLocalSigning = !!params.fullLocalSigning;
            if (signatureCount === 0 || (!fullLocalSigning && signatureCount !== -1)) {
                // if the signature count is positive, we do not want to throw the error, because it is expected
                throw new Error('number of signatures is invalid - something went wrong when signing');
            }
        }
    }
    return Bluebird.resolve({
        transactionHex: transaction.toHex()
    });
};
/**
 * Verify the signature on an input.
 *
 * If the transaction is fully signed, returns a positive number representing the number of valid signatures.
 * If the transaction is partially signed, returns a negative number representing the number of valid signatures.
 * @param transaction The bitcoinjs-lib transaction object
 * @param inputIndex the input index to verify
 * @param pubScript the redeem script to verify with
 * @param ignoreKeyIndices array of multisig keys indexes (in order of keychains on the wallet). e.g. [1] to ignore backup keys
 * @param amount
 * @returns {number}
 */
exports.verifyInputSignatures = function (transaction, inputIndex, pubScript, ignoreKeyIndices, amount, isBCH) {
    if (isBCH === void 0) { isBCH = false; }
    if (inputIndex < 0 || inputIndex >= transaction.ins.length) {
        throw new Error('illegal index');
    }
    ignoreKeyIndices = ignoreKeyIndices || [];
    var currentTransactionInput = transaction.ins[inputIndex];
    var sigScript = currentTransactionInput.script;
    var sigsNeeded = 1;
    var sigs = [];
    var pubKeys = [];
    var decompiledSigScript = bitcoin.script.decompile(sigScript);
    var isSegwitInput = currentTransactionInput.witness.length > 0;
    if (isSegwitInput) {
        decompiledSigScript = currentTransactionInput.witness;
        sigScript = bitcoin.script.compile(decompiledSigScript);
        if (!amount) {
            return 0;
        }
    }
    // Check the script type to determine number of signatures, the pub keys, and the script to hash.
    var inputClassification = bitcoin.script.classifyInput(sigScript, true);
    switch (inputClassification) {
        case 'scripthash':
            // Replace the pubScript with the P2SH Script.
            pubScript = decompiledSigScript[decompiledSigScript.length - 1];
            var decompiledPubScript = bitcoin.script.decompile(pubScript);
            sigsNeeded = decompiledPubScript[0] - bitcoin.opcodes.OP_1 + 1;
            for (var index = 1; index < decompiledSigScript.length - 1; ++index) {
                sigs.push(decompiledSigScript[index]);
            }
            for (var index = 1; index < decompiledPubScript.length - 2; ++index) {
                // we minus 1 because the key indexes start from the second chunk (first chunk is used for total keys)
                if (_.includes(ignoreKeyIndices, index - 1)) {
                    // ignore this public key (do not treat it as valid for a signature)
                    continue;
                }
                pubKeys.push(decompiledPubScript[index]);
            }
            break;
        case 'pubkeyhash':
            sigsNeeded = 1;
            sigs.push(decompiledSigScript[0]);
            pubKeys.push(decompiledSigScript[1]);
            break;
        default:
            return 0;
    }
    var numVerifiedSignatures = 0;
    for (var sigIndex = 0; sigIndex < sigs.length; ++sigIndex) {
        // If this is an OP_0, then its been left as a placeholder for a future sig.
        if (sigs[sigIndex] === bitcoin.opcodes.OP_0) {
            continue;
        }
        var hashType = sigs[sigIndex][sigs[sigIndex].length - 1];
        sigs[sigIndex] = sigs[sigIndex].slice(0, sigs[sigIndex].length - 1); // pop hash type from end
        var signatureHash = void 0;
        if (isSegwitInput) {
            signatureHash = transaction.hashForWitnessV0(inputIndex, pubScript, amount, hashType);
        }
        else if (isBCH) {
            signatureHash = transaction.hashForCashSignature(inputIndex, pubScript, amount, hashType);
        }
        else {
            signatureHash = transaction.hashForSignature(inputIndex, pubScript, hashType);
        }
        var validSig = false;
        // Enumerate the possible public keys
        for (var pubKeyIndex = 0; pubKeyIndex < pubKeys.length; ++pubKeyIndex) {
            var pubKey = bitcoin.ECPair.fromPublicKeyBuffer(pubKeys[pubKeyIndex]);
            var signature = bitcoin.ECSignature.fromDER(sigs[sigIndex]);
            validSig = pubKey.verify(signatureHash, signature);
            if (validSig) {
                pubKeys.splice(pubKeyIndex, 1); // remove the pubkey so we can't match 2 sigs against the same pubkey
                break;
            }
        }
        if (!validSig) {
            throw new Error('invalid signature for index ' + inputIndex);
        }
        numVerifiedSignatures++;
    }
    if (numVerifiedSignatures < sigsNeeded) {
        numVerifiedSignatures = -numVerifiedSignatures;
    }
    return numVerifiedSignatures;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3RyYW5zYWN0aW9uQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7O0FBRUg7R0FDRztBQUNILEVBQUU7QUFDRixxQkFBcUI7QUFDckIsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvREFBb0Q7QUFDcEQsRUFBRTtBQUVGLG1DQUFxQztBQUNyQyx5Q0FBMkM7QUFDM0MsMEJBQTRCO0FBQzVCLDRDQUErQztBQUMvQyxxQ0FBK0M7QUFDL0MsZ0NBQW1DO0FBQ25DLElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN2QyxpQ0FBbUM7QUF1Qm5DLEVBQUU7QUFDRixxQkFBcUI7QUFDckIsV0FBVztBQUNYLDBDQUEwQztBQUMxQyw4TUFBOE07QUFDOU0sc0dBQXNHO0FBQ3RHLGtJQUFrSTtBQUNsSSw2SEFBNkg7QUFDN0gsdUdBQXVHO0FBQ3ZHLCtFQUErRTtBQUMvRSxxRUFBcUU7QUFDckUsNkVBQTZFO0FBQzdFLHdHQUF3RztBQUN4RyxpSUFBaUk7QUFDakksd0lBQXdJO0FBQ3hJLDRJQUE0STtBQUM1SSx1RUFBdUU7QUFDdkUsMkVBQTJFO0FBQzNFLDRGQUE0RjtBQUM1RixPQUFPLENBQUMsaUJBQWlCLEdBQUcsVUFBUyxNQUFNO0lBQ3pDLElBQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDO0lBQzVDLElBQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxRQUFRLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUM7SUFDeEUsSUFBSSxVQUFVLEdBQThFLEVBQUUsQ0FBQztJQUMvRixJQUFJLFNBQVMsR0FBMkMsRUFBRSxDQUFDO0lBQzNELElBQUksa0JBQWtCLEdBQWEsRUFBRSxDQUFDO0lBQ3RDLElBQUksU0FB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QUFJLHFCQUFxQixHQUFHLFVBQVUsRUFBRTtRQUN0QyxxQkFBcUIsR0FBRyxDQUFDLHFCQUFxQixDQUFDO0tBQ2hEO0lBQ0QsT0FBTyxxQkFBcUIsQ0FBQztBQUMvQixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBoaWRkZW5cbiAqL1xuXG4vKipcbiAqL1xuLy9cbi8vIFRyYW5zYWN0aW9uQnVpbGRlclxuLy8gQSB1dGlsaXR5IGZvciBidWlsZGluZyBhbmQgc2lnbmluZyB0cmFuc2FjdGlvbnNcbi8vXG4vLyBDb3B5cmlnaHQgMjAxNCwgQml0R28sIEluYy4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuXG5pbXBvcnQgKiBhcyBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgKiBhcyBiaXRjb2luIGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBWaXJ0dWFsU2l6ZXMgfSBmcm9tICdAYml0Z28vdW5zcGVudHMnO1xuaW1wb3J0IHsgZ2V0TmV0d29yaywgaGRQYXRoIH0gZnJvbSAnLi9iaXRjb2luJztcbmltcG9ydCBkZWJ1Z0xpYiA9IHJlcXVpcmUoJ2RlYnVnJyk7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTGliKCdiaXRnbzp2MTp0eGInKTtcbmltcG9ydCAqIGFzIGNvbW1vbiBmcm9tICcuL2NvbW1vbic7XG5cbmludGVyZmFjZSBCYXNlT3V0cHV0IHtcbiAgYW1vdW50OiBudW1iZXI7XG4gIHRyYXZlbEluZm8/OiBhbnk7XG59XG5cbmludGVyZmFjZSBBZGRyZXNzT3V0cHV0IGV4dGVuZHMgQmFzZU91dHB1dCB7XG4gIGFkZHJlc3M6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFNjcmlwdE91dHB1dCBleHRlbmRzIEJhc2VPdXRwdXQge1xuICBzY3JpcHQ6IEJ1ZmZlcjtcbn1cblxudHlwZSBPdXRwdXQgPSBBZGRyZXNzT3V0cHV0IHwgU2NyaXB0T3V0cHV0O1xuXG5pbnRlcmZhY2UgQml0R29VbnNwZW50IHtcbiAgdmFsdWU6IG51bWJlcjtcbiAgdHhfaGFzaDogQnVmZmVyO1xuICB0eF9vdXRwdXRfbjogbnVtYmVyO1xufVxuXG4vL1xuLy8gVHJhbnNhY3Rpb25CdWlsZGVyXG4vLyBAcGFyYW1zOlxuLy8gICB3YWxsZXQ6ICBhIHdhbGxldCBvYmplY3QgdG8gc2VuZCBmcm9tXG4vLyAgIHJlY2lwaWVudHM6IGFycmF5IG9mIHJlY2lwaWVudCBvYmplY3RzIGFuZCB0aGUgYW1vdW50IHRvIHNlbmQgdG8gZWFjaCBlLmcuIFt7YWRkcmVzczogJzM4QktETlpiUGNMb2d2VmJjeDJla0o5RTZWdjk0RHFEcXcnLCBhbW91bnQ6IDE1MDB9LCB7YWRkcmVzczogJzM2ZUw4eVFxQ24xSE1SbVZGRm80OXQyUEozcGFpOHdRYW0nLCBhbW91bnQ6IDIwMDB9XVxuLy8gICBmZWU6IHRoZSBmZWUgdG8gdXNlIHdpdGggdGhpcyB0cmFuc2FjdGlvbi4gIGlmIG5vdCBwcm92aWRlZCwgYSBkZWZhdWx0LCBtaW5pbXVtIGZlZSB3aWxsIGJlIHVzZWQuXG4vLyAgIGZlZVJhdGU6IHRoZSBhbW91bnQgb2YgZmVlIHBlciBraWxvYnl0ZSAtIG9wdGlvbmFsIC0gc3BlY2lmeSBlaXRoZXIgZmVlLCBmZWVSYXRlLCBvciBmZWVUeENvbmZpcm1UYXJnZXQgYnV0IG5vdCBtb3JlIHRoYW4gb25lXG4vLyAgIGZlZVR4Q29uZmlybVRhcmdldDogY2FsY3VsYXRlIHRoZSBmZWVzIHBlciBraWxvYnl0ZSBzdWNoIHRoYXQgdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgY29uZmlybWVkIGluIHRoaXMgbnVtYmVyIG9mIGJsb2Nrc1xuLy8gICBtYXhGZWVSYXRlOiBUaGUgbWF4aW11bSBmZWUgcGVyIGtiIHRvIHVzZSBpbiBzYXRvc2hpcywgZm9yIHNhZmV0eSBwdXJwb3NlcyB3aGVuIHVzaW5nIGR5bmFtaWMgZmVlc1xuLy8gICBtaW5Db25maXJtczogdGhlIG1pbmltdW0gY29uZmlybWF0aW9ucyBhbiBvdXRwdXQgbXVzdCBoYXZlIGJlZm9yZSBzcGVuZGluZ1xuLy8gICBmb3JjZUNoYW5nZUF0RW5kOiBmb3JjZSB0aGUgY2hhbmdlIGFkZHJlc3MgdG8gYmUgdGhlIGxhc3Qgb3V0cHV0XG4vLyAgIGNoYW5nZUFkZHJlc3M6IHNwZWNpZnkgdGhlIGNoYW5nZSBhZGRyZXNzIHJhdGhlciB0aGFuIGdlbmVyYXRlIGEgbmV3IG9uZVxuLy8gICBub1NwbGl0Q2hhbmdlOiBzZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIGF1dG9tYXRpYyBjaGFuZ2Ugc3BsaXR0aW5nIGZvciBwdXJwb3NlcyBvZiB1bnNwZW50IG1hbmFnZW1lbnRcbi8vICAgdGFyZ2V0V2FsbGV0VW5zcGVudHM6IHNwZWNpZnkgYSBudW1iZXIgb2YgdGFyZ2V0IHVuc3BlbnRzIHRvIG1haW50YWluIGluIHRoZSB3YWxsZXQgKGN1cnJlbnRseSBkZWZhdWx0ZWQgdG8gOCBieSB0aGUgc2VydmVyKVxuLy8gICB2YWxpZGF0ZTogZXh0cmEgdmVyaWZpY2F0aW9uIG9mIHRoZSBjaGFuZ2UgYWRkcmVzc2VzLCB3aGljaCBpcyBhbHdheXMgZG9uZSBzZXJ2ZXItc2lkZSBhbmQgaXMgcmVkdW5kYW50IGNsaWVudC1zaWRlIChkZWZhdWx0cyB0cnVlKVxuLy8gICBtaW5VbnNwZW50U2l6ZTogVGhlIG1pbmltdW0gc2l6ZSBpbiBzYXRvc2hpcyBvZiB1bnNwZW50IHRvIHVzZSAodG8gcHJldmVudCBzcGVuZGluZyB1bnNwZW50cyB3b3J0aCBsZXNzIHRoYW4gZmVlIGFkZGVkKS4gRGVmYXVsdHMgdG8gMC5cbi8vICAgZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzczogVXNlIHRoaXMgc2luZ2xlIGtleSBhZGRyZXNzIHRvIHBheSBmZWVzXG4vLyAgIGZlZVNpbmdsZUtleVdJRjogVXNlIHRoZSBhZGRyZXNzIGJhc2VkIG9uIHRoaXMgcHJpdmF0ZSBrZXkgdG8gcGF5IGZlZXNcbi8vICAgdW5zcGVudHNGZXRjaFBhcmFtczogRXh0cmEgcGFyYW1ldGVycyB0byB1c2UgZm9yIGZldGNoaW5nIHVuc3BlbnRzIGZvciB0aGlzIHRyYW5zYWN0aW9uXG5leHBvcnRzLmNyZWF0ZVRyYW5zYWN0aW9uID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIGNvbnN0IG1pbkNvbmZpcm1zID0gcGFyYW1zLm1pbkNvbmZpcm1zIHx8IDA7XG4gIGNvbnN0IHZhbGlkYXRlID0gcGFyYW1zLnZhbGlkYXRlID09PSB1bmRlZmluZWQgPyB0cnVlIDogcGFyYW1zLnZhbGlkYXRlO1xuICBsZXQgcmVjaXBpZW50czogeyBhZGRyZXNzOiBzdHJpbmc7IGFtb3VudDogbnVtYmVyOyBzY3JpcHQ/OiBzdHJpbmc7IHRyYXZlbEluZm8/OiBhbnk7IH1bXSA9IFtdO1xuICBsZXQgb3BSZXR1cm5zOiB7IG1lc3NhZ2U6IHN0cmluZzsgYW1vdW50OiBudW1iZXI7IH1bXSA9IFtdO1xuICBsZXQgZXh0cmFDaGFuZ2VBbW91bnRzOiBudW1iZXJbXSA9IFtdO1xuICBsZXQgZXN0VHhTaXplOiBudW1iZXI7XG4gIGxldCB0cmF2ZWxJbmZvcztcblxuICAvLyBTYW5pdHkgY2hlY2sgdGhlIGFyZ3VtZW50cyBwYXNzZWQgaW5cbiAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcy53YWxsZXQpIHx8XG4gIChwYXJhbXMuZmVlICYmICFfLmlzTnVtYmVyKHBhcmFtcy5mZWUpKSB8fFxuICAocGFyYW1zLmZlZVJhdGUgJiYgIV8uaXNOdW1iZXIocGFyYW1zLmZlZVJhdGUpKSB8fFxuICAhXy5pc0ludGVnZXIobWluQ29uZmlybXMpIHx8XG4gIChwYXJhbXMuZm9yY2VDaGFuZ2VBdEVuZCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmZvcmNlQ2hhbmdlQXRFbmQpKSB8fFxuICAocGFyYW1zLmNoYW5nZUFkZHJlc3MgJiYgIV8uaXNTdHJpbmcocGFyYW1zLmNoYW5nZUFkZHJlc3MpKSB8fFxuICAocGFyYW1zLm5vU3BsaXRDaGFuZ2UgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5ub1NwbGl0Q2hhbmdlKSkgfHxcbiAgKHBhcmFtcy50YXJnZXRXYWxsZXRVbnNwZW50cyAmJiAhXy5pc0ludGVnZXIocGFyYW1zLnRhcmdldFdhbGxldFVuc3BlbnRzKSkgfHxcbiAgKHZhbGlkYXRlICYmICFfLmlzQm9vbGVhbih2YWxpZGF0ZSkpIHx8XG4gIChwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlICYmICFfLmlzQm9vbGVhbihwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlKSkgfHxcbiAgKHBhcmFtcy5taW5VbnNwZW50U2l6ZSAmJiAhXy5pc051bWJlcihwYXJhbXMubWluVW5zcGVudFNpemUpKSB8fFxuICAocGFyYW1zLm1heEZlZVJhdGUgJiYgIV8uaXNOdW1iZXIocGFyYW1zLm1heEZlZVJhdGUpKSB8fFxuICAvLyB0aGlzIHNob3VsZCBiZSBhbiBhcnJheSBhbmQgaXRzIGxlbmd0aCBtdXN0IGJlIGF0IGxlYXN0IDFcbiAgKHBhcmFtcy51bnNwZW50cyAmJiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLnVuc3BlbnRzKSB8fCBwYXJhbXMudW5zcGVudHMubGVuZ3RoIDwgMSkpIHx8XG4gIChwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0ICYmICFfLmlzSW50ZWdlcihwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0KSkgfHxcbiAgKHBhcmFtcy5pbnN0YW50ICYmICFfLmlzQm9vbGVhbihwYXJhbXMuaW5zdGFudCkpIHx8XG4gIChwYXJhbXMuYml0Z29GZWUgJiYgIV8uaXNPYmplY3QocGFyYW1zLmJpdGdvRmVlKSkgfHxcbiAgKHBhcmFtcy51bnNwZW50c0ZldGNoUGFyYW1zICYmICFfLmlzT2JqZWN0KHBhcmFtcy51bnNwZW50c0ZldGNoUGFyYW1zKSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBjb25zdCBiaXRnbyA9IHBhcmFtcy53YWxsZXQuYml0Z287XG4gIGNvbnN0IGNvbnN0YW50cyA9IGJpdGdvLmdldENvbnN0YW50cygpO1xuICBjb25zdCBuZXR3b3JrID0gZ2V0TmV0d29yayhjb21tb24uRW52aXJvbm1lbnRzW2JpdGdvLmdldEVudigpXS5uZXR3b3JrKTtcblxuICAvLyBUaGUgdXNlciBjYW4gc3BlY2lmeSBhIHNlcGVyYXRlLCBzaW5nbGUta2V5IHdhbGxldCBmb3IgdGhlIHB1cnBvc2VzIG9mIHBheWluZyBtaW5lcidzIGZlZXNcbiAgLy8gV2hlbiBjcmVhdGluZyBhIHRyYW5zYWN0aW9uIHRoaXMgY2FuIGJlIHNwZWNpZmllZCBhcyBhbiBpbnB1dCBhZGRyZXNzIG9yIHRoZSBwcml2YXRlIGtleSBpbiBXSUZcbiAgbGV0IGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3M7XG4gIGxldCBmZWVTaW5nbGVLZXlJbnB1dEFtb3VudCA9IDA7XG4gIGlmIChwYXJhbXMuZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICBiaXRjb2luLmFkZHJlc3MuZnJvbUJhc2U1OENoZWNrKHBhcmFtcy5mZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzKTtcbiAgICAgIGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgPSBwYXJhbXMuZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYml0Y29pbiBhZGRyZXNzOiAnICsgcGFyYW1zLmZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJhbXMuZmVlU2luZ2xlS2V5V0lGKSB7XG4gICAgY29uc3QgZmVlU2luZ2xlS2V5ID0gYml0Y29pbi5FQ1BhaXIuZnJvbVdJRihwYXJhbXMuZmVlU2luZ2xlS2V5V0lGLCBuZXR3b3JrKTtcbiAgICBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzID0gZmVlU2luZ2xlS2V5LmdldEFkZHJlc3MoKTtcbiAgICAvLyBJZiB0aGUgdXNlciBzcGVjaWZpZXMgYm90aCwgY2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzIGNvcnJlc3BvbmRzIHRvIHRoZSBhZGRyZXNzIG9mIGZlZVNpbmdsZUtleVdJRlxuICAgIGlmIChwYXJhbXMuZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyAmJlxuICAgIHBhcmFtcy5mZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzICE9PSBmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3M6ICcgKyBwYXJhbXMuZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyArXG4gICAgICAnIGRpZCBub3QgY29ycmVzcG9uZCB0byBhZGRyZXNzIG9mIGZlZVNpbmdsZUtleVdJRjogJyArIGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghXy5pc09iamVjdChwYXJhbXMucmVjaXBpZW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY2lwaWVudHMgbXVzdCBiZSBhcnJheSBvZiB7IGFkZHJlc3M6IGFiYywgYW1vdW50OiAxMDAwMDAgfSBvYmplY3RzJyk7XG4gIH1cblxuICBsZXQgZmVlUGFyYW1zRGVmaW5lZCA9IDA7XG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZmVlKSkge1xuICAgIGZlZVBhcmFtc0RlZmluZWQrKztcbiAgfVxuXG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZmVlUmF0ZSkpIHtcbiAgICBmZWVQYXJhbXNEZWZpbmVkKys7XG4gIH1cblxuICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmZlZVR4Q29uZmlybVRhcmdldCkpIHtcbiAgICBmZWVQYXJhbXNEZWZpbmVkKys7XG4gIH1cblxuICBpZiAoZmVlUGFyYW1zRGVmaW5lZCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzcGVjaWZ5IG1vcmUgdGhhbiBvbmUgb2YgZmVlLCBmZWVSYXRlIGFuZCBmZWVUeENvbmZpcm1UYXJnZXQnKTtcbiAgfVxuXG4gIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5tYXhGZWVSYXRlKSkge1xuICAgIHBhcmFtcy5tYXhGZWVSYXRlID0gY29uc3RhbnRzLm1heEZlZVJhdGU7XG4gIH1cblxuICAvLyBDb252ZXJ0IHRoZSBvbGQgZm9ybWF0IG9mIHBhcmFtcy5yZWNpcGllbnRzIChkaWN0aW9uYXJ5IG9mIGFkZHJlc3M6YW1vdW50KSB0byBuZXcgZm9ybWF0OiB7IGRlc3RpbmF0aW9uQWRkcmVzcywgYW1vdW50IH1cbiAgaWYgKCEocGFyYW1zLnJlY2lwaWVudHMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICByZWNpcGllbnRzID0gW107XG4gICAgT2JqZWN0LmtleXMocGFyYW1zLnJlY2lwaWVudHMpLmZvckVhY2goZnVuY3Rpb24oZGVzdGluYXRpb25BZGRyZXNzKSB7XG4gICAgICBjb25zdCBhbW91bnQgPSBwYXJhbXMucmVjaXBpZW50c1tkZXN0aW5hdGlvbkFkZHJlc3NdO1xuICAgICAgcmVjaXBpZW50cy5wdXNoKHsgYWRkcmVzczogZGVzdGluYXRpb25BZGRyZXNzLCBhbW91bnQ6IGFtb3VudCB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZWNpcGllbnRzID0gcGFyYW1zLnJlY2lwaWVudHM7XG4gIH1cblxuICBpZiAocGFyYW1zLm9wUmV0dXJucykge1xuICAgIGlmICghKHBhcmFtcy5vcFJldHVybnMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIG9wUmV0dXJucyA9IFtdO1xuICAgICAgT2JqZWN0LmtleXMocGFyYW1zLm9wUmV0dXJucykuZm9yRWFjaChmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IHBhcmFtcy5vcFJldHVybnNbbWVzc2FnZV07XG4gICAgICAgIG9wUmV0dXJucy5wdXNoKHsgbWVzc2FnZSwgYW1vdW50IH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wUmV0dXJucyA9IHBhcmFtcy5vcFJldHVybnM7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlY2lwaWVudHMubGVuZ3RoID09PSAwICYmIG9wUmV0dXJucy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgaGF2ZSBhdCBsZWFzdCBvbmUgcmVjaXBpZW50Jyk7XG4gIH1cblxuICBsZXQgZmVlID0gcGFyYW1zLmZlZTtcbiAgbGV0IGZlZVJhdGUgPSBwYXJhbXMuZmVlUmF0ZTtcblxuICAvLyBGbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGNsYXNzIHdpbGwgY29tcHV0ZSB0aGUgZmVlXG4gIGNvbnN0IHNob3VsZENvbXB1dGVCZXN0RmVlID0gKF8uaXNVbmRlZmluZWQoZmVlKSk7XG5cbiAgbGV0IHRvdGFsT3V0cHV0QW1vdW50ID0gMDtcblxuICByZWNpcGllbnRzLmZvckVhY2goZnVuY3Rpb24ocmVjaXBpZW50KSB7XG4gICAgaWYgKF8uaXNTdHJpbmcocmVjaXBpZW50LmFkZHJlc3MpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBiaXRjb2luLmFkZHJlc3MuZnJvbUJhc2U1OENoZWNrKHJlY2lwaWVudC5hZGRyZXNzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJpdGNvaW4gYWRkcmVzczogJyArIHJlY2lwaWVudC5hZGRyZXNzKTtcbiAgICAgIH1cbiAgICAgIGlmICghIXJlY2lwaWVudC5zY3JpcHQpIHtcbiAgICAgICAgLy8gQSBzY3JpcHQgd2FzIHByb3ZpZGVkIGFzIHdlbGwgLSB2YWxpZGF0ZSB0aGF0IHRoZSBhZGRyZXNzIGNvcnJlc3BvbmRzIHRvIHRoYXRcbiAgICAgICAgaWYgKGJpdGNvaW4uYWRkcmVzcy50b091dHB1dFNjcmlwdChyZWNpcGllbnQuYWRkcmVzcywgbmV0d29yaykudG9TdHJpbmcoJ2hleCcpICE9PSByZWNpcGllbnQuc2NyaXB0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIHNjcmlwdCBhbmQgYWRkcmVzcyBwcm92aWRlZCBidXQgdGhleSBkaWQgbm90IG1hdGNoOiAnICsgcmVjaXBpZW50LmFkZHJlc3MgKyAnICcgKyByZWNpcGllbnQuc2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIV8uaXNJbnRlZ2VyKHJlY2lwaWVudC5hbW91bnQpIHx8IHJlY2lwaWVudC5hbW91bnQgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYW1vdW50IGZvciAnICsgcmVjaXBpZW50LmFkZHJlc3MgKyAnOiAnICsgcmVjaXBpZW50LmFtb3VudCk7XG4gICAgfVxuICAgIHRvdGFsT3V0cHV0QW1vdW50ICs9IHJlY2lwaWVudC5hbW91bnQ7XG4gIH0pO1xuXG4gIG9wUmV0dXJucy5mb3JFYWNoKGZ1bmN0aW9uKG9wUmV0dXJuKSB7XG4gICAgdG90YWxPdXRwdXRBbW91bnQgKz0gb3BSZXR1cm4uYW1vdW50O1xuICB9KTtcblxuICBsZXQgYml0Z29GZWVJbmZvID0gcGFyYW1zLmJpdGdvRmVlO1xuICBpZiAoYml0Z29GZWVJbmZvICYmXG4gICghXy5pc0ludGVnZXIoYml0Z29GZWVJbmZvLmFtb3VudCkgfHwgIV8uaXNTdHJpbmcoYml0Z29GZWVJbmZvLmFkZHJlc3MpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaXRnb0ZlZUluZm8nKTtcbiAgfVxuXG4gIC8vIFRoZSB0b3RhbCBhbW91bnQgbmVlZGVkIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICBsZXQgdG90YWxBbW91bnQgPSB0b3RhbE91dHB1dEFtb3VudCArIChmZWUgfHwgMCk7XG5cbiAgLy8gVGhlIGxpc3Qgb2YgdW5zcGVudCB0cmFuc2FjdGlvbnMgYmVpbmcgdXNlZCBpbiB0aGlzIHRyYW5zYWN0aW9uLlxuICBsZXQgdW5zcGVudHM7XG5cbiAgLy8gdGhlIHRvdGFsIG51bWJlciBvZiB1bnNwZW50cyBvbiB0aGlzIHdhbGxldFxuICBsZXQgdG90YWxVbnNwZW50c0NvdW50O1xuXG4gIC8vIHRoZSBudW1iZXIgb2YgdW5zcGVudHMgd2UgZmV0Y2hlZCBmcm9tIHRoZSBzZXJ2ZXIsIGJlZm9yZSBmaWx0ZXJpbmdcbiAgbGV0IGZldGNoZWRVbnNwZW50c0NvdW50O1xuXG4gIC8vIFRoZSBsaXN0IG9mIHVuc3BlbnQgdHJhbnNhY3Rpb25zIGJlaW5nIHVzZWQgd2l0aCB6ZXJvLWNvbmZpcm1hdGlvbnNcbiAgbGV0IHplcm9Db25mVW5zcGVudFR4SWRzO1xuXG4gIC8vIFRoZSBzdW0gb2YgdGhlIGlucHV0IHZhbHVlcyBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgbGV0IGlucHV0QW1vdW50O1xuXG4gIGxldCBjaGFuZ2VPdXRwdXRzOiBPdXRwdXRbXSA9IFtdO1xuXG4gIC8vIFRoZSB0cmFuc2FjdGlvbi5cbiAgbGV0IHRyYW5zYWN0aW9uID0gbmV3IGJpdGNvaW4uVHJhbnNhY3Rpb25CdWlsZGVyKG5ldHdvcmspO1xuXG4gIGNvbnN0IGdldEJpdEdvRmVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnRyeShmdW5jdGlvbigpIHtcbiAgICAgIGlmIChiaXRnb0ZlZUluZm8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmFtcy53YWxsZXQuZ2V0Qml0R29GZWUoeyBhbW91bnQ6IHRvdGFsT3V0cHV0QW1vdW50LCBpbnN0YW50OiBwYXJhbXMuaW5zdGFudCB9KVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LmZlZSA+IDApIHtcbiAgICAgICAgICBiaXRnb0ZlZUluZm8gPSB7XG4gICAgICAgICAgICBhbW91bnQ6IHJlc3VsdC5mZWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KVxuICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGJpdGdvRmVlSW5mbyAmJiBiaXRnb0ZlZUluZm8uYW1vdW50ID4gMCkge1xuICAgICAgICB0b3RhbEFtb3VudCArPSBiaXRnb0ZlZUluZm8uYW1vdW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IGdldEJpdEdvRmVlQWRkcmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCbHVlYmlyZC50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGJpdGdvRmVlSW5mbywgb3IgYWRkcmVzcyBpcyBhbHJlYWR5IHNldCwgZG9uJ3QgZ2V0IGEgbmV3IG9uZVxuICAgICAgaWYgKCFiaXRnb0ZlZUluZm8gfHwgYml0Z29GZWVJbmZvLmFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpdGdvLmdldEJpdEdvRmVlQWRkcmVzcygpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgYml0Z29GZWVJbmZvLmFkZHJlc3MgPSByZXN1bHQuYWRkcmVzcztcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEdldCBhIGR5bmFtaWMgZmVlIGVzdGltYXRlIGZyb20gdGhlIEJpdEdvIHNlcnZlciBpZiBmZWVUeENvbmZpcm1UYXJnZXRcbiAgLy8gaXMgc3BlY2lmaWVkIG9yIGlmIG5vIGZlZS1yZWxhdGVkIHBhcmFtcyBhcmUgc3BlY2lmaWVkXG4gIGNvbnN0IGdldER5bmFtaWNGZWVSYXRlRXN0aW1hdGUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAocGFyYW1zLmZlZVR4Q29uZmlybVRhcmdldCB8fCAhZmVlUGFyYW1zRGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGJpdGdvLmVzdGltYXRlRmVlKHtcbiAgICAgICAgbnVtQmxvY2tzOiBwYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0LFxuICAgICAgICBtYXhGZWU6IHBhcmFtcy5tYXhGZWVSYXRlLFxuICAgICAgICBpbnB1dHM6IHplcm9Db25mVW5zcGVudFR4SWRzLFxuICAgICAgICB0eFNpemU6IGVzdFR4U2l6ZSxcbiAgICAgICAgY3BmcEF3YXJlOiB0cnVlXG4gICAgICB9KVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IGVzdGltYXRlZEZlZVJhdGUgPSByZXN1bHQuY3BmcEZlZVBlcktiO1xuICAgICAgICBjb25zdCBtaW5pbXVtID0gcGFyYW1zLmluc3RhbnQgPyBNYXRoLm1heChjb25zdGFudHMubWluRmVlUmF0ZSwgY29uc3RhbnRzLm1pbkluc3RhbnRGZWVSYXRlKSA6IGNvbnN0YW50cy5taW5GZWVSYXRlO1xuICAgICAgICAvLyA1IHNhdG9zaGlzIHBlciBieXRlXG4gICAgICAgIC8vIGl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHRoZSBwYWRkaW5nIG9ubHkgYXBwbGllcyB3aGVuIHRoZSB0aHJlc2hvbGQgaXMgY3Jvc3NlZCwgYnV0IG5vdCB3aGVuIHRoZSBkZWx0YSBpcyBsZXNzIHRoYW4gdGhlIHBhZGRpbmdcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IDUwMDA7XG4gICAgICAgIGlmIChlc3RpbWF0ZWRGZWVSYXRlIDwgbWluaW11bSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKG5ldyBEYXRlKCkgKyAnOiBFcnJvciB3aGVuIGVzdGltYXRpbmcgZmVlIGZvciBzZW5kIGZyb20gJyArIHBhcmFtcy53YWxsZXQuaWQoKSArICcsIGl0IHdhcyB0b28gbG93IC0gJyArIGVzdGltYXRlZEZlZVJhdGUpO1xuICAgICAgICAgIGZlZVJhdGUgPSBtaW5pbXVtICsgcGFkZGluZztcbiAgICAgICAgfSBlbHNlIGlmIChlc3RpbWF0ZWRGZWVSYXRlID4gcGFyYW1zLm1heEZlZVJhdGUpIHtcbiAgICAgICAgICBmZWVSYXRlID0gcGFyYW1zLm1heEZlZVJhdGUgLSBwYWRkaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZlZVJhdGUgPSBlc3RpbWF0ZWRGZWVSYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZWVSYXRlO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vIHNhbml0eSBjaGVjayBmYWlsZWQgb24gdHggc2l6ZVxuICAgICAgICBpZiAoXy5pbmNsdWRlcyhlLm1lc3NhZ2UsICdpbnZhbGlkIHR4U2l6ZScpKSB7XG4gICAgICAgICAgcmV0dXJuIEJsdWViaXJkLnJlamVjdChlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb3VsZG4ndCBlc3RpbWF0ZSB0aGUgZmVlLCBwcm9jZWVkIHVzaW5nIHRoZSBkZWZhdWx0XG4gICAgICAgICAgZmVlUmF0ZSA9IGNvbnN0YW50cy5mYWxsYmFja0ZlZVJhdGU7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIGVzdGltYXRpbmcgZmVlIGZvciBzZW5kIGZyb20gJyArIHBhcmFtcy53YWxsZXQuaWQoKSArICc6ICcgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuXG4gIC8vIEdldCB0aGUgdW5zcGVudHMgZm9yIHRoZSBzZW5kaW5nIHdhbGxldC5cbiAgY29uc3QgZ2V0VW5zcGVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmIChwYXJhbXMudW5zcGVudHMpIHsgLy8gd2UganVzdCB3YW5uYSB1c2UgY3VzdG9tIHVuc3BlbnRzXG4gICAgICB1bnNwZW50cyA9IHBhcmFtcy51bnNwZW50cztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgZW5vdWdoIHVuc3BlbnRzIGZvciB0aGUgcmVxdWVzdGVkIGFtb3VudFxuICAgIGNvbnN0IG9wdGlvbnMgPSBfLm1lcmdlKHt9LCBwYXJhbXMudW5zcGVudHNGZXRjaFBhcmFtcyB8fCB7fSwge1xuICAgICAgdGFyZ2V0OiB0b3RhbEFtb3VudCxcbiAgICAgIG1pblNpemU6IHBhcmFtcy5taW5VbnNwZW50U2l6ZSB8fCAwLFxuICAgICAgaW5zdGFudDogcGFyYW1zLmluc3RhbnQsIC8vIGluc2lzdCBvbiBpbnN0YW50IHVuc3BlbnRzIG9ubHlcbiAgICAgIHRhcmdldFdhbGxldFVuc3BlbnRzOiBwYXJhbXMudGFyZ2V0V2FsbGV0VW5zcGVudHNcbiAgICB9KTtcbiAgICBpZiAocGFyYW1zLmluc3RhbnQpIHtcbiAgICAgIG9wdGlvbnMuaW5zdGFudCA9IHBhcmFtcy5pbnN0YW50OyAvLyBpbnNpc3Qgb24gaW5zdGFudCB1bnNwZW50cyBvbmx5XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcy53YWxsZXQudW5zcGVudHNQYWdlZChvcHRpb25zKVxuICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIHRvdGFsVW5zcGVudHNDb3VudCA9IHJlc3VsdHMudG90YWw7XG4gICAgICBmZXRjaGVkVW5zcGVudHNDb3VudCA9IHJlc3VsdHMuY291bnQ7XG4gICAgICB1bnNwZW50cyA9IHJlc3VsdHMudW5zcGVudHMuZmlsdGVyKGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgY29uc3QgY29uZmlybXMgPSB1LmNvbmZpcm1hdGlvbnMgfHwgMDtcbiAgICAgICAgaWYgKCFwYXJhbXMuZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlICYmIHUuaXNDaGFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlybXMgPj0gbWluQ29uZmlybXM7XG4gICAgICB9KTtcblxuICAgICAgLy8gYWJvcnQgZWFybHkgaWYgdGhlcmUncyBubyB2aWFibGUgdW5zcGVudHMsIGJlY2F1c2UgaXQgd29uJ3QgYmUgcG9zc2libGUgdG8gY3JlYXRlIHRoZSB0eG4gbGF0ZXJcbiAgICAgIGlmICh1bnNwZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJzAgdW5zcGVudHMgYXZhaWxhYmxlIGZvciB0cmFuc2FjdGlvbiBjcmVhdGlvbicpO1xuICAgICAgfVxuXG4gICAgICAvLyBjcmVhdGUgYXJyYXkgb2YgdW5jb25maXJtZWQgdW5zcGVudCBJRCBzdHJpbmdzIG9mIHRoZSBmb3JtIFwidHhIYXNoOm91dHB1dEluZGV4XCJcbiAgICAgIHplcm9Db25mVW5zcGVudFR4SWRzID0gXyhyZXN1bHRzLnVuc3BlbnRzKS5maWx0ZXIoZnVuY3Rpb24odSkge1xuICAgICAgICByZXR1cm4gIXUuY29uZmlybWF0aW9ucztcbiAgICAgIH0pLm1hcChmdW5jdGlvbih1KSB7XG4gICAgICAgIHJldHVybiB1LnR4X2hhc2ggKyAnOicgKyB1LnR4X291dHB1dF9uO1xuICAgICAgfSkudmFsdWUoKTtcbiAgICAgIGlmIChfLmlzRW1wdHkoemVyb0NvbmZVbnNwZW50VHhJZHMpKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gcGFzcyBhbiBlbXB0eSBhcnJheSBvZiBpbnB1dHMgdG8gdGhlIHNlcnZlciwgYmVjYXVzZSBpdCBhc3N1bWVzIGlmIHRoZVxuICAgICAgICAvLyBpbnB1dHMgYXJndW1lbnRzIGV4aXN0cywgaXQgY29udGFpbnMgdmFsdWVzXG4gICAgICAgIHplcm9Db25mVW5zcGVudFR4SWRzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHJlc3BlY3QgdGhlIG9sZCBzcGxpdENoYW5nZVNpemU9MCBwYXJhbWV0ZXJcbiAgICAgIGlmICghcGFyYW1zLm5vU3BsaXRDaGFuZ2UgJiYgcGFyYW1zLnNwbGl0Q2hhbmdlU2l6ZSAhPT0gMCkge1xuICAgICAgICBleHRyYUNoYW5nZUFtb3VudHMgPSByZXN1bHRzLmV4dHJhQ2hhbmdlQW1vdW50cyB8fCBbXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIHVuc3BlbnRzIGZvciB0aGUgc2luZ2xlIGtleSBmZWUgYWRkcmVzc1xuICBsZXQgZmVlU2luZ2xlS2V5VW5zcGVudHM6IEJpdEdvVW5zcGVudFtdID0gW107XG4gIGNvbnN0IGdldFVuc3BlbnRzRm9yU2luZ2xlS2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MpIHtcbiAgICAgIGxldCBmZWVUYXJnZXQgPSAwLjAxZTg7XG4gICAgICBpZiAocGFyYW1zLmluc3RhbnQpIHtcbiAgICAgICAgZmVlVGFyZ2V0ICs9IHRvdGFsQW1vdW50ICogMC4wMDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYml0Z28uZ2V0KGJpdGdvLnVybCgnL2FkZHJlc3MvJyArIGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgKyAnL3Vuc3BlbnRzP3RhcmdldD0nICsgZmVlVGFyZ2V0KSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5ib2R5LnRvdGFsIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHVuc3BlbnRzIGF2YWlsYWJsZSBpbiBzaW5nbGUga2V5IGZlZSBzb3VyY2UnKTtcbiAgICAgICAgfVxuICAgICAgICBmZWVTaW5nbGVLZXlVbnNwZW50cyA9IHJlc3BvbnNlLmJvZHkudW5zcGVudHM7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgbGV0IG1pbmVyRmVlSW5mbzogYW55ID0ge307XG4gIGxldCB0eEluZm86IGFueSA9IHt9O1xuXG4gIC8vIEl0ZXJhdGUgdW5zcGVudHMsIHN1bSB0aGUgaW5wdXRzLCBhbmQgc2F2ZSBfaW5wdXRzIHdpdGggdGhlIHRvdGFsXG4gIC8vIGlucHV0IGFtb3VudCBhbmQgZmluYWwgbGlzdCBvZiBpbnB1dHMgdG8gdXNlIHdpdGggdGhlIHRyYW5zYWN0aW9uLlxuICBsZXQgZmVlU2luZ2xlS2V5VW5zcGVudHNVc2VkOiBCaXRHb1Vuc3BlbnRbXSA9IFtdO1xuXG4gIGNvbnN0IGNvbGxlY3RJbnB1dHMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXVuc3BlbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyB1bnNwZW50cyBhdmFpbGFibGUgb24gd2FsbGV0Jyk7XG4gICAgfVxuICAgIGlucHV0QW1vdW50ID0gMDtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY29zdCBvZiBzcGVuZGluZyBhIHNpbmdsZSBpbnB1dCwgaS5lLiB0aGUgc21hbGxlc3QgZWNvbm9taWNhbCB1bnNwZW50IHZhbHVlXG4gICAgcmV0dXJuIEJsdWViaXJkLnRyeShmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKF8uaXNOdW1iZXIocGFyYW1zLmZlZVJhdGUpIHx8IF8uaXNOdW1iZXIocGFyYW1zLm9yaWdpbmFsRmVlUmF0ZSkpIHtcbiAgICAgICAgcmV0dXJuICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZmVlUmF0ZSkgPyBwYXJhbXMuZmVlUmF0ZSA6IHBhcmFtcy5vcmlnaW5hbEZlZVJhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJpdGdvLmVzdGltYXRlRmVlKHtcbiAgICAgICAgICBudW1CbG9ja3M6IHBhcmFtcy5mZWVUeENvbmZpcm1UYXJnZXQsXG4gICAgICAgICAgbWF4RmVlOiBwYXJhbXMubWF4RmVlUmF0ZVxuICAgICAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbihmZWVSYXRlRXN0aW1hdGUpIHtcbiAgICAgICAgICByZXR1cm4gZmVlUmF0ZUVzdGltYXRlLmZlZVBlcktiO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KS50aGVuKGZ1bmN0aW9uKGZlZVJhdGUpIHtcbiAgICAgIC8vIERvbid0IHNwZW5kIGlucHV0cyB0aGF0IGNhbm5vdCBwYXkgZm9yIHRoZWlyIG93biBjb3N0LlxuICAgICAgbGV0IG1pbklucHV0VmFsdWUgPSAwO1xuICAgICAgaWYgKF8uaXNJbnRlZ2VyKHBhcmFtcy5taW5VbnNwZW50U2l6ZSkpIHtcbiAgICAgICAgbWluSW5wdXRWYWx1ZSA9IHBhcmFtcy5taW5VbnNwZW50U2l6ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IHBydW5lZFVuc3BlbnRDb3VudCA9IDA7XG4gICAgICBjb25zdCBvcmlnaW5hbFVuc3BlbnRDb3VudCA9IHVuc3BlbnRzLmxlbmd0aDtcbiAgICAgIHVuc3BlbnRzID0gXy5maWx0ZXIodW5zcGVudHMsIGZ1bmN0aW9uKHVuc3BlbnQpIHtcbiAgICAgICAgY29uc3QgaXNTZWd3aXRJbnB1dCA9ICEhdW5zcGVudC53aXRuZXNzU2NyaXB0O1xuICAgICAgICBjb25zdCBjdXJyZW50SW5wdXRTaXplID0gaXNTZWd3aXRJbnB1dCA/IFZpcnR1YWxTaXplcy50eFAyc2hQMndzaElucHV0U2l6ZSA6IFZpcnR1YWxTaXplcy50eFAyc2hJbnB1dFNpemU7XG4gICAgICAgIGNvbnN0IGZlZUJhc2VkTWluSW5wdXRWYWx1ZSA9IChmZWVSYXRlICogY3VycmVudElucHV0U2l6ZSkgLyAxMDAwO1xuICAgICAgICBjb25zdCBjdXJyZW50TWluSW5wdXRWYWx1ZSA9IE1hdGgubWF4KG1pbklucHV0VmFsdWUsIGZlZUJhc2VkTWluSW5wdXRWYWx1ZSk7XG4gICAgICAgIGlmIChjdXJyZW50TWluSW5wdXRWYWx1ZSA+IHVuc3BlbnQudmFsdWUpIHtcbiAgICAgICAgICAvLyBwcnVuaW5nIHVuc3BlbnRcbiAgICAgICAgICBjb25zdCBwcnVuZURldGFpbHMgPSB7XG4gICAgICAgICAgICBnZW5lcmFsTWluSW5wdXRWYWx1ZTogbWluSW5wdXRWYWx1ZSxcbiAgICAgICAgICAgIGZlZUJhc2VkTWluSW5wdXRWYWx1ZSxcbiAgICAgICAgICAgIGN1cnJlbnRNaW5JbnB1dFZhbHVlLFxuICAgICAgICAgICAgZmVlUmF0ZSxcbiAgICAgICAgICAgIGlucHV0U2l6ZTogY3VycmVudElucHV0U2l6ZSxcbiAgICAgICAgICAgIHVuc3BlbnQ6IHVuc3BlbnRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBwcnVuaW5nIHVuc3BlbnQ6ICR7SlNPTi5zdHJpbmdpZnkocHJ1bmVEZXRhaWxzLCBudWxsLCA0KX1gKTtcbiAgICAgICAgICBwcnVuZWRVbnNwZW50Q291bnQrKztcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHBydW5lZFVuc3BlbnRDb3VudCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coYHBydW5lZCAke3BydW5lZFVuc3BlbnRDb3VudH0gb3V0IG9mICR7b3JpZ2luYWxVbnNwZW50Q291bnR9IHVuc3BlbnRzYCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1bnNwZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnN1ZmZpY2llbnQgZnVuZHMnKTtcbiAgICAgIH1cbiAgICAgIGxldCBzZWd3aXRJbnB1dENvdW50ID0gMDtcbiAgICAgIHVuc3BlbnRzLmV2ZXJ5KGZ1bmN0aW9uKHVuc3BlbnQpIHtcbiAgICAgICAgaWYgKHVuc3BlbnQud2l0bmVzc1NjcmlwdCkge1xuICAgICAgICAgIHNlZ3dpdElucHV0Q291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBpbnB1dEFtb3VudCArPSB1bnNwZW50LnZhbHVlO1xuICAgICAgICB0cmFuc2FjdGlvbi5hZGRJbnB1dCh1bnNwZW50LnR4X2hhc2gsIHVuc3BlbnQudHhfb3V0cHV0X24sIDB4ZmZmZmZmZmYpO1xuXG4gICAgICAgIHJldHVybiAoaW5wdXRBbW91bnQgPCAoZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyA/IHRvdGFsT3V0cHV0QW1vdW50IDogdG90YWxBbW91bnQpKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBpZiBwYXlpbmcgZmVlcyBmcm9tIGFuIGV4dGVybmFsIHNpbmdsZSBrZXkgd2FsbGV0LCBhZGQgdGhlIGlucHV0c1xuICAgICAgaWYgKGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MpIHtcbiAgICAgICAgLy8gY29sbGVjdCB0aGUgYW1vdW50IHVzZWQgaW4gdGhlIGZlZSBpbnB1dHMgc28gd2UgY2FuIGdldCBjaGFuZ2UgbGF0ZXJcbiAgICAgICAgZmVlU2luZ2xlS2V5SW5wdXRBbW91bnQgPSAwO1xuICAgICAgICBmZWVTaW5nbGVLZXlVbnNwZW50c1VzZWQgPSBbXTtcbiAgICAgICAgZmVlU2luZ2xlS2V5VW5zcGVudHMuZXZlcnkoZnVuY3Rpb24odW5zcGVudCkge1xuICAgICAgICAgIGZlZVNpbmdsZUtleUlucHV0QW1vdW50ICs9IHVuc3BlbnQudmFsdWU7XG4gICAgICAgICAgaW5wdXRBbW91bnQgKz0gdW5zcGVudC52YWx1ZTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGRJbnB1dCh1bnNwZW50LnR4X2hhc2gsIHVuc3BlbnQudHhfb3V0cHV0X24pO1xuICAgICAgICAgIGZlZVNpbmdsZUtleVVuc3BlbnRzVXNlZC5wdXNoKHVuc3BlbnQpO1xuICAgICAgICAgIC8vIHVzZSB0aGUgZmVlIHdhbGxldCB0byBwYXkgbWluZXIgZmVlcyBhbmQgcG90ZW50aWFsbHkgaW5zdGFudCBmZWVzXG4gICAgICAgICAgcmV0dXJuIChmZWVTaW5nbGVLZXlJbnB1dEFtb3VudCA8IChmZWUgKyAoYml0Z29GZWVJbmZvID8gYml0Z29GZWVJbmZvLmFtb3VudCA6IDApKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0eEluZm8gPSB7XG4gICAgICAgIG5QMnNoSW5wdXRzOiB0cmFuc2FjdGlvbi50eC5pbnMubGVuZ3RoIC0gKGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgPyAxIDogMCkgLSBzZWd3aXRJbnB1dENvdW50LFxuICAgICAgICBuUDJzaFAyd3NoSW5wdXRzOiBzZWd3aXRJbnB1dENvdW50LFxuICAgICAgICBuUDJwa2hJbnB1dHM6IGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MgPyAxIDogMCxcbiAgICAgICAgbk91dHB1dHM6IChcbiAgICAgICAgICByZWNpcGllbnRzLmxlbmd0aCArIDEgKyAvLyByZWNpcGllbnRzIGFuZCBjaGFuZ2VcbiAgICAgICAgZXh0cmFDaGFuZ2VBbW91bnRzLmxlbmd0aCArIC8vIGV4dHJhIGNoYW5nZSBzcGxpdHRpbmdcbiAgICAgICAgKGJpdGdvRmVlSW5mbyAmJiBiaXRnb0ZlZUluZm8uYW1vdW50ID4gMCA/IDEgOiAwKSArIC8vIGFkZCBvdXRwdXQgZm9yIGJpdGdvIGZlZVxuICAgICAgICAoZmVlU2luZ2xlS2V5U291cmNlQWRkcmVzcyA/IDEgOiAwKSAvLyBhZGQgc2luZ2xlIGtleSBzb3VyY2UgYWRkcmVzcyBjaGFuZ2VcbiAgICAgICAgKVxuICAgICAgfTtcblxuICAgICAgZXN0VHhTaXplID0gZXN0aW1hdGVUcmFuc2FjdGlvblNpemUoe1xuICAgICAgICBuUDJzaElucHV0czogdHhJbmZvLm5QMnNoSW5wdXRzLFxuICAgICAgICBuUDJzaFAyd3NoSW5wdXRzOiB0eEluZm8ublAyc2hQMndzaElucHV0cyxcbiAgICAgICAgblAycGtoSW5wdXRzOiB0eEluZm8ublAycGtoSW5wdXRzLFxuICAgICAgICBuT3V0cHV0czogdHhJbmZvLm5PdXRwdXRzXG4gICAgICB9KTtcbiAgICB9KS50aGVuKGdldER5bmFtaWNGZWVSYXRlRXN0aW1hdGUpXG4gICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICBtaW5lckZlZUluZm8gPSBleHBvcnRzLmNhbGN1bGF0ZU1pbmVyRmVlSW5mbyh7XG4gICAgICAgIGJpdGdvOiBwYXJhbXMud2FsbGV0LmJpdGdvLFxuICAgICAgICBmZWVSYXRlOiBmZWVSYXRlLFxuICAgICAgICBuUDJzaElucHV0czogdHhJbmZvLm5QMnNoSW5wdXRzLFxuICAgICAgICBuUDJzaFAyd3NoSW5wdXRzOiB0eEluZm8ublAyc2hQMndzaElucHV0cyxcbiAgICAgICAgblAycGtoSW5wdXRzOiB0eEluZm8ublAycGtoSW5wdXRzLFxuICAgICAgICBuT3V0cHV0czogdHhJbmZvLm5PdXRwdXRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKHNob3VsZENvbXB1dGVCZXN0RmVlKSB7XG4gICAgICAgIGNvbnN0IGFwcHJveGltYXRlRmVlID0gbWluZXJGZWVJbmZvLmZlZTtcbiAgICAgICAgY29uc3Qgc2hvdWxkUmVjdXJzZSA9IF8uaXNVbmRlZmluZWQoZmVlKSB8fCBhcHByb3hpbWF0ZUZlZSA+IGZlZTtcbiAgICAgICAgZmVlID0gYXBwcm94aW1hdGVGZWU7XG4gICAgICAgIC8vIFJlY29tcHV0ZSB0b3RhbEFtb3VudCBmcm9tIHNjcmF0Y2hcbiAgICAgICAgdG90YWxBbW91bnQgPSBmZWUgKyB0b3RhbE91dHB1dEFtb3VudDtcbiAgICAgICAgaWYgKGJpdGdvRmVlSW5mbykge1xuICAgICAgICAgIHRvdGFsQW1vdW50ICs9IGJpdGdvRmVlSW5mby5hbW91bnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFJlY3Vyc2UpIHtcbiAgICAgICAgICAvLyBpZiBmZWUgY2hhbmdlZCwgcmUtY29sbGVjdCBpbnB1dHNcbiAgICAgICAgICBpbnB1dEFtb3VudCA9IDA7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSBuZXcgYml0Y29pbi5UcmFuc2FjdGlvbkJ1aWxkZXIobmV0d29yayk7XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3RJbnB1dHMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB0b3RhbEZlZSA9IGZlZSArIChiaXRnb0ZlZUluZm8gPyBiaXRnb0ZlZUluZm8uYW1vdW50IDogMCk7XG5cbiAgICAgIGlmIChmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IHN1bW1lZFNpbmdsZUtleVVuc3BlbnRzID0gXy5zdW1CeShmZWVTaW5nbGVLZXlVbnNwZW50cywgJ3ZhbHVlJyk7XG4gICAgICAgIGlmICh0b3RhbEZlZSA+IHN1bW1lZFNpbmdsZUtleVVuc3BlbnRzKSB7XG4gICAgICAgICAgY29uc3QgZXJyOiBhbnkgPSBuZXcgRXJyb3IoJ0luc3VmZmljaWVudCBmZWUgYW1vdW50IGF2YWlsYWJsZSBpbiBzaW5nbGUga2V5IGZlZSBzb3VyY2U6ICcgKyBzdW1tZWRTaW5nbGVLZXlVbnNwZW50cyk7XG4gICAgICAgICAgZXJyLnJlc3VsdCA9IHtcbiAgICAgICAgICAgIGZlZTogZmVlLFxuICAgICAgICAgICAgZmVlUmF0ZTogZmVlUmF0ZSxcbiAgICAgICAgICAgIGVzdGltYXRlZFNpemU6IG1pbmVyRmVlSW5mby5zaXplLFxuICAgICAgICAgICAgYXZhaWxhYmxlOiBpbnB1dEFtb3VudCxcbiAgICAgICAgICAgIGJpdGdvRmVlOiBiaXRnb0ZlZUluZm8sXG4gICAgICAgICAgICB0eEluZm86IHR4SW5mb1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIEJsdWViaXJkLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnB1dEFtb3VudCA8IChmZWVTaW5nbGVLZXlTb3VyY2VBZGRyZXNzID8gdG90YWxPdXRwdXRBbW91bnQgOiB0b3RhbEFtb3VudCkpIHtcbiAgICAgICAgLy8gVGhlIHVuc3BlbnRzIHdlJ3JlIHVzaW5nIGZvciBpbnB1dHMgZG8gbm90IGhhdmUgc3VmZmljaWVudCB2YWx1ZSBvbiB0aGVtIHRvXG4gICAgICAgIC8vIHNhdGlzZnkgdGhlIHVzZXIncyByZXF1ZXN0ZWQgc3BlbmQgYW1vdW50LiBUaGF0IG1heSBiZSBiZWNhdXNlIHRoZSB3YWxsZXQncyBiYWxhbmNlXG4gICAgICAgIC8vIGlzIHNpbXBseSB0b28gbG93LCBvciBpdCBtaWdodCBiZSB0aGF0IHRoZSB3YWxsZXQncyBiYWxhbmNlIGlzIHN1ZmZpY2llbnQgYnV0XG4gICAgICAgIC8vIHdlIGRpZG4ndCBmZXRjaCBlbm91Z2ggdW5zcGVudHMuIFRvbyBmZXcgdW5zcGVudHMgY291bGQgcmVzdWx0IGZyb20gdGhlIHdhbGxldFxuICAgICAgICAvLyBoYXZpbmcgbWFueSBzbWFsbCB1bnNwZW50cyBhbmQgd2UgaGl0IG91ciBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIGlucHV0cyB3ZSBjYW4gdXNlXG4gICAgICAgIC8vIGluIGEgdHhuLCBvciBpdCBtaWdodCBoYXZlIGJlZW4gdGhhdCB0aGUgZmlsdGVycyB0aGUgdXNlciBwYXNzZWQgaW4gKGxpa2UgbWluQ29uZmlybXMpXG4gICAgICAgIC8vIGRpc3F1YWxpZmllZCB0b28gbWFueSBvZiB0aGUgdW5zcGVudHNcbiAgICAgICAgbGV0IGVycjtcbiAgICAgICAgaWYgKHRvdGFsVW5zcGVudHNDb3VudCA9PT0gZmV0Y2hlZFVuc3BlbnRzQ291bnQpIHtcbiAgICAgICAgICAvLyB3ZSBmZXRjaGVkIGV2ZXJ5IHVuc3BlbnQgdGhlIHdhbGxldCBoYWQsIGJ1dCBpdCBzdGlsbCB3YXNuJ3QgZW5vdWdoXG4gICAgICAgICAgZXJyID0gbmV3IEVycm9yKCdJbnN1ZmZpY2llbnQgZnVuZHMnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB3ZSB3ZXJlbid0IGFibGUgdG8gZmV0Y2ggYWxsIHRoZSB1bnNwZW50cyBvbiB0aGUgd2FsbGV0XG4gICAgICAgICAgZXJyID0gbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBzaXplIHRvbyBsYXJnZSBkdWUgdG8gdG9vIG1hbnkgdW5zcGVudHMuIENhbiBzZW5kIG9ubHkgJHtpbnB1dEFtb3VudH0gc2F0b3NoaXMgaW4gdGhpcyB0cmFuc2FjdGlvbmApO1xuICAgICAgICB9XG4gICAgICAgIGVyci5yZXN1bHQgPSB7XG4gICAgICAgICAgZmVlOiBmZWUsXG4gICAgICAgICAgZmVlUmF0ZTogZmVlUmF0ZSxcbiAgICAgICAgICBlc3RpbWF0ZWRTaXplOiBtaW5lckZlZUluZm8uc2l6ZSxcbiAgICAgICAgICBhdmFpbGFibGU6IGlucHV0QW1vdW50LFxuICAgICAgICAgIGJpdGdvRmVlOiBiaXRnb0ZlZUluZm8sXG4gICAgICAgICAgdHhJbmZvOiB0eEluZm9cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJsdWViaXJkLnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8vIEFkZCB0aGUgb3V0cHV0cyBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgY29uc3QgY29sbGVjdE91dHB1dHMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAobWluZXJGZWVJbmZvLnNpemUgPj0gOTAwMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gdG9vIGxhcmdlOiBlc3RpbWF0ZWQgc2l6ZSAnICsgbWluZXJGZWVJbmZvLnNpemUgKyAnIGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0czogT3V0cHV0W10gPSBbXTtcblxuICAgIHJlY2lwaWVudHMuZm9yRWFjaChmdW5jdGlvbihyZWNpcGllbnQpIHtcbiAgICAgIGxldCBzY3JpcHQ7XG4gICAgICBpZiAoXy5pc1N0cmluZyhyZWNpcGllbnQuYWRkcmVzcykpIHtcbiAgICAgICAgc2NyaXB0ID0gYml0Y29pbi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KHJlY2lwaWVudC5hZGRyZXNzLCBuZXR3b3JrKTtcbiAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChyZWNpcGllbnQuc2NyaXB0KSkge1xuICAgICAgICBzY3JpcHQgPSByZWNpcGllbnQuc2NyaXB0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWl0aGVyIHJlY2lwaWVudCBhZGRyZXNzIG5vciBzY3JpcHQgd2FzIHByb3ZpZGVkJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkYXRlIHRyYXZlbEluZm8gaWYgaXQgZXhpc3RzXG4gICAgICBsZXQgdHJhdmVsSW5mbztcbiAgICAgIGlmICghXy5pc0VtcHR5KHJlY2lwaWVudC50cmF2ZWxJbmZvKSkge1xuICAgICAgICB0cmF2ZWxJbmZvID0gcmVjaXBpZW50LnRyYXZlbEluZm87XG4gICAgICAgIC8vIEJldHRlciB0byBhdm9pZCB0cm91YmxlIG5vdywgYmVmb3JlIHR4IGlzIGNyZWF0ZWRcbiAgICAgICAgYml0Z28udHJhdmVsUnVsZSgpLnZhbGlkYXRlVHJhdmVsSW5mbyh0cmF2ZWxJbmZvKTtcbiAgICAgIH1cblxuICAgICAgb3V0cHV0cy5wdXNoKHtcbiAgICAgICAgc2NyaXB0OiBzY3JpcHQsXG4gICAgICAgIGFtb3VudDogcmVjaXBpZW50LmFtb3VudCxcbiAgICAgICAgdHJhdmVsSW5mbzogdHJhdmVsSW5mb1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBvcFJldHVybnMuZm9yRWFjaChmdW5jdGlvbih7IG1lc3NhZ2UsIGFtb3VudCB9KSB7XG4gICAgICBjb25zdCBzY3JpcHQgPSBiaXRjb2luLnNjcmlwdC5mcm9tQVNNKCdPUF9SRVRVUk4gJyArIEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICBvdXRwdXRzLnB1c2goeyBzY3JpcHQsIGFtb3VudCB9KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGdldENoYW5nZU91dHB1dHMgPSBmdW5jdGlvbihjaGFuZ2VBbW91bnQ6IG51bWJlcik6IE91dHB1dFtdIHwgQmx1ZWJpcmQ8T3V0cHV0W10+IHtcbiAgICAgIGlmIChjaGFuZ2VBbW91bnQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmVnYXRpdmUgY2hhbmdlIGFtb3VudDogJyArIGNoYW5nZUFtb3VudCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdDogT3V0cHV0W10gPSBbXTtcbiAgICAgIC8vIGlmIHdlIHBhaWQgZmVlcyBmcm9tIGEgc2luZ2xlIGtleSB3YWxsZXQsIHJldHVybiB0aGUgZmVlIGNoYW5nZSBmaXJzdFxuICAgICAgaWYgKGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgZmVlU2luZ2xlS2V5V2FsbGV0Q2hhbmdlQW1vdW50ID0gZmVlU2luZ2xlS2V5SW5wdXRBbW91bnQgLSAoZmVlICsgKGJpdGdvRmVlSW5mbyA/IGJpdGdvRmVlSW5mby5hbW91bnQgOiAwKSk7XG4gICAgICAgIGlmIChmZWVTaW5nbGVLZXlXYWxsZXRDaGFuZ2VBbW91bnQgPj0gY29uc3RhbnRzLm1pbk91dHB1dFNpemUpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh7IGFkZHJlc3M6IGZlZVNpbmdsZUtleVNvdXJjZUFkZHJlc3MsIGFtb3VudDogZmVlU2luZ2xlS2V5V2FsbGV0Q2hhbmdlQW1vdW50IH0pO1xuICAgICAgICAgIGNoYW5nZUFtb3VudCA9IGNoYW5nZUFtb3VudCAtIGZlZVNpbmdsZUtleVdhbGxldENoYW5nZUFtb3VudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlQW1vdW50IDwgY29uc3RhbnRzLm1pbk91dHB1dFNpemUpIHtcbiAgICAgICAgLy8gR2l2ZSBpdCB0byB0aGUgbWluZXJzXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMud2FsbGV0LnR5cGUoKSA9PT0gJ3NhZmUnKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMud2FsbGV0LmFkZHJlc3NlcygpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goeyBhZGRyZXNzOiByZXNwb25zZS5hZGRyZXNzZXNbMF0uYWRkcmVzcywgYW1vdW50OiBjaGFuZ2VBbW91bnQgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBleHRyYUNoYW5nZVRvdGFsID0gXy5zdW0oZXh0cmFDaGFuZ2VBbW91bnRzKTtcbiAgICAgIC8vIFNhbml0eSBjaGVja1xuICAgICAgaWYgKGV4dHJhQ2hhbmdlVG90YWwgPiBjaGFuZ2VBbW91bnQpIHtcbiAgICAgICAgZXh0cmFDaGFuZ2VBbW91bnRzID0gW107XG4gICAgICAgIGV4dHJhQ2hhbmdlVG90YWwgPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBjb3B5IGFuZCBhZGQgcmVtYWluaW5nIGNoYW5nZSBhbW91bnRcbiAgICAgIGNvbnN0IGFsbENoYW5nZUFtb3VudHMgPSBleHRyYUNoYW5nZUFtb3VudHMuc2xpY2UoMCk7XG4gICAgICBhbGxDaGFuZ2VBbW91bnRzLnB1c2goY2hhbmdlQW1vdW50IC0gZXh0cmFDaGFuZ2VUb3RhbCk7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZSBhc3luYyBmdW5jIHRvIGFkZCBhbGwgY2hhbmdlIG91dHB1dHNcbiAgICAgIGNvbnN0IGFkZENoYW5nZU91dHB1dHMgPSBmdW5jdGlvbigpOiBPdXRwdXRbXSB8IEJsdWViaXJkPE91dHB1dFtdPiB7XG4gICAgICAgIGNvbnN0IHRoaXNBbW91bnQgPSBhbGxDaGFuZ2VBbW91bnRzLnNoaWZ0KCk7XG4gICAgICAgIGlmICghdGhpc0Ftb3VudCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJsdWViaXJkLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLmNoYW5nZUFkZHJlc3MpIHtcbiAgICAgICAgICAgIC8vIElmIHVzZXIgcGFzc2VkIGEgY2hhbmdlIGFkZHJlc3MsIHVzZSBpdCBmb3IgYWxsIG91dHB1dHNcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuY2hhbmdlQWRkcmVzcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBhZGRyZXNzIHBlciBvdXRwdXQsIGZvciBwcml2YWN5XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgaWYgc2Vnd2l0IG9yIG5vdFxuICAgICAgICAgICAgY29uc3QgY2hhbmdlQ2hhaW4gPSBwYXJhbXMud2FsbGV0LmdldENoYW5nZUNoYWluKHBhcmFtcyk7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLndhbGxldC5jcmVhdGVBZGRyZXNzKHsgY2hhaW46IGNoYW5nZUNoYWluLCB2YWxpZGF0ZTogdmFsaWRhdGUgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmFkZHJlc3M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGFkZHJlc3MpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh7IGFkZHJlc3M6IGFkZHJlc3MsIGFtb3VudDogdGhpc0Ftb3VudCB9KTtcbiAgICAgICAgICByZXR1cm4gYWRkQ2hhbmdlT3V0cHV0cygpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBhZGRDaGFuZ2VPdXRwdXRzKCk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBjaGFuZ2Ugb3V0cHV0KHMpIGFuZCBpbnN0YW50IGZlZSBvdXRwdXQgaWYgYXBwbGljYWJsZVxuICAgIHJldHVybiBCbHVlYmlyZC50cnkoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0Q2hhbmdlT3V0cHV0cyhpbnB1dEFtb3VudCAtIHRvdGFsQW1vdW50KTtcbiAgICB9KVxuICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgY2hhbmdlT3V0cHV0cyA9IHJlc3VsdDtcbiAgICAgIGNvbnN0IGV4dHJhT3V0cHV0cyA9IGNoYW5nZU91dHB1dHMuY29uY2F0KFtdKTsgLy8gY29weSB0aGUgYXJyYXlcbiAgICAgIGlmIChiaXRnb0ZlZUluZm8gJiYgYml0Z29GZWVJbmZvLmFtb3VudCA+IDApIHtcbiAgICAgICAgZXh0cmFPdXRwdXRzLnB1c2goYml0Z29GZWVJbmZvKTtcbiAgICAgIH1cbiAgICAgIGV4dHJhT3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICBpZiAoKG91dHB1dCBhcyBBZGRyZXNzT3V0cHV0KS5hZGRyZXNzKSB7XG4gICAgICAgICAgKG91dHB1dCBhcyBTY3JpcHRPdXRwdXQpLnNjcmlwdCA9XG4gICAgICAgICAgICBiaXRjb2luLmFkZHJlc3MudG9PdXRwdXRTY3JpcHQoKG91dHB1dCBhcyBBZGRyZXNzT3V0cHV0KS5hZGRyZXNzLCBuZXR3b3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlY2lkZSB3aGVyZSB0byBwdXQgdGhlIG91dHB1dHMgLSBkZWZhdWx0IGlzIHRvIHJhbmRvbWl6ZSB1bmxlc3MgZm9yY2VkIHRvIGVuZFxuICAgICAgICBjb25zdCBvdXRwdXRJbmRleCA9IHBhcmFtcy5mb3JjZUNoYW5nZUF0RW5kID8gb3V0cHV0cy5sZW5ndGggOiBfLnJhbmRvbSgwLCBvdXRwdXRzLmxlbmd0aCk7XG4gICAgICAgIG91dHB1dHMuc3BsaWNlKG91dHB1dEluZGV4LCAwLCBvdXRwdXQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZCBhbGwgb3V0cHV0cyB0byB0aGUgdHJhbnNhY3Rpb25cbiAgICAgIG91dHB1dHMuZm9yRWFjaChmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uYWRkT3V0cHV0KChvdXRwdXQgYXMgU2NyaXB0T3V0cHV0KS5zY3JpcHQsIG91dHB1dC5hbW91bnQpO1xuICAgICAgfSk7XG5cbiAgICAgIHRyYXZlbEluZm9zID0gXyhvdXRwdXRzKS5tYXAoZnVuY3Rpb24ob3V0cHV0LCBpbmRleCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBvdXRwdXQudHJhdmVsSW5mbztcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5vdXRwdXRJbmRleCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKVxuICAgICAgLnZhbHVlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gU2VyaWFsaXplIHRoZSB0cmFuc2FjdGlvbiwgcmV0dXJuaW5nIHdoYXQgaXMgbmVlZGVkIHRvIHNpZ24gaXRcbiAgY29uc3Qgc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gb25seSBuZWVkIHRvIHJldHVybiB0aGUgdW5zcGVudHMgdGhhdCB3ZXJlIHVzZWQgYW5kIGp1c3QgdGhlIGNoYWluUGF0aCwgcmVkZWVtU2NyaXB0LCBhbmQgaW5zdGFudCBmbGFnXG4gICAgY29uc3QgcGlja2VkVW5zcGVudHM6IGFueSA9IF8ubWFwKHVuc3BlbnRzLCBmdW5jdGlvbih1bnNwZW50KSB7XG4gICAgICByZXR1cm4gXy5waWNrKHVuc3BlbnQsIFsnY2hhaW5QYXRoJywgJ3JlZGVlbVNjcmlwdCcsICdpbnN0YW50JywgJ3dpdG5lc3NTY3JpcHQnLCAnc2NyaXB0JywgJ3ZhbHVlJ10pO1xuICAgIH0pO1xuICAgIGNvbnN0IHBydW5lZFVuc3BlbnRzID0gXy5zbGljZShwaWNrZWRVbnNwZW50cywgMCwgdHJhbnNhY3Rpb24udHguaW5zLmxlbmd0aCAtIGZlZVNpbmdsZUtleVVuc3BlbnRzVXNlZC5sZW5ndGgpO1xuICAgIF8uZWFjaChmZWVTaW5nbGVLZXlVbnNwZW50c1VzZWQsIGZ1bmN0aW9uKGZlZVVuc3BlbnQpIHtcbiAgICAgIHBydW5lZFVuc3BlbnRzLnB1c2goeyByZWRlZW1TY3JpcHQ6IGZhbHNlLCBjaGFpblBhdGg6IGZhbHNlIH0pOyAvLyBtYXJrIGFzIGZhbHNlIHRvIHNpZ25pZnkgYSBub24tbXVsdGlzaWcgYWRkcmVzc1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdDogYW55ID0ge1xuICAgICAgdHJhbnNhY3Rpb25IZXg6IHRyYW5zYWN0aW9uLmJ1aWxkSW5jb21wbGV0ZSgpLnRvSGV4KCksXG4gICAgICB1bnNwZW50czogcHJ1bmVkVW5zcGVudHMsXG4gICAgICBmZWU6IGZlZSxcbiAgICAgIGNoYW5nZUFkZHJlc3NlczogY2hhbmdlT3V0cHV0cy5tYXAoZnVuY3Rpb24oY28pIHtcbiAgICAgICAgcmV0dXJuIF8ucGljayhjbywgWydhZGRyZXNzJywgJ3BhdGgnLCAnYW1vdW50J10pO1xuICAgICAgfSksXG4gICAgICB3YWxsZXRJZDogcGFyYW1zLndhbGxldC5pZCgpLFxuICAgICAgd2FsbGV0S2V5Y2hhaW5zOiBwYXJhbXMud2FsbGV0LmtleWNoYWlucyxcbiAgICAgIGZlZVJhdGU6IGZlZVJhdGUsXG4gICAgICBpbnN0YW50OiBwYXJhbXMuaW5zdGFudCxcbiAgICAgIGJpdGdvRmVlOiBiaXRnb0ZlZUluZm8sXG4gICAgICBlc3RpbWF0ZWRTaXplOiBtaW5lckZlZUluZm8uc2l6ZSxcbiAgICAgIHR4SW5mbzogdHhJbmZvLFxuICAgICAgdHJhdmVsSW5mb3M6IHRyYXZlbEluZm9zXG4gICAgfTtcblxuICAgIC8vIEFkZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBpZiAocmVzdWx0Lmluc3RhbnQgJiYgYml0Z29GZWVJbmZvKSB7XG4gICAgICByZXN1bHQuaW5zdGFudEZlZSA9IF8ucGljayhiaXRnb0ZlZUluZm8sIFsnYW1vdW50JywgJ2FkZHJlc3MnXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gQmx1ZWJpcmQudHJ5KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnZXRCaXRHb0ZlZSgpO1xuICB9KVxuICAudGhlbihmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gQmx1ZWJpcmQuYWxsKFtnZXRCaXRHb0ZlZUFkZHJlc3MoKSwgZ2V0VW5zcGVudHMoKSwgZ2V0VW5zcGVudHNGb3JTaW5nbGVLZXkoKV0pO1xuICB9KVxuICAudGhlbihjb2xsZWN0SW5wdXRzKVxuICAudGhlbihjb2xsZWN0T3V0cHV0cylcbiAgLnRoZW4oc2VyaWFsaXplKTtcbn07XG5cblxuLyoqXG4gKiBFc3RpbWF0ZSB0aGUgc2l6ZSBvZiBhIHRyYW5zYWN0aW9uIGluIGJ5dGVzIGJhc2VkIG9uIHRoZSBudW1iZXIgb2ZcbiAqIGlucHV0cyBhbmQgb3V0cHV0cyBwcmVzZW50LlxuICogQHBhcmFtcyBwYXJhbXMge1xuICogICBuUDJzaElucHV0czogbnVtYmVyIG9mIFAyU0ggKG11bHRpc2lnKSBpbnB1dHNcbiAqICAgblAycGtoSW5wdXRzOiBudW1iZXIgb2YgUDJQS0ggKHNpbmdsZSBzaWcpIGlucHV0c1xuICogICBuT3V0cHV0czogbnVtYmVyIG9mIG91dHB1dHNcbiAqIH1cbiAqXG4gKiBAcmV0dXJucyBzaXplOiBlc3RpbWF0ZWQgc2l6ZSBvZiB0aGUgdHJhbnNhY3Rpb24gaW4gYnl0ZXNcbiAqL1xuY29uc3QgZXN0aW1hdGVUcmFuc2FjdGlvblNpemUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgaWYgKCFfLmlzSW50ZWdlcihwYXJhbXMublAyc2hJbnB1dHMpIHx8IHBhcmFtcy5uUDJzaElucHV0cyA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyBwb3NpdGl2ZSBuUDJzaElucHV0cycpO1xuICB9XG4gIGlmICghXy5pc0ludGVnZXIocGFyYW1zLm5QMnBraElucHV0cykgfHwgcGFyYW1zLm5QMnBraElucHV0cyA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyBwb3NpdGl2ZSBuUDJwa2hJbnB1dHMgdG8gYmUgbnVtZXJpYycpO1xuICB9XG4gIGlmICghXy5pc0ludGVnZXIocGFyYW1zLm5QMnNoUDJ3c2hJbnB1dHMpIHx8IHBhcmFtcy5uUDJzaFAyd3NoSW5wdXRzIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIHBvc2l0aXZlIG5QMnNoUDJ3c2hJbnB1dHMgdG8gYmUgbnVtZXJpYycpO1xuICB9XG4gIGlmICgocGFyYW1zLm5QMnNoSW5wdXRzICsgcGFyYW1zLm5QMnNoUDJ3c2hJbnB1dHMpIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIGF0IGxlYXN0IG9uZSBuUDJzaElucHV0cyBvciBuUDJzaFAyd3NoSW5wdXRzJyk7XG4gIH1cbiAgaWYgKCFfLmlzSW50ZWdlcihwYXJhbXMubk91dHB1dHMpIHx8IHBhcmFtcy5uT3V0cHV0cyA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyBwb3NpdGl2ZSBuT3V0cHV0cycpO1xuICB9XG5cblxuICBjb25zdCBlc3RpbWF0ZWRTaXplID0gVmlydHVhbFNpemVzLnR4UDJzaElucHV0U2l6ZSAqIHBhcmFtcy5uUDJzaElucHV0cyArXG4gIFZpcnR1YWxTaXplcy50eFAyc2hQMndzaElucHV0U2l6ZSAqIChwYXJhbXMublAyc2hQMndzaElucHV0cyB8fCAwKSArXG4gIFZpcnR1YWxTaXplcy50eFAycGtoSW5wdXRTaXplVW5jb21wcmVzc2VkS2V5ICogKHBhcmFtcy5uUDJwa2hJbnB1dHMgfHwgMCkgK1xuICBWaXJ0dWFsU2l6ZXMudHhQMnBraE91dHB1dFNpemUgKiBwYXJhbXMubk91dHB1dHMgK1xuICAvLyBpZiB0aGUgdHggY29udGFpbnMgYXQgbGVhc3Qgb25lIHNlZ3dpdCBpbnB1dCwgdGhlIHR4IG92ZXJoZWFkIGlzIGluY3JlYXNlZCBieSAxXG4gIFZpcnR1YWxTaXplcy50eE92ZXJoZWFkU2l6ZSArIChwYXJhbXMublAyc2hQMndzaElucHV0cyA+IDAgPyAxIDogMCk7XG5cbiAgcmV0dXJuIGVzdGltYXRlZFNpemU7XG59O1xuXG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBmZWUgYW5kIGVzdGltYXRlZCBzaXplIGluIGJ5dGVzIGZvciBhIHRyYW5zYWN0aW9uLlxuICogQHBhcmFtcyBwYXJhbXMge1xuICogICBiaXRnbzogYml0Z28gb2JqZWN0XG4gKiAgIGZlZVJhdGU6IHNhdG9zaGlzIHBlciBraWxvYnl0ZVxuICogICBuUDJzaElucHV0czogbnVtYmVyIG9mIFAyU0ggKG11bHRpc2lnKSBpbnB1dHNcbiAqICAgblAycGtoSW5wdXRzOiBudW1iZXIgb2YgUDJQS0ggKHNpbmdsZSBzaWcpIGlucHV0c1xuICogICBuT3V0cHV0czogbnVtYmVyIG9mIG91dHB1dHNcbiAqIH1cbiAqXG4gKiBAcmV0dXJucyB7XG4gKiAgIHNpemU6IGVzdGltYXRlZCBzaXplIG9mIHRoZSB0cmFuc2FjdGlvbiBpbiBieXRlc1xuICogICBmZWU6IGVzdGltYXRlZCBmZWUgaW4gc2F0b3NoaXMgZm9yIHRoZSB0cmFuc2FjdGlvblxuICogICBmZWVSYXRlOiBmZWUgcmF0ZSB0aGF0IHdhcyB1c2VkIHRvIGVzdGltYXRlIHRoZSBmZWUgZm9yIHRoZSB0cmFuc2FjdGlvblxuICogfVxuICovXG5leHBvcnRzLmNhbGN1bGF0ZU1pbmVyRmVlSW5mbyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBjb25zdCBmZWVSYXRlVG9Vc2UgPSBwYXJhbXMuZmVlUmF0ZSB8fCBwYXJhbXMuYml0Z28uZ2V0Q29uc3RhbnRzKCkuZmFsbGJhY2tGZWVSYXRlO1xuICBjb25zdCBlc3RpbWF0ZWRTaXplID0gZXN0aW1hdGVUcmFuc2FjdGlvblNpemUocGFyYW1zKTtcblxuICByZXR1cm4ge1xuICAgIHNpemU6IGVzdGltYXRlZFNpemUsXG4gICAgZmVlOiBNYXRoLmNlaWwoZXN0aW1hdGVkU2l6ZSAqIGZlZVJhdGVUb1VzZSAvIDEwMDApLFxuICAgIGZlZVJhdGU6IGZlZVJhdGVUb1VzZVxuICB9O1xufTtcblxuLypcbiAqIEdpdmVuIGEgdHJhbnNhY3Rpb24gaGV4LCB1bnNwZW50IGluZm9ybWF0aW9uIChjaGFpbiBwYXRoIGFuZCByZWRlZW0gc2NyaXB0cyksIGFuZCB0aGUga2V5Y2hhaW4geHBydixcbiAqIHBlcmZvcm0ga2V5IGRlcml2YXRpb24gYW5kIHNpZ24gdGhlIGlucHV0cyBpbiB0aGUgdHJhbnNhY3Rpb24gYmFzZWQgb24gdGhlIHVuc3BlbnQgaW5mb3JtYXRpb24gcHJvdmlkZWRcbiAqXG4gKiBAcGFyYW1zOlxuICogIHRyYW5zYWN0aW9uSGV4IHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgdHJhbnNhY3Rpb24gaW4gaGV4XG4gKiAgdW5zcGVudHMgYXJyYXkgb2YgdW5zcGVudCBpbmZvcm1hdGlvbiwgd2hlcmUgZWFjaCB1bnNwZW50IGlzIGEgY2hhaW5QYXRoIGFuZCByZWRlZW1TY3JpcHQgd2l0aCB0aGUgc2FtZVxuICogIGluZGV4IGFzIHRoZSBpbnB1dHMgaW4gdGhlIHRyYW5zYWN0aW9uSGV4XG4gKiAga2V5Y2hhaW4gS2V5Y2hhaW4gY29udGFpbmluZyB0aGUgeHBydiB0byBzaWduIHdpdGguIEZvciBsZWdhY3kgc3VwcG9ydCBvZiBzYWZlIHdhbGxldHMsIGtleWNoYWluIGNhblxuIGFsc28gYmUgYSBXSUYgcHJpdmF0ZSBrZXkuXG4gKiAgc2lnbmluZ0tleSBwcml2YXRlIGtleSBpbiBXSUYgZm9yIHNhZmUgd2FsbGV0cywgd2hlbiBrZXljaGFpbiBpcyB1bmF2YWlsYWJsZVxuICogIHZhbGlkYXRlIGNsaWVudC1zaWRlIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gLSBjYW4gYmUgZGlzYWJsZWQgZm9yIGltcHJvdmVkIHBlcmZvcm1hbmNlIChzaWduYXR1cmVzXG4gKiAgICAgICAgICAgYXJlIHN0aWxsIHZhbGlkYXRlZCBzZXJ2ZXItc2lkZSkuXG4gKiAgZmVlU2luZ2xlS2V5V0lGIFVzZSB0aGUgYWRkcmVzcyBiYXNlZCBvbiB0aGlzIHByaXZhdGUga2V5IHRvIHBheSBmZWVzXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5zaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgbGV0IGtleWNoYWluID0gcGFyYW1zLmtleWNoYWluOyAvLyBkdXBsaWNhdGUgc28gYXMgdG8gbm90IG11dGF0ZSBiZWxvd1xuXG4gIGNvbnN0IHZhbGlkYXRlID0gKHBhcmFtcy52YWxpZGF0ZSA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBwYXJhbXMudmFsaWRhdGU7XG4gIGxldCBwcml2S2V5O1xuICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnRyYW5zYWN0aW9uSGV4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIHRoZSB0cmFuc2FjdGlvbiBoZXggYXMgYSBzdHJpbmcnKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLnVuc3BlbnRzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIHRoZSB1bnNwZW50cyBhcnJheScpO1xuICB9XG4gIGlmICghXy5pc0Jvb2xlYW4odmFsaWRhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgdmFsaWRhdGUgdG8gYmUgYSBib29sZWFuJyk7XG4gIH1cbiAgbGV0IG5ldHdvcmsgPSBnZXROZXR3b3JrKCk7XG4gIGNvbnN0IGVuYWJsZUJDSCA9IChfLmlzQm9vbGVhbihwYXJhbXMuZm9yY2VCQ0gpICYmIHBhcmFtcy5mb3JjZUJDSCA9PT0gdHJ1ZSk7XG5cbiAgaWYgKCFfLmlzT2JqZWN0KGtleWNoYWluKSB8fCAhXy5pc1N0cmluZygoa2V5Y2hhaW4gYXMgYW55KS54cHJ2KSkge1xuICAgIGlmIChfLmlzU3RyaW5nKHBhcmFtcy5zaWduaW5nS2V5KSkge1xuICAgICAgcHJpdktleSA9IGJpdGNvaW4uRUNQYWlyLmZyb21XSUYocGFyYW1zLnNpZ25pbmdLZXksIG5ldHdvcmspO1xuICAgICAga2V5Y2hhaW4gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIHRoZSBrZXljaGFpbiBvYmplY3Qgd2l0aCB4cHJ2Jyk7XG4gICAgfVxuICB9XG5cbiAgbGV0IGZlZVNpbmdsZUtleTtcbiAgaWYgKHBhcmFtcy5mZWVTaW5nbGVLZXlXSUYpIHtcbiAgICBmZWVTaW5nbGVLZXkgPSBiaXRjb2luLkVDUGFpci5mcm9tV0lGKHBhcmFtcy5mZWVTaW5nbGVLZXlXSUYsIG5ldHdvcmspO1xuICB9XG5cbiAgZGVidWcoJ05ldHdvcms6ICVPJywgbmV0d29yayk7XG5cbiAgaWYgKGVuYWJsZUJDSCkge1xuICAgIGRlYnVnKCdFbmFibGluZyBCQ0jigKYnKTtcbiAgICBuZXR3b3JrID0gXy5leHRlbmQoe30sIG5ldHdvcmssIHsgY29pbjogJ2JjaCcgfSk7XG4gICAgZGVidWcoJ05ldyBuZXR3b3JrOiAlTycsIG5ldHdvcmspO1xuICB9XG5cbiAgbGV0IHRyYW5zYWN0aW9uID0gYml0Y29pbi5UcmFuc2FjdGlvbi5mcm9tSGV4KHBhcmFtcy50cmFuc2FjdGlvbkhleCwgbmV0d29yayk7XG4gIGlmICh0cmFuc2FjdGlvbi5pbnMubGVuZ3RoICE9PSBwYXJhbXMudW5zcGVudHMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2YgdW5zcGVudHMgYXJyYXkgc2hvdWxkIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgdHJhbnNhY3Rpb24gaW5wdXRzJyk7XG4gIH1cblxuICAvLyBkZWNvcmF0ZSB0cmFuc2FjdGlvbiB3aXRoIGlucHV0IHZhbHVlcyBmb3IgVHJhbnNhY3Rpb25CdWlsZGVyIGluc3RhbnRpYXRpb25cbiAgY29uc3QgaXNVdHhvVHggPSBfLmlzT2JqZWN0KHRyYW5zYWN0aW9uKSAmJiBBcnJheS5pc0FycmF5KCh0cmFuc2FjdGlvbiBhcyBhbnkpLmlucyk7XG4gIGNvbnN0IGFyZVZhbGlkVW5zcGVudHMgPSBfLmlzT2JqZWN0KHBhcmFtcykgJiYgQXJyYXkuaXNBcnJheSgocGFyYW1zIGFzIGFueSkudW5zcGVudHMpO1xuICBpZiAoaXNVdHhvVHggJiYgYXJlVmFsaWRVbnNwZW50cykge1xuICAgIC8vIGV4dGVuZCB0aGUgdHJhbnNhY3Rpb24gaW5wdXRzIHdpdGggdGhlIHZhbHVlc1xuICAgIGNvbnN0IGlucHV0VmFsdWVzID0gXy5tYXAocGFyYW1zLnVuc3BlbnRzLCAodSA9PiBfLnBpY2sodSwgJ3ZhbHVlJykpKTtcbiAgICB0cmFuc2FjdGlvbi5pbnMubWFwKChjdXJyZW50SXRlbSwgaW5kZXgpID0+IF8uZXh0ZW5kKGN1cnJlbnRJdGVtLCBpbnB1dFZhbHVlc1tpbmRleF0pKTtcbiAgfVxuXG4gIGxldCByb290RXh0S2V5UGF0aDtcbiAgbGV0IHJvb3RFeHRLZXk7XG4gIGlmIChrZXljaGFpbikge1xuICAgIHJvb3RFeHRLZXkgPSBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KGtleWNoYWluLnhwcnYpO1xuICAgIHJvb3RFeHRLZXlQYXRoID0gaGRQYXRoKHJvb3RFeHRLZXkpO1xuICB9XG5cbiAgY29uc3QgdHhiID0gYml0Y29pbi5UcmFuc2FjdGlvbkJ1aWxkZXIuZnJvbVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBuZXR3b3JrKTtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdHhiLnR4Lmlucy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICBjb25zdCBjdXJyZW50VW5zcGVudCA9IHBhcmFtcy51bnNwZW50c1tpbmRleF07XG4gICAgaWYgKGN1cnJlbnRVbnNwZW50LnJlZGVlbVNjcmlwdCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIHRoaXMgaXMgdGhlIGlucHV0IGZyb20gYSBzaW5nbGUga2V5IGZlZSBhZGRyZXNzXG4gICAgICBpZiAoIWZlZVNpbmdsZUtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbmdsZSBrZXkgYWRkcmVzcyB1c2VkIGluIGlucHV0IGJ1dCBmZWVTaW5nbGVLZXlXSUYgbm90IHByb3ZpZGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmFibGVCQ0gpIHtcbiAgICAgICAgZmVlU2luZ2xlS2V5Lm5ldHdvcmsgPSBuZXR3b3JrO1xuICAgICAgfVxuXG4gICAgICB0eGIuc2lnbihpbmRleCwgZmVlU2luZ2xlS2V5KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYWluUGF0aCA9IGN1cnJlbnRVbnNwZW50LmNoYWluUGF0aDtcbiAgICBpZiAocm9vdEV4dEtleVBhdGgpIHtcbiAgICAgIGNvbnN0IHN1YlBhdGggPSBrZXljaGFpbi53YWxsZXRTdWJQYXRoIHx8ICcvMC8wJztcbiAgICAgIGNvbnN0IHBhdGggPSBrZXljaGFpbi5wYXRoICsgc3ViUGF0aCArIGNoYWluUGF0aDtcbiAgICAgIHByaXZLZXkgPSByb290RXh0S2V5UGF0aC5kZXJpdmVLZXkocGF0aCk7XG4gICAgfVxuXG4gICAgcHJpdktleS5uZXR3b3JrID0gbmV0d29yaztcblxuICAgIGNvbnN0IGlzU2Vnd2l0SW5wdXQgPSAhIWN1cnJlbnRVbnNwZW50LndpdG5lc3NTY3JpcHQ7XG5cbiAgICAvLyBzdWJzY3JpcHQgaXMgdGhlIHBhcnQgb2YgdGhlIG91dHB1dCBzY3JpcHQgYWZ0ZXIgdGhlIE9QX0NPREVTRVBBUkFUT1IuXG4gICAgLy8gU2luY2Ugd2UgYXJlIG9ubHkgZXZlciBzaWduaW5nIHAyc2ggb3V0cHV0cywgd2hpY2ggZG8gbm90IGhhdmVcbiAgICAvLyBPUF9DT0RFU0VQQVJBVE9SUywgaXQgaXMgYWx3YXlzIHRoZSBvdXRwdXQgc2NyaXB0LlxuICAgIGNvbnN0IHN1YnNjcmlwdCA9IEJ1ZmZlci5mcm9tKGN1cnJlbnRVbnNwZW50LnJlZGVlbVNjcmlwdCwgJ2hleCcpO1xuICAgIGN1cnJlbnRVbnNwZW50LnZhbGlkYXRpb25TY3JpcHQgPSBzdWJzY3JpcHQ7XG5cbiAgICAvLyBJbiBvcmRlciB0byBzaWduIHdpdGggYml0Y29pbmpzLWxpYiwgd2UgbXVzdCB1c2UgaXRzIHRyYW5zYWN0aW9uXG4gICAgLy8gYnVpbGRlciwgY29uZnVzaW5nbHkgbmFtZWQgdGhlIHNhbWUgZXhhY3QgdGhpbmcgYXMgb3VyIHRyYW5zYWN0aW9uXG4gICAgLy8gYnVpbGRlciwgYnV0IHdpdGggaW5lcXVpdmFsZW50IGJlaGF2aW9yLlxuICAgIHRyeSB7XG5cbiAgICAgIGlmIChpc1NlZ3dpdElucHV0KSB7XG4gICAgICAgIGRlYnVnKCdTaWduaW5nIHNlZ3dpdCBpbnB1dCAjJWQnLCBpbmRleCk7XG4gICAgICAgIGlmIChlbmFibGVCQ0gpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JDSCBkb2VzIG5vdCBzdXBwb3J0IHNlZ3dpdCBpbnB1dHMnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2lnbmF0dXJlcyA9IF8uY2xvbmVEZWVwKHR4Yi5pbnB1dHNbaW5kZXhdLnNpZ25hdHVyZXMpO1xuICAgICAgICBjb25zdCB3aXRuZXNzU2NyaXB0ID0gQnVmZmVyLmZyb20oY3VycmVudFVuc3BlbnQud2l0bmVzc1NjcmlwdCwgJ2hleCcpO1xuICAgICAgICBjdXJyZW50VW5zcGVudC52YWxpZGF0aW9uU2NyaXB0ID0gd2l0bmVzc1NjcmlwdDtcblxuICAgICAgICBkZWJ1ZygnQ3VycmVudCB1bnNwZW50IHZhbHVlOiAlZCcsIGN1cnJlbnRVbnNwZW50LnZhbHVlKTtcblxuICAgICAgICB0eGIuc2lnbihpbmRleCwgcHJpdktleSwgc3Vic2NyaXB0LCBiaXRjb2luLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMLCBjdXJyZW50VW5zcGVudC52YWx1ZSwgd2l0bmVzc1NjcmlwdCk7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2lnbmF0dXJlcykpIHtcbiAgICAgICAgICAvLyBmb3Igc2Vnd2l0IGlucHV0cywgaWYgdGhleSBhcmUgcGFydGlhbGx5IHNpZ25lZCwgYml0Y29pbmpzLWxpYiBvdmVycmlkZXMgcHJldmlvdXMgc2lnbmF0dXJlc1xuICAgICAgICAgIC8vIHRoaXMgd29ya2Fyb3VuZCBmb3JjZXMgdGhlbSB0byBiZSBwcmVzZXJ2ZWRcbiAgICAgICAgICBzaWduYXR1cmVzID0gc2lnbmF0dXJlcy5maWx0ZXIoc2lnID0+ICEhc2lnKTtcbiAgICAgICAgICAvLyBMYXN0LCBvdmVycmlkZSBidWlsZGVyJ3Mgc2lnbmF0dXJlcyBwcm9wZXJ0eSB0byBhbiBhcnJheSBpbmNsdWRpbmcgcHJldmlvdXMgc2lnbmF0dXJlcywgaWYgdGhlcmUgYXJlIGFueS5cbiAgICAgICAgICBjb25zdCBidWlsZGVyU2lnbmF0dXJlcyA9IHR4Yi5pbnB1dHNbaW5kZXhdLnNpZ25hdHVyZXM7XG4gICAgICAgICAgY29uc3Qgbm9uRW1wdHlTaWduYXR1cmVzID0gXy5yZW1vdmUoYnVpbGRlclNpZ25hdHVyZXMsIHNpZyA9PiAhIXNpZyk7XG4gICAgICAgICAgc2lnbmF0dXJlcy5wdXNoLmFwcGx5KHNpZ25hdHVyZXMsIG5vbkVtcHR5U2lnbmF0dXJlcyk7XG4gICAgICAgICAgdHhiLmlucHV0c1tpbmRleF0uc2lnbmF0dXJlcyA9IHNpZ25hdHVyZXM7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ1NpZ25pbmcgbm9uLXNlZ3dpdCBpbnB1dCAjJWQnLCBpbmRleCk7XG5cbiAgICAgICAgLy8gb25seSBpZiBiaXRjb2luIGNhc2ggaXMgZW5hYmxlZCwgd2hpY2ggc2hvdWxkIG9ubHkgYmUgaW4gdW5pdCB0ZXN0cyBhbnl3YXlcbiAgICAgICAgY29uc3QgYmNoUGFyYW1ldGVyID0gZW5hYmxlQkNIID8gY3VycmVudFVuc3BlbnQudmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBzaWdIYXNoVHlwZSA9IGJpdGNvaW4uVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEw7XG4gICAgICAgIGlmIChlbmFibGVCQ0gpIHtcbiAgICAgICAgICBzaWdIYXNoVHlwZSB8PSBiaXRjb2luLlRyYW5zYWN0aW9uLlNJR0hBU0hfQklUQ09JTkNBU0hCSVAxNDM7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ0JDSCBwYXJhbWV0ZXI6ICVkJywgYmNoUGFyYW1ldGVyKTtcbiAgICAgICAgZGVidWcoJ1NpZ2hhc2ggdHlwZTogJWQnLCBzaWdIYXNoVHlwZSk7XG4gICAgICAgIHR4Yi5zaWduKGluZGV4LCBwcml2S2V5LCBzdWJzY3JpcHQsIHNpZ0hhc2hUeXBlLCBiY2hQYXJhbWV0ZXIpO1xuICAgICAgfVxuXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gd2UgbmVlZCB0byBrbm93IHdoYXQncyBjYXVzaW5nIHRoaXNcbiAgICAgIGUucmVzdWx0ID0ge1xuICAgICAgICB1bnNwZW50OiBjdXJyZW50VW5zcGVudFxuICAgICAgfTtcbiAgICAgIGUubWVzc2FnZSA9IGBGYWlsZWQgdG8gc2lnbiBpbnB1dCAjJHtpbmRleH0gLSAke2UubWVzc2FnZX0gLSAke0pTT04uc3RyaW5naWZ5KGUucmVzdWx0LCBudWxsLCA0KX0gLSBcXG4ke2Uuc3RhY2t9YDtcbiAgICAgIGRlYnVnKCdpbnB1dCBzaWduIGZhaWxlZDogJXMnLCBlLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIEJsdWViaXJkLnJlamVjdChlKTtcbiAgICB9XG5cbiAgfVxuXG4gIC8vIHJlc2VyaWFsaXplIHRyYW5zYWN0aW9uXG4gIHRyYW5zYWN0aW9uID0gdHhiLmJ1aWxkKCk7XG5cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRyYW5zYWN0aW9uLmlucy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAvLyBiaXRjb2luanMtbGliIGFkZHMgb25lIG1vcmUgT1BfMCB0aGFuIHdlIG5lZWQuIEl0IGNyZWF0ZXMgb25lIE9QXzAgZm9yXG4gICAgLy8gZXZlcnkgbiBwdWJsaWMga2V5cyBpbiBhbiBtLW9mLW4gbXVsdGlzaWcsIGFuZCByZXBsYWNlcyB0aGUgT1BfMHMgd2l0aFxuICAgIC8vIHRoZSBzaWduYXR1cmUgb2YgdGhlIG50aCBwdWJsaWMga2V5LCB0aGVuIHJlbW92ZXMgYW55IHJlbWFpbmluZyBPUF8wc1xuICAgIC8vIGF0IHRoZSBlbmQuIFRoaXMgYmVoYXZpb3IgaXMgbm90IGluY29ycmVjdCBhbmQgdmFsaWQgZm9yIHNvbWUgdXNlXG4gICAgLy8gY2FzZXMsIHBhcnRpY3VsYXJseSBpZiB5b3UgZG8gbm90IGtub3cgd2hpY2gga2V5cyB3aWxsIGJlIHNpZ25pbmcgdGhlXG4gICAgLy8gdHJhbnNhY3Rpb24gYW5kIHRoZSBzaWduYXR1cmVzIG1heSBiZSBhZGRlZCB0byB0aGUgdHJhbnNhY3Rpb24gaW4gYW55XG4gICAgLy8gY2hyb25vbG9naWNhbCBvcmRlciwgYnV0IGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIEJpdEdvIEFQSSwgd2hpY2hcbiAgICAvLyBhc3N1bWVzIG0gT1BfMHMgZm9yIG0tb2YtbiBtdWx0aXNpZyAob3IgbS0xIGFmdGVyIHRoZSBmaXJzdCBzaWduYXR1cmVcbiAgICAvLyBpcyBjcmVhdGVkKS4gVGh1cyB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgc3VwZXJmbHVvdXMgT1BfMC5cblxuICAgIGNvbnN0IGN1cnJlbnRVbnNwZW50ID0gcGFyYW1zLnVuc3BlbnRzW2luZGV4XTtcblxuICAgIC8vIFRoZSBzaWduYXR1cmVzIGFyZSB2YWxpZGF0ZWQgc2VydmVyIHNpZGUgYW5kIG9uIHRoZSBiaXRjb2luIG5ldHdvcmssIHNvXG4gICAgLy8gdGhlIHNpZ25hdHVyZSB2YWxpZGF0aW9uIGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZzpcbiAgICAvLyB2YWxpZGF0ZSA9IGZhbHNlXG4gICAgaWYgKHZhbGlkYXRlKSB7XG4gICAgICBjb25zdCBzaWduYXR1cmVDb3VudCA9IGV4cG9ydHMudmVyaWZ5SW5wdXRTaWduYXR1cmVzKHRyYW5zYWN0aW9uLCBpbmRleCwgY3VycmVudFVuc3BlbnQudmFsaWRhdGlvblNjcmlwdCwgZmFsc2UsIGN1cnJlbnRVbnNwZW50LnZhbHVlLCBlbmFibGVCQ0gpO1xuICAgICAgLy8gVE9ETzogZmlndXJlIG91dCBzb21ldGhpbmcgc21hcnRlciBmb3IgaGFsZi1zaWduZWRcblxuICAgICAgLy8gaWYgcGFyYW1zLmZ1bGxMb2NhbFNpZ25pbmcgaXMgc2V0IHRvIHRydWUsIHdlIGFsbG93IGN1c3RvbSBub24temVybyB2YWx1ZXNcbiAgICAgIC8vIG90aGVyd2lzZSwgdGhlIHNpZ25hdHVyZSBjb3VudCBoYXMgdG8gYmUgLTFcblxuICAgICAgY29uc3QgZnVsbExvY2FsU2lnbmluZyA9ICEhcGFyYW1zLmZ1bGxMb2NhbFNpZ25pbmc7XG4gICAgICBpZiAoc2lnbmF0dXJlQ291bnQgPT09IDAgfHwgKCFmdWxsTG9jYWxTaWduaW5nICYmIHNpZ25hdHVyZUNvdW50ICE9PSAtMSkpIHtcbiAgICAgICAgLy8gaWYgdGhlIHNpZ25hdHVyZSBjb3VudCBpcyBwb3NpdGl2ZSwgd2UgZG8gbm90IHdhbnQgdG8gdGhyb3cgdGhlIGVycm9yLCBiZWNhdXNlIGl0IGlzIGV4cGVjdGVkXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIG9mIHNpZ25hdHVyZXMgaXMgaW52YWxpZCAtIHNvbWV0aGluZyB3ZW50IHdyb25nIHdoZW4gc2lnbmluZycpO1xuICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUoe1xuICAgIHRyYW5zYWN0aW9uSGV4OiB0cmFuc2FjdGlvbi50b0hleCgpXG4gIH0pO1xufTtcblxuLyoqXG4gKiBWZXJpZnkgdGhlIHNpZ25hdHVyZSBvbiBhbiBpbnB1dC5cbiAqXG4gKiBJZiB0aGUgdHJhbnNhY3Rpb24gaXMgZnVsbHkgc2lnbmVkLCByZXR1cm5zIGEgcG9zaXRpdmUgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIHZhbGlkIHNpZ25hdHVyZXMuXG4gKiBJZiB0aGUgdHJhbnNhY3Rpb24gaXMgcGFydGlhbGx5IHNpZ25lZCwgcmV0dXJucyBhIG5lZ2F0aXZlIG51bWJlciByZXByZXNlbnRpbmcgdGhlIG51bWJlciBvZiB2YWxpZCBzaWduYXR1cmVzLlxuICogQHBhcmFtIHRyYW5zYWN0aW9uIFRoZSBiaXRjb2luanMtbGliIHRyYW5zYWN0aW9uIG9iamVjdFxuICogQHBhcmFtIGlucHV0SW5kZXggdGhlIGlucHV0IGluZGV4IHRvIHZlcmlmeVxuICogQHBhcmFtIHB1YlNjcmlwdCB0aGUgcmVkZWVtIHNjcmlwdCB0byB2ZXJpZnkgd2l0aFxuICogQHBhcmFtIGlnbm9yZUtleUluZGljZXMgYXJyYXkgb2YgbXVsdGlzaWcga2V5cyBpbmRleGVzIChpbiBvcmRlciBvZiBrZXljaGFpbnMgb24gdGhlIHdhbGxldCkuIGUuZy4gWzFdIHRvIGlnbm9yZSBiYWNrdXAga2V5c1xuICogQHBhcmFtIGFtb3VudFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy52ZXJpZnlJbnB1dFNpZ25hdHVyZXMgPSBmdW5jdGlvbih0cmFuc2FjdGlvbiwgaW5wdXRJbmRleCwgcHViU2NyaXB0LCBpZ25vcmVLZXlJbmRpY2VzLCBhbW91bnQsIGlzQkNIID0gZmFsc2UpIHtcbiAgaWYgKGlucHV0SW5kZXggPCAwIHx8IGlucHV0SW5kZXggPj0gdHJhbnNhY3Rpb24uaW5zLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaWxsZWdhbCBpbmRleCcpO1xuICB9XG5cbiAgaWdub3JlS2V5SW5kaWNlcyA9IGlnbm9yZUtleUluZGljZXMgfHwgW107XG4gIGNvbnN0IGN1cnJlbnRUcmFuc2FjdGlvbklucHV0ID0gdHJhbnNhY3Rpb24uaW5zW2lucHV0SW5kZXhdO1xuICBsZXQgc2lnU2NyaXB0ID0gY3VycmVudFRyYW5zYWN0aW9uSW5wdXQuc2NyaXB0O1xuICBsZXQgc2lnc05lZWRlZCA9IDE7XG4gIGNvbnN0IHNpZ3M6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IHB1YktleXM6IHN0cmluZ1tdID0gW107XG4gIGxldCBkZWNvbXBpbGVkU2lnU2NyaXB0ID0gYml0Y29pbi5zY3JpcHQuZGVjb21waWxlKHNpZ1NjcmlwdCk7XG5cbiAgY29uc3QgaXNTZWd3aXRJbnB1dCA9IGN1cnJlbnRUcmFuc2FjdGlvbklucHV0LndpdG5lc3MubGVuZ3RoID4gMDtcbiAgaWYgKGlzU2Vnd2l0SW5wdXQpIHtcbiAgICBkZWNvbXBpbGVkU2lnU2NyaXB0ID0gY3VycmVudFRyYW5zYWN0aW9uSW5wdXQud2l0bmVzcztcbiAgICBzaWdTY3JpcHQgPSBiaXRjb2luLnNjcmlwdC5jb21waWxlKGRlY29tcGlsZWRTaWdTY3JpcHQpO1xuICAgIGlmICghYW1vdW50KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayB0aGUgc2NyaXB0IHR5cGUgdG8gZGV0ZXJtaW5lIG51bWJlciBvZiBzaWduYXR1cmVzLCB0aGUgcHViIGtleXMsIGFuZCB0aGUgc2NyaXB0IHRvIGhhc2guXG4gIGNvbnN0IGlucHV0Q2xhc3NpZmljYXRpb24gPSBiaXRjb2luLnNjcmlwdC5jbGFzc2lmeUlucHV0KHNpZ1NjcmlwdCwgdHJ1ZSk7XG4gIHN3aXRjaCAoaW5wdXRDbGFzc2lmaWNhdGlvbikge1xuICAgIGNhc2UgJ3NjcmlwdGhhc2gnOlxuICAgICAgLy8gUmVwbGFjZSB0aGUgcHViU2NyaXB0IHdpdGggdGhlIFAyU0ggU2NyaXB0LlxuICAgICAgcHViU2NyaXB0ID0gZGVjb21waWxlZFNpZ1NjcmlwdFtkZWNvbXBpbGVkU2lnU2NyaXB0Lmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgZGVjb21waWxlZFB1YlNjcmlwdCA9IGJpdGNvaW4uc2NyaXB0LmRlY29tcGlsZShwdWJTY3JpcHQpO1xuICAgICAgc2lnc05lZWRlZCA9IGRlY29tcGlsZWRQdWJTY3JpcHRbMF0gLSBiaXRjb2luLm9wY29kZXMuT1BfMSArIDE7XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgZGVjb21waWxlZFNpZ1NjcmlwdC5sZW5ndGggLSAxOyArK2luZGV4KSB7XG4gICAgICAgIHNpZ3MucHVzaChkZWNvbXBpbGVkU2lnU2NyaXB0W2luZGV4XSk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgZGVjb21waWxlZFB1YlNjcmlwdC5sZW5ndGggLSAyOyArK2luZGV4KSB7XG4gICAgICAgIC8vIHdlIG1pbnVzIDEgYmVjYXVzZSB0aGUga2V5IGluZGV4ZXMgc3RhcnQgZnJvbSB0aGUgc2Vjb25kIGNodW5rIChmaXJzdCBjaHVuayBpcyB1c2VkIGZvciB0b3RhbCBrZXlzKVxuICAgICAgICBpZiAoXy5pbmNsdWRlcyhpZ25vcmVLZXlJbmRpY2VzLCBpbmRleCAtIDEpKSB7XG4gICAgICAgICAgLy8gaWdub3JlIHRoaXMgcHVibGljIGtleSAoZG8gbm90IHRyZWF0IGl0IGFzIHZhbGlkIGZvciBhIHNpZ25hdHVyZSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBwdWJLZXlzLnB1c2goZGVjb21waWxlZFB1YlNjcmlwdFtpbmRleF0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHVia2V5aGFzaCc6XG4gICAgICBzaWdzTmVlZGVkID0gMTtcbiAgICAgIHNpZ3MucHVzaChkZWNvbXBpbGVkU2lnU2NyaXB0WzBdKTtcbiAgICAgIHB1YktleXMucHVzaChkZWNvbXBpbGVkU2lnU2NyaXB0WzFdKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGxldCBudW1WZXJpZmllZFNpZ25hdHVyZXMgPSAwO1xuICBmb3IgKGxldCBzaWdJbmRleCA9IDA7IHNpZ0luZGV4IDwgc2lncy5sZW5ndGg7ICsrc2lnSW5kZXgpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGFuIE9QXzAsIHRoZW4gaXRzIGJlZW4gbGVmdCBhcyBhIHBsYWNlaG9sZGVyIGZvciBhIGZ1dHVyZSBzaWcuXG4gICAgaWYgKHNpZ3Nbc2lnSW5kZXhdID09PSBiaXRjb2luLm9wY29kZXMuT1BfMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzaFR5cGUgPSBzaWdzW3NpZ0luZGV4XVtzaWdzW3NpZ0luZGV4XS5sZW5ndGggLSAxXTtcbiAgICBzaWdzW3NpZ0luZGV4XSA9IHNpZ3Nbc2lnSW5kZXhdLnNsaWNlKDAsIHNpZ3Nbc2lnSW5kZXhdLmxlbmd0aCAtIDEpOyAvLyBwb3AgaGFzaCB0eXBlIGZyb20gZW5kXG4gICAgbGV0IHNpZ25hdHVyZUhhc2g7XG4gICAgaWYgKGlzU2Vnd2l0SW5wdXQpIHtcbiAgICAgIHNpZ25hdHVyZUhhc2ggPSB0cmFuc2FjdGlvbi5oYXNoRm9yV2l0bmVzc1YwKGlucHV0SW5kZXgsIHB1YlNjcmlwdCwgYW1vdW50LCBoYXNoVHlwZSk7XG4gICAgfSBlbHNlIGlmIChpc0JDSCkge1xuICAgICAgc2lnbmF0dXJlSGFzaCA9IHRyYW5zYWN0aW9uLmhhc2hGb3JDYXNoU2lnbmF0dXJlKGlucHV0SW5kZXgsIHB1YlNjcmlwdCwgYW1vdW50LCBoYXNoVHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpZ25hdHVyZUhhc2ggPSB0cmFuc2FjdGlvbi5oYXNoRm9yU2lnbmF0dXJlKGlucHV0SW5kZXgsIHB1YlNjcmlwdCwgaGFzaFR5cGUpO1xuICAgIH1cblxuICAgIGxldCB2YWxpZFNpZyA9IGZhbHNlO1xuXG4gICAgLy8gRW51bWVyYXRlIHRoZSBwb3NzaWJsZSBwdWJsaWMga2V5c1xuICAgIGZvciAobGV0IHB1YktleUluZGV4ID0gMDsgcHViS2V5SW5kZXggPCBwdWJLZXlzLmxlbmd0aDsgKytwdWJLZXlJbmRleCkge1xuICAgICAgY29uc3QgcHViS2V5ID0gYml0Y29pbi5FQ1BhaXIuZnJvbVB1YmxpY0tleUJ1ZmZlcihwdWJLZXlzW3B1YktleUluZGV4XSk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBiaXRjb2luLkVDU2lnbmF0dXJlLmZyb21ERVIoc2lnc1tzaWdJbmRleF0pO1xuICAgICAgdmFsaWRTaWcgPSBwdWJLZXkudmVyaWZ5KHNpZ25hdHVyZUhhc2gsIHNpZ25hdHVyZSk7XG4gICAgICBpZiAodmFsaWRTaWcpIHtcbiAgICAgICAgcHViS2V5cy5zcGxpY2UocHViS2V5SW5kZXgsIDEpOyAgLy8gcmVtb3ZlIHRoZSBwdWJrZXkgc28gd2UgY2FuJ3QgbWF0Y2ggMiBzaWdzIGFnYWluc3QgdGhlIHNhbWUgcHVia2V5XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXZhbGlkU2lnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnbmF0dXJlIGZvciBpbmRleCAnICsgaW5wdXRJbmRleCk7XG4gICAgfVxuICAgIG51bVZlcmlmaWVkU2lnbmF0dXJlcysrO1xuICB9XG5cbiAgaWYgKG51bVZlcmlmaWVkU2lnbmF0dXJlcyA8IHNpZ3NOZWVkZWQpIHtcbiAgICBudW1WZXJpZmllZFNpZ25hdHVyZXMgPSAtbnVtVmVyaWZpZWRTaWduYXR1cmVzO1xuICB9XG4gIHJldHVybiBudW1WZXJpZmllZFNpZ25hdHVyZXM7XG59O1xuIl19