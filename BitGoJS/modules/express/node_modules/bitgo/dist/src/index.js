"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @prettier
 */
//
// index.js - Module definition for BitGoJS
//
// Copyright 2019, BitGo, Inc.  All Rights Reserved.
//
var common = require("./common");
__export(require("./bitgo"));
// Expose bitcoin and sjcl
var utxoLib = require("@bitgo/utxo-lib");
var bitcoin_1 = require("./bitcoin");
// can't add types for these since they are part of @bitgo/utxo-lib's default export
// see https://github.com/Microsoft/TypeScript/issues/14080
utxoLib.hdPath = bitcoin_1.hdPath;
utxoLib.makeRandomKey = bitcoin_1.makeRandomKey;
exports.bitcoin = utxoLib;
exports.sjcl = require('./vendor/sjcl.min.js');
exports.bs58 = require('bs58');
var buffer_1 = require("buffer");
exports.Buffer = buffer_1.Buffer;
var _ = require("lodash");
var errors = require("./errors");
exports.Environments = _.cloneDeep(common.Environments);
exports.Errors = errors;
var coinFactory_1 = require("./v2/coinFactory");
exports.GlobalCoinFactory = coinFactory_1.GlobalCoinFactory;
__export(require("./v2"));
/**
 * Set the network, i.e. either "bitcoin" for production with real bitcoin, or
 * "testnet" for development with testnet bitcoin.
 *
 * @deprecated
 */
function setNetwork(network) {
    common.setNetwork(network);
}
exports.setNetwork = setNetwork;
/**
 * Get the network. Returns either "bitcoin" or "testnet".
 *
 * @deprecated
 */
function getNetwork() {
    return common.getNetwork();
}
exports.getNetwork = getNetwork;
/**
 * @deprecated
 */
function getNetworkObj() {
    return exports.bitcoin.networks[common.getNetwork()];
}
exports.getNetworkObj = getNetworkObj;
setNetwork('testnet');
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7R0FFRztBQUNILEVBQUU7QUFDRiwyQ0FBMkM7QUFDM0MsRUFBRTtBQUNGLG9EQUFvRDtBQUNwRCxFQUFFO0FBQ0YsaUNBQW1DO0FBRW5DLDZCQUF3QjtBQUV4QiwwQkFBMEI7QUFDMUIseUNBQTJDO0FBQzNDLHFDQUFrRDtBQUVsRCxvRkFBb0Y7QUFDcEYsMkRBQTJEO0FBQzFELE9BQWUsQ0FBQyxNQUFNLEdBQUcsZ0JBQU0sQ0FBQztBQUNoQyxPQUFlLENBQUMsYUFBYSxHQUFHLHVCQUFhLENBQUM7QUFFbEMsUUFBQSxPQUFPLEdBQUcsT0FBTyxDQUFDO0FBQ2xCLFFBQUEsSUFBSSxHQUFHLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBQ3ZDLFFBQUEsSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUVwQyxpQ0FBZ0M7QUFBdkIsMEJBQUEsTUFBTSxDQUFBO0FBRWYsMEJBQTRCO0FBQzVCLGlDQUFtQztBQUN0QixRQUFBLFlBQVksR0FBRyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNoRCxRQUFBLE1BQU0sR0FBRyxNQUFNLENBQUM7QUFDN0IsZ0RBQXNFO0FBQTdELDBDQUFBLGlCQUFpQixDQUFBO0FBRzFCLDBCQUFxQjtBQUVyQjs7Ozs7R0FLRztBQUNILFNBQWdCLFVBQVUsQ0FBQyxPQUFPO0lBQ2hDLE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDN0IsQ0FBQztBQUZELGdDQUVDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLFVBQVU7SUFDeEIsT0FBTyxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7QUFDN0IsQ0FBQztBQUZELGdDQUVDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixhQUFhO0lBQzNCLE9BQU8sZUFBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQztBQUMvQyxDQUFDO0FBRkQsc0NBRUM7QUFFRCxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG4vL1xuLy8gaW5kZXguanMgLSBNb2R1bGUgZGVmaW5pdGlvbiBmb3IgQml0R29KU1xuLy9cbi8vIENvcHlyaWdodCAyMDE5LCBCaXRHbywgSW5jLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgKiBmcm9tICcuL2JpdGdvJztcblxuLy8gRXhwb3NlIGJpdGNvaW4gYW5kIHNqY2xcbmltcG9ydCAqIGFzIHV0eG9MaWIgZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCB7IGhkUGF0aCwgbWFrZVJhbmRvbUtleSB9IGZyb20gJy4vYml0Y29pbic7XG5cbi8vIGNhbid0IGFkZCB0eXBlcyBmb3IgdGhlc2Ugc2luY2UgdGhleSBhcmUgcGFydCBvZiBAYml0Z28vdXR4by1saWIncyBkZWZhdWx0IGV4cG9ydFxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTQwODBcbih1dHhvTGliIGFzIGFueSkuaGRQYXRoID0gaGRQYXRoO1xuKHV0eG9MaWIgYXMgYW55KS5tYWtlUmFuZG9tS2V5ID0gbWFrZVJhbmRvbUtleTtcblxuZXhwb3J0IGNvbnN0IGJpdGNvaW4gPSB1dHhvTGliO1xuZXhwb3J0IGNvbnN0IHNqY2wgPSByZXF1aXJlKCcuL3ZlbmRvci9zamNsLm1pbi5qcycpO1xuZXhwb3J0IGNvbnN0IGJzNTggPSByZXF1aXJlKCdiczU4Jyk7XG5cbmV4cG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XG5cbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIGVycm9ycyBmcm9tICcuL2Vycm9ycyc7XG5leHBvcnQgY29uc3QgRW52aXJvbm1lbnRzID0gXy5jbG9uZURlZXAoY29tbW9uLkVudmlyb25tZW50cyk7XG5leHBvcnQgY29uc3QgRXJyb3JzID0gZXJyb3JzO1xuZXhwb3J0IHsgR2xvYmFsQ29pbkZhY3RvcnksIENvaW5Db25zdHJ1Y3RvciB9IGZyb20gJy4vdjIvY29pbkZhY3RvcnknO1xuZXhwb3J0IHsgVjFOZXR3b3JrLCBWMVJtZ05ldHdvcmsgfSBmcm9tICcuL3YyL3R5cGVzJztcbmV4cG9ydCB7IEVudmlyb25tZW50TmFtZSB9IGZyb20gJy4vdjIvZW52aXJvbm1lbnRzJztcbmV4cG9ydCAqIGZyb20gJy4vdjInO1xuXG4vKipcbiAqIFNldCB0aGUgbmV0d29yaywgaS5lLiBlaXRoZXIgXCJiaXRjb2luXCIgZm9yIHByb2R1Y3Rpb24gd2l0aCByZWFsIGJpdGNvaW4sIG9yXG4gKiBcInRlc3RuZXRcIiBmb3IgZGV2ZWxvcG1lbnQgd2l0aCB0ZXN0bmV0IGJpdGNvaW4uXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldE5ldHdvcmsobmV0d29yaykge1xuICBjb21tb24uc2V0TmV0d29yayhuZXR3b3JrKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5ldHdvcmsuIFJldHVybnMgZWl0aGVyIFwiYml0Y29pblwiIG9yIFwidGVzdG5ldFwiLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXR3b3JrKCkge1xuICByZXR1cm4gY29tbW9uLmdldE5ldHdvcmsoKTtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV0d29ya09iaigpIHtcbiAgcmV0dXJuIGJpdGNvaW4ubmV0d29ya3NbY29tbW9uLmdldE5ldHdvcmsoKV07XG59XG5cbnNldE5ldHdvcmsoJ3Rlc3RuZXQnKTtcbiJdfQ==