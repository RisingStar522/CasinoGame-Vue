"use strict";
/**
 * @hidden
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 */
//
// TravelRule Object
// BitGo accessor for a specific enterprise
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
var bitcoin = require("@bitgo/utxo-lib");
var common = require("./common");
var _ = require("lodash");
var bitcoin_1 = require("./bitcoin");
//
// Constructor
//
var TravelRule = function (bitgo) {
    this.bitgo = bitgo;
};
TravelRule.prototype.url = function (extra) {
    extra = extra || '';
    return this.bitgo.url('/travel/' + extra);
};
/**
  * Get available travel-rule info recipients for a transaction
  * @param params
  *  txid: transaction id
  * @param callback
  * @returns {*}
  */
TravelRule.prototype.getRecipients = function (params, callback) {
    params = params || {};
    params.txid = params.txid || params.hash;
    common.validateParams(params, ['txid'], [], callback);
    var url = this.url(params.txid + '/recipients');
    return this.bitgo.get(url)
        .result('recipients')
        .nodeify(callback);
};
TravelRule.prototype.validateTravelInfo = function (info) {
    var fields = {
        amount: { type: 'number' },
        toAddress: { type: 'string' },
        toEnterprise: { type: 'string' },
        fromUserName: { type: 'string' },
        fromUserAccount: { type: 'string' },
        fromUserAddress: { type: 'string' },
        toUserName: { type: 'string' },
        toUserAccount: { type: 'string' },
        toUserAddress: { type: 'string' },
        extra: { type: 'object' }
    };
    _.forEach(fields, function (field, fieldName) {
        // No required fields yet -- should there be?
        if (field.required) {
            if (info[fieldName] === undefined) {
                throw new Error('missing required field ' + fieldName + ' in travel info');
            }
        }
        if (info[fieldName] && typeof (info[fieldName]) !== field.type) {
            throw new Error('incorrect type for field ' + fieldName + ' in travel info, expected ' + field.type);
        }
    });
    // Strip out any other fields we don't know about
    var result = _.pick(info, _.keys(fields));
    if (_.isEmpty(result)) {
        throw new Error('empty travel data');
    }
    return result;
};
/**
 * Takes a transaction object as returned by getTransaction or listTransactions, along
 * with a keychain (or hdnode object), and attempts to decrypt any encrypted travel
 * info included in the transaction's receivedTravelInfo field.
 * Parameters:
 *   tx: a transaction object
 *   keychain: keychain object (with xprv)
 *   hdnode: a bitcoin.HDNode object (may be provided instead of keychain)
 * Returns:
 *   the tx object, augmented with decrypted travelInfo fields
 */
TravelRule.prototype.decryptReceivedTravelInfo = function (params) {
    if (params === void 0) { params = {}; }
    var tx = params.tx;
    if (!_.isObject(tx)) {
        throw new Error('expecting tx param to be object');
    }
    if (!tx.receivedTravelInfo || !tx.receivedTravelInfo.length) {
        return tx;
    }
    var hdNode;
    // Passing in hdnode is faster because it doesn't reconstruct the key every time
    if (params.hdnode) {
        hdNode = params.hdnode;
    }
    else {
        var keychain = params.keychain;
        if (!_.isObject(keychain) || !_.isString(keychain.xprv)) {
            throw new Error('expecting keychain param with xprv');
        }
        hdNode = bitcoin.HDNode.fromBase58(keychain.xprv);
    }
    var self = this;
    var hdPathNode = bitcoin_1.hdPath(hdNode);
    tx.receivedTravelInfo.forEach(function (info) {
        var key = hdPathNode.deriveKey(info.toPubKeyPath);
        var secret = self.bitgo.getECDHSecret({
            eckey: key,
            otherPubKeyHex: info.fromPubKey
        });
        try {
            var decrypted = this.bitgo.decrypt({
                input: info.encryptedTravelInfo,
                password: secret
            });
            info.travelInfo = JSON.parse(decrypted);
        }
        catch (err) {
            console.error('failed to decrypt or parse travel info for ', info.transactionId + ':' + info.outputIndex);
        }
    });
    return tx;
};
TravelRule.prototype.prepareParams = function (params) {
    params = params || {};
    params.txid = params.txid || params.hash;
    common.validateParams(params, ['txid'], ['fromPrivateInfo']);
    var txid = params.txid;
    var recipient = params.recipient;
    var travelInfo = params.travelInfo;
    if (!recipient || !_.isObject(recipient)) {
        throw new Error('invalid or missing recipient');
    }
    if (!travelInfo || !_.isObject(travelInfo)) {
        throw new Error('invalid or missing travelInfo');
    }
    if (!params.noValidate) {
        travelInfo = this.validateTravelInfo(travelInfo);
    }
    // Fill in toEnterprise if not already filled
    if (!travelInfo.toEnterprise && recipient.enterprise) {
        travelInfo.toEnterprise = recipient.enterprise;
    }
    // If a key was not provided, create a new random key
    var fromKey = params.fromKey && bitcoin.ECPair.fromWIF(params.fromKey, bitcoin_1.getNetwork());
    if (!fromKey) {
        fromKey = bitcoin_1.makeRandomKey();
    }
    // Compute the shared key for encryption
    var sharedSecret = this.bitgo.getECDHSecret({
        eckey: fromKey,
        otherPubKeyHex: recipient.pubKey
    });
    // JSON-ify and encrypt the payload
    var travelInfoJSON = JSON.stringify(travelInfo);
    var encryptedTravelInfo = this.bitgo.encrypt({
        input: travelInfoJSON,
        password: sharedSecret
    });
    var result = {
        txid: txid,
        outputIndex: recipient.outputIndex,
        toPubKey: recipient.pubKey,
        fromPubKey: fromKey.getPublicKeyBuffer().toString('hex'),
        encryptedTravelInfo: encryptedTravelInfo,
        fromPrivateInfo: undefined
    };
    if (params.fromPrivateInfo) {
        result.fromPrivateInfo = params.fromPrivateInfo;
    }
    return result;
};
/**
 * Send travel data to the server for a transaction
 */
TravelRule.prototype.send = function (params, callback) {
    params = params || {};
    params.txid = params.txid || params.hash;
    common.validateParams(params, ['txid', 'toPubKey', 'encryptedTravelInfo'], ['fromPubKey', 'fromPrivateInfo'], callback);
    if (!_.isNumber(params.outputIndex)) {
        throw new Error('invalid outputIndex');
    }
    return this.bitgo.post(this.url(params.txid + '/' + params.outputIndex))
        .send(params)
        .result()
        .nodeify(callback);
};
/**
 * Send multiple travel rule infos for the outputs of a single transaction.
 * Parameters:
 *   - txid (or hash): txid of the transaction (must be a sender of the tx)
 *   - travelInfos: array of travelInfo objects which look like the following:
 *     {
 *       outputIndex: number,     // tx output index
 *       fromUserName: string,    // name of the sending user
 *       fromUserAccount: string, // account id of the sending user
 *       fromUserAddress: string, // mailing address of the sending user
 *       toUserName: string,      // name of the receiving user
 *       toUserAccount: string,   // account id of the receiving user
 *       toUserAddress: string    // mailing address of the receiving user
 *     }
 *     All fields aside from outputIndex are optional, but at least one must
 *     be defined.
 *
 *  It is not necessary to provide travelInfo for all output indices.
 *  End-to-end encryption of the travel info is handled automatically by this method.
 *
 */
TravelRule.prototype.sendMany = function (params, callback) {
    params = params || {};
    params.txid = params.txid || params.hash;
    common.validateParams(params, ['txid'], callback);
    var travelInfos = params.travelInfos;
    if (!_.isArray(travelInfos)) {
        throw new Error('expected parameter travelInfos to be array');
    }
    var self = this;
    var travelInfoMap = _(travelInfos)
        .keyBy('outputIndex')
        .mapValues(function (travelInfo) {
        return self.validateTravelInfo(travelInfo);
    })
        .value();
    return self.getRecipients({ txid: params.txid })
        .then(function (recipients) {
        // Build up data to post
        var sendParamsList = [];
        // don't regenerate a new random key for each recipient
        var fromKey = params.fromKey || bitcoin_1.makeRandomKey().toWIF();
        recipients.forEach(function (recipient) {
            var outputIndex = recipient.outputIndex;
            var info = travelInfoMap[outputIndex];
            if (info) {
                if (info.amount && info.amount !== recipient.amount) {
                    throw new Error('amount did not match for output index ' + outputIndex);
                }
                var sendParams = self.prepareParams({
                    txid: params.txid,
                    recipient: recipient,
                    travelInfo: info,
                    fromKey: fromKey,
                    noValidate: true // don't re-validate
                });
                sendParamsList.push(sendParams);
            }
        });
        var result = {
            matched: sendParamsList.length,
            results: []
        };
        var sendSerial = function () {
            var sendParams = sendParamsList.shift();
            if (!sendParams) {
                return result;
            }
            return self.send(sendParams)
                .then(function (res) {
                result.results.push({ result: res });
                return sendSerial();
            })
                .catch(function (err) {
                result.results.push({ error: err.toString() });
                return sendSerial();
            });
        };
        return sendSerial();
    });
};
module.exports = TravelRule;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhdmVsUnVsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmF2ZWxSdWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7R0FFRzs7QUFFSDtHQUNHO0FBQ0gsRUFBRTtBQUNGLG9CQUFvQjtBQUNwQiwyQ0FBMkM7QUFDM0MsRUFBRTtBQUNGLG9EQUFvRDtBQUNwRCxFQUFFO0FBRUYseUNBQTJDO0FBQzNDLGlDQUFtQztBQUNuQywwQkFBNEI7QUFDNUIscUNBQThEO0FBeUI5RCxFQUFFO0FBQ0YsY0FBYztBQUNkLEVBQUU7QUFDRixJQUFNLFVBQVUsR0FBRyxVQUFTLEtBQUs7SUFDL0IsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDckIsQ0FBQyxDQUFDO0FBRUYsVUFBVSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsVUFBUyxLQUFLO0lBQ3ZDLEtBQUssR0FBRyxLQUFLLElBQUksRUFBRSxDQUFDO0lBQ3BCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQyxDQUFDO0FBQzVDLENBQUMsQ0FBQztBQUdGOzs7Ozs7SUFNSTtBQUNKLFVBQVUsQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLFVBQVMsTUFBTSxFQUFFLFFBQVE7SUFDNUQsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFDdEIsTUFBTSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUM7SUFDekMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFFdEQsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLGFBQWEsQ0FBQyxDQUFDO0lBQ2xELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENB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Q0FBQztRQUVGLElBQU0sVUFBVSxHQUFHO1lBQ2pCLElBQU0sVUFBVSxHQUFHLGNBQWMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUMxQyxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNmLE9BQU8sTUFBTSxDQUFDO2FBQ2Y7WUFDRCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO2lCQUMzQixJQUFJLENBQUMsVUFBUyxHQUFHO2dCQUNoQixNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUNyQyxPQUFPLFVBQVUsRUFBRSxDQUFDO1lBQ3RCLENBQUMsQ0FBQztpQkFDRCxLQUFLLENBQUMsVUFBUyxHQUFHO2dCQUNqQixNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUMvQyxPQUFPLFVBQVUsRUFBRSxDQUFDO1lBQ3RCLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDO1FBRUYsT0FBTyxVQUFVLEVBQUUsQ0FBQztJQUN0QixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxPQUFPLEdBQUcsVUFBVSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaGlkZGVuXG4gKi9cblxuLyoqXG4gKi9cbi8vXG4vLyBUcmF2ZWxSdWxlIE9iamVjdFxuLy8gQml0R28gYWNjZXNzb3IgZm9yIGEgc3BlY2lmaWMgZW50ZXJwcmlzZVxuLy9cbi8vIENvcHlyaWdodCAyMDE0LCBCaXRHbywgSW5jLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG5cbmltcG9ydCAqIGFzIGJpdGNvaW4gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCAqIGFzIGNvbW1vbiBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBnZXROZXR3b3JrLCBtYWtlUmFuZG9tS2V5LCBoZFBhdGggfSBmcm9tICcuL2JpdGNvaW4nO1xuXG5pbnRlcmZhY2UgRGVjcnlwdFJlY2VpdmVkVHJhdmVsUnVsZU9wdGlvbnMge1xuICB0eD86IHtcbiAgICByZWNlaXZlZFRyYXZlbEluZm8/OiB7XG4gICAgICB0b1B1YktleVBhdGg6IHN0cmluZztcbiAgICAgIGZyb21QdWJLZXk6IHN0cmluZztcbiAgICAgIGVuY3J5cHRlZFRyYXZlbEluZm86IHN0cmluZztcbiAgICAgIHRyYXZlbEluZm86IHN0cmluZztcbiAgICAgIHRyYW5zYWN0aW9uSWQ6IHN0cmluZztcbiAgICAgIG91dHB1dEluZGV4OiBudW1iZXI7XG4gICAgfVtdO1xuICB9O1xuICBrZXljaGFpbj86IHtcbiAgICB4cHJ2Pzogc3RyaW5nO1xuICB9O1xuICBoZG5vZGU/OiBiaXRjb2luLkhETm9kZTtcbn1cblxuaW50ZXJmYWNlIFJlY2lwaWVudCB7XG4gIGVudGVycHJpc2U6IHN0cmluZztcbiAgcHViS2V5OiBzdHJpbmc7XG4gIG91dHB1dEluZGV4OiBzdHJpbmc7XG59XG5cbi8vXG4vLyBDb25zdHJ1Y3RvclxuLy9cbmNvbnN0IFRyYXZlbFJ1bGUgPSBmdW5jdGlvbihiaXRnbykge1xuICB0aGlzLmJpdGdvID0gYml0Z287XG59O1xuXG5UcmF2ZWxSdWxlLnByb3RvdHlwZS51cmwgPSBmdW5jdGlvbihleHRyYSkge1xuICBleHRyYSA9IGV4dHJhIHx8ICcnO1xuICByZXR1cm4gdGhpcy5iaXRnby51cmwoJy90cmF2ZWwvJyArIGV4dHJhKTtcbn07XG5cblxuLyoqXG4gICogR2V0IGF2YWlsYWJsZSB0cmF2ZWwtcnVsZSBpbmZvIHJlY2lwaWVudHMgZm9yIGEgdHJhbnNhY3Rpb25cbiAgKiBAcGFyYW0gcGFyYW1zXG4gICogIHR4aWQ6IHRyYW5zYWN0aW9uIGlkXG4gICogQHBhcmFtIGNhbGxiYWNrXG4gICogQHJldHVybnMgeyp9XG4gICovXG5UcmF2ZWxSdWxlLnByb3RvdHlwZS5nZXRSZWNpcGllbnRzID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIHBhcmFtcy50eGlkID0gcGFyYW1zLnR4aWQgfHwgcGFyYW1zLmhhc2g7XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndHhpZCddLCBbXSwgY2FsbGJhY2spO1xuXG4gIGNvbnN0IHVybCA9IHRoaXMudXJsKHBhcmFtcy50eGlkICsgJy9yZWNpcGllbnRzJyk7XG4gIHJldHVybiB0aGlzLmJpdGdvLmdldCh1cmwpXG4gIC5yZXN1bHQoJ3JlY2lwaWVudHMnKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG5UcmF2ZWxSdWxlLnByb3RvdHlwZS52YWxpZGF0ZVRyYXZlbEluZm8gPSBmdW5jdGlvbihpbmZvKSB7XG4gIGNvbnN0IGZpZWxkcyA9IHtcbiAgICBhbW91bnQ6IHsgdHlwZTogJ251bWJlcicgfSxcbiAgICB0b0FkZHJlc3M6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICB0b0VudGVycHJpc2U6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICBmcm9tVXNlck5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICBmcm9tVXNlckFjY291bnQ6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICBmcm9tVXNlckFkZHJlc3M6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICB0b1VzZXJOYW1lOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgdG9Vc2VyQWNjb3VudDogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgIHRvVXNlckFkZHJlc3M6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICBleHRyYTogeyB0eXBlOiAnb2JqZWN0JyB9XG4gIH07XG5cbiAgXy5mb3JFYWNoKGZpZWxkcywgZnVuY3Rpb24oZmllbGQ6IGFueSwgZmllbGROYW1lKSB7XG4gICAgLy8gTm8gcmVxdWlyZWQgZmllbGRzIHlldCAtLSBzaG91bGQgdGhlcmUgYmU/XG4gICAgaWYgKGZpZWxkLnJlcXVpcmVkKSB7XG4gICAgICBpZiAoaW5mb1tmaWVsZE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIGZpZWxkICcgKyBmaWVsZE5hbWUgKyAnIGluIHRyYXZlbCBpbmZvJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbmZvW2ZpZWxkTmFtZV0gJiYgdHlwZW9mKGluZm9bZmllbGROYW1lXSkgIT09IGZpZWxkLnR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5jb3JyZWN0IHR5cGUgZm9yIGZpZWxkICcgKyBmaWVsZE5hbWUgKyAnIGluIHRyYXZlbCBpbmZvLCBleHBlY3RlZCAnICsgZmllbGQudHlwZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBTdHJpcCBvdXQgYW55IG90aGVyIGZpZWxkcyB3ZSBkb24ndCBrbm93IGFib3V0XG4gIGNvbnN0IHJlc3VsdCA9IF8ucGljayhpbmZvLCBfLmtleXMoZmllbGRzKSk7XG4gIGlmIChfLmlzRW1wdHkocmVzdWx0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZW1wdHkgdHJhdmVsIGRhdGEnKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIHRyYW5zYWN0aW9uIG9iamVjdCBhcyByZXR1cm5lZCBieSBnZXRUcmFuc2FjdGlvbiBvciBsaXN0VHJhbnNhY3Rpb25zLCBhbG9uZ1xuICogd2l0aCBhIGtleWNoYWluIChvciBoZG5vZGUgb2JqZWN0KSwgYW5kIGF0dGVtcHRzIHRvIGRlY3J5cHQgYW55IGVuY3J5cHRlZCB0cmF2ZWxcbiAqIGluZm8gaW5jbHVkZWQgaW4gdGhlIHRyYW5zYWN0aW9uJ3MgcmVjZWl2ZWRUcmF2ZWxJbmZvIGZpZWxkLlxuICogUGFyYW1ldGVyczpcbiAqICAgdHg6IGEgdHJhbnNhY3Rpb24gb2JqZWN0XG4gKiAgIGtleWNoYWluOiBrZXljaGFpbiBvYmplY3QgKHdpdGggeHBydilcbiAqICAgaGRub2RlOiBhIGJpdGNvaW4uSEROb2RlIG9iamVjdCAobWF5IGJlIHByb3ZpZGVkIGluc3RlYWQgb2Yga2V5Y2hhaW4pXG4gKiBSZXR1cm5zOlxuICogICB0aGUgdHggb2JqZWN0LCBhdWdtZW50ZWQgd2l0aCBkZWNyeXB0ZWQgdHJhdmVsSW5mbyBmaWVsZHNcbiAqL1xuVHJhdmVsUnVsZS5wcm90b3R5cGUuZGVjcnlwdFJlY2VpdmVkVHJhdmVsSW5mbyA9IGZ1bmN0aW9uKHBhcmFtczogRGVjcnlwdFJlY2VpdmVkVHJhdmVsUnVsZU9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB0eCA9IHBhcmFtcy50eDtcbiAgaWYgKCFfLmlzT2JqZWN0KHR4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIHR4IHBhcmFtIHRvIGJlIG9iamVjdCcpO1xuICB9XG5cbiAgaWYgKCF0eC5yZWNlaXZlZFRyYXZlbEluZm8gfHwgIXR4LnJlY2VpdmVkVHJhdmVsSW5mby5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHg7XG4gIH1cblxuICBsZXQgaGROb2RlO1xuICAvLyBQYXNzaW5nIGluIGhkbm9kZSBpcyBmYXN0ZXIgYmVjYXVzZSBpdCBkb2Vzbid0IHJlY29uc3RydWN0IHRoZSBrZXkgZXZlcnkgdGltZVxuICBpZiAocGFyYW1zLmhkbm9kZSkge1xuICAgIGhkTm9kZSA9IHBhcmFtcy5oZG5vZGU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qga2V5Y2hhaW4gPSBwYXJhbXMua2V5Y2hhaW47XG4gICAgaWYgKCFfLmlzT2JqZWN0KGtleWNoYWluKSB8fCAhXy5pc1N0cmluZyhrZXljaGFpbi54cHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3Rpbmcga2V5Y2hhaW4gcGFyYW0gd2l0aCB4cHJ2Jyk7XG4gICAgfVxuICAgIGhkTm9kZSA9IGJpdGNvaW4uSEROb2RlLmZyb21CYXNlNTgoa2V5Y2hhaW4ueHBydik7XG4gIH1cblxuICBjb25zdCBzZWxmID0gdGhpcztcbiAgY29uc3QgaGRQYXRoTm9kZSA9IGhkUGF0aChoZE5vZGUpO1xuICB0eC5yZWNlaXZlZFRyYXZlbEluZm8uZm9yRWFjaChmdW5jdGlvbihpbmZvKSB7XG4gICAgY29uc3Qga2V5ID0gaGRQYXRoTm9kZS5kZXJpdmVLZXkoaW5mby50b1B1YktleVBhdGgpO1xuICAgIGNvbnN0IHNlY3JldCA9IHNlbGYuYml0Z28uZ2V0RUNESFNlY3JldCh7XG4gICAgICBlY2tleToga2V5LFxuICAgICAgb3RoZXJQdWJLZXlIZXg6IGluZm8uZnJvbVB1YktleVxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZWNyeXB0ZWQgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICBpbnB1dDogaW5mby5lbmNyeXB0ZWRUcmF2ZWxJbmZvLFxuICAgICAgICBwYXNzd29yZDogc2VjcmV0XG4gICAgICB9KTtcbiAgICAgIGluZm8udHJhdmVsSW5mbyA9IEpTT04ucGFyc2UoZGVjcnlwdGVkKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCB0byBkZWNyeXB0IG9yIHBhcnNlIHRyYXZlbCBpbmZvIGZvciAnLCBpbmZvLnRyYW5zYWN0aW9uSWQgKyAnOicgKyBpbmZvLm91dHB1dEluZGV4KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0eDtcbn07XG5cblRyYXZlbFJ1bGUucHJvdG90eXBlLnByZXBhcmVQYXJhbXMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBwYXJhbXMudHhpZCA9IHBhcmFtcy50eGlkIHx8IHBhcmFtcy5oYXNoO1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3R4aWQnXSwgWydmcm9tUHJpdmF0ZUluZm8nXSk7XG4gIGNvbnN0IHR4aWQgPSBwYXJhbXMudHhpZDtcbiAgY29uc3QgcmVjaXBpZW50OiBSZWNpcGllbnQgfCB1bmRlZmluZWQgPSBwYXJhbXMucmVjaXBpZW50O1xuICBsZXQgdHJhdmVsSW5mbyA9IHBhcmFtcy50cmF2ZWxJbmZvO1xuICBpZiAoIXJlY2lwaWVudCB8fCAhXy5pc09iamVjdChyZWNpcGllbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG9yIG1pc3NpbmcgcmVjaXBpZW50Jyk7XG4gIH1cbiAgaWYgKCF0cmF2ZWxJbmZvIHx8ICFfLmlzT2JqZWN0KHRyYXZlbEluZm8pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG9yIG1pc3NpbmcgdHJhdmVsSW5mbycpO1xuICB9XG4gIGlmICghcGFyYW1zLm5vVmFsaWRhdGUpIHtcbiAgICB0cmF2ZWxJbmZvID0gdGhpcy52YWxpZGF0ZVRyYXZlbEluZm8odHJhdmVsSW5mbyk7XG4gIH1cblxuICAvLyBGaWxsIGluIHRvRW50ZXJwcmlzZSBpZiBub3QgYWxyZWFkeSBmaWxsZWRcbiAgaWYgKCF0cmF2ZWxJbmZvLnRvRW50ZXJwcmlzZSAmJiByZWNpcGllbnQuZW50ZXJwcmlzZSkge1xuICAgIHRyYXZlbEluZm8udG9FbnRlcnByaXNlID0gcmVjaXBpZW50LmVudGVycHJpc2U7XG4gIH1cblxuICAvLyBJZiBhIGtleSB3YXMgbm90IHByb3ZpZGVkLCBjcmVhdGUgYSBuZXcgcmFuZG9tIGtleVxuICBsZXQgZnJvbUtleSA9IHBhcmFtcy5mcm9tS2V5ICYmIGJpdGNvaW4uRUNQYWlyLmZyb21XSUYocGFyYW1zLmZyb21LZXksIGdldE5ldHdvcmsoKSk7XG4gIGlmICghZnJvbUtleSkge1xuICAgIGZyb21LZXkgPSBtYWtlUmFuZG9tS2V5KCk7XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBzaGFyZWQga2V5IGZvciBlbmNyeXB0aW9uXG4gIGNvbnN0IHNoYXJlZFNlY3JldCA9IHRoaXMuYml0Z28uZ2V0RUNESFNlY3JldCh7XG4gICAgZWNrZXk6IGZyb21LZXksXG4gICAgb3RoZXJQdWJLZXlIZXg6IHJlY2lwaWVudC5wdWJLZXlcbiAgfSk7XG5cbiAgLy8gSlNPTi1pZnkgYW5kIGVuY3J5cHQgdGhlIHBheWxvYWRcbiAgY29uc3QgdHJhdmVsSW5mb0pTT04gPSBKU09OLnN0cmluZ2lmeSh0cmF2ZWxJbmZvKTtcbiAgY29uc3QgZW5jcnlwdGVkVHJhdmVsSW5mbyA9IHRoaXMuYml0Z28uZW5jcnlwdCh7XG4gICAgaW5wdXQ6IHRyYXZlbEluZm9KU09OLFxuICAgIHBhc3N3b3JkOiBzaGFyZWRTZWNyZXRcbiAgfSk7XG5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHR4aWQ6IHR4aWQsXG4gICAgb3V0cHV0SW5kZXg6IHJlY2lwaWVudC5vdXRwdXRJbmRleCxcbiAgICB0b1B1YktleTogcmVjaXBpZW50LnB1YktleSxcbiAgICBmcm9tUHViS2V5OiBmcm9tS2V5LmdldFB1YmxpY0tleUJ1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICBlbmNyeXB0ZWRUcmF2ZWxJbmZvOiBlbmNyeXB0ZWRUcmF2ZWxJbmZvLFxuICAgIGZyb21Qcml2YXRlSW5mbzogdW5kZWZpbmVkXG4gIH07XG5cbiAgaWYgKHBhcmFtcy5mcm9tUHJpdmF0ZUluZm8pIHtcbiAgICByZXN1bHQuZnJvbVByaXZhdGVJbmZvID0gcGFyYW1zLmZyb21Qcml2YXRlSW5mbztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFNlbmQgdHJhdmVsIGRhdGEgdG8gdGhlIHNlcnZlciBmb3IgYSB0cmFuc2FjdGlvblxuICovXG5UcmF2ZWxSdWxlLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIHBhcmFtcy50eGlkID0gcGFyYW1zLnR4aWQgfHwgcGFyYW1zLmhhc2g7XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndHhpZCcsICd0b1B1YktleScsICdlbmNyeXB0ZWRUcmF2ZWxJbmZvJ10sIFsnZnJvbVB1YktleScsICdmcm9tUHJpdmF0ZUluZm8nXSwgY2FsbGJhY2spO1xuXG4gIGlmICghXy5pc051bWJlcihwYXJhbXMub3V0cHV0SW5kZXgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG91dHB1dEluZGV4Jyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMudXJsKHBhcmFtcy50eGlkICsgJy8nICsgcGFyYW1zLm91dHB1dEluZGV4KSlcbiAgLnNlbmQocGFyYW1zKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTZW5kIG11bHRpcGxlIHRyYXZlbCBydWxlIGluZm9zIGZvciB0aGUgb3V0cHV0cyBvZiBhIHNpbmdsZSB0cmFuc2FjdGlvbi5cbiAqIFBhcmFtZXRlcnM6XG4gKiAgIC0gdHhpZCAob3IgaGFzaCk6IHR4aWQgb2YgdGhlIHRyYW5zYWN0aW9uIChtdXN0IGJlIGEgc2VuZGVyIG9mIHRoZSB0eClcbiAqICAgLSB0cmF2ZWxJbmZvczogYXJyYXkgb2YgdHJhdmVsSW5mbyBvYmplY3RzIHdoaWNoIGxvb2sgbGlrZSB0aGUgZm9sbG93aW5nOlxuICogICAgIHtcbiAqICAgICAgIG91dHB1dEluZGV4OiBudW1iZXIsICAgICAvLyB0eCBvdXRwdXQgaW5kZXhcbiAqICAgICAgIGZyb21Vc2VyTmFtZTogc3RyaW5nLCAgICAvLyBuYW1lIG9mIHRoZSBzZW5kaW5nIHVzZXJcbiAqICAgICAgIGZyb21Vc2VyQWNjb3VudDogc3RyaW5nLCAvLyBhY2NvdW50IGlkIG9mIHRoZSBzZW5kaW5nIHVzZXJcbiAqICAgICAgIGZyb21Vc2VyQWRkcmVzczogc3RyaW5nLCAvLyBtYWlsaW5nIGFkZHJlc3Mgb2YgdGhlIHNlbmRpbmcgdXNlclxuICogICAgICAgdG9Vc2VyTmFtZTogc3RyaW5nLCAgICAgIC8vIG5hbWUgb2YgdGhlIHJlY2VpdmluZyB1c2VyXG4gKiAgICAgICB0b1VzZXJBY2NvdW50OiBzdHJpbmcsICAgLy8gYWNjb3VudCBpZCBvZiB0aGUgcmVjZWl2aW5nIHVzZXJcbiAqICAgICAgIHRvVXNlckFkZHJlc3M6IHN0cmluZyAgICAvLyBtYWlsaW5nIGFkZHJlc3Mgb2YgdGhlIHJlY2VpdmluZyB1c2VyXG4gKiAgICAgfVxuICogICAgIEFsbCBmaWVsZHMgYXNpZGUgZnJvbSBvdXRwdXRJbmRleCBhcmUgb3B0aW9uYWwsIGJ1dCBhdCBsZWFzdCBvbmUgbXVzdFxuICogICAgIGJlIGRlZmluZWQuXG4gKlxuICogIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gcHJvdmlkZSB0cmF2ZWxJbmZvIGZvciBhbGwgb3V0cHV0IGluZGljZXMuXG4gKiAgRW5kLXRvLWVuZCBlbmNyeXB0aW9uIG9mIHRoZSB0cmF2ZWwgaW5mbyBpcyBoYW5kbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhpcyBtZXRob2QuXG4gKlxuICovXG5UcmF2ZWxSdWxlLnByb3RvdHlwZS5zZW5kTWFueSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBwYXJhbXMudHhpZCA9IHBhcmFtcy50eGlkIHx8IHBhcmFtcy5oYXNoO1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3R4aWQnXSwgY2FsbGJhY2spO1xuXG4gIGNvbnN0IHRyYXZlbEluZm9zID0gcGFyYW1zLnRyYXZlbEluZm9zO1xuICBpZiAoIV8uaXNBcnJheSh0cmF2ZWxJbmZvcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHBhcmFtZXRlciB0cmF2ZWxJbmZvcyB0byBiZSBhcnJheScpO1xuICB9XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGNvbnN0IHRyYXZlbEluZm9NYXAgPSBfKHRyYXZlbEluZm9zKVxuICAua2V5QnkoJ291dHB1dEluZGV4JylcbiAgLm1hcFZhbHVlcyhmdW5jdGlvbih0cmF2ZWxJbmZvKSB7XG4gICAgcmV0dXJuIHNlbGYudmFsaWRhdGVUcmF2ZWxJbmZvKHRyYXZlbEluZm8pO1xuICB9KVxuICAudmFsdWUoKTtcblxuICByZXR1cm4gc2VsZi5nZXRSZWNpcGllbnRzKHsgdHhpZDogcGFyYW1zLnR4aWQgfSlcbiAgLnRoZW4oZnVuY3Rpb24ocmVjaXBpZW50cykge1xuXG4gICAgLy8gQnVpbGQgdXAgZGF0YSB0byBwb3N0XG4gICAgY29uc3Qgc2VuZFBhcmFtc0xpc3Q6IGFueVtdID0gW107XG4gICAgLy8gZG9uJ3QgcmVnZW5lcmF0ZSBhIG5ldyByYW5kb20ga2V5IGZvciBlYWNoIHJlY2lwaWVudFxuICAgIGNvbnN0IGZyb21LZXkgPSBwYXJhbXMuZnJvbUtleSB8fCBtYWtlUmFuZG9tS2V5KCkudG9XSUYoKTtcblxuICAgIHJlY2lwaWVudHMuZm9yRWFjaChmdW5jdGlvbihyZWNpcGllbnQpIHtcbiAgICAgIGNvbnN0IG91dHB1dEluZGV4ID0gcmVjaXBpZW50Lm91dHB1dEluZGV4O1xuICAgICAgY29uc3QgaW5mbyA9IHRyYXZlbEluZm9NYXBbb3V0cHV0SW5kZXhdO1xuICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgaWYgKGluZm8uYW1vdW50ICYmIGluZm8uYW1vdW50ICE9PSByZWNpcGllbnQuYW1vdW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbW91bnQgZGlkIG5vdCBtYXRjaCBmb3Igb3V0cHV0IGluZGV4ICcgKyBvdXRwdXRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZFBhcmFtcyA9IHNlbGYucHJlcGFyZVBhcmFtcyh7XG4gICAgICAgICAgdHhpZDogcGFyYW1zLnR4aWQsXG4gICAgICAgICAgcmVjaXBpZW50OiByZWNpcGllbnQsXG4gICAgICAgICAgdHJhdmVsSW5mbzogaW5mbyxcbiAgICAgICAgICBmcm9tS2V5OiBmcm9tS2V5LFxuICAgICAgICAgIG5vVmFsaWRhdGU6IHRydWUgLy8gZG9uJ3QgcmUtdmFsaWRhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbmRQYXJhbXNMaXN0LnB1c2goc2VuZFBhcmFtcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXN1bHQ6IHtcbiAgICAgIG1hdGNoZWQ6IG51bWJlcjtcbiAgICAgIHJlc3VsdHM6IHtcbiAgICAgICAgcmVzdWx0PzogYW55O1xuICAgICAgICBlcnJvcj86IHN0cmluZztcbiAgICAgIH1bXTtcbiAgICB9ID0ge1xuICAgICAgbWF0Y2hlZDogc2VuZFBhcmFtc0xpc3QubGVuZ3RoLFxuICAgICAgcmVzdWx0czogW11cbiAgICB9O1xuXG4gICAgY29uc3Qgc2VuZFNlcmlhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3Qgc2VuZFBhcmFtcyA9IHNlbmRQYXJhbXNMaXN0LnNoaWZ0KCk7XG4gICAgICBpZiAoIXNlbmRQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLnNlbmQoc2VuZFBhcmFtcylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICByZXN1bHQucmVzdWx0cy5wdXNoKHsgcmVzdWx0OiByZXMgfSk7XG4gICAgICAgIHJldHVybiBzZW5kU2VyaWFsKCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICByZXN1bHQucmVzdWx0cy5wdXNoKHsgZXJyb3I6IGVyci50b1N0cmluZygpIH0pO1xuICAgICAgICByZXR1cm4gc2VuZFNlcmlhbCgpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBzZW5kU2VyaWFsKCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmF2ZWxSdWxlO1xuIl19