"use strict";
/**
 * @hidden
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/**
 */
//
// Wallet Object
// BitGo accessor for a specific wallet
//
// Copyright 2014, BitGo, Inc.  All Rights Reserved.
//
var unspents_1 = require("@bitgo/unspents");
var TransactionBuilder = require('./transactionBuilder');
var bitcoin = require("@bitgo/utxo-lib");
// TODO: switch to bitcoinjs-lib eventually once we upgrade it to version 3.x.x
var PendingApproval = require('./pendingapproval');
var common = require("./common");
var Bluebird = require("bluebird");
var co = Bluebird.coroutine;
var _ = require("lodash");
var bitcoin_1 = require("./bitcoin");
var request = require('superagent');
//
// Constructor
//
var Wallet = function (bitgo, wallet) {
    this.bitgo = bitgo;
    this.wallet = wallet;
    this.keychains = [];
    if (wallet.private) {
        this.keychains = wallet.private.keychains;
    }
};
Wallet.prototype.toJSON = function () {
    return this.wallet;
};
//
// id
// Get the id of this wallet.
//
Wallet.prototype.id = function () {
    return this.wallet.id;
};
//
// label
// Get the label of this wallet.
//
Wallet.prototype.label = function () {
    return this.wallet.label;
};
//
// balance
// Get the balance of this wallet.
//
Wallet.prototype.balance = function () {
    return this.wallet.balance;
};
//
// balance
// Get the spendable balance of this wallet.
// This is the total of all unspents except those that are unconfirmed and external
//
Wallet.prototype.spendableBalance = function () {
    return this.wallet.spendableBalance;
};
//
// confirmedBalance
// Get the confirmedBalance of this wallet.
//
Wallet.prototype.confirmedBalance = function () {
    return this.wallet.confirmedBalance;
};
//
// canSendInstant
// Returns if the wallet can send instant transactions
// This is impacted by the choice of backup key provider
//
Wallet.prototype.canSendInstant = function () {
    return this.wallet && this.wallet.canSendInstant;
};
//
// instant balance
// Get the instant balance of this wallet.
// This is the total of all unspents that may be spent instantly.
//
Wallet.prototype.instantBalance = function () {
    if (!this.canSendInstant()) {
        throw new Error('not an instant wallet');
    }
    return this.wallet.instantBalance;
};
//
// unconfirmedSends
// Get the balance of unconfirmedSends of this wallet.
//
Wallet.prototype.unconfirmedSends = function () {
    return this.wallet.unconfirmedSends;
};
//
// unconfirmedReceives
// Get the balance of unconfirmedReceives balance of this wallet.
//
Wallet.prototype.unconfirmedReceives = function () {
    return this.wallet.unconfirmedReceives;
};
//
// type
// Get the type of this wallet, e.g. 'safehd'
//
Wallet.prototype.type = function () {
    return this.wallet.type;
};
Wallet.prototype.url = function (extra) {
    extra = extra || '';
    return this.bitgo.url('/wallet/' + this.id() + extra);
};
//
// pendingApprovals
// returns the pending approvals list for this wallet as pending approval objects
//
Wallet.prototype.pendingApprovals = function () {
    var self = this;
    return this.wallet.pendingApprovals.map(function (p) {
        return new PendingApproval(self.bitgo, p, self);
    });
};
//
// approvalsRequired
// returns the number of approvals required to approve pending approvals involving this wallet
//
Wallet.prototype.approvalsRequired = function () {
    return this.wallet.approvalsRequired || 1;
};
//
// get
// Refetches this wallet and returns it
//
Wallet.prototype.get = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var self = this;
    return this.bitgo.get(this.url())
        .result()
        .then(function (res) {
        self.wallet = res;
        return self;
    })
        .nodeify(callback);
};
//
// updateApprovalsRequired
// Updates the number of approvals required on a pending approval involving this wallet.
// The approvals required is by default 1, but this function allows you to update the
// number such that 1 <= approvalsRequired <= walletAdmins.length - 1
//
Wallet.prototype.updateApprovalsRequired = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (params.approvalsRequired === undefined ||
        !_.isInteger(params.approvalsRequired) ||
        params.approvalsRequired < 1) {
        throw new Error('invalid approvalsRequired: must be a nonzero positive number');
    }
    var self = this;
    var currentApprovalsRequired = this.approvalsRequired();
    if (currentApprovalsRequired === params.approvalsRequired) {
        // no-op, just return the current wallet
        return Bluebird.try(function () {
            return self.wallet;
        })
            .nodeify(callback);
    }
    return this.bitgo.put(this.url())
        .send(params)
        .result()
        .nodeify(callback);
};
/**
 * Returns the correct chain for change, taking into consideration segwit
 */
Wallet.prototype.getChangeChain = function (params) {
    var useSegwitChange = !!this.bitgo.getConstants().enableSegwit;
    if (!_.isUndefined(params.segwitChange)) {
        if (!_.isBoolean(params.segwitChange)) {
            throw new Error('segwitChange must be a boolean');
        }
        // if segwit is disabled through the constants, segwit change should still not be created
        useSegwitChange = this.bitgo.getConstants().enableSegwit && params.segwitChange;
    }
    return useSegwitChange ? unspents_1.Codes.internal.p2shP2wsh : unspents_1.Codes.internal.p2sh;
};
//
// createAddress
// Creates a new address for use with this wallet.
//
Wallet.prototype.createAddress = function (params, callback) {
    var self = this;
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (this.type() === 'safe') {
        throw new Error('You are using a legacy wallet that cannot create a new address');
    }
    // Default to client-side address validation on, for safety. Use validate=false to disable.
    var shouldValidate = params.validate !== undefined ? params.validate : this.bitgo.getValidate();
    var allowExisting = params.allowExisting;
    if (typeof allowExisting !== 'boolean') {
        params.allowExisting = (allowExisting === 'true');
    }
    var isSegwit = this.bitgo.getConstants().enableSegwit;
    var defaultChain = isSegwit ? unspents_1.Codes.external.p2shP2wsh : unspents_1.Codes.external.p2sh;
    var chain = params.chain;
    if (chain === null || chain === undefined) {
        chain = defaultChain;
    }
    return this.bitgo.post(this.url('/address/' + chain))
        .send(params)
        .result()
        .then(function (addr) {
        if (shouldValidate) {
            self.validateAddress(addr);
        }
        return addr;
    })
        .nodeify(callback);
};
/**
 * Generate address locally without calling server
 * @param params
 *
 */
Wallet.prototype.generateAddress = function (_a) {
    var segwit = _a.segwit, path = _a.path, keychains = _a.keychains, threshold = _a.threshold;
    var isSegwit = !!segwit;
    var signatureThreshold = 2;
    if (_.isInteger(threshold)) {
        signatureThreshold = threshold;
        if (signatureThreshold <= 0) {
            throw new Error('threshold has to be positive');
        }
    }
    var pathRegex = /^\/1?[01]\/\d+$/;
    if (!path.match(pathRegex)) {
        throw new Error('unsupported path: ' + path);
    }
    var rootKeys = this.keychains;
    if (Array.isArray(keychains)) {
        rootKeys = keychains;
    }
    var network = common.Environments[this.bitgo.getEnv()].network;
    var derivedKeys = rootKeys.map(function (k) {
        var hdnode = bitcoin.HDNode.fromBase58(k.xpub);
        var derivationPath = k.path + path;
        if (k.walletSubPath) {
            // if a keychain has a wallet subpath, it should be used as an infix
            derivationPath = k.path + k.walletSubPath + path;
        }
        if (!derivationPath.startsWith('m')) {
            // all derivation paths need to start with m, but k.path may already contain that
            derivationPath = "m/" + derivationPath;
        }
        return bitcoin_1.hdPath(hdnode).deriveKey(derivationPath).getPublicKeyBuffer();
    });
    var pathComponents = path.split('/');
    var normalizedPathComponents = _.map(pathComponents, function (component) {
        if (component && component.length > 0) {
            return parseInt(component, 10);
        }
    });
    var pathDetails = _.filter(normalizedPathComponents, _.isInteger);
    var addressDetails = {
        chainPath: path,
        path: path,
        chain: pathDetails[0],
        index: pathDetails[1],
        wallet: this.id()
    };
    // redeem script normally, witness script for segwit
    var inputScript = bitcoin.script.multisig.output.encode(signatureThreshold, derivedKeys);
    var inputScriptHash = bitcoin.crypto.hash160(inputScript);
    var outputScript = bitcoin.script.scriptHash.output.encode(inputScriptHash);
    addressDetails.redeemScript = inputScript.toString('hex');
    if (isSegwit) {
        var witnessScriptHash = bitcoin.crypto.sha256(inputScript);
        var redeemScript = bitcoin.script.witnessScriptHash.output.encode(witnessScriptHash);
        var redeemScriptHash = bitcoin.crypto.hash160(redeemScript);
        outputScript = bitcoin.script.scriptHash.output.encode(redeemScriptHash);
        addressDetails.witnessScript = inputScript.toString('hex');
        addressDetails.redeemScript = redeemScript.toString('hex');
    }
    addressDetails.outputScript = outputScript.toString('hex');
    addressDetails.address = bitcoin.address.fromOutputScript(outputScript, bitcoin_1.getNetwork(network));
    return addressDetails;
};
//
// validateAddress
// Validates an address and path by calculating it locally from the keychain xpubs
//
Wallet.prototype.validateAddress = function (params) {
    common.validateParams(params, ['address', 'path'], []);
    var isSegwit = !!params.witnessScript && params.witnessScript.length > 0;
    var generatedAddress = this.generateAddress({ path: params.path, segwit: isSegwit });
    if (generatedAddress.address !== params.address) {
        throw new Error('address validation failure: ' + params.address + ' vs. ' + generatedAddress.address);
    }
};
//
// addresses
// Gets the addresses of a HD wallet.
// Options include:
//  limit: the number of addresses to get
//
Wallet.prototype.addresses = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var query = {};
    if (params.details) {
        query.details = 1;
    }
    var chain = params.chain;
    if (chain !== null && chain !== undefined) {
        if (Array.isArray(chain)) {
            query.chain = _.uniq(_.filter(chain, _.isInteger));
        }
        else {
            if (chain !== 0 && chain !== 1) {
                throw new Error('invalid chain argument, expecting 0 or 1');
            }
            query.chain = chain;
        }
    }
    if (params.limit) {
        if (!_.isInteger(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        query.limit = params.limit;
    }
    if (params.skip) {
        if (!_.isInteger(params.skip)) {
            throw new Error('invalid skip argument, expecting number');
        }
        query.skip = params.skip;
    }
    if (params.sort) {
        if (!_.isNumber(params.sort)) {
            throw new Error('invalid sort argument, expecting number');
        }
        query.sort = params.sort;
    }
    var url = this.url('/addresses');
    return this.bitgo.get(url)
        .query(query)
        .result()
        .nodeify(callback);
};
Wallet.prototype.stats = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var args = [];
    if (params.limit) {
        if (!_.isInteger(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        args.push('limit=' + params.limit);
    }
    var query = '';
    if (args.length) {
        query = '?' + args.join('&');
    }
    var url = this.url('/stats' + query);
    return this.bitgo.get(url)
        .result()
        .nodeify(callback);
};
/**
 * Refresh the wallet object by syncing with the back-end
 * @param callback
 * @returns {Wallet}
 */
Wallet.prototype.refresh = function (params, callback) {
    return co(function () {
        var query, res;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    query = _.extend({}, _.pick(params, ['gpk']));
                    return [4 /*yield*/, this.bitgo.get(this.url()).query(query).result()];
                case 1:
                    res = _a.sent();
                    this.wallet = res;
                    return [2 /*return*/, this];
            }
        });
    }).call(this).asCallback(callback);
};
//
// address
// Gets information about a single address on a HD wallet.
// Information includes index, path, redeemScript, sent, received, txCount and balance
// Options include:
//  address: the address on this wallet to get
//
Wallet.prototype.address = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['address'], [], callback);
    var url = this.url('/addresses/' + params.address);
    return this.bitgo.get(url)
        .result()
        .nodeify(callback);
};
/**
 * Freeze the wallet for a duration of choice, stopping BitGo from signing any transactions.
 * @param {number} limit The duration to freeze the wallet for in seconds, defaults to 3600.
 */
Wallet.prototype.freeze = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (params.duration) {
        if (!_.isNumber(params.duration)) {
            throw new Error('invalid duration - should be number of seconds');
        }
    }
    return this.bitgo.post(this.url('/freeze'))
        .send(params)
        .result()
        .nodeify(callback);
};
//
// delete
// Deletes the wallet
//
Wallet.prototype.delete = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.del(this.url())
        .result()
        .nodeify(callback);
};
//
// labels
// List the labels for the addresses in a given wallet
//
Wallet.prototype.labels = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var url = this.bitgo.url('/labels/' + this.id());
    return this.bitgo.get(url)
        .result('labels')
        .nodeify(callback);
};
/**
 * Rename a wallet
 * @param params
 *  - label: the wallet's intended new name
 * @param callback
 * @returns {*}
 */
Wallet.prototype.setWalletName = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['label'], [], callback);
    var url = this.bitgo.url('/wallet/' + this.id());
    return this.bitgo.put(url)
        .send({ label: params.label })
        .result()
        .nodeify(callback);
};
//
// setLabel
// Sets a label on the provided address
//
Wallet.prototype.setLabel = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['address', 'label'], [], callback);
    var self = this;
    if (!self.bitgo.verifyAddress({ address: params.address })) {
        throw new Error('Invalid bitcoin address: ' + params.address);
    }
    var url = this.bitgo.url('/labels/' + this.id() + '/' + params.address);
    return this.bitgo.put(url)
        .send({ label: params.label })
        .result()
        .nodeify(callback);
};
//
// deleteLabel
// Deletes the label associated with the provided address
//
Wallet.prototype.deleteLabel = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['address'], [], callback);
    var self = this;
    if (!self.bitgo.verifyAddress({ address: params.address })) {
        throw new Error('Invalid bitcoin address: ' + params.address);
    }
    var url = this.bitgo.url('/labels/' + this.id() + '/' + params.address);
    return this.bitgo.del(url)
        .result()
        .nodeify(callback);
};
//
// unspents
// List ALL the unspents for a given wallet
// This method will return a paged list of all unspents
//
// Parameters include:
//   limit:  the optional limit of unspents to collect in BTC
//   minConf: only include results with this number of confirmations
//   target: the amount of btc to find to spend
//   instant: only find instant transactions (must specify a target)
//
Wallet.prototype.unspents = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var allUnspents = [];
    var self = this;
    var getUnspentsBatch = function (skip, limit) {
        var queryObject = _.cloneDeep(params);
        if (skip > 0) {
            queryObject.skip = skip;
        }
        if (limit && limit > 0) {
            queryObject.limit = limit;
        }
        return self.unspentsPaged(queryObject)
            .then(function (result) {
            // The API has its own limit handling. For example, the API does not support limits bigger than 500. If the limit
            // specified here is bigger than that, we will have to do multiple requests with necessary limit adjustment.
            for (var i = 0; i < result.unspents.length; i++) {
                var unspent = result.unspents[i];
                allUnspents.push(unspent);
            }
            // Our limit adjustment makes sure that we never fetch more unspents than we need, meaning that if we hit the
            // limit, we hit it precisely
            if (allUnspents.length >= params.limit) {
                return allUnspents; // we aren't interested in any further unspents
            }
            var totalUnspentCount = result.total;
            // if no target is specified and the SDK indicates that there has been a limit, we need to fetch another batch
            if (!params.target && totalUnspentCount && totalUnspentCount > allUnspents.length) {
                // we need to fetch the next batch
                // let's just offset the current skip by the count
                var newSkip = skip + result.count;
                var newLimit = void 0;
                if (limit > 0) {
                    // we set the new limit to be precisely the number of missing unspents to hit our own limit
                    newLimit = limit - allUnspents.length;
                }
                return getUnspentsBatch(newSkip, newLimit);
            }
            return allUnspents;
        });
    };
    return getUnspentsBatch(0, params.limit)
        .nodeify(callback);
};
/**
 * List the unspents (paged) for a given wallet, returning the result as an object of unspents, count, skip and total
 * This method may not return all the unspents as the list is paged by the API
 * @param params
 * @param params.limit the optional limit of unspents to collect in BTC
 * @param params.skip index in list of unspents to start paging from
 * @param params.minConfirms only include results with this number of confirmations
 * @param params.target the amount of btc to find to spend
 * @param params.instant only find instant transactions (must specify a target)
 * @param params.targetWalletUnspents desired number of unspents to have in the wallet after the tx goes through (requires target)
 * @param params.minSize minimum unspent size in satoshis
 * @param params.segwit request segwit unspents (defaults to true if undefined)
 * @param params.allowLedgerSegwit allow segwit unspents for ledger devices (defaults to false if undefined)
 * @param callback
 * @returns {*}
 */
Wallet.prototype.unspentsPaged = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (!_.isUndefined(params.limit) && !_.isInteger(params.limit)) {
        throw new Error('invalid limit - should be number');
    }
    if (!_.isUndefined(params.skip) && !_.isInteger(params.skip)) {
        throw new Error('invalid skip - should be number');
    }
    if (!_.isUndefined(params.minConfirms) && !_.isInteger(params.minConfirms)) {
        throw new Error('invalid minConfirms - should be number');
    }
    if (!_.isUndefined(params.target) && !_.isNumber(params.target)) {
        throw new Error('invalid target - should be number');
    }
    if (!_.isUndefined(params.instant) && !_.isBoolean(params.instant)) {
        throw new Error('invalid instant flag - should be boolean');
    }
    if (!_.isUndefined(params.segwit) && !_.isBoolean(params.segwit)) {
        throw new Error('invalid segwit flag - should be boolean');
    }
    if (!_.isUndefined(params.targetWalletUnspents) && !_.isInteger(params.targetWalletUnspents)) {
        throw new Error('invalid targetWalletUnspents flag - should be number');
    }
    if (!_.isUndefined(params.minSize) && !_.isNumber(params.minSize)) {
        throw new Error('invalid argument: minSize must be a number');
    }
    if (!_.isUndefined(params.instant) && !_.isUndefined(params.minConfirms)) {
        throw new Error('only one of instant and minConfirms may be defined');
    }
    if (!_.isUndefined(params.targetWalletUnspents) && _.isUndefined(params.target)) {
        throw new Error('targetWalletUnspents can only be specified in conjunction with a target');
    }
    if (!_.isUndefined(params.allowLedgerSegwit) && !_.isBoolean(params.allowLedgerSegwit)) {
        throw new Error('invalid argument: allowLedgerSegwit must be a boolean');
    }
    var queryObject = _.cloneDeep(params);
    if (!_.isUndefined(params.target)) {
        // skip and limit are unavailable when a target is specified
        delete queryObject.skip;
        delete queryObject.limit;
    }
    queryObject.segwit = true;
    if (!_.isUndefined(params.segwit)) {
        queryObject.segwit = params.segwit;
    }
    if (!_.isUndefined(params.allowLedgerSegwit)) {
        queryObject.allowLedgerSegwit = params.allowLedgerSegwit;
    }
    return this.bitgo.get(this.url('/unspents'))
        .query(queryObject)
        .result()
        .nodeify(callback);
};
//
// transactions
// List the transactions for a given wallet
// Options include:
//     TODO:  Add iterators for start/count/etc
Wallet.prototype.transactions = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    var args = [];
    if (params.limit) {
        if (!_.isInteger(params.limit)) {
            throw new Error('invalid limit argument, expecting number');
        }
        args.push('limit=' + params.limit);
    }
    if (params.skip) {
        if (!_.isInteger(params.skip)) {
            throw new Error('invalid skip argument, expecting number');
        }
        args.push('skip=' + params.skip);
    }
    if (params.minHeight) {
        if (!_.isInteger(params.minHeight)) {
            throw new Error('invalid minHeight argument, expecting number');
        }
        args.push('minHeight=' + params.minHeight);
    }
    if (params.maxHeight) {
        if (!_.isInteger(params.maxHeight) || params.maxHeight < 0) {
            throw new Error('invalid maxHeight argument, expecting positive integer');
        }
        args.push('maxHeight=' + params.maxHeight);
    }
    if (params.minConfirms) {
        if (!_.isInteger(params.minConfirms) || params.minConfirms < 0) {
            throw new Error('invalid minConfirms argument, expecting positive integer');
        }
        args.push('minConfirms=' + params.minConfirms);
    }
    if (!_.isUndefined(params.compact)) {
        if (!_.isBoolean(params.compact)) {
            throw new Error('invalid compact argument, expecting boolean');
        }
        args.push('compact=' + params.compact);
    }
    var query = '';
    if (args.length) {
        query = '?' + args.join('&');
    }
    var url = this.url('/tx' + query);
    return this.bitgo.get(url)
        .result()
        .nodeify(callback);
};
//
// transaction
// Get a transaction by ID for a given wallet
Wallet.prototype.getTransaction = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    var url = this.url('/tx/' + params.id);
    return this.bitgo.get(url)
        .result()
        .nodeify(callback);
};
//
// pollForTransaction
// Poll a transaction until successful or times out
// Parameters:
//   id: the txid
//   delay: delay between polls in ms (default: 1000)
//   timeout: timeout in ms (default: 10000)
Wallet.prototype.pollForTransaction = function (params, callback) {
    var self = this;
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    if (params.delay && !_.isNumber(params.delay)) {
        throw new Error('invalid delay parameter');
    }
    if (params.timeout && !_.isNumber(params.timeout)) {
        throw new Error('invalid timeout parameter');
    }
    params.delay = params.delay || 1000;
    params.timeout = params.timeout || 10000;
    var start = new Date();
    var doNextPoll = function () {
        return self.getTransaction(params)
            .then(function (res) {
            return res;
        })
            .catch(function (err) {
            if (err.status !== 404 || new Date().valueOf() - start.valueOf() > params.timeout) {
                throw err;
            }
            return Bluebird.delay(params.delay)
                .then(function () {
                return doNextPoll();
            });
        });
    };
    return doNextPoll();
};
//
// transaction by sequence id
// Get a transaction by sequence id for a given wallet
Wallet.prototype.getWalletTransactionBySequenceId = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['sequenceId'], [], callback);
    var url = this.url('/tx/sequence/' + params.sequenceId);
    return this.bitgo.get(url)
        .result()
        .nodeify(callback);
};
//
// Key chains
// Gets the user key chain for this wallet
// The user key chain is typically the first keychain of the wallet and has the encrypted xpriv stored on BitGo.
// Useful when trying to get the users' keychain from the server before decrypting to sign a transaction.
Wallet.prototype.getEncryptedUserKeychain = function (params, callback) {
    return co(function () {
        var self, tryKeyChain;
        return __generator(this, function (_a) {
            params = params || {};
            common.validateParams(params, [], [], callback);
            self = this;
            tryKeyChain = co(function (index) {
                var error, params, keychain;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!self.keychains || index >= self.keychains.length) {
                                error = new Error('No encrypted keychains on this wallet.');
                                error.code = 'no_encrypted_keychain_on_wallet';
                                throw error;
                            }
                            params = { xpub: self.keychains[index].xpub };
                            return [4 /*yield*/, self.bitgo.keychains().get(params)];
                        case 1:
                            keychain = _a.sent();
                            // If we find the xprv, then this is probably the user keychain we're looking for
                            keychain.walletSubPath = self.keychains[index].path;
                            if (keychain.encryptedXprv) {
                                return [2 /*return*/, keychain];
                            }
                            return [2 /*return*/, tryKeyChain(index + 1)];
                    }
                });
            });
            return [2 /*return*/, tryKeyChain(0)];
        });
    }).call(this).asCallback(callback);
};
//
// createTransaction
// Create a transaction (unsigned). To sign it, do signTransaction
// Parameters:
//   recipients - object of recipient addresses and the amount to send to each e.g. {address:1500, address2:1500}
//   fee      - the blockchain fee to send (optional)
//   feeRate  - the fee per kb to send (optional)
//   minConfirms - minimum number of confirms to use when gathering unspents
//   forceChangeAtEnd - force change address to be last output (optional)
//   noSplitChange - disable automatic change splitting for purposes of unspent management
//   changeAddress - override the change address (optional)
//   validate - extra verification of change addresses (which are always verified server-side) (defaults to global config)
// Returns:
//   callback(err, { transactionHex: string, unspents: [inputs], fee: satoshis })
Wallet.prototype.createTransaction = function (params, callback) {
    params = _.extend({}, params);
    common.validateParams(params, [], [], callback);
    if ((!_.isNumber(params.fee) && !_.isUndefined(params.fee)) ||
        (!_.isNumber(params.feeRate) && !_.isUndefined(params.feeRate)) ||
        (!_.isNumber(params.minConfirms) && !_.isUndefined(params.minConfirms)) ||
        (!_.isBoolean(params.forceChangeAtEnd) && !_.isUndefined(params.forceChangeAtEnd)) ||
        (!_.isString(params.changeAddress) && !_.isUndefined(params.changeAddress)) ||
        (!_.isBoolean(params.validate) && !_.isUndefined(params.validate)) ||
        (!_.isBoolean(params.instant) && !_.isUndefined(params.instant))) {
        throw new Error('invalid argument');
    }
    if (!_.isObject(params.recipients)) {
        throw new Error('expecting recipients object');
    }
    params.validate = params.validate !== undefined ? params.validate : this.bitgo.getValidate();
    params.wallet = this;
    return TransactionBuilder.createTransaction(params)
        .nodeify(callback);
};
//
// signTransaction
// Sign a previously created transaction with a keychain
// Parameters:
// transactionHex - serialized form of the transaction in hex
// unspents - array of unspent information, where each unspent is a chainPath
//            and redeemScript with the same index as the inputs in the
//            transactionHex
// keychain - Keychain containing the xprv to sign with.
// signingKey - For legacy safe wallets, the private key string.
// validate - extra verification of signatures (which are always verified server-side) (defaults to global config)
// Returns:
//   callback(err, transaction)
Wallet.prototype.signTransaction = function (params, callback) {
    params = _.extend({}, params);
    common.validateParams(params, ['transactionHex'], [], callback);
    if (!Array.isArray(params.unspents)) {
        throw new Error('expecting the unspents array');
    }
    if ((!_.isObject(params.keychain) || !params.keychain.xprv) && !_.isString(params.signingKey)) {
        // allow passing in a WIF private key for legacy safe wallet support
        var error = new Error('expecting keychain object with xprv or signingKey WIF');
        error.code = 'missing_keychain_or_signingKey';
        throw error;
    }
    params.validate = params.validate !== undefined ? params.validate : this.bitgo.getValidate();
    params.bitgo = this.bitgo;
    return TransactionBuilder.signTransaction(params)
        .then(function (result) {
        return {
            tx: result.transactionHex
        };
    })
        .nodeify(callback);
};
//
// send
// Send a transaction to the Bitcoin network via BitGo.
// One of the keys is typically signed, and BitGo will sign the other (if approved) and relay it to the P2P network.
// Parameters:
//   tx  - the hex encoded, signed transaction to send
// Returns:
//
Wallet.prototype.sendTransaction = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['tx'], ['message', 'otp'], callback);
    return this.bitgo.post(this.bitgo.url('/tx/send'))
        .send(params)
        .result()
        .then(function (body) {
        if (body.pendingApproval) {
            return _.extend(body, { status: 'pendingApproval' });
        }
        if (body.otp) {
            return _.extend(body, { status: 'otp' });
        }
        return {
            status: 'accepted',
            tx: body.transaction,
            hash: body.transactionHash,
            instant: body.instant,
            instantId: body.instantId
        };
    })
        .nodeify(callback);
};
/**
 * Share the wallet with an existing BitGo user.
 * @param {string} user The recipient's user id, must have a corresponding user record in our database.
 * @param {keychain} keychain The keychain to be shared with the recipient.
 * @param {string} permissions A comma-separated value string that specifies the recipient's permissions if the share is accepted.
 * @param {string} message The message to be used for this share.
 */
Wallet.prototype.createShare = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['user', 'permissions'], [], callback);
    if (params.keychain && !_.isEmpty(params.keychain)) {
        if (!params.keychain.xpub || !params.keychain.encryptedXprv || !params.keychain.fromPubKey || !params.keychain.toPubKey || !params.keychain.path) {
            throw new Error('requires keychain parameters - xpub, encryptedXprv, fromPubKey, toPubKey, path');
        }
    }
    return this.bitgo.post(this.url('/share'))
        .send(params)
        .result()
        .nodeify(callback);
};
//
// createInvite
// invite a non BitGo customer to join a wallet
// Parameters:
//   email - the recipient's email address
//   permissions - the recipient's permissions if the share is accepted
// Returns:
//
Wallet.prototype.createInvite = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['email', 'permissions'], ['message'], callback);
    var options = {
        toEmail: params.email,
        permissions: params.permissions
    };
    if (params.message) {
        options.message = params.message;
    }
    return this.bitgo.post(this.url('/invite'))
        .send(options)
        .result()
        .nodeify(callback);
};
//
// confirmInviteAndShareWallet
// confirm my invite on this wallet to a recipient who has
// subsequently signed up by creating the actual wallet share
// Parameters:
//   walletInviteId - the wallet invite id
//   walletPassphrase - required if the wallet share success is expected
// Returns:
//
Wallet.prototype.confirmInviteAndShareWallet = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['walletInviteId'], ['walletPassphrase'], callback);
    var self = this;
    return this.bitgo.wallets().listInvites()
        .then(function (invites) {
        var outgoing = invites.outgoing;
        var invite = _.find(outgoing, function (out) {
            return out.id === params.walletInviteId;
        });
        if (!invite) {
            throw new Error('wallet invite not found');
        }
        var options = {
            email: invite.toEmail,
            permissions: invite.permissions,
            message: invite.message,
            walletPassphrase: params.walletPassphrase
        };
        return self.shareWallet(options);
    })
        .then(function () {
        return this.bitgo.put(this.bitgo.url('/walletinvite/' + params.walletInviteId));
    })
        .nodeify(callback);
};
//
// sendCoins
// Send coins to a destination address from this wallet using the user key.
// 1. Gets the user keychain by checking the wallet for a key which has an encrypted xpriv
// 2. Decrypts user key
// 3. Creates the transaction with default fee
// 4. Signs transaction with decrypted user key
// 3. Sends the transaction to BitGo
//
// Parameters:
//   address - the destination address
//   amount - the amount in satoshis to be sent
//   message - optional message to attach to transaction
//   walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
//   xprv - the private key in string form, if walletPassphrase is not available
//   (See transactionBuilder.createTransaction for other passthrough params)
// Returns:
//
Wallet.prototype.sendCoins = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['address'], ['message'], callback);
    if (!_.isNumber(params.amount)) {
        throw new Error('invalid argument for amount - number expected');
    }
    params.recipients = {};
    params.recipients[params.address] = params.amount;
    return this.sendMany(params)
        .nodeify(callback);
};
//
// sendMany
// Send coins to multiple destination addresses from this wallet using the user key.
// 1. Gets the user keychain by checking the wallet for a key which has an encrypted xpriv
// 2. Decrypts user key
// 3. Creates the transaction with default fee
// 4. Signs transaction with decrypted user key
// 3. Sends the transaction to BitGo
//
// Parameters:
//   recipients - array of { address: string, amount: number, travelInfo: object } to send to
//   walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
//   xprv - the private key in string form, if walletPassphrase is not available
//   (See transactionBuilder.createTransaction for other passthrough params)
// Returns:
//
Wallet.prototype.sendMany = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], ['message', 'otp'], callback);
    var self = this;
    if (!_.isObject(params.recipients)) {
        throw new Error('expecting recipients object');
    }
    if (params.fee && !_.isNumber(params.fee)) {
        throw new Error('invalid argument for fee - number expected');
    }
    if (params.feeRate && !_.isNumber(params.feeRate)) {
        throw new Error('invalid argument for feeRate - number expected');
    }
    if (params.instant && !_.isBoolean(params.instant)) {
        throw new Error('invalid argument for instant - boolean expected');
    }
    var bitgoFee;
    var travelInfos;
    var finalResult;
    var unspentsUsed;
    var acceptedBuildParams = [
        'numBlocks', 'feeRate', 'minConfirms', 'enforceMinConfirmsForChange',
        'targetWalletUnspents', 'message', 'minValue', 'maxValue',
        'noSplitChange', 'comment'
    ];
    var preservedBuildParams = _.pick(params, acceptedBuildParams);
    // Get the user keychain
    var retPromise = this.createAndSignTransaction(params)
        .then(function (transaction) {
        // Send the transaction
        bitgoFee = transaction.bitgoFee;
        travelInfos = transaction.travelInfos;
        unspentsUsed = transaction.unspents;
        return self.sendTransaction({
            tx: transaction.tx,
            message: params.message,
            sequenceId: params.sequenceId,
            instant: params.instant,
            otp: params.otp,
            // The below params are for logging only, and do not impact the API call
            estimatedSize: transaction.estimatedSize,
            buildParams: preservedBuildParams
        });
    })
        .then(function (result) {
        var tx = bitcoin.Transaction.fromHex(result.tx);
        var inputsSum = _.sumBy(unspentsUsed, 'value');
        var outputsSum = _.sumBy(tx.outs, 'value');
        var feeUsed = inputsSum - outputsSum;
        if (isNaN(feeUsed)) {
            throw new Error('invalid feeUsed');
        }
        result.fee = feeUsed,
            result.feeRate = feeUsed * 1000 / tx.virtualSize();
        result.travelInfos = travelInfos;
        if (bitgoFee) {
            result.bitgoFee = bitgoFee;
        }
        finalResult = result;
        // Handle sending travel infos if they exist, but make sure we never fail here.
        // Error or result (with possible sub-errors) will be provided in travelResult
        if (travelInfos && travelInfos.length) {
            try {
                return self.pollForTransaction({ id: result.hash })
                    .then(function () {
                    return self.bitgo.travelRule().sendMany(result);
                })
                    .then(function (res) {
                    finalResult.travelResult = res;
                })
                    .catch(function (err) {
                    // catch async errors
                    finalResult.travelResult = { error: err.message };
                });
            }
            catch (err) {
                // catch synchronous errors
                finalResult.travelResult = { error: err.message };
            }
        }
    })
        .then(function () {
        return finalResult;
    });
    return Bluebird.resolve(retPromise).nodeify(callback);
};
/**
 * Accelerate a stuck transaction using Child-Pays-For-Parent (CPFP).
 *
 * This should only be used for stuck transactions which have no unconfirmed inputs.
 *
 * @param {Object} params - Input parameters
 * @param {String} params.transactionID - ID of transaction to accelerate
 * @param {Number} params.feeRate - New effective fee rate for stuck transaction (sat per 1000 bytes)
 * @param {Number} params.maxAdditionalUnspents - Maximum additional unspents to use from the wallet to cover any child fees that the parent unspent output cannot cover. Defaults to 100.
 * @param {String} params.walletPassphrase - The passphrase which should be used to decrypt the wallet private key. One of either walletPassphrase or xprv is required.
 * @param {String} params.xprv - The private key for the wallet. One of either walletPassphrase or xprv is required.
 * @param {Function} callback
 * @returns Result of sendTransaction() on the child transaction
 */
Wallet.prototype.accelerateTransaction = function accelerateTransaction(params, callback) {
    var _this = this;
    var self = this;
    /**
     * Helper function to estimate a transactions size in virtual bytes.
     * Actual transactions may be slightly fewer virtual bytes, due to
     * the fact that valid ECSDA signatures have a variable length
     * between 8 and 73 virtual bytes.
     *
     * @param inputs.segwit The number of segwit inputs to the transaction
     * @param inputs.P2SH The number of P2SH inputs to the transaction
     * @param inputs.P2PKH The number of P2PKH inputs to the transaction
     */
    var estimateTxVSize = function (inputs) {
        var segwit = inputs.segwit || 0;
        var P2SH = inputs.P2SH || 0;
        var P2PKH = inputs.P2PKH || 0;
        var childFeeInfo = TransactionBuilder.calculateMinerFeeInfo({
            nP2shInputs: P2SH,
            nP2pkhInputs: P2PKH,
            nP2shP2wshInputs: segwit,
            nOutputs: 1,
            feeRate: 1
        });
        return childFeeInfo.size;
    };
    /**
     * Calculate the number of satoshis that should be paid in fees by the child transaction
     *
     * @param inputs Inputs to the child transaction which are passed to estimateTxVSize
     * @param parentFee The number of satoshis the parent tx originally paid in fees
     * @param parentVSize The number of virtual bytes in the parent tx
     * @param feeRate The new fee rate which should be paid by the combined CPFP transaction
     * @returns {number} The number of satoshis the child tx should pay in fees
     */
    var estimateChildFee = function (_a) {
        var inputs = _a.inputs, parentFee = _a.parentFee, parentVSize = _a.parentVSize, feeRate = _a.feeRate;
        // calculate how much more we *should* have paid in parent fees,
        // had the parent been originally sent with the new fee rate
        var additionalParentFee = _.ceil(parentVSize * feeRate / 1000) - parentFee;
        // calculate how much we would pay in fees for the child,
        // if it were only paying for itself at the new fee rate
        var childFee = estimateTxVSize(inputs) * feeRate / 1000;
        return _.ceil(childFee + additionalParentFee);
    };
    /**
     * Helper function to find additional unspents to use to pay the child tx fees.
     * This function is called when the the parent tx output is not sufficient to
     * cover the total fees which should be paid by the child tx.
     *
     * @param inputs Inputs to the child transaction which are passed to estimateTxVSize
     * @param parentOutputValue The value of the output from the parent tx which we are using as an input to the child tx
     * @param parentFee The number of satoshis the parent tx originally paid in fees
     * @param parentVSize The number of virtual bytes in the parent tx
     * @param maxUnspents The maximum number of additional unspents which should be used to cover the remaining child fees
     * @returns An object with the additional unspents to use, the updated number of satoshis which should be paid by
     *          the child tx, and the updated inputs for the child tx.
     */
    var findAdditionalUnspents = function (_a) {
        var inputs = _a.inputs, parentOutputValue = _a.parentOutputValue, parentFee = _a.parentFee, parentVSize = _a.parentVSize, maxUnspents = _a.maxUnspents;
        return co(function coFindAdditionalUnspents() {
            var additionalUnspents, currentChildFeeEstimate, uncoveredChildFee, _loop_1, this_1, state_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        additionalUnspents = [];
                        currentChildFeeEstimate = estimateChildFee({ inputs: inputs, parentFee: parentFee, parentVSize: parentVSize, feeRate: params.feeRate });
                        uncoveredChildFee = currentChildFeeEstimate - parentOutputValue;
                        _loop_1 = function () {
                            var unspents, additionalUnspentValue;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this_1.unspents({
                                            minConfirms: 1,
                                            target: uncoveredChildFee,
                                            limit: maxUnspents - additionalUnspents.length
                                        })];
                                    case 1:
                                        unspents = _a.sent();
                                        if (unspents.length === 0) {
                                            return [2 /*return*/, "break"];
                                        }
                                        additionalUnspentValue = 0;
                                        // consume all unspents returned by the server, even if we don't need
                                        // all of them to cover the child fee. This is because the server will
                                        // return enough unspent value to ensure that the minimum change amount
                                        // is achieved for the child tx, and we can't leave out those unspents
                                        // or else the minimum change amount constraint could be violated
                                        _.forEach(unspents, function (unspent) {
                                            // update the child tx inputs
                                            var unspentChain = getChain(unspent);
                                            if (unspentChain === unspents_1.Codes.p2shP2wsh.external || unspentChain === unspents_1.Codes.p2shP2wsh.internal) {
                                                inputs.segwit++;
                                            }
                                            else {
                                                inputs.P2SH++;
                                            }
                                            additionalUnspents.push(unspent);
                                            additionalUnspentValue += unspent.value;
                                        });
                                        currentChildFeeEstimate = estimateChildFee({ inputs: inputs, parentFee: parentFee, parentVSize: parentVSize, feeRate: params.feeRate });
                                        uncoveredChildFee = currentChildFeeEstimate - parentOutputValue - additionalUnspentValue;
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _a.label = 1;
                    case 1:
                        if (!(uncoveredChildFee > 0 && additionalUnspents.length < maxUnspents)) return [3 /*break*/, 3];
                        return [5 /*yield**/, _loop_1()];
                    case 2:
                        state_1 = _a.sent();
                        if (state_1 === "break")
                            return [3 /*break*/, 3];
                        return [3 /*break*/, 1];
                    case 3:
                        if (uncoveredChildFee > 0) {
                            // Unable to find enough unspents to cover the child fee
                            throw new Error("Insufficient confirmed unspents available to cover the child fee");
                        }
                        // found enough unspents
                        return [2 /*return*/, {
                                additional: additionalUnspents,
                                newChildFee: currentChildFeeEstimate,
                                newInputs: inputs
                            }];
                }
            });
        }).call(_this);
    };
    /**
     * Helper function to get a full copy (including witness data) of an arbitrary tx using only the tx id.
     *
     * We have to use an external service for this (currently blockstream.info), since
     * the v1 indexer service (based on bitcoinj) does not have segwit support and
     * does not return any segwit related fields in the tx hex.
     *
     * @param parentTxId The ID of the transaction to get the full hex of
     * @returns {Bluebird<any>} The full hex for the specified transaction
     */
    function getParentTxHex(_a) {
        var parentTxId = _a.parentTxId;
        return __awaiter(this, void 0, void 0, function () {
            var explorerBaseUrl, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        explorerBaseUrl = common.Environments[self.bitgo.getEnv()].btcExplorerBaseUrl;
                        return [4 /*yield*/, request.get(explorerBaseUrl + "/tx/" + parentTxId + "/hex")];
                    case 1:
                        result = _b.sent();
                        if (!result.text || !/([a-f0-9]{2})+/.test(result.text)) {
                            throw new Error("Did not successfully receive parent tx hex. Received '" + _.truncate(result.text, { length: 100 }) + "' instead.");
                        }
                        return [2 /*return*/, result.text];
                }
            });
        });
    }
    /**
     * Helper function to get the chain from an unspent or tx output.
     *
     * @param outputOrUnspent The output or unspent whose chain should be determined
     * @returns {number} The chain for the given output or unspent
     */
    var getChain = function (outputOrUnspent) {
        if (outputOrUnspent.chain !== undefined) {
            return outputOrUnspent.chain;
        }
        if (outputOrUnspent.chainPath !== undefined) {
            return _.toNumber(outputOrUnspent.chainPath.split('/')[1]);
        }
        // no way to tell the chain, let's just blow up now instead
        // of blowing up later when the undefined return value is used.
        // Note: for unspents the field to use is 'address', but for outputs
        // the field to use is 'account'
        throw Error("Could not get chain for output on account " + (outputOrUnspent.account || outputOrUnspent.address));
    };
    /**
     * Helper function to calculate the actual value contribution an output or unspent will
     * contribute to a transaction, were it to be used. Each type of output or unspent
     * will have a different value contribution since each type has a different number
     * of virtual bytes, and thus will cause a different fee to be paid.
     *
     * @param outputOrUnspent Output or unspent whose effective value should be determined
     * @returns {number} The actual number of satoshis that this unspent or output
     *                   would contribute to a transaction, were it to be used.
     */
    var effectiveValue = function (outputOrUnspent) {
        var chain = getChain(outputOrUnspent);
        if (chain === unspents_1.Codes.p2shP2wsh.external || chain === unspents_1.Codes.p2shP2wsh.internal) {
            // VirtualSizes.txP2shP2wshInputSize is in bytes, so we need to convert to kB
            return outputOrUnspent.value - (unspents_1.VirtualSizes.txP2shP2wshInputSize * params.feeRate / 1000);
        }
        // VirtualSizes.txP2shInputSize is in bytes, so we need to convert to kB
        return outputOrUnspent.value - (unspents_1.VirtualSizes.txP2shInputSize * params.feeRate / 1000);
    };
    /**
     * Coroutine which actually implements the accelerateTransaction algorithm
     *
     * Described at a high level, the algorithm is as follows:
     * 1) Find appropriate output from parent transaction to use as child transaction input
     * 2) Find unspent corresponding to parent transaction output. If not found, return to step 1.
     * 3) Determine if parent transaction unspent can cover entire child fee, plus minimum change
     * 4) If yes, go to step 6
     * 5) Otherwise, find additional unspents from the wallet to use to cover the remaining child fee
     * 6) Create and sign the child transaction, using the parent transaction output
     *    (and, if necessary, additional wallet unspents) as inputs
     * 7) Broadcast the new child transaction
     */
    return co(function coAccelerateTransaction() {
        var parentTx, walletOutputs, sortedOutputs, parentUnspentToUse, outputToUse, unspentsResult, parentTxHex, decodedParent, parentVSize, parentRate, isParentOutputSegwit, childInputs, childFee, unspentsToUse, minChangeSize, _a, additional, newChildFee, newInputs, maxFeeRate, childVSize, combinedVSize, combinedFee, combinedFeeRate, changeAmount, changeChain, changeAddress, tx, childFeeRate;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    params = params || {};
                    common.validateParams(params, ['transactionID'], [], callback);
                    // validate fee rate
                    if (params.feeRate === undefined) {
                        throw new Error('Missing parameter: feeRate');
                    }
                    if (!_.isFinite(params.feeRate) || params.feeRate <= 0) {
                        throw new Error('Expecting positive finite number for parameter: feeRate');
                    }
                    // validate maxUnspents
                    if (params.maxAdditionalUnspents === undefined) {
                        // by default, use at most 100 additional unspents (not including the unspent output from the parent tx)
                        params.maxAdditionalUnspents = 100;
                    }
                    if (!_.isInteger(params.maxAdditionalUnspents) || params.maxAdditionalUnspents <= 0) {
                        throw Error('Expecting positive integer for parameter: maxAdditionalUnspents');
                    }
                    return [4 /*yield*/, this.getTransaction({ id: params.transactionID })];
                case 1:
                    parentTx = _b.sent();
                    if (parentTx.confirmations > 0) {
                        throw new Error("Transaction " + params.transactionID + " is already confirmed and cannot be accelerated");
                    }
                    walletOutputs = _.filter(parentTx.outputs, function (output) { return output.isMine; });
                    if (walletOutputs.length === 0) {
                        throw new Error("Transaction " + params.transactionID + " contains no outputs to this wallet, and thus cannot be accelerated");
                    }
                    sortedOutputs = _.sortBy(walletOutputs, effectiveValue);
                    _b.label = 2;
                case 2:
                    if (!(sortedOutputs.length > 0 && parentUnspentToUse === undefined)) return [3 /*break*/, 4];
                    outputToUse = sortedOutputs.pop();
                    return [4 /*yield*/, this.unspents({
                            minSize: outputToUse.value,
                            maxSize: outputToUse.value
                        })];
                case 3:
                    unspentsResult = _b.sent();
                    parentUnspentToUse = _.find(unspentsResult, function (unspent) {
                        // make sure unspent belongs to the given txid
                        if (unspent.tx_hash !== params.transactionID) {
                            return false;
                        }
                        // make sure unspent has correct v_out index
                        return unspent.tx_output_n === outputToUse.vout;
                    });
                    return [3 /*break*/, 2];
                case 4:
                    if (parentUnspentToUse === undefined) {
                        throw new Error("Could not find unspent output from parent tx to use as child input");
                    }
                    return [4 /*yield*/, getParentTxHex({ parentTxId: params.transactionID })];
                case 5:
                    parentTxHex = _b.sent();
                    decodedParent = bitcoin.Transaction.fromHex(parentTxHex);
                    parentVSize = decodedParent.virtualSize();
                    // make sure id from decoded tx and given tx id match
                    // this should catch problems emanating from the use of an external service
                    // for getting the complete parent tx hex
                    if (decodedParent.getId() !== params.transactionID) {
                        throw new Error("Decoded transaction id is " + decodedParent.getId() + ", which does not match given txid " + params.transactionID);
                    }
                    parentRate = 1000 * parentTx.fee / parentVSize;
                    if (params.feeRate <= parentRate) {
                        throw new Error("Cannot lower fee rate! (Parent tx fee rate is " + parentRate + " sat/kB, and requested fee rate was " + params.feeRate + " sat/kB)");
                    }
                    isParentOutputSegwit = outputToUse.chain === unspents_1.Codes.p2shP2wsh.external ||
                        outputToUse.chain === unspents_1.Codes.p2shP2wsh.internal;
                    childInputs = {
                        segwit: isParentOutputSegwit ? 1 : 0,
                        P2SH: isParentOutputSegwit ? 0 : 1
                    };
                    childFee = estimateChildFee({
                        inputs: childInputs,
                        parentFee: parentTx.fee,
                        feeRate: params.feeRate,
                        parentVSize: parentVSize
                    });
                    unspentsToUse = [parentUnspentToUse];
                    minChangeSize = this.bitgo.getConstants().minChangeSize || 1e7;
                    if (!(outputToUse.value < childFee + minChangeSize)) return [3 /*break*/, 7];
                    return [4 /*yield*/, findAdditionalUnspents({
                            inputs: childInputs,
                            parentOutputValue: outputToUse.value,
                            parentFee: parentTx.fee,
                            maxUnspents: params.maxAdditionalUnspents,
                            parentVSize: parentVSize
                        })];
                case 6:
                    _a = _b.sent(), additional = _a.additional, newChildFee = _a.newChildFee, newInputs = _a.newInputs;
                    childFee = newChildFee;
                    childInputs = newInputs;
                    unspentsToUse.push.apply(unspentsToUse, additional);
                    _b.label = 7;
                case 7:
                    maxFeeRate = this.bitgo.getConstants().maxFeeRate;
                    childVSize = estimateTxVSize(childInputs);
                    combinedVSize = childVSize + parentVSize;
                    combinedFee = parentTx.fee + childFee;
                    combinedFeeRate = 1000 * combinedFee / combinedVSize;
                    if (combinedFeeRate > maxFeeRate) {
                        throw new Error("Transaction cannot be accelerated. Combined fee rate of " + combinedFeeRate + " sat/kB exceeds maximum fee rate of " + maxFeeRate + " sat/kB");
                    }
                    changeAmount = _.sumBy(unspentsToUse, function (unspent) { return unspent.value; }) - childFee;
                    changeChain = this.getChangeChain({});
                    return [4 /*yield*/, this.createAddress({ chain: changeChain })];
                case 8:
                    changeAddress = _b.sent();
                    return [4 /*yield*/, this.createAndSignTransaction({
                            unspents: unspentsToUse,
                            recipients: [{
                                    address: changeAddress.address,
                                    amount: changeAmount
                                }],
                            fee: childFee,
                            bitgoFee: {
                                amount: 0,
                                address: ''
                            },
                            xprv: params.xprv,
                            walletPassphrase: params.walletPassphrase
                        })];
                case 9:
                    tx = _b.sent();
                    childFeeRate = 1000 * childFee / childVSize;
                    if (childFeeRate > maxFeeRate) {
                        // combined tx is within max fee rate limits, but the child tx is not.
                        // in this case, we need to use the ignoreMaxFeeRate flag to get the child tx to be accepted
                        tx.ignoreMaxFeeRate = true;
                    }
                    return [2 /*return*/, this.sendTransaction(tx)];
            }
        });
    }).call(this).asCallback(callback);
};
//
// createAndSignTransaction
// INTERNAL function to create and sign a transaction
//
// Parameters:
//   recipients - array of { address, amount } to send to
//   walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
//   (See transactionBuilder.createTransaction for other passthrough params)
// Returns:
//
Wallet.prototype.createAndSignTransaction = function (params, callback) {
    return co(function () {
        var transaction, fee, feeRate, estimatedSize, bitgoFee, travelInfos, unspents, keychain, e_1, safeUserKey, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    params = params || {};
                    common.validateParams(params, [], [], callback);
                    if (!_.isObject(params.recipients)) {
                        throw new Error('expecting recipients object');
                    }
                    if (params.fee && !_.isNumber(params.fee)) {
                        throw new Error('invalid argument for fee - number expected');
                    }
                    if (params.feeRate && !_.isNumber(params.feeRate)) {
                        throw new Error('invalid argument for feeRate - number expected');
                    }
                    if (params.dynamicFeeConfirmTarget && !_.isNumber(params.dynamicFeeConfirmTarget)) {
                        throw new Error('invalid argument for confirmTarget - number expected');
                    }
                    if (params.instant && !_.isBoolean(params.instant)) {
                        throw new Error('invalid argument for instant - boolean expected');
                    }
                    return [4 /*yield*/, this.createTransaction(params)];
                case 1:
                    transaction = _a.sent();
                    fee = transaction.fee;
                    feeRate = transaction.feeRate;
                    estimatedSize = transaction.estimatedSize;
                    bitgoFee = transaction.bitgoFee;
                    travelInfos = transaction.travelInfos;
                    unspents = transaction.unspents;
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 6]);
                    return [4 /*yield*/, this.getAndPrepareSigningKeychain(params)];
                case 3:
                    keychain = _a.sent();
                    transaction.keychain = keychain;
                    return [3 /*break*/, 6];
                case 4:
                    e_1 = _a.sent();
                    if (e_1.code !== 'no_encrypted_keychain_on_wallet') {
                        throw e_1;
                    }
                    // this might be a safe wallet, so let's retrieve the private key info
                    return [4 /*yield*/, this.refresh({ gpk: true })];
                case 5:
                    // this might be a safe wallet, so let's retrieve the private key info
                    _a.sent();
                    safeUserKey = _.get(this.wallet, 'private.userPrivKey');
                    if (_.isString(safeUserKey) && _.isString(params.walletPassphrase)) {
                        transaction.signingKey = this.bitgo.decrypt({ password: params.walletPassphrase, input: safeUserKey });
                    }
                    else {
                        throw e_1;
                    }
                    return [3 /*break*/, 6];
                case 6:
                    transaction.feeSingleKeyWIF = params.feeSingleKeyWIF;
                    return [4 /*yield*/, this.signTransaction(transaction)];
                case 7:
                    result = _a.sent();
                    return [2 /*return*/, _.extend(result, {
                            fee: fee,
                            feeRate: feeRate,
                            instant: params.instant,
                            bitgoFee: bitgoFee,
                            travelInfos: travelInfos,
                            estimatedSize: estimatedSize,
                            unspents: unspents
                        })];
            }
        });
    }).call(this).asCallback(callback);
};
//
// getAndPrepareSigningKeychain
// INTERNAL function to get the user keychain for signing.
// Caller must provider either a keychain, or walletPassphrase or xprv as a string
// If the caller provides the keychain with xprv, it is simply returned.
// If the caller provides the encrypted xprv (walletPassphrase), then fetch the keychain object and decrypt
// Otherwise if the xprv is provided, fetch the keychain object and augment it with the xprv.
//
// Parameters:
//   keychain - keychain with xprv
//   xprv - the private key in string form
//   walletPassphrase - the passphrase to be used to decrypt the user key on this wallet
// Returns:
//   Keychain object containing xprv, xpub and paths
//
Wallet.prototype.getAndPrepareSigningKeychain = function (params, callback) {
    params = params || {};
    // If keychain with xprv is already provided, use it
    if (_.isObject(params.keychain) && params.keychain.xprv) {
        return Bluebird.resolve(params.keychain);
    }
    common.validateParams(params, [], ['walletPassphrase', 'xprv'], callback);
    if ((params.walletPassphrase && params.xprv) || (!params.walletPassphrase && !params.xprv)) {
        throw new Error('must provide exactly one of xprv or walletPassphrase');
    }
    var self = this;
    // Caller provided a wallet passphrase
    if (params.walletPassphrase) {
        return self.getEncryptedUserKeychain()
            .then(function (keychain) {
            // Decrypt the user key with a passphrase
            try {
                keychain.xprv = self.bitgo.decrypt({ password: params.walletPassphrase, input: keychain.encryptedXprv });
            }
            catch (e) {
                throw new Error('Unable to decrypt user keychain');
            }
            return keychain;
        });
    }
    // Caller provided an xprv - validate and construct keychain object
    var xpub;
    try {
        xpub = bitcoin.HDNode.fromBase58(params.xprv).neutered().toBase58();
    }
    catch (e) {
        throw new Error('Unable to parse the xprv');
    }
    if (xpub === params.xprv) {
        throw new Error('xprv provided was not a private key (found xpub instead)');
    }
    var walletXpubs = _.map(self.keychains, 'xpub');
    if (!_.includes(walletXpubs, xpub)) {
        throw new Error('xprv provided was not a keychain on this wallet!');
    }
    // get the keychain object from bitgo to find the path and (potential) wallet structure
    return self.bitgo.keychains().get({ xpub: xpub })
        .then(function (keychain) {
        keychain.xprv = params.xprv;
        return keychain;
    });
};
/**
 * Takes a wallet's unspents and fans them out into a larger number of equally sized unspents
 * @param params
 *  target: set how many unspents you want to have in the end
 *  minConfirms: minimum number of confirms the unspents must have
 *  xprv: private key to sign transaction
 *  walletPassphrase: wallet passphrase to decrypt the wallet's private key
 * @param callback
 * @returns {*}
 */
Wallet.prototype.fanOutUnspents = function (params, callback) {
    var self = this;
    return Bluebird.coroutine(function () {
        var MAX_FANOUT_INPUT_COUNT, MAX_FANOUT_OUTPUT_COUNT, validate, target, minConfirms, splitNumberIntoCloseNaturalNumbers, allUnspents, grossAmount, txParams, newAddressPromises, newAddresses, splitAmounts, error_1, debugParams, baseFee, totalFee, netAmount, remainingSplitAmounts, fanoutTx, e_2, debugParams;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    MAX_FANOUT_INPUT_COUNT = 80;
                    MAX_FANOUT_OUTPUT_COUNT = 300;
                    params = params || {};
                    common.validateParams(params, [], ['walletPassphrase', 'xprv'], callback);
                    validate = params.validate === undefined ? true : params.validate;
                    target = params.target;
                    // the target must be defined, be a number, be at least two, and be a natural number
                    if (!_.isNumber(target) || target < 2 || (target % 1) !== 0) {
                        throw new Error('Target needs to be a positive integer');
                    }
                    if (target > MAX_FANOUT_OUTPUT_COUNT) {
                        throw new Error('Fan out target too high');
                    }
                    minConfirms = params.minConfirms;
                    if (minConfirms === undefined) {
                        minConfirms = 1;
                    }
                    if (!_.isNumber(minConfirms) || minConfirms < 0) {
                        throw new Error('minConfirms needs to be an integer >= 0');
                    }
                    splitNumberIntoCloseNaturalNumbers = function (total, partCount) {
                        var partSize = Math.floor(total / partCount);
                        var remainder = total - partSize * partCount;
                        // initialize placeholder array
                        var almostEqualParts = new Array(partCount);
                        // fill the first remainder parts with the value partSize+1
                        _.fill(almostEqualParts, partSize + 1, 0, remainder);
                        // fill the remaining parts with the value partSize
                        _.fill(almostEqualParts, partSize, remainder);
                        // assert the correctness of the almost equal parts
                        // TODO: add check for the biggest deviation between any two parts and make sure it's <= 1
                        if (_(almostEqualParts).sum() !== total || _(almostEqualParts).size() !== partCount) {
                            throw new Error('part sum or part count mismatch');
                        }
                        return almostEqualParts;
                    };
                    return [4 /*yield*/, self.unspents({ minConfirms: minConfirms })];
                case 1:
                    allUnspents = _a.sent();
                    if (allUnspents.length < 1) {
                        throw new Error('No unspents to branch out');
                    }
                    // this consolidation is essentially just a waste of money
                    if (allUnspents.length >= target) {
                        throw new Error('Fan out target has to be bigger than current number of unspents');
                    }
                    // we have at the very minimum 81 inputs, and 81 outputs. That transaction will be big
                    // in the medium run, this algorithm could be reworked to only work with a subset of the transactions
                    if (allUnspents.length > MAX_FANOUT_INPUT_COUNT) {
                        throw new Error('Too many unspents');
                    }
                    grossAmount = _(allUnspents).map('value').sum();
                    txParams = _.extend({}, params);
                    txParams.unspents = allUnspents;
                    txParams.recipients = {};
                    newAddressPromises = _.range(target)
                        .map(function () { return self.createAddress({ chain: self.getChangeChain(params), validate: validate }); });
                    return [4 /*yield*/, Bluebird.all(newAddressPromises)];
                case 2:
                    newAddresses = _a.sent();
                    splitAmounts = splitNumberIntoCloseNaturalNumbers(grossAmount, target);
                    // map the newly created addresses to the almost components amounts we just calculated
                    txParams.recipients = _.zipObject(_.map(newAddresses, 'address'), splitAmounts);
                    txParams.noSplitChange = true;
                    _a.label = 3;
                case 3:
                    _a.trys.push([3, 5, , 6]);
                    return [4 /*yield*/, self.sendMany(txParams)];
                case 4:
                    _a.sent();
                    return [3 /*break*/, 6];
                case 5:
                    error_1 = _a.sent();
                    // as expected, the transaction creation did indeed fail due to insufficient fees
                    // the error suggests a fee value which we then use for the transaction
                    // however, let's make sure it wasn't something else
                    if (!error_1.fee && (!error_1.result || !error_1.result.fee)) {
                        debugParams = _.omit(txParams, ['walletPassphrase', 'xprv']);
                        error_1.message += "\n\nTX PARAMS:\n " + JSON.stringify(debugParams, null, 4);
                        throw error_1;
                    }
                    baseFee = error_1.fee || error_1.result.fee;
                    totalFee = baseFee;
                    if (error_1.result.bitgoFee && error_1.result.bitgoFee.amount) {
                        totalFee += error_1.result.bitgoFee.amount;
                        txParams.bitgoFee = error_1.result.bitgoFee;
                    }
                    // Need to clear these out since only 1 may be set
                    delete txParams.fee;
                    txParams.originalFeeRate = txParams.feeRate;
                    delete txParams.feeRate;
                    delete txParams.feeTxConfirmTarget;
                    txParams.fee = baseFee;
                    netAmount = error_1.result.available - totalFee;
                    remainingSplitAmounts = splitNumberIntoCloseNaturalNumbers(netAmount, target);
                    // and the distribution again mapped to the new addresses
                    txParams.recipients = _.zipObject(_.map(newAddresses, 'address'), remainingSplitAmounts);
                    return [3 /*break*/, 6];
                case 6:
                    _a.trys.push([6, 8, , 9]);
                    return [4 /*yield*/, self.sendMany(txParams)];
                case 7:
                    fanoutTx = _a.sent();
                    return [3 /*break*/, 9];
                case 8:
                    e_2 = _a.sent();
                    debugParams = _.omit(txParams, ['walletPassphrase', 'xprv']);
                    e_2.message += "\n\nTX PARAMS:\n " + JSON.stringify(debugParams, null, 4);
                    throw e_2;
                case 9: return [2 /*return*/, Bluebird.resolve(fanoutTx).asCallback(callback)];
            }
        });
    })().asCallback(callback);
};
/**
 * Determine whether to fan out or coalesce a wallet's unspents
 * @param params
 * @param callback
 * @returns {Request|Promise.<T>|*}
 */
Wallet.prototype.regroupUnspents = function (params, callback) {
    params = params || {};
    var target = params.target;
    if (!_.isNumber(target) || target < 1 || (target % 1) !== 0) {
        // the target must be defined, be a number, be at least one, and be a natural number
        throw new Error('Target needs to be a positive integer');
    }
    var minConfirms = params.minConfirms;
    if (minConfirms === undefined) {
        minConfirms = 1;
    }
    if ((!_.isNumber(minConfirms) || minConfirms < 0)) {
        throw new Error('minConfirms needs to be an integer equal to or bigger than 0');
    }
    var self = this;
    return self.unspents({ minConfirms: minConfirms })
        .then(function (unspents) {
        if (unspents.length === target) {
            return unspents;
        }
        else if (unspents.length > target) {
            return self.consolidateUnspents(params, callback);
        }
        else if (unspents.length < target) {
            return self.fanOutUnspents(params, callback);
        }
    });
};
/**
 * Consolidate a wallet's unspents into fewer unspents
 * @param params
 *  target: set how many unspents you want to have in the end
 *  maxInputCountPerConsolidation: set how many maximum inputs are to be permitted per consolidation batch
 *  xprv: private key to sign transaction
 *  walletPassphrase: wallet passphrase to decrypt the wallet's private key
 *  maxIterationCount: maximum number of iterations to be performed until function stops
 *  progressCallback: method to be called with object outlining current progress details
 * @param callback
 * @returns {*}
 */
Wallet.prototype.consolidateUnspents = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], ['walletPassphrase', 'xprv'], callback);
    var validate = params.validate === undefined ? true : params.validate;
    var target = params.target;
    if (target === undefined) {
        target = 1;
    }
    else if (!_.isNumber(target) || target < 1 || (target % 1) !== 0) {
        // the target must be defined, be a number, be at least one, and be a natural number
        throw new Error('Target needs to be a positive integer');
    }
    if (params.maxSize && !_.isNumber(params.maxSize)) {
        throw new Error('maxSize should be a number');
    }
    if (params.minSize && !_.isNumber(params.minSize)) {
        throw new Error('minSize should be a number');
    }
    // maximum number of inputs per transaction for consolidation
    var MAX_INPUT_COUNT = 200;
    var maxInputCount = params.maxInputCountPerConsolidation;
    if (maxInputCount === undefined) { // null or unidentified, because equality to zero returns true in if(! clause
        maxInputCount = MAX_INPUT_COUNT;
    }
    if (typeof (maxInputCount) !== 'number' || maxInputCount < 2 || (maxInputCount % 1) !== 0) {
        throw new Error('Maximum consolidation input count needs to be an integer equal to or bigger than 2');
    }
    else if (maxInputCount > MAX_INPUT_COUNT) {
        throw new Error('Maximum consolidation input count cannot be bigger than ' + MAX_INPUT_COUNT);
    }
    var maxIterationCount = params.maxIterationCount || -1;
    if (params.maxIterationCount && (!_.isNumber(maxIterationCount) || maxIterationCount < 1) || (maxIterationCount % 1) !== 0) {
        throw new Error('Maximum iteration count needs to be an integer equal to or bigger than 1');
    }
    var minConfirms = params.minConfirms;
    if (minConfirms === undefined) {
        minConfirms = 1;
    }
    if ((!_.isNumber(minConfirms) || minConfirms < 0)) {
        throw new Error('minConfirms needs to be an integer equal to or bigger than 0');
    }
    var minSize = params.minSize || 0;
    if (params.feeRate) {
        // fee rate is in satoshis per kB, input size in bytes
        var feeBasedMinSize = Math.ceil(unspents_1.VirtualSizes.txP2shInputSize * params.feeRate / 1000);
        if (params.minSize && minSize < feeBasedMinSize) {
            throw new Error('provided minSize too low due to too high fee rate');
        }
        minSize = Math.max(feeBasedMinSize, minSize);
        if (!params.minSize) {
            // fee rate-based min size needs no logging if it was set explicitly
            console.log('Only consolidating unspents larger than ' + minSize + ' satoshis to avoid wasting money on fees. To consolidate smaller unspents, use a lower fee rate.');
        }
    }
    var iterationCount = 0;
    var self = this;
    var consolidationIndex = 0;
    /**
     * Consolidate one batch of up to MAX_INPUT_COUNT unspents.
     * @returns {*}
     */
    var runNextConsolidation = co(function () {
        var consolidationTransactions, isFinalConsolidation, queryParams, allUnspents, allUnspentsCount, targetInputCount, inputCount, currentChunk, changeChain, newAddress, txParams, currentAddress, grossAmount, error_2, debugParams, baseFee, bitgoFee, totalFee, netAmount, sentTx, e_3, debugParams, _a, _b, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    consolidationTransactions = [];
                    isFinalConsolidation = false;
                    iterationCount++;
                    queryParams = {
                        limit: target + maxInputCount,
                        minConfirms: minConfirms,
                        minSize: minSize
                    };
                    if (params.maxSize) {
                        queryParams.maxSize = params.maxSize;
                    }
                    return [4 /*yield*/, self.unspents(queryParams)];
                case 1:
                    allUnspents = _d.sent();
                    // this consolidation is essentially just a waste of money
                    if (allUnspents.length <= target) {
                        if (iterationCount <= 1) {
                            // this is the first iteration, so the method is incorrect
                            throw new Error('Fewer unspents than consolidation target. Use fanOutUnspents instead.');
                        }
                        else {
                            // it's a later iteration, so the target may have been surpassed (due to confirmations in the background)
                            throw new Error('Done');
                        }
                    }
                    allUnspentsCount = allUnspents.length;
                    targetInputCount = allUnspentsCount - target + 1;
                    targetInputCount = Math.min(targetInputCount, allUnspents.length);
                    inputCount = Math.min(targetInputCount, maxInputCount);
                    // if either the number of inputs left to coalesce equals the number we will coalesce in this iteration
                    // or if the number of iterations matches the maximum permitted number
                    isFinalConsolidation = (inputCount === targetInputCount || iterationCount === maxIterationCount);
                    currentChunk = allUnspents.splice(0, inputCount);
                    changeChain = self.getChangeChain(params);
                    return [4 /*yield*/, self.createAddress({ chain: changeChain, validate: validate })];
                case 2:
                    newAddress = _d.sent();
                    txParams = _.extend({}, params);
                    currentAddress = newAddress;
                    grossAmount = _(currentChunk).map('value').sum();
                    txParams.unspents = currentChunk;
                    txParams.recipients = {};
                    txParams.recipients[newAddress.address] = grossAmount;
                    txParams.noSplitChange = true;
                    if (txParams.unspents.length <= 1) {
                        throw new Error('Done');
                    }
                    _d.label = 3;
                case 3:
                    _d.trys.push([3, 5, , 6]);
                    return [4 /*yield*/, self.sendMany(txParams)];
                case 4:
                    _d.sent();
                    return [3 /*break*/, 6];
                case 5:
                    error_2 = _d.sent();
                    // this error should occur due to insufficient funds
                    // however, let's make sure it wasn't something else
                    if (!error_2.fee && (!error_2.result || !error_2.result.fee)) {
                        debugParams = _.omit(txParams, ['walletPassphrase', 'xprv']);
                        error_2.message += "\n\nTX PARAMS:\n " + JSON.stringify(debugParams, null, 4);
                        throw error_2;
                    }
                    baseFee = error_2.fee || error_2.result.fee;
                    bitgoFee = 0;
                    totalFee = baseFee;
                    if (error_2.result.bitgoFee && error_2.result.bitgoFee.amount) {
                        bitgoFee = error_2.result.bitgoFee.amount;
                        totalFee += bitgoFee;
                        txParams.bitgoFee = error_2.result.bitgoFee;
                    }
                    netAmount = Math.max(error_2.result.available - totalFee, self.bitgo.getConstants().minOutputSize);
                    // Need to clear these out since only 1 may be set
                    delete txParams.fee;
                    txParams.originalFeeRate = txParams.feeRate;
                    delete txParams.feeRate;
                    delete txParams.feeTxConfirmTarget;
                    // we set the fee explicitly
                    txParams.fee = error_2.result.available - netAmount - bitgoFee;
                    txParams.recipients[newAddress.address] = netAmount;
                    return [3 /*break*/, 6];
                case 6:
                    _d.trys.push([6, 8, , 9]);
                    return [4 /*yield*/, self.sendMany(txParams)];
                case 7:
                    sentTx = _d.sent();
                    return [3 /*break*/, 9];
                case 8:
                    e_3 = _d.sent();
                    debugParams = _.omit(txParams, ['walletPassphrase', 'xprv']);
                    e_3.message += "\n\nTX PARAMS:\n " + JSON.stringify(debugParams, null, 4);
                    throw e_3;
                case 9:
                    consolidationTransactions.push(sentTx);
                    if (_.isFunction(params.progressCallback)) {
                        params.progressCallback({
                            txid: sentTx.hash,
                            destination: currentAddress,
                            amount: grossAmount,
                            fee: sentTx.fee,
                            inputCount: inputCount,
                            index: consolidationIndex
                        });
                    }
                    consolidationIndex++;
                    if (!!isFinalConsolidation) return [3 /*break*/, 12];
                    // this last consolidation has not yet brought the unspents count down to the target unspent count
                    // therefore, we proceed by consolidating yet another batch
                    // before we do that, we wait 1 second so that the newly created unspent will be fetched in the next batch
                    return [4 /*yield*/, Bluebird.delay(1000)];
                case 10:
                    // this last consolidation has not yet brought the unspents count down to the target unspent count
                    // therefore, we proceed by consolidating yet another batch
                    // before we do that, we wait 1 second so that the newly created unspent will be fetched in the next batch
                    _d.sent();
                    _b = (_a = consolidationTransactions.push).apply;
                    _c = [consolidationTransactions];
                    return [4 /*yield*/, runNextConsolidation()];
                case 11:
                    _b.apply(_a, _c.concat([_d.sent()]));
                    _d.label = 12;
                case 12: 
                // this is the final consolidation transaction. We return all the ones we've had so far
                return [2 /*return*/, consolidationTransactions];
            }
        });
    });
    return runNextConsolidation(this, target)
        .catch(function (err) {
        if (err.message === 'Done') {
            return;
        }
        throw err;
    })
        .nodeify(callback);
};
Wallet.prototype.shareWallet = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['email', 'permissions'], ['walletPassphrase', 'message'], callback);
    if (params.reshare !== undefined && !_.isBoolean(params.reshare)) {
        throw new Error('Expected reshare to be a boolean.');
    }
    if (params.skipKeychain !== undefined && !_.isBoolean(params.skipKeychain)) {
        throw new Error('Expected skipKeychain to be a boolean. ');
    }
    var needsKeychain = !params.skipKeychain && params.permissions.indexOf('spend') !== -1;
    if (params.disableEmail !== undefined && !_.isBoolean(params.disableEmail)) {
        throw new Error('Expected disableEmail to be a boolean.');
    }
    var self = this;
    var sharing;
    var sharedKeychain;
    return this.bitgo.getSharingKey({ email: params.email.toLowerCase() })
        .then(function (result) {
        sharing = result;
        if (needsKeychain) {
            return self.getEncryptedUserKeychain({})
                .then(function (keychain) {
                // Decrypt the user key with a passphrase
                if (keychain.encryptedXprv) {
                    if (!params.walletPassphrase) {
                        throw new Error('Missing walletPassphrase argument');
                    }
                    try {
                        keychain.xprv = self.bitgo.decrypt({ password: params.walletPassphrase, input: keychain.encryptedXprv });
                    }
                    catch (e) {
                        throw new Error('Unable to decrypt user keychain');
                    }
                    var eckey = bitcoin_1.makeRandomKey();
                    var secret = self.bitgo.getECDHSecret({ eckey: eckey, otherPubKeyHex: sharing.pubkey });
                    var newEncryptedXprv = self.bitgo.encrypt({ password: secret, input: keychain.xprv });
                    sharedKeychain = {
                        xpub: keychain.xpub,
                        encryptedXprv: newEncryptedXprv,
                        fromPubKey: eckey.getPublicKeyBuffer().toString('hex'),
                        toPubKey: sharing.pubkey,
                        path: sharing.path
                    };
                }
            });
        }
    })
        .then(function () {
        var options = {
            user: sharing.userId,
            permissions: params.permissions,
            reshare: params.reshare,
            message: params.message,
            disableEmail: params.disableEmail
        };
        if (sharedKeychain) {
            options.keychain = sharedKeychain;
        }
        else if (params.skipKeychain) {
            options.keychain = {};
        }
        return self.createShare(options);
    })
        .nodeify(callback);
};
Wallet.prototype.removeUser = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['user'], [], callback);
    return this.bitgo.del(this.url('/user/' + params.user))
        .send()
        .result()
        .nodeify(callback);
};
Wallet.prototype.getPolicy = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.get(this.url('/policy'))
        .send()
        .result()
        .nodeify(callback);
};
Wallet.prototype.getPolicyStatus = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.get(this.url('/policy/status'))
        .send()
        .result()
        .nodeify(callback);
};
Wallet.prototype.setPolicyRule = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id', 'type'], ['message'], callback);
    if (!_.isObject(params.condition)) {
        throw new Error('missing parameter: conditions object');
    }
    if (!_.isObject(params.action)) {
        throw new Error('missing parameter: action object');
    }
    return this.bitgo.put(this.url('/policy/rule'))
        .send(params)
        .result()
        .nodeify(callback);
};
Wallet.prototype.removePolicyRule = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], ['message'], callback);
    return this.bitgo.del(this.url('/policy/rule'))
        .send(params)
        .result()
        .nodeify(callback);
};
Wallet.prototype.listWebhooks = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    return this.bitgo.get(this.url('/webhooks'))
        .send()
        .result()
        .nodeify(callback);
};
/**
 * Simulate wallet webhook, currently for webhooks of type transaction and pending approval
 * @param params
 * - webhookId (required): id of the webhook to be simulated
 * - txHash (optional but required for transaction webhooks) hash of the simulated transaction
 * - pendingApprovalId (optional but required for pending approval webhooks) id of the simulated pending approval
 * @param callback
 * @returns {*}
 */
Wallet.prototype.simulateWebhook = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['webhookId'], ['txHash', 'pendingApprovalId'], callback);
    var hasTxHash = !!params.txHash;
    var hasPendingApprovalId = !!params.pendingApprovalId;
    if ((hasTxHash && hasPendingApprovalId) || (!hasTxHash && !hasPendingApprovalId)) {
        throw new Error('must supply either txHash or pendingApprovalId, but not both');
    }
    // depending on the coin type of the wallet, the txHash has to adhere to its respective format
    // but the server takes care of that
    // only take the txHash and pendingApprovalId properties
    var filteredParams = _.pick(params, ['txHash', 'pendingApprovalId']);
    var webhookId = params.webhookId;
    return this.bitgo.post(this.url('/webhooks/' + webhookId + '/simulate'))
        .send(filteredParams)
        .result()
        .nodeify(callback);
};
Wallet.prototype.addWebhook = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['url', 'type'], [], callback);
    return this.bitgo.post(this.url('/webhooks'))
        .send(params)
        .result()
        .nodeify(callback);
};
Wallet.prototype.removeWebhook = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['url', 'type'], [], callback);
    return this.bitgo.del(this.url('/webhooks'))
        .send(params)
        .result()
        .nodeify(callback);
};
Wallet.prototype.estimateFee = function (params, callback) {
    common.validateParams(params, [], [], callback);
    if (params.amount && params.recipients) {
        throw new Error('cannot specify both amount as well as recipients');
    }
    if (params.recipients && !_.isObject(params.recipients)) {
        throw new Error('recipients must be array of { address: abc, amount: 100000 } objects');
    }
    if (params.amount && !_.isNumber(params.amount)) {
        throw new Error('invalid amount argument, expecting number');
    }
    var recipients = params.recipients || [];
    if (params.amount) {
        // only the amount was passed in, so we need to make a false recipient to run createTransaction with
        recipients.push({
            address: common.Environments[this.bitgo.env].signingAddress,
            amount: params.amount
        });
    }
    var transactionParams = _.extend({}, params);
    transactionParams.amount = undefined;
    transactionParams.recipients = recipients;
    return this.createTransaction(transactionParams)
        .then(function (tx) {
        return {
            estimatedSize: tx.estimatedSize,
            fee: tx.fee,
            feeRate: tx.feeRate
        };
    });
};
// Not fully implemented / released on SDK. Testing for now.
Wallet.prototype.updatePolicyRule = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id', 'type'], [], callback);
    return this.bitgo.put(this.url('/policy/rule'))
        .send(params)
        .result()
        .nodeify(callback);
};
Wallet.prototype.deletePolicyRule = function (params, callback) {
    params = params || {};
    common.validateParams(params, ['id'], [], callback);
    return this.bitgo.del(this.url('/policy/rule'))
        .send(params)
        .result()
        .nodeify(callback);
};
//
// getBitGoFee
// Get the required on-transaction BitGo fee
//
Wallet.prototype.getBitGoFee = function (params, callback) {
    params = params || {};
    common.validateParams(params, [], [], callback);
    if (!_.isNumber(params.amount)) {
        throw new Error('invalid amount argument');
    }
    if (params.instant && !_.isBoolean(params.instant)) {
        throw new Error('invalid instant argument');
    }
    return this.bitgo.get(this.url('/billing/fee'))
        .query(params)
        .result()
        .nodeify(callback);
};
module.exports = Wallet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3dhbGxldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVIO0dBQ0c7QUFDSCxFQUFFO0FBQ0YsZ0JBQWdCO0FBQ2hCLHVDQUF1QztBQUN2QyxFQUFFO0FBQ0Ysb0RBQW9EO0FBQ3BELEVBQUU7QUFFRiw0Q0FBc0Q7QUFFdEQsSUFBTSxrQkFBa0IsR0FBRyxPQUFPLENBQUMsc0JBQXNCLENBQUMsQ0FBQztBQUMzRCx5Q0FBMkM7QUFDM0MsK0VBQStFO0FBQy9FLElBQU0sZUFBZSxHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBRXJELGlDQUFtQztBQUNuQyxtQ0FBcUM7QUFDckMsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQUM5QiwwQkFBNEI7QUFDNUIscUNBQThEO0FBQzlELElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUV0QyxFQUFFO0FBQ0YsY0FBYztBQUNkLEVBQUU7QUFDRixJQUFNLE1BQU0sR0FBRyxVQUFTLEtBQUssRUFBRSxNQUFNO0lBQ25DLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ25CLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0lBQ3JCLElBQUksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO0lBRXBCLElBQUksTUFBTSxDQUFDLE9BQU8sRUFBRTtRQUNsQixJQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDO0tBQzNDO0FBQ0gsQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUc7SUFDeEIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0FBQ3JCLENBQUMsQ0FBQztBQUVGLEVBQUU7QUFDRixLQUFLO0FBQ0ws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LEVBQUUsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFFaEQsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDOUQsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO0tBQ3JEO0lBQ0QsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDNUQsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO0tBQ3BEO0lBQ0QsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEVBQUU7UUFDMUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO0tBQzNEO0lBQ0QsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDL0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO0tBQ3REO0lBQ0QsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDbEUsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsQ0FBQyxDQUFDO0tBQzdEO0lBQ0QsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FB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O0FBQ3JCLENBQUMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxTQUFTLENBQUMsVUFBVSxHQUFHLFVBQVMsTUFBTSxFQUFFLFFBQVE7SUFDckQsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFDdEIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFFdEQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDdEQsSUFBSSxFQUFFO1NBQ04sTUFBTSxFQUFFO1NBQ1IsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3JCLENBQUMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLFVBQVMsTUFBTSxFQUFFLFFBQVE7SUFDcEQsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFDdEIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUVoRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDekMsSUFBSSxFQUFFO1NBQ04sTUFBTSxFQUFFO1NBQ1IsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3JCLENBQUMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxTQUFTLENBQUMsZUFBZSxHQUFHLFVBQVMsTUFBTSxFQUFFLFFBQVE7SUFDMUQsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFDdEIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUVoRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMs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QUcsQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUM5QyxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQ1osTUFBTSxFQUFFO1NBQ1IsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3JCLENBQUMsQ0FBQztBQUVGLEVBQUU7QUFDRixjQUFjO0FBQ2QsNENBQTRDO0FBQzVDLEVBQUU7QUFDRixNQUFNLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxVQUFTLE1BQU0sRUFBRSxRQUFRO0lBQ3RELE1BQU0sR0FBRyxNQUFNLElBQUksRUFBRSxDQUFDO0lBQ3RCLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDaEQsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztLQUM1QztJQUNELElBQUksTUFBTSxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ2xELE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQztLQUM3QztJQUNELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUM5QyxLQUFLLENBQUMsTUFBTSxDQUFDO1NBQ2IsTUFBTSxFQUFFO1NBQ1IsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3JCLENBQUMsQ0FBQztBQUVGLGlCQUFTLE1BQU0sQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGhpZGRlblxuICovXG5cbi8qKlxuICovXG4vL1xuLy8gV2FsbGV0IE9iamVjdFxuLy8gQml0R28gYWNjZXNzb3IgZm9yIGEgc3BlY2lmaWMgd2FsbGV0XG4vL1xuLy8gQ29weXJpZ2h0IDIwMTQsIEJpdEdvLCBJbmMuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cblxuaW1wb3J0IHsgQ29kZXMsIFZpcnR1YWxTaXplcyB9IGZyb20gJ0BiaXRnby91bnNwZW50cyc7XG5cbmNvbnN0IFRyYW5zYWN0aW9uQnVpbGRlciA9IHJlcXVpcmUoJy4vdHJhbnNhY3Rpb25CdWlsZGVyJyk7XG5pbXBvcnQgKiBhcyBiaXRjb2luIGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG4vLyBUT0RPOiBzd2l0Y2ggdG8gYml0Y29pbmpzLWxpYiBldmVudHVhbGx5IG9uY2Ugd2UgdXBncmFkZSBpdCB0byB2ZXJzaW9uIDMueC54XG5jb25zdCBQZW5kaW5nQXBwcm92YWwgPSByZXF1aXJlKCcuL3BlbmRpbmdhcHByb3ZhbCcpO1xuXG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0ICogYXMgQmx1ZWJpcmQgZnJvbSAnYmx1ZWJpcmQnO1xuY29uc3QgY28gPSBCbHVlYmlyZC5jb3JvdXRpbmU7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBoZFBhdGgsIG1ha2VSYW5kb21LZXksIGdldE5ldHdvcmsgfSBmcm9tICcuL2JpdGNvaW4nO1xuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoJ3N1cGVyYWdlbnQnKTtcblxuLy9cbi8vIENvbnN0cnVjdG9yXG4vL1xuY29uc3QgV2FsbGV0ID0gZnVuY3Rpb24oYml0Z28sIHdhbGxldCkge1xuICB0aGlzLmJpdGdvID0gYml0Z287XG4gIHRoaXMud2FsbGV0ID0gd2FsbGV0O1xuICB0aGlzLmtleWNoYWlucyA9IFtdO1xuXG4gIGlmICh3YWxsZXQucHJpdmF0ZSkge1xuICAgIHRoaXMua2V5Y2hhaW5zID0gd2FsbGV0LnByaXZhdGUua2V5Y2hhaW5zO1xuICB9XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy53YWxsZXQ7XG59O1xuXG4vL1xuLy8gaWRcbi8vIEdldCB0aGUgaWQgb2YgdGhpcyB3YWxsZXQuXG4vL1xuV2FsbGV0LnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy53YWxsZXQuaWQ7XG59O1xuXG4vL1xuLy8gbGFiZWxcbi8vIEdldCB0aGUgbGFiZWwgb2YgdGhpcyB3YWxsZXQuXG4vL1xuV2FsbGV0LnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy53YWxsZXQubGFiZWw7XG59O1xuXG4vL1xuLy8gYmFsYW5jZVxuLy8gR2V0IHRoZSBiYWxhbmNlIG9mIHRoaXMgd2FsbGV0LlxuLy9cbldhbGxldC5wcm90b3R5cGUuYmFsYW5jZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy53YWxsZXQuYmFsYW5jZTtcbn07XG5cbi8vXG4vLyBiYWxhbmNlXG4vLyBHZXQgdGhlIHNwZW5kYWJsZSBiYWxhbmNlIG9mIHRoaXMgd2FsbGV0LlxuLy8gVGhpcyBpcyB0aGUgdG90YWwgb2YgYWxsIHVuc3BlbnRzIGV4Y2VwdCB0aG9zZSB0aGF0IGFyZSB1bmNvbmZpcm1lZCBhbmQgZXh0ZXJuYWxcbi8vXG5XYWxsZXQucHJvdG90eXBlLnNwZW5kYWJsZUJhbGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMud2FsbGV0LnNwZW5kYWJsZUJhbGFuY2U7XG59O1xuXG4vL1xuLy8gY29uZmlybWVkQmFsYW5jZVxuLy8gR2V0IHRoZSBjb25maXJtZWRCYWxhbmNlIG9mIHRoaXMgd2FsbGV0LlxuLy9cbldhbGxldC5wcm90b3R5cGUuY29uZmlybWVkQmFsYW5jZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy53YWxsZXQuY29uZmlybWVkQmFsYW5jZTtcbn07XG5cbi8vXG4vLyBjYW5TZW5kSW5zdGFudFxuLy8gUmV0dXJucyBpZiB0aGUgd2FsbGV0IGNhbiBzZW5kIGluc3RhbnQgdHJhbnNhY3Rpb25zXG4vLyBUaGlzIGlzIGltcGFjdGVkIGJ5IHRoZSBjaG9pY2Ugb2YgYmFja3VwIGtleSBwcm92aWRlclxuLy9cbldhbGxldC5wcm90b3R5cGUuY2FuU2VuZEluc3RhbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMud2FsbGV0ICYmIHRoaXMud2FsbGV0LmNhblNlbmRJbnN0YW50O1xufTtcblxuLy9cbi8vIGluc3RhbnQgYmFsYW5jZVxuLy8gR2V0IHRoZSBpbnN0YW50IGJhbGFuY2Ugb2YgdGhpcyB3YWxsZXQuXG4vLyBUaGlzIGlzIHRoZSB0b3RhbCBvZiBhbGwgdW5zcGVudHMgdGhhdCBtYXkgYmUgc3BlbnQgaW5zdGFudGx5LlxuLy9cbldhbGxldC5wcm90b3R5cGUuaW5zdGFudEJhbGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmNhblNlbmRJbnN0YW50KCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBhbiBpbnN0YW50IHdhbGxldCcpO1xuICB9XG4gIHJldHVybiB0aGlzLndhbGxldC5pbnN0YW50QmFsYW5jZTtcbn07XG5cbi8vXG4vLyB1bmNvbmZpcm1lZFNlbmRzXG4vLyBHZXQgdGhlIGJhbGFuY2Ugb2YgdW5jb25maXJtZWRTZW5kcyBvZiB0aGlzIHdhbGxldC5cbi8vXG5XYWxsZXQucHJvdG90eXBlLnVuY29uZmlybWVkU2VuZHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMud2FsbGV0LnVuY29uZmlybWVkU2VuZHM7XG59O1xuXG4vL1xuLy8gdW5jb25maXJtZWRSZWNlaXZlc1xuLy8gR2V0IHRoZSBiYWxhbmNlIG9mIHVuY29uZmlybWVkUmVjZWl2ZXMgYmFsYW5jZSBvZiB0aGlzIHdhbGxldC5cbi8vXG5XYWxsZXQucHJvdG90eXBlLnVuY29uZmlybWVkUmVjZWl2ZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMud2FsbGV0LnVuY29uZmlybWVkUmVjZWl2ZXM7XG59O1xuXG4vL1xuLy8gdHlwZVxuLy8gR2V0IHRoZSB0eXBlIG9mIHRoaXMgd2FsbGV0LCBlLmcuICdzYWZlaGQnXG4vL1xuV2FsbGV0LnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndhbGxldC50eXBlO1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS51cmwgPSBmdW5jdGlvbihleHRyYSkge1xuICBleHRyYSA9IGV4dHJhIHx8ICcnO1xuICByZXR1cm4gdGhpcy5iaXRnby51cmwoJy93YWxsZXQvJyArIHRoaXMuaWQoKSArIGV4dHJhKTtcbn07XG5cbi8vXG4vLyBwZW5kaW5nQXBwcm92YWxzXG4vLyByZXR1cm5zIHRoZSBwZW5kaW5nIGFwcHJvdmFscyBsaXN0IGZvciB0aGlzIHdhbGxldCBhcyBwZW5kaW5nIGFwcHJvdmFsIG9iamVjdHNcbi8vXG5XYWxsZXQucHJvdG90eXBlLnBlbmRpbmdBcHByb3ZhbHMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLndhbGxldC5wZW5kaW5nQXBwcm92YWxzLm1hcChmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIG5ldyBQZW5kaW5nQXBwcm92YWwoc2VsZi5iaXRnbywgcCwgc2VsZik7XG4gIH0pO1xufTtcblxuLy9cbi8vIGFwcHJvdmFsc1JlcXVpcmVkXG4vLyByZXR1cm5zIHRoZSBudW1iZXIgb2YgYXBwcm92YWxzIHJlcXVpcmVkIHRvIGFwcHJvdmUgcGVuZGluZyBhcHByb3ZhbHMgaW52b2x2aW5nIHRoaXMgd2FsbGV0XG4vL1xuV2FsbGV0LnByb3RvdHlwZS5hcHByb3ZhbHNSZXF1aXJlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy53YWxsZXQuYXBwcm92YWxzUmVxdWlyZWQgfHwgMTtcbn07XG5cbi8vXG4vLyBnZXRcbi8vIFJlZmV0Y2hlcyB0aGlzIHdhbGxldCBhbmQgcmV0dXJucyBpdFxuLy9cbldhbGxldC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjayk6IEJsdWViaXJkPGFueT4ge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgpKVxuICAucmVzdWx0KClcbiAgLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgc2VsZi53YWxsZXQgPSByZXM7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0pXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyB1cGRhdGVBcHByb3ZhbHNSZXF1aXJlZFxuLy8gVXBkYXRlcyB0aGUgbnVtYmVyIG9mIGFwcHJvdmFscyByZXF1aXJlZCBvbiBhIHBlbmRpbmcgYXBwcm92YWwgaW52b2x2aW5nIHRoaXMgd2FsbGV0LlxuLy8gVGhlIGFwcHJvdmFscyByZXF1aXJlZCBpcyBieSBkZWZhdWx0IDEsIGJ1dCB0aGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gdXBkYXRlIHRoZVxuLy8gbnVtYmVyIHN1Y2ggdGhhdCAxIDw9IGFwcHJvdmFsc1JlcXVpcmVkIDw9IHdhbGxldEFkbWlucy5sZW5ndGggLSAxXG4vL1xuV2FsbGV0LnByb3RvdHlwZS51cGRhdGVBcHByb3ZhbHNSZXF1aXJlZCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spOiBCbHVlYmlyZDxhbnk+IHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcbiAgaWYgKHBhcmFtcy5hcHByb3ZhbHNSZXF1aXJlZCA9PT0gdW5kZWZpbmVkIHx8XG4gICFfLmlzSW50ZWdlcihwYXJhbXMuYXBwcm92YWxzUmVxdWlyZWQpIHx8XG4gIHBhcmFtcy5hcHByb3ZhbHNSZXF1aXJlZCA8IDFcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFwcHJvdmFsc1JlcXVpcmVkOiBtdXN0IGJlIGEgbm9uemVybyBwb3NpdGl2ZSBudW1iZXInKTtcbiAgfVxuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICBjb25zdCBjdXJyZW50QXBwcm92YWxzUmVxdWlyZWQgPSB0aGlzLmFwcHJvdmFsc1JlcXVpcmVkKCk7XG4gIGlmIChjdXJyZW50QXBwcm92YWxzUmVxdWlyZWQgPT09IHBhcmFtcy5hcHByb3ZhbHNSZXF1aXJlZCkge1xuICAgIC8vIG5vLW9wLCBqdXN0IHJldHVybiB0aGUgY3VycmVudCB3YWxsZXRcbiAgICByZXR1cm4gQmx1ZWJpcmQudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNlbGYud2FsbGV0O1xuICAgIH0pXG4gICAgLm5vZGVpZnkoY2FsbGJhY2spO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28ucHV0KHRoaXMudXJsKCkpXG4gIC5zZW5kKHBhcmFtcylcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29ycmVjdCBjaGFpbiBmb3IgY2hhbmdlLCB0YWtpbmcgaW50byBjb25zaWRlcmF0aW9uIHNlZ3dpdFxuICovXG5XYWxsZXQucHJvdG90eXBlLmdldENoYW5nZUNoYWluID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIGxldCB1c2VTZWd3aXRDaGFuZ2UgPSAhIXRoaXMuYml0Z28uZ2V0Q29uc3RhbnRzKCkuZW5hYmxlU2Vnd2l0O1xuICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLnNlZ3dpdENoYW5nZSkpIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5zZWd3aXRDaGFuZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlZ3dpdENoYW5nZSBtdXN0IGJlIGEgYm9vbGVhbicpO1xuICAgIH1cblxuICAgIC8vIGlmIHNlZ3dpdCBpcyBkaXNhYmxlZCB0aHJvdWdoIHRoZSBjb25zdGFudHMsIHNlZ3dpdCBjaGFuZ2Ugc2hvdWxkIHN0aWxsIG5vdCBiZSBjcmVhdGVkXG4gICAgdXNlU2Vnd2l0Q2hhbmdlID0gdGhpcy5iaXRnby5nZXRDb25zdGFudHMoKS5lbmFibGVTZWd3aXQgJiYgcGFyYW1zLnNlZ3dpdENoYW5nZTtcbiAgfVxuICByZXR1cm4gdXNlU2Vnd2l0Q2hhbmdlID8gQ29kZXMuaW50ZXJuYWwucDJzaFAyd3NoIDogQ29kZXMuaW50ZXJuYWwucDJzaDtcbn07XG5cbi8vXG4vLyBjcmVhdGVBZGRyZXNzXG4vLyBDcmVhdGVzIGEgbmV3IGFkZHJlc3MgZm9yIHVzZSB3aXRoIHRoaXMgd2FsbGV0LlxuLy9cbldhbGxldC5wcm90b3R5cGUuY3JlYXRlQWRkcmVzcyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG4gIGlmICh0aGlzLnR5cGUoKSA9PT0gJ3NhZmUnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIHVzaW5nIGEgbGVnYWN5IHdhbGxldCB0aGF0IGNhbm5vdCBjcmVhdGUgYSBuZXcgYWRkcmVzcycpO1xuICB9XG5cbiAgLy8gRGVmYXVsdCB0byBjbGllbnQtc2lkZSBhZGRyZXNzIHZhbGlkYXRpb24gb24sIGZvciBzYWZldHkuIFVzZSB2YWxpZGF0ZT1mYWxzZSB0byBkaXNhYmxlLlxuICBjb25zdCBzaG91bGRWYWxpZGF0ZSA9IHBhcmFtcy52YWxpZGF0ZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1zLnZhbGlkYXRlIDogdGhpcy5iaXRnby5nZXRWYWxpZGF0ZSgpO1xuXG4gIGNvbnN0IGFsbG93RXhpc3RpbmcgPSBwYXJhbXMuYWxsb3dFeGlzdGluZztcbiAgaWYgKHR5cGVvZiBhbGxvd0V4aXN0aW5nICE9PSAnYm9vbGVhbicpIHtcbiAgICBwYXJhbXMuYWxsb3dFeGlzdGluZyA9IChhbGxvd0V4aXN0aW5nID09PSAndHJ1ZScpO1xuICB9XG5cbiAgY29uc3QgaXNTZWd3aXQgPSB0aGlzLmJpdGdvLmdldENvbnN0YW50cygpLmVuYWJsZVNlZ3dpdDtcbiAgY29uc3QgZGVmYXVsdENoYWluID0gaXNTZWd3aXQgPyBDb2Rlcy5leHRlcm5hbC5wMnNoUDJ3c2ggOiBDb2Rlcy5leHRlcm5hbC5wMnNoO1xuXG4gIGxldCBjaGFpbiA9IHBhcmFtcy5jaGFpbjtcbiAgaWYgKGNoYWluID09PSBudWxsIHx8IGNoYWluID09PSB1bmRlZmluZWQpIHtcbiAgICBjaGFpbiA9IGRlZmF1bHRDaGFpbjtcbiAgfVxuICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMudXJsKCcvYWRkcmVzcy8nICsgY2hhaW4pKVxuICAuc2VuZChwYXJhbXMpXG4gIC5yZXN1bHQoKVxuICAudGhlbihmdW5jdGlvbihhZGRyKSB7XG4gICAgaWYgKHNob3VsZFZhbGlkYXRlKSB7XG4gICAgICBzZWxmLnZhbGlkYXRlQWRkcmVzcyhhZGRyKTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZHI7XG4gIH0pXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYWRkcmVzcyBsb2NhbGx5IHdpdGhvdXQgY2FsbGluZyBzZXJ2ZXJcbiAqIEBwYXJhbSBwYXJhbXNcbiAqXG4gKi9cbldhbGxldC5wcm90b3R5cGUuZ2VuZXJhdGVBZGRyZXNzID0gZnVuY3Rpb24oeyBzZWd3aXQsIHBhdGgsIGtleWNoYWlucywgdGhyZXNob2xkIH0pIHtcbiAgY29uc3QgaXNTZWd3aXQgPSAhIXNlZ3dpdDtcbiAgbGV0IHNpZ25hdHVyZVRocmVzaG9sZCA9IDI7XG4gIGlmIChfLmlzSW50ZWdlcih0aHJlc2hvbGQpKSB7XG4gICAgc2lnbmF0dXJlVGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAgIGlmIChzaWduYXR1cmVUaHJlc2hvbGQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aHJlc2hvbGQgaGFzIHRvIGJlIHBvc2l0aXZlJyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcGF0aFJlZ2V4ID0gL15cXC8xP1swMV1cXC9cXGQrJC87XG4gIGlmICghcGF0aC5tYXRjaChwYXRoUmVnZXgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBwYXRoOiAnICsgcGF0aCk7XG4gIH1cblxuICBsZXQgcm9vdEtleXMgPSB0aGlzLmtleWNoYWlucztcbiAgaWYgKEFycmF5LmlzQXJyYXkoa2V5Y2hhaW5zKSkge1xuICAgIHJvb3RLZXlzID0ga2V5Y2hhaW5zO1xuICB9XG5cbiAgY29uc3QgbmV0d29yayA9IGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5iaXRnby5nZXRFbnYoKV0ubmV0d29yaztcblxuICBjb25zdCBkZXJpdmVkS2V5cyA9IHJvb3RLZXlzLm1hcChmdW5jdGlvbihrKSB7XG4gICAgY29uc3QgaGRub2RlID0gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OChrLnhwdWIpO1xuICAgIGxldCBkZXJpdmF0aW9uUGF0aCA9IGsucGF0aCArIHBhdGg7XG4gICAgaWYgKGsud2FsbGV0U3ViUGF0aCkge1xuICAgICAgLy8gaWYgYSBrZXljaGFpbiBoYXMgYSB3YWxsZXQgc3VicGF0aCwgaXQgc2hvdWxkIGJlIHVzZWQgYXMgYW4gaW5maXhcbiAgICAgIGRlcml2YXRpb25QYXRoID0gay5wYXRoICsgay53YWxsZXRTdWJQYXRoICsgcGF0aDtcbiAgICB9XG4gICAgaWYgKCFkZXJpdmF0aW9uUGF0aC5zdGFydHNXaXRoKCdtJykpIHtcbiAgICAgIC8vIGFsbCBkZXJpdmF0aW9uIHBhdGhzIG5lZWQgdG8gc3RhcnQgd2l0aCBtLCBidXQgay5wYXRoIG1heSBhbHJlYWR5IGNvbnRhaW4gdGhhdFxuICAgICAgZGVyaXZhdGlvblBhdGggPSBgbS8ke2Rlcml2YXRpb25QYXRofWA7XG4gICAgfVxuICAgIHJldHVybiBoZFBhdGgoaGRub2RlKS5kZXJpdmVLZXkoZGVyaXZhdGlvblBhdGgpLmdldFB1YmxpY0tleUJ1ZmZlcigpO1xuICB9KTtcblxuICBjb25zdCBwYXRoQ29tcG9uZW50cyA9IHBhdGguc3BsaXQoJy8nKTtcbiAgY29uc3Qgbm9ybWFsaXplZFBhdGhDb21wb25lbnRzID0gXy5tYXAocGF0aENvbXBvbmVudHMsIChjb21wb25lbnQpID0+IHtcbiAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoY29tcG9uZW50LCAxMCk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcGF0aERldGFpbHMgPSBfLmZpbHRlcihub3JtYWxpemVkUGF0aENvbXBvbmVudHMsIF8uaXNJbnRlZ2VyKTtcblxuICBjb25zdCBhZGRyZXNzRGV0YWlsczogYW55ID0ge1xuICAgIGNoYWluUGF0aDogcGF0aCxcbiAgICBwYXRoOiBwYXRoLFxuICAgIGNoYWluOiBwYXRoRGV0YWlsc1swXSxcbiAgICBpbmRleDogcGF0aERldGFpbHNbMV0sXG4gICAgd2FsbGV0OiB0aGlzLmlkKClcbiAgfTtcblxuICAvLyByZWRlZW0gc2NyaXB0IG5vcm1hbGx5LCB3aXRuZXNzIHNjcmlwdCBmb3Igc2Vnd2l0XG4gIGNvbnN0IGlucHV0U2NyaXB0ID0gYml0Y29pbi5zY3JpcHQubXVsdGlzaWcub3V0cHV0LmVuY29kZShzaWduYXR1cmVUaHJlc2hvbGQsIGRlcml2ZWRLZXlzKTtcbiAgY29uc3QgaW5wdXRTY3JpcHRIYXNoID0gYml0Y29pbi5jcnlwdG8uaGFzaDE2MChpbnB1dFNjcmlwdCk7XG4gIGxldCBvdXRwdXRTY3JpcHQgPSBiaXRjb2luLnNjcmlwdC5zY3JpcHRIYXNoLm91dHB1dC5lbmNvZGUoaW5wdXRTY3JpcHRIYXNoKTtcbiAgYWRkcmVzc0RldGFpbHMucmVkZWVtU2NyaXB0ID0gaW5wdXRTY3JpcHQudG9TdHJpbmcoJ2hleCcpO1xuXG4gIGlmIChpc1NlZ3dpdCkge1xuICAgIGNvbnN0IHdpdG5lc3NTY3JpcHRIYXNoID0gYml0Y29pbi5jcnlwdG8uc2hhMjU2KGlucHV0U2NyaXB0KTtcbiAgICBjb25zdCByZWRlZW1TY3JpcHQgPSBiaXRjb2luLnNjcmlwdC53aXRuZXNzU2NyaXB0SGFzaC5vdXRwdXQuZW5jb2RlKHdpdG5lc3NTY3JpcHRIYXNoKTtcbiAgICBjb25zdCByZWRlZW1TY3JpcHRIYXNoID0gYml0Y29pbi5jcnlwdG8uaGFzaDE2MChyZWRlZW1TY3JpcHQpO1xuICAgIG91dHB1dFNjcmlwdCA9IGJpdGNvaW4uc2NyaXB0LnNjcmlwdEhhc2gub3V0cHV0LmVuY29kZShyZWRlZW1TY3JpcHRIYXNoKTtcbiAgICBhZGRyZXNzRGV0YWlscy53aXRuZXNzU2NyaXB0ID0gaW5wdXRTY3JpcHQudG9TdHJpbmcoJ2hleCcpO1xuICAgIGFkZHJlc3NEZXRhaWxzLnJlZGVlbVNjcmlwdCA9IHJlZGVlbVNjcmlwdC50b1N0cmluZygnaGV4Jyk7XG4gIH1cblxuICBhZGRyZXNzRGV0YWlscy5vdXRwdXRTY3JpcHQgPSBvdXRwdXRTY3JpcHQudG9TdHJpbmcoJ2hleCcpO1xuICBhZGRyZXNzRGV0YWlscy5hZGRyZXNzID0gYml0Y29pbi5hZGRyZXNzLmZyb21PdXRwdXRTY3JpcHQob3V0cHV0U2NyaXB0LCBnZXROZXR3b3JrKG5ldHdvcmspKTtcblxuICByZXR1cm4gYWRkcmVzc0RldGFpbHM7XG59O1xuXG4vL1xuLy8gdmFsaWRhdGVBZGRyZXNzXG4vLyBWYWxpZGF0ZXMgYW4gYWRkcmVzcyBhbmQgcGF0aCBieSBjYWxjdWxhdGluZyBpdCBsb2NhbGx5IGZyb20gdGhlIGtleWNoYWluIHhwdWJzXG4vL1xuV2FsbGV0LnByb3RvdHlwZS52YWxpZGF0ZUFkZHJlc3MgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydhZGRyZXNzJywgJ3BhdGgnXSwgW10pO1xuICBjb25zdCBpc1NlZ3dpdCA9ICEhcGFyYW1zLndpdG5lc3NTY3JpcHQgJiYgcGFyYW1zLndpdG5lc3NTY3JpcHQubGVuZ3RoID4gMDtcblxuICBjb25zdCBnZW5lcmF0ZWRBZGRyZXNzID0gdGhpcy5nZW5lcmF0ZUFkZHJlc3MoeyBwYXRoOiBwYXJhbXMucGF0aCwgc2Vnd2l0OiBpc1NlZ3dpdCB9KTtcbiAgaWYgKGdlbmVyYXRlZEFkZHJlc3MuYWRkcmVzcyAhPT0gcGFyYW1zLmFkZHJlc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZHJlc3MgdmFsaWRhdGlvbiBmYWlsdXJlOiAnICsgcGFyYW1zLmFkZHJlc3MgKyAnIHZzLiAnICsgZ2VuZXJhdGVkQWRkcmVzcy5hZGRyZXNzKTtcbiAgfVxufTtcblxuLy9cbi8vIGFkZHJlc3Nlc1xuLy8gR2V0cyB0aGUgYWRkcmVzc2VzIG9mIGEgSEQgd2FsbGV0LlxuLy8gT3B0aW9ucyBpbmNsdWRlOlxuLy8gIGxpbWl0OiB0aGUgbnVtYmVyIG9mIGFkZHJlc3NlcyB0byBnZXRcbi8vXG5XYWxsZXQucHJvdG90eXBlLmFkZHJlc3NlcyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcblxuICBjb25zdCBxdWVyeTogYW55ID0ge307XG4gIGlmIChwYXJhbXMuZGV0YWlscykge1xuICAgIHF1ZXJ5LmRldGFpbHMgPSAxO1xuICB9XG5cbiAgY29uc3QgY2hhaW4gPSBwYXJhbXMuY2hhaW47XG4gIGlmIChjaGFpbiAhPT0gbnVsbCAmJiBjaGFpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hhaW4pKSB7XG4gICAgICBxdWVyeS5jaGFpbiA9IF8udW5pcShfLmZpbHRlcihjaGFpbiwgXy5pc0ludGVnZXIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNoYWluICE9PSAwICYmIGNoYWluICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjaGFpbiBhcmd1bWVudCwgZXhwZWN0aW5nIDAgb3IgMScpO1xuICAgICAgfVxuICAgICAgcXVlcnkuY2hhaW4gPSBjaGFpbjtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgIGlmICghXy5pc0ludGVnZXIocGFyYW1zLmxpbWl0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgfVxuICAgIHF1ZXJ5LmxpbWl0ID0gcGFyYW1zLmxpbWl0O1xuICB9XG4gIGlmIChwYXJhbXMuc2tpcCkge1xuICAgIGlmICghXy5pc0ludGVnZXIocGFyYW1zLnNraXApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2tpcCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgIH1cbiAgICBxdWVyeS5za2lwID0gcGFyYW1zLnNraXA7XG4gIH1cbiAgaWYgKHBhcmFtcy5zb3J0KSB7XG4gICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5zb3J0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNvcnQgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICB9XG4gICAgcXVlcnkuc29ydCA9IHBhcmFtcy5zb3J0O1xuICB9XG5cbiAgY29uc3QgdXJsID0gdGhpcy51cmwoJy9hZGRyZXNzZXMnKTtcbiAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHVybClcbiAgLnF1ZXJ5KHF1ZXJ5KVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5zdGF0cyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcbiAgY29uc3QgYXJnczogc3RyaW5nW10gPSBbXTtcbiAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgIGlmICghXy5pc0ludGVnZXIocGFyYW1zLmxpbWl0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgfVxuICAgIGFyZ3MucHVzaCgnbGltaXQ9JyArIHBhcmFtcy5saW1pdCk7XG4gIH1cbiAgbGV0IHF1ZXJ5ID0gJyc7XG4gIGlmIChhcmdzLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgYXJncy5qb2luKCcmJyk7XG4gIH1cblxuICBjb25zdCB1cmwgPSB0aGlzLnVybCgnL3N0YXRzJyArIHF1ZXJ5KTtcblxuICByZXR1cm4gdGhpcy5iaXRnby5nZXQodXJsKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZWZyZXNoIHRoZSB3YWxsZXQgb2JqZWN0IGJ5IHN5bmNpbmcgd2l0aCB0aGUgYmFjay1lbmRcbiAqIEBwYXJhbSBjYWxsYmFja1xuICogQHJldHVybnMge1dhbGxldH1cbiAqL1xuV2FsbGV0LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICByZXR1cm4gY28oZnVuY3Rpb24gKigpIHtcbiAgICAvLyB3aGVuIHNldCB0byB0cnVlLCBncGsgcmV0dXJucyB0aGUgcHJpdmF0ZSBkYXRhIG9mIHNhZmUgd2FsbGV0c1xuICAgIGNvbnN0IHF1ZXJ5ID0gXy5leHRlbmQoe30sIF8ucGljayhwYXJhbXMsIFsnZ3BrJ10pKTtcbiAgICBjb25zdCByZXMgPSB5aWVsZCB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgpKS5xdWVyeShxdWVyeSkucmVzdWx0KCk7XG4gICAgdGhpcy53YWxsZXQgPSByZXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLmNhbGwodGhpcykuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gYWRkcmVzc1xuLy8gR2V0cyBpbmZvcm1hdGlvbiBhYm91dCBhIHNpbmdsZSBhZGRyZXNzIG9uIGEgSEQgd2FsbGV0LlxuLy8gSW5mb3JtYXRpb24gaW5jbHVkZXMgaW5kZXgsIHBhdGgsIHJlZGVlbVNjcmlwdCwgc2VudCwgcmVjZWl2ZWQsIHR4Q291bnQgYW5kIGJhbGFuY2Vcbi8vIE9wdGlvbnMgaW5jbHVkZTpcbi8vICBhZGRyZXNzOiB0aGUgYWRkcmVzcyBvbiB0aGlzIHdhbGxldCB0byBnZXRcbi8vXG5XYWxsZXQucHJvdG90eXBlLmFkZHJlc3MgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydhZGRyZXNzJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgY29uc3QgdXJsID0gdGhpcy51cmwoJy9hZGRyZXNzZXMvJyArIHBhcmFtcy5hZGRyZXNzKTtcblxuICByZXR1cm4gdGhpcy5iaXRnby5nZXQodXJsKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBGcmVlemUgdGhlIHdhbGxldCBmb3IgYSBkdXJhdGlvbiBvZiBjaG9pY2UsIHN0b3BwaW5nIEJpdEdvIGZyb20gc2lnbmluZyBhbnkgdHJhbnNhY3Rpb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IFRoZSBkdXJhdGlvbiB0byBmcmVlemUgdGhlIHdhbGxldCBmb3IgaW4gc2Vjb25kcywgZGVmYXVsdHMgdG8gMzYwMC5cbiAqL1xuV2FsbGV0LnByb3RvdHlwZS5mcmVlemUgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG5cbiAgaWYgKHBhcmFtcy5kdXJhdGlvbikge1xuICAgIGlmICghXy5pc051bWJlcihwYXJhbXMuZHVyYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZHVyYXRpb24gLSBzaG91bGQgYmUgbnVtYmVyIG9mIHNlY29uZHMnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMudXJsKCcvZnJlZXplJykpXG4gIC5zZW5kKHBhcmFtcylcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBkZWxldGVcbi8vIERlbGV0ZXMgdGhlIHdhbGxldFxuLy9cbldhbGxldC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLmRlbCh0aGlzLnVybCgpKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIGxhYmVsc1xuLy8gTGlzdCB0aGUgbGFiZWxzIGZvciB0aGUgYWRkcmVzc2VzIGluIGEgZ2l2ZW4gd2FsbGV0XG4vL1xuV2FsbGV0LnByb3RvdHlwZS5sYWJlbHMgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG5cbiAgY29uc3QgdXJsID0gdGhpcy5iaXRnby51cmwoJy9sYWJlbHMvJyArIHRoaXMuaWQoKSk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHVybClcbiAgLnJlc3VsdCgnbGFiZWxzJylcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZW5hbWUgYSB3YWxsZXRcbiAqIEBwYXJhbSBwYXJhbXNcbiAqICAtIGxhYmVsOiB0aGUgd2FsbGV0J3MgaW50ZW5kZWQgbmV3IG5hbWVcbiAqIEBwYXJhbSBjYWxsYmFja1xuICogQHJldHVybnMgeyp9XG4gKi9cbldhbGxldC5wcm90b3R5cGUuc2V0V2FsbGV0TmFtZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2xhYmVsJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgY29uc3QgdXJsID0gdGhpcy5iaXRnby51cmwoJy93YWxsZXQvJyArIHRoaXMuaWQoKSk7XG4gIHJldHVybiB0aGlzLmJpdGdvLnB1dCh1cmwpXG4gIC5zZW5kKHsgbGFiZWw6IHBhcmFtcy5sYWJlbCB9KVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIHNldExhYmVsXG4vLyBTZXRzIGEgbGFiZWwgb24gdGhlIHByb3ZpZGVkIGFkZHJlc3Ncbi8vXG5XYWxsZXQucHJvdG90eXBlLnNldExhYmVsID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnYWRkcmVzcycsICdsYWJlbCddLCBbXSwgY2FsbGJhY2spO1xuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gIGlmICghc2VsZi5iaXRnby52ZXJpZnlBZGRyZXNzKHsgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MgfSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYml0Y29pbiBhZGRyZXNzOiAnICsgcGFyYW1zLmFkZHJlc3MpO1xuICB9XG5cbiAgY29uc3QgdXJsID0gdGhpcy5iaXRnby51cmwoJy9sYWJlbHMvJyArIHRoaXMuaWQoKSArICcvJyArIHBhcmFtcy5hZGRyZXNzKTtcblxuICByZXR1cm4gdGhpcy5iaXRnby5wdXQodXJsKVxuICAuc2VuZCh7IGxhYmVsOiBwYXJhbXMubGFiZWwgfSlcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBkZWxldGVMYWJlbFxuLy8gRGVsZXRlcyB0aGUgbGFiZWwgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aWRlZCBhZGRyZXNzXG4vL1xuV2FsbGV0LnByb3RvdHlwZS5kZWxldGVMYWJlbCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2FkZHJlc3MnXSwgW10sIGNhbGxiYWNrKTtcblxuICBjb25zdCBzZWxmID0gdGhpcztcblxuICBpZiAoIXNlbGYuYml0Z28udmVyaWZ5QWRkcmVzcyh7IGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzIH0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJpdGNvaW4gYWRkcmVzczogJyArIHBhcmFtcy5hZGRyZXNzKTtcbiAgfVxuXG4gIGNvbnN0IHVybCA9IHRoaXMuYml0Z28udXJsKCcvbGFiZWxzLycgKyB0aGlzLmlkKCkgKyAnLycgKyBwYXJhbXMuYWRkcmVzcyk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZGVsKHVybClcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyB1bnNwZW50c1xuLy8gTGlzdCBBTEwgdGhlIHVuc3BlbnRzIGZvciBhIGdpdmVuIHdhbGxldFxuLy8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gYSBwYWdlZCBsaXN0IG9mIGFsbCB1bnNwZW50c1xuLy9cbi8vIFBhcmFtZXRlcnMgaW5jbHVkZTpcbi8vICAgbGltaXQ6ICB0aGUgb3B0aW9uYWwgbGltaXQgb2YgdW5zcGVudHMgdG8gY29sbGVjdCBpbiBCVENcbi8vICAgbWluQ29uZjogb25seSBpbmNsdWRlIHJlc3VsdHMgd2l0aCB0aGlzIG51bWJlciBvZiBjb25maXJtYXRpb25zXG4vLyAgIHRhcmdldDogdGhlIGFtb3VudCBvZiBidGMgdG8gZmluZCB0byBzcGVuZFxuLy8gICBpbnN0YW50OiBvbmx5IGZpbmQgaW5zdGFudCB0cmFuc2FjdGlvbnMgKG11c3Qgc3BlY2lmeSBhIHRhcmdldClcbi8vXG5XYWxsZXQucHJvdG90eXBlLnVuc3BlbnRzID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gIGNvbnN0IGFsbFVuc3BlbnRzOiBhbnlbXSA9IFtdO1xuICBjb25zdCBzZWxmID0gdGhpcztcblxuICBjb25zdCBnZXRVbnNwZW50c0JhdGNoID0gZnVuY3Rpb24oc2tpcCwgbGltaXQ/KSB7XG5cbiAgICBjb25zdCBxdWVyeU9iamVjdCA9IF8uY2xvbmVEZWVwKHBhcmFtcyk7XG4gICAgaWYgKHNraXAgPiAwKSB7XG4gICAgICBxdWVyeU9iamVjdC5za2lwID0gc2tpcDtcbiAgICB9XG4gICAgaWYgKGxpbWl0ICYmIGxpbWl0ID4gMCkge1xuICAgICAgcXVlcnlPYmplY3QubGltaXQgPSBsaW1pdDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi51bnNwZW50c1BhZ2VkKHF1ZXJ5T2JqZWN0KVxuICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgLy8gVGhlIEFQSSBoYXMgaXRzIG93biBsaW1pdCBoYW5kbGluZy4gRm9yIGV4YW1wbGUsIHRoZSBBUEkgZG9lcyBub3Qgc3VwcG9ydCBsaW1pdHMgYmlnZ2VyIHRoYW4gNTAwLiBJZiB0aGUgbGltaXRcbiAgICAgIC8vIHNwZWNpZmllZCBoZXJlIGlzIGJpZ2dlciB0aGFuIHRoYXQsIHdlIHdpbGwgaGF2ZSB0byBkbyBtdWx0aXBsZSByZXF1ZXN0cyB3aXRoIG5lY2Vzc2FyeSBsaW1pdCBhZGp1c3RtZW50LlxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQudW5zcGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdW5zcGVudCA9IHJlc3VsdC51bnNwZW50c1tpXTtcbiAgICAgICAgYWxsVW5zcGVudHMucHVzaCh1bnNwZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gT3VyIGxpbWl0IGFkanVzdG1lbnQgbWFrZXMgc3VyZSB0aGF0IHdlIG5ldmVyIGZldGNoIG1vcmUgdW5zcGVudHMgdGhhbiB3ZSBuZWVkLCBtZWFuaW5nIHRoYXQgaWYgd2UgaGl0IHRoZVxuICAgICAgLy8gbGltaXQsIHdlIGhpdCBpdCBwcmVjaXNlbHlcbiAgICAgIGlmIChhbGxVbnNwZW50cy5sZW5ndGggPj0gcGFyYW1zLmxpbWl0KSB7XG4gICAgICAgIHJldHVybiBhbGxVbnNwZW50czsgLy8gd2UgYXJlbid0IGludGVyZXN0ZWQgaW4gYW55IGZ1cnRoZXIgdW5zcGVudHNcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG90YWxVbnNwZW50Q291bnQgPSByZXN1bHQudG90YWw7XG4gICAgICAvLyBpZiBubyB0YXJnZXQgaXMgc3BlY2lmaWVkIGFuZCB0aGUgU0RLIGluZGljYXRlcyB0aGF0IHRoZXJlIGhhcyBiZWVuIGEgbGltaXQsIHdlIG5lZWQgdG8gZmV0Y2ggYW5vdGhlciBiYXRjaFxuICAgICAgaWYgKCFwYXJhbXMudGFyZ2V0ICYmIHRvdGFsVW5zcGVudENvdW50ICYmIHRvdGFsVW5zcGVudENvdW50ID4gYWxsVW5zcGVudHMubGVuZ3RoKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZmV0Y2ggdGhlIG5leHQgYmF0Y2hcbiAgICAgICAgLy8gbGV0J3MganVzdCBvZmZzZXQgdGhlIGN1cnJlbnQgc2tpcCBieSB0aGUgY291bnRcbiAgICAgICAgY29uc3QgbmV3U2tpcCA9IHNraXAgKyByZXN1bHQuY291bnQ7XG4gICAgICAgIGxldCBuZXdMaW1pdDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgICAgICBpZiAobGltaXQgPiAwKSB7XG4gICAgICAgICAgLy8gd2Ugc2V0IHRoZSBuZXcgbGltaXQgdG8gYmUgcHJlY2lzZWx5IHRoZSBudW1iZXIgb2YgbWlzc2luZyB1bnNwZW50cyB0byBoaXQgb3VyIG93biBsaW1pdFxuICAgICAgICAgIG5ld0xpbWl0ID0gbGltaXQgLSBhbGxVbnNwZW50cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFVuc3BlbnRzQmF0Y2gobmV3U2tpcCwgbmV3TGltaXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWxsVW5zcGVudHM7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIGdldFVuc3BlbnRzQmF0Y2goMCwgcGFyYW1zLmxpbWl0KVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIExpc3QgdGhlIHVuc3BlbnRzIChwYWdlZCkgZm9yIGEgZ2l2ZW4gd2FsbGV0LCByZXR1cm5pbmcgdGhlIHJlc3VsdCBhcyBhbiBvYmplY3Qgb2YgdW5zcGVudHMsIGNvdW50LCBza2lwIGFuZCB0b3RhbFxuICogVGhpcyBtZXRob2QgbWF5IG5vdCByZXR1cm4gYWxsIHRoZSB1bnNwZW50cyBhcyB0aGUgbGlzdCBpcyBwYWdlZCBieSB0aGUgQVBJXG4gKiBAcGFyYW0gcGFyYW1zXG4gKiBAcGFyYW0gcGFyYW1zLmxpbWl0IHRoZSBvcHRpb25hbCBsaW1pdCBvZiB1bnNwZW50cyB0byBjb2xsZWN0IGluIEJUQ1xuICogQHBhcmFtIHBhcmFtcy5za2lwIGluZGV4IGluIGxpc3Qgb2YgdW5zcGVudHMgdG8gc3RhcnQgcGFnaW5nIGZyb21cbiAqIEBwYXJhbSBwYXJhbXMubWluQ29uZmlybXMgb25seSBpbmNsdWRlIHJlc3VsdHMgd2l0aCB0aGlzIG51bWJlciBvZiBjb25maXJtYXRpb25zXG4gKiBAcGFyYW0gcGFyYW1zLnRhcmdldCB0aGUgYW1vdW50IG9mIGJ0YyB0byBmaW5kIHRvIHNwZW5kXG4gKiBAcGFyYW0gcGFyYW1zLmluc3RhbnQgb25seSBmaW5kIGluc3RhbnQgdHJhbnNhY3Rpb25zIChtdXN0IHNwZWNpZnkgYSB0YXJnZXQpXG4gKiBAcGFyYW0gcGFyYW1zLnRhcmdldFdhbGxldFVuc3BlbnRzIGRlc2lyZWQgbnVtYmVyIG9mIHVuc3BlbnRzIHRvIGhhdmUgaW4gdGhlIHdhbGxldCBhZnRlciB0aGUgdHggZ29lcyB0aHJvdWdoIChyZXF1aXJlcyB0YXJnZXQpXG4gKiBAcGFyYW0gcGFyYW1zLm1pblNpemUgbWluaW11bSB1bnNwZW50IHNpemUgaW4gc2F0b3NoaXNcbiAqIEBwYXJhbSBwYXJhbXMuc2Vnd2l0IHJlcXVlc3Qgc2Vnd2l0IHVuc3BlbnRzIChkZWZhdWx0cyB0byB0cnVlIGlmIHVuZGVmaW5lZClcbiAqIEBwYXJhbSBwYXJhbXMuYWxsb3dMZWRnZXJTZWd3aXQgYWxsb3cgc2Vnd2l0IHVuc3BlbnRzIGZvciBsZWRnZXIgZGV2aWNlcyAoZGVmYXVsdHMgdG8gZmFsc2UgaWYgdW5kZWZpbmVkKVxuICogQHBhcmFtIGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuV2FsbGV0LnByb3RvdHlwZS51bnNwZW50c1BhZ2VkID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMubGltaXQpICYmICFfLmlzSW50ZWdlcihwYXJhbXMubGltaXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IC0gc2hvdWxkIGJlIG51bWJlcicpO1xuICB9XG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuc2tpcCkgJiYgIV8uaXNJbnRlZ2VyKHBhcmFtcy5za2lwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBza2lwIC0gc2hvdWxkIGJlIG51bWJlcicpO1xuICB9XG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMubWluQ29uZmlybXMpICYmICFfLmlzSW50ZWdlcihwYXJhbXMubWluQ29uZmlybXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1pbkNvbmZpcm1zIC0gc2hvdWxkIGJlIG51bWJlcicpO1xuICB9XG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMudGFyZ2V0KSAmJiAhXy5pc051bWJlcihwYXJhbXMudGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0YXJnZXQgLSBzaG91bGQgYmUgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5pbnN0YW50KSAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmluc3RhbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RhbnQgZmxhZyAtIHNob3VsZCBiZSBib29sZWFuJyk7XG4gIH1cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5zZWd3aXQpICYmICFfLmlzQm9vbGVhbihwYXJhbXMuc2Vnd2l0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzZWd3aXQgZmxhZyAtIHNob3VsZCBiZSBib29sZWFuJyk7XG4gIH1cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy50YXJnZXRXYWxsZXRVbnNwZW50cykgJiYgIV8uaXNJbnRlZ2VyKHBhcmFtcy50YXJnZXRXYWxsZXRVbnNwZW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdGFyZ2V0V2FsbGV0VW5zcGVudHMgZmxhZyAtIHNob3VsZCBiZSBudW1iZXInKTtcbiAgfVxuICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLm1pblNpemUpICYmICFfLmlzTnVtYmVyKHBhcmFtcy5taW5TaXplKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudDogbWluU2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5pbnN0YW50KSAmJiAhXy5pc1VuZGVmaW5lZChwYXJhbXMubWluQ29uZmlybXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IG9uZSBvZiBpbnN0YW50IGFuZCBtaW5Db25maXJtcyBtYXkgYmUgZGVmaW5lZCcpO1xuICB9XG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMudGFyZ2V0V2FsbGV0VW5zcGVudHMpICYmIF8uaXNVbmRlZmluZWQocGFyYW1zLnRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldFdhbGxldFVuc3BlbnRzIGNhbiBvbmx5IGJlIHNwZWNpZmllZCBpbiBjb25qdW5jdGlvbiB3aXRoIGEgdGFyZ2V0Jyk7XG4gIH1cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5hbGxvd0xlZGdlclNlZ3dpdCkgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5hbGxvd0xlZGdlclNlZ3dpdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQ6IGFsbG93TGVkZ2VyU2Vnd2l0IG11c3QgYmUgYSBib29sZWFuJyk7XG4gIH1cblxuICBjb25zdCBxdWVyeU9iamVjdCA9IF8uY2xvbmVEZWVwKHBhcmFtcyk7XG5cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy50YXJnZXQpKSB7XG4gICAgLy8gc2tpcCBhbmQgbGltaXQgYXJlIHVuYXZhaWxhYmxlIHdoZW4gYSB0YXJnZXQgaXMgc3BlY2lmaWVkXG4gICAgZGVsZXRlIHF1ZXJ5T2JqZWN0LnNraXA7XG4gICAgZGVsZXRlIHF1ZXJ5T2JqZWN0LmxpbWl0O1xuICB9XG5cbiAgcXVlcnlPYmplY3Quc2Vnd2l0ID0gdHJ1ZTtcbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5zZWd3aXQpKSB7XG4gICAgcXVlcnlPYmplY3Quc2Vnd2l0ID0gcGFyYW1zLnNlZ3dpdDtcbiAgfVxuXG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuYWxsb3dMZWRnZXJTZWd3aXQpKSB7XG4gICAgcXVlcnlPYmplY3QuYWxsb3dMZWRnZXJTZWd3aXQgPSBwYXJhbXMuYWxsb3dMZWRnZXJTZWd3aXQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy51cmwoJy91bnNwZW50cycpKVxuICAucXVlcnkocXVlcnlPYmplY3QpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG4vL1xuLy8gdHJhbnNhY3Rpb25zXG4vLyBMaXN0IHRoZSB0cmFuc2FjdGlvbnMgZm9yIGEgZ2l2ZW4gd2FsbGV0XG4vLyBPcHRpb25zIGluY2x1ZGU6XG4vLyAgICAgVE9ETzogIEFkZCBpdGVyYXRvcnMgZm9yIHN0YXJ0L2NvdW50L2V0Y1xuV2FsbGV0LnByb3RvdHlwZS50cmFuc2FjdGlvbnMgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG5cbiAgY29uc3QgYXJnczogc3RyaW5nW10gPSBbXTtcbiAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgIGlmICghXy5pc0ludGVnZXIocGFyYW1zLmxpbWl0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgfVxuICAgIGFyZ3MucHVzaCgnbGltaXQ9JyArIHBhcmFtcy5saW1pdCk7XG4gIH1cbiAgaWYgKHBhcmFtcy5za2lwKSB7XG4gICAgaWYgKCFfLmlzSW50ZWdlcihwYXJhbXMuc2tpcCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBza2lwIGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgfVxuICAgIGFyZ3MucHVzaCgnc2tpcD0nICsgcGFyYW1zLnNraXApO1xuICB9XG4gIGlmIChwYXJhbXMubWluSGVpZ2h0KSB7XG4gICAgaWYgKCFfLmlzSW50ZWdlcihwYXJhbXMubWluSGVpZ2h0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1pbkhlaWdodCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgIH1cbiAgICBhcmdzLnB1c2goJ21pbkhlaWdodD0nICsgcGFyYW1zLm1pbkhlaWdodCk7XG4gIH1cbiAgaWYgKHBhcmFtcy5tYXhIZWlnaHQpIHtcbiAgICBpZiAoIV8uaXNJbnRlZ2VyKHBhcmFtcy5tYXhIZWlnaHQpIHx8IHBhcmFtcy5tYXhIZWlnaHQgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbWF4SGVpZ2h0IGFyZ3VtZW50LCBleHBlY3RpbmcgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgIH1cbiAgICBhcmdzLnB1c2goJ21heEhlaWdodD0nICsgcGFyYW1zLm1heEhlaWdodCk7XG4gIH1cbiAgaWYgKHBhcmFtcy5taW5Db25maXJtcykge1xuICAgIGlmICghXy5pc0ludGVnZXIocGFyYW1zLm1pbkNvbmZpcm1zKSB8fCBwYXJhbXMubWluQ29uZmlybXMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbWluQ29uZmlybXMgYXJndW1lbnQsIGV4cGVjdGluZyBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgfVxuICAgIGFyZ3MucHVzaCgnbWluQ29uZmlybXM9JyArIHBhcmFtcy5taW5Db25maXJtcyk7XG4gIH1cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5jb21wYWN0KSkge1xuICAgIGlmICghXy5pc0Jvb2xlYW4ocGFyYW1zLmNvbXBhY3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY29tcGFjdCBhcmd1bWVudCwgZXhwZWN0aW5nIGJvb2xlYW4nKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKCdjb21wYWN0PScgKyBwYXJhbXMuY29tcGFjdCk7XG4gIH1cbiAgbGV0IHF1ZXJ5ID0gJyc7XG4gIGlmIChhcmdzLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgYXJncy5qb2luKCcmJyk7XG4gIH1cblxuICBjb25zdCB1cmwgPSB0aGlzLnVybCgnL3R4JyArIHF1ZXJ5KTtcblxuICByZXR1cm4gdGhpcy5iaXRnby5nZXQodXJsKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIHRyYW5zYWN0aW9uXG4vLyBHZXQgYSB0cmFuc2FjdGlvbiBieSBJRCBmb3IgYSBnaXZlbiB3YWxsZXRcbldhbGxldC5wcm90b3R5cGUuZ2V0VHJhbnNhY3Rpb24gPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCddLCBbXSwgY2FsbGJhY2spO1xuXG4gIGNvbnN0IHVybCA9IHRoaXMudXJsKCcvdHgvJyArIHBhcmFtcy5pZCk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHVybClcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBwb2xsRm9yVHJhbnNhY3Rpb25cbi8vIFBvbGwgYSB0cmFuc2FjdGlvbiB1bnRpbCBzdWNjZXNzZnVsIG9yIHRpbWVzIG91dFxuLy8gUGFyYW1ldGVyczpcbi8vICAgaWQ6IHRoZSB0eGlkXG4vLyAgIGRlbGF5OiBkZWxheSBiZXR3ZWVuIHBvbGxzIGluIG1zIChkZWZhdWx0OiAxMDAwKVxuLy8gICB0aW1lb3V0OiB0aW1lb3V0IGluIG1zIChkZWZhdWx0OiAxMDAwMClcbldhbGxldC5wcm90b3R5cGUucG9sbEZvclRyYW5zYWN0aW9uID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2lkJ10sIFtdLCBjYWxsYmFjayk7XG4gIGlmIChwYXJhbXMuZGVsYXkgJiYgIV8uaXNOdW1iZXIocGFyYW1zLmRlbGF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkZWxheSBwYXJhbWV0ZXInKTtcbiAgfVxuICBpZiAocGFyYW1zLnRpbWVvdXQgJiYgIV8uaXNOdW1iZXIocGFyYW1zLnRpbWVvdXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHRpbWVvdXQgcGFyYW1ldGVyJyk7XG4gIH1cbiAgcGFyYW1zLmRlbGF5ID0gcGFyYW1zLmRlbGF5IHx8IDEwMDA7XG4gIHBhcmFtcy50aW1lb3V0ID0gcGFyYW1zLnRpbWVvdXQgfHwgMTAwMDA7XG5cbiAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSgpO1xuXG4gIGNvbnN0IGRvTmV4dFBvbGwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5nZXRUcmFuc2FjdGlvbihwYXJhbXMpXG4gICAgLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pXG4gICAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVyci5zdGF0dXMgIT09IDQwNCB8fCBuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHN0YXJ0LnZhbHVlT2YoKSA+IHBhcmFtcy50aW1lb3V0KSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCbHVlYmlyZC5kZWxheShwYXJhbXMuZGVsYXkpXG4gICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGRvTmV4dFBvbGwoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBkb05leHRQb2xsKCk7XG59O1xuXG4vL1xuLy8gdHJhbnNhY3Rpb24gYnkgc2VxdWVuY2UgaWRcbi8vIEdldCBhIHRyYW5zYWN0aW9uIGJ5IHNlcXVlbmNlIGlkIGZvciBhIGdpdmVuIHdhbGxldFxuV2FsbGV0LnByb3RvdHlwZS5nZXRXYWxsZXRUcmFuc2FjdGlvbkJ5U2VxdWVuY2VJZCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3NlcXVlbmNlSWQnXSwgW10sIGNhbGxiYWNrKTtcblxuICBjb25zdCB1cmwgPSB0aGlzLnVybCgnL3R4L3NlcXVlbmNlLycgKyBwYXJhbXMuc2VxdWVuY2VJZCk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHVybClcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBLZXkgY2hhaW5zXG4vLyBHZXRzIHRoZSB1c2VyIGtleSBjaGFpbiBmb3IgdGhpcyB3YWxsZXRcbi8vIFRoZSB1c2VyIGtleSBjaGFpbiBpcyB0eXBpY2FsbHkgdGhlIGZpcnN0IGtleWNoYWluIG9mIHRoZSB3YWxsZXQgYW5kIGhhcyB0aGUgZW5jcnlwdGVkIHhwcml2IHN0b3JlZCBvbiBCaXRHby5cbi8vIFVzZWZ1bCB3aGVuIHRyeWluZyB0byBnZXQgdGhlIHVzZXJzJyBrZXljaGFpbiBmcm9tIHRoZSBzZXJ2ZXIgYmVmb3JlIGRlY3J5cHRpbmcgdG8gc2lnbiBhIHRyYW5zYWN0aW9uLlxuV2FsbGV0LnByb3RvdHlwZS5nZXRFbmNyeXB0ZWRVc2VyS2V5Y2hhaW4gPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBjbyhmdW5jdGlvbiAqKCkge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGNvbnN0IHRyeUtleUNoYWluID0gY28oZnVuY3Rpb24gKihpbmRleCkge1xuICAgICAgaWYgKCFzZWxmLmtleWNoYWlucyB8fCBpbmRleCA+PSBzZWxmLmtleWNoYWlucy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcignTm8gZW5jcnlwdGVkIGtleWNoYWlucyBvbiB0aGlzIHdhbGxldC4nKTtcbiAgICAgICAgZXJyb3IuY29kZSA9ICdub19lbmNyeXB0ZWRfa2V5Y2hhaW5fb25fd2FsbGV0JztcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmFtcyA9IHsgeHB1Yjogc2VsZi5rZXljaGFpbnNbaW5kZXhdLnhwdWIgfTtcblxuICAgICAgY29uc3Qga2V5Y2hhaW4gPSB5aWVsZCBzZWxmLmJpdGdvLmtleWNoYWlucygpLmdldChwYXJhbXMpO1xuICAgICAgLy8gSWYgd2UgZmluZCB0aGUgeHBydiwgdGhlbiB0aGlzIGlzIHByb2JhYmx5IHRoZSB1c2VyIGtleWNoYWluIHdlJ3JlIGxvb2tpbmcgZm9yXG4gICAgICBrZXljaGFpbi53YWxsZXRTdWJQYXRoID0gc2VsZi5rZXljaGFpbnNbaW5kZXhdLnBhdGg7XG4gICAgICBpZiAoa2V5Y2hhaW4uZW5jcnlwdGVkWHBydikge1xuICAgICAgICByZXR1cm4ga2V5Y2hhaW47XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ5S2V5Q2hhaW4oaW5kZXggKyAxKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0cnlLZXlDaGFpbigwKTtcbiAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBjcmVhdGVUcmFuc2FjdGlvblxuLy8gQ3JlYXRlIGEgdHJhbnNhY3Rpb24gKHVuc2lnbmVkKS4gVG8gc2lnbiBpdCwgZG8gc2lnblRyYW5zYWN0aW9uXG4vLyBQYXJhbWV0ZXJzOlxuLy8gICByZWNpcGllbnRzIC0gb2JqZWN0IG9mIHJlY2lwaWVudCBhZGRyZXNzZXMgYW5kIHRoZSBhbW91bnQgdG8gc2VuZCB0byBlYWNoIGUuZy4ge2FkZHJlc3M6MTUwMCwgYWRkcmVzczI6MTUwMH1cbi8vICAgZmVlICAgICAgLSB0aGUgYmxvY2tjaGFpbiBmZWUgdG8gc2VuZCAob3B0aW9uYWwpXG4vLyAgIGZlZVJhdGUgIC0gdGhlIGZlZSBwZXIga2IgdG8gc2VuZCAob3B0aW9uYWwpXG4vLyAgIG1pbkNvbmZpcm1zIC0gbWluaW11bSBudW1iZXIgb2YgY29uZmlybXMgdG8gdXNlIHdoZW4gZ2F0aGVyaW5nIHVuc3BlbnRzXG4vLyAgIGZvcmNlQ2hhbmdlQXRFbmQgLSBmb3JjZSBjaGFuZ2UgYWRkcmVzcyB0byBiZSBsYXN0IG91dHB1dCAob3B0aW9uYWwpXG4vLyAgIG5vU3BsaXRDaGFuZ2UgLSBkaXNhYmxlIGF1dG9tYXRpYyBjaGFuZ2Ugc3BsaXR0aW5nIGZvciBwdXJwb3NlcyBvZiB1bnNwZW50IG1hbmFnZW1lbnRcbi8vICAgY2hhbmdlQWRkcmVzcyAtIG92ZXJyaWRlIHRoZSBjaGFuZ2UgYWRkcmVzcyAob3B0aW9uYWwpXG4vLyAgIHZhbGlkYXRlIC0gZXh0cmEgdmVyaWZpY2F0aW9uIG9mIGNoYW5nZSBhZGRyZXNzZXMgKHdoaWNoIGFyZSBhbHdheXMgdmVyaWZpZWQgc2VydmVyLXNpZGUpIChkZWZhdWx0cyB0byBnbG9iYWwgY29uZmlnKVxuLy8gUmV0dXJuczpcbi8vICAgY2FsbGJhY2soZXJyLCB7IHRyYW5zYWN0aW9uSGV4OiBzdHJpbmcsIHVuc3BlbnRzOiBbaW5wdXRzXSwgZmVlOiBzYXRvc2hpcyB9KVxuV2FsbGV0LnByb3RvdHlwZS5jcmVhdGVUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gXy5leHRlbmQoe30sIHBhcmFtcyk7XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gIGlmICgoIV8uaXNOdW1iZXIocGFyYW1zLmZlZSkgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLmZlZSkpIHx8XG4gICghXy5pc051bWJlcihwYXJhbXMuZmVlUmF0ZSkgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLmZlZVJhdGUpKSB8fFxuICAoIV8uaXNOdW1iZXIocGFyYW1zLm1pbkNvbmZpcm1zKSAmJiAhXy5pc1VuZGVmaW5lZChwYXJhbXMubWluQ29uZmlybXMpKSB8fFxuICAoIV8uaXNCb29sZWFuKHBhcmFtcy5mb3JjZUNoYW5nZUF0RW5kKSAmJiAhXy5pc1VuZGVmaW5lZChwYXJhbXMuZm9yY2VDaGFuZ2VBdEVuZCkpIHx8XG4gICghXy5pc1N0cmluZyhwYXJhbXMuY2hhbmdlQWRkcmVzcykgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLmNoYW5nZUFkZHJlc3MpKSB8fFxuICAoIV8uaXNCb29sZWFuKHBhcmFtcy52YWxpZGF0ZSkgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLnZhbGlkYXRlKSkgfHxcbiAgKCFfLmlzQm9vbGVhbihwYXJhbXMuaW5zdGFudCkgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLmluc3RhbnQpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcy5yZWNpcGllbnRzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIHJlY2lwaWVudHMgb2JqZWN0Jyk7XG4gIH1cblxuICBwYXJhbXMudmFsaWRhdGUgPSBwYXJhbXMudmFsaWRhdGUgIT09IHVuZGVmaW5lZCA/IHBhcmFtcy52YWxpZGF0ZSA6IHRoaXMuYml0Z28uZ2V0VmFsaWRhdGUoKTtcbiAgcGFyYW1zLndhbGxldCA9IHRoaXM7XG5cbiAgcmV0dXJuIFRyYW5zYWN0aW9uQnVpbGRlci5jcmVhdGVUcmFuc2FjdGlvbihwYXJhbXMpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cblxuLy9cbi8vIHNpZ25UcmFuc2FjdGlvblxuLy8gU2lnbiBhIHByZXZpb3VzbHkgY3JlYXRlZCB0cmFuc2FjdGlvbiB3aXRoIGEga2V5Y2hhaW5cbi8vIFBhcmFtZXRlcnM6XG4vLyB0cmFuc2FjdGlvbkhleCAtIHNlcmlhbGl6ZWQgZm9ybSBvZiB0aGUgdHJhbnNhY3Rpb24gaW4gaGV4XG4vLyB1bnNwZW50cyAtIGFycmF5IG9mIHVuc3BlbnQgaW5mb3JtYXRpb24sIHdoZXJlIGVhY2ggdW5zcGVudCBpcyBhIGNoYWluUGF0aFxuLy8gICAgICAgICAgICBhbmQgcmVkZWVtU2NyaXB0IHdpdGggdGhlIHNhbWUgaW5kZXggYXMgdGhlIGlucHV0cyBpbiB0aGVcbi8vICAgICAgICAgICAgdHJhbnNhY3Rpb25IZXhcbi8vIGtleWNoYWluIC0gS2V5Y2hhaW4gY29udGFpbmluZyB0aGUgeHBydiB0byBzaWduIHdpdGguXG4vLyBzaWduaW5nS2V5IC0gRm9yIGxlZ2FjeSBzYWZlIHdhbGxldHMsIHRoZSBwcml2YXRlIGtleSBzdHJpbmcuXG4vLyB2YWxpZGF0ZSAtIGV4dHJhIHZlcmlmaWNhdGlvbiBvZiBzaWduYXR1cmVzICh3aGljaCBhcmUgYWx3YXlzIHZlcmlmaWVkIHNlcnZlci1zaWRlKSAoZGVmYXVsdHMgdG8gZ2xvYmFsIGNvbmZpZylcbi8vIFJldHVybnM6XG4vLyAgIGNhbGxiYWNrKGVyciwgdHJhbnNhY3Rpb24pXG5XYWxsZXQucHJvdG90eXBlLnNpZ25UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gXy5leHRlbmQoe30sIHBhcmFtcyk7XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndHJhbnNhY3Rpb25IZXgnXSwgW10sIGNhbGxiYWNrKTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLnVuc3BlbnRzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIHRoZSB1bnNwZW50cyBhcnJheScpO1xuICB9XG5cbiAgaWYgKCghXy5pc09iamVjdChwYXJhbXMua2V5Y2hhaW4pIHx8ICFwYXJhbXMua2V5Y2hhaW4ueHBydikgJiYgIV8uaXNTdHJpbmcocGFyYW1zLnNpZ25pbmdLZXkpKSB7XG4gICAgLy8gYWxsb3cgcGFzc2luZyBpbiBhIFdJRiBwcml2YXRlIGtleSBmb3IgbGVnYWN5IHNhZmUgd2FsbGV0IHN1cHBvcnRcbiAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKCdleHBlY3Rpbmcga2V5Y2hhaW4gb2JqZWN0IHdpdGggeHBydiBvciBzaWduaW5nS2V5IFdJRicpO1xuICAgIGVycm9yLmNvZGUgPSAnbWlzc2luZ19rZXljaGFpbl9vcl9zaWduaW5nS2V5JztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHBhcmFtcy52YWxpZGF0ZSA9IHBhcmFtcy52YWxpZGF0ZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1zLnZhbGlkYXRlIDogdGhpcy5iaXRnby5nZXRWYWxpZGF0ZSgpO1xuICBwYXJhbXMuYml0Z28gPSB0aGlzLmJpdGdvO1xuICByZXR1cm4gVHJhbnNhY3Rpb25CdWlsZGVyLnNpZ25UcmFuc2FjdGlvbihwYXJhbXMpXG4gIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eDogcmVzdWx0LnRyYW5zYWN0aW9uSGV4XG4gICAgfTtcbiAgfSlcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIHNlbmRcbi8vIFNlbmQgYSB0cmFuc2FjdGlvbiB0byB0aGUgQml0Y29pbiBuZXR3b3JrIHZpYSBCaXRHby5cbi8vIE9uZSBvZiB0aGUga2V5cyBpcyB0eXBpY2FsbHkgc2lnbmVkLCBhbmQgQml0R28gd2lsbCBzaWduIHRoZSBvdGhlciAoaWYgYXBwcm92ZWQpIGFuZCByZWxheSBpdCB0byB0aGUgUDJQIG5ldHdvcmsuXG4vLyBQYXJhbWV0ZXJzOlxuLy8gICB0eCAgLSB0aGUgaGV4IGVuY29kZWQsIHNpZ25lZCB0cmFuc2FjdGlvbiB0byBzZW5kXG4vLyBSZXR1cm5zOlxuLy9cbldhbGxldC5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsndHgnXSwgWydtZXNzYWdlJywgJ290cCddLCBjYWxsYmFjayk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28ucG9zdCh0aGlzLmJpdGdvLnVybCgnL3R4L3NlbmQnKSlcbiAgLnNlbmQocGFyYW1zKVxuICAucmVzdWx0KClcbiAgLnRoZW4oZnVuY3Rpb24oYm9keSkge1xuICAgIGlmIChib2R5LnBlbmRpbmdBcHByb3ZhbCkge1xuICAgICAgcmV0dXJuIF8uZXh0ZW5kKGJvZHksIHsgc3RhdHVzOiAncGVuZGluZ0FwcHJvdmFsJyB9KTtcbiAgICB9XG5cbiAgICBpZiAoYm9keS5vdHApIHtcbiAgICAgIHJldHVybiBfLmV4dGVuZChib2R5LCB7IHN0YXR1czogJ290cCcgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogJ2FjY2VwdGVkJyxcbiAgICAgIHR4OiBib2R5LnRyYW5zYWN0aW9uLFxuICAgICAgaGFzaDogYm9keS50cmFuc2FjdGlvbkhhc2gsXG4gICAgICBpbnN0YW50OiBib2R5Lmluc3RhbnQsXG4gICAgICBpbnN0YW50SWQ6IGJvZHkuaW5zdGFudElkXG4gICAgfTtcbiAgfSlcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTaGFyZSB0aGUgd2FsbGV0IHdpdGggYW4gZXhpc3RpbmcgQml0R28gdXNlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyIFRoZSByZWNpcGllbnQncyB1c2VyIGlkLCBtdXN0IGhhdmUgYSBjb3JyZXNwb25kaW5nIHVzZXIgcmVjb3JkIGluIG91ciBkYXRhYmFzZS5cbiAqIEBwYXJhbSB7a2V5Y2hhaW59IGtleWNoYWluIFRoZSBrZXljaGFpbiB0byBiZSBzaGFyZWQgd2l0aCB0aGUgcmVjaXBpZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHBlcm1pc3Npb25zIEEgY29tbWEtc2VwYXJhdGVkIHZhbHVlIHN0cmluZyB0aGF0IHNwZWNpZmllcyB0aGUgcmVjaXBpZW50J3MgcGVybWlzc2lvbnMgaWYgdGhlIHNoYXJlIGlzIGFjY2VwdGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gYmUgdXNlZCBmb3IgdGhpcyBzaGFyZS5cbiAqL1xuV2FsbGV0LnByb3RvdHlwZS5jcmVhdGVTaGFyZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3VzZXInLCAncGVybWlzc2lvbnMnXSwgW10sIGNhbGxiYWNrKTtcblxuICBpZiAocGFyYW1zLmtleWNoYWluICYmICFfLmlzRW1wdHkocGFyYW1zLmtleWNoYWluKSkge1xuICAgIGlmICghcGFyYW1zLmtleWNoYWluLnhwdWIgfHwgIXBhcmFtcy5rZXljaGFpbi5lbmNyeXB0ZWRYcHJ2IHx8ICFwYXJhbXMua2V5Y2hhaW4uZnJvbVB1YktleSB8fCAhcGFyYW1zLmtleWNoYWluLnRvUHViS2V5IHx8ICFwYXJhbXMua2V5Y2hhaW4ucGF0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlcyBrZXljaGFpbiBwYXJhbWV0ZXJzIC0geHB1YiwgZW5jcnlwdGVkWHBydiwgZnJvbVB1YktleSwgdG9QdWJLZXksIHBhdGgnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMudXJsKCcvc2hhcmUnKSlcbiAgLnNlbmQocGFyYW1zKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIGNyZWF0ZUludml0ZVxuLy8gaW52aXRlIGEgbm9uIEJpdEdvIGN1c3RvbWVyIHRvIGpvaW4gYSB3YWxsZXRcbi8vIFBhcmFtZXRlcnM6XG4vLyAgIGVtYWlsIC0gdGhlIHJlY2lwaWVudCdzIGVtYWlsIGFkZHJlc3Ncbi8vICAgcGVybWlzc2lvbnMgLSB0aGUgcmVjaXBpZW50J3MgcGVybWlzc2lvbnMgaWYgdGhlIHNoYXJlIGlzIGFjY2VwdGVkXG4vLyBSZXR1cm5zOlxuLy9cbldhbGxldC5wcm90b3R5cGUuY3JlYXRlSW52aXRlID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnZW1haWwnLCAncGVybWlzc2lvbnMnXSwgWydtZXNzYWdlJ10sIGNhbGxiYWNrKTtcblxuICBjb25zdCBvcHRpb25zOiBhbnkgPSB7XG4gICAgdG9FbWFpbDogcGFyYW1zLmVtYWlsLFxuICAgIHBlcm1pc3Npb25zOiBwYXJhbXMucGVybWlzc2lvbnNcbiAgfTtcblxuICBpZiAocGFyYW1zLm1lc3NhZ2UpIHtcbiAgICBvcHRpb25zLm1lc3NhZ2UgPSBwYXJhbXMubWVzc2FnZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmJpdGdvLnBvc3QodGhpcy51cmwoJy9pbnZpdGUnKSlcbiAgLnNlbmQob3B0aW9ucylcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBjb25maXJtSW52aXRlQW5kU2hhcmVXYWxsZXRcbi8vIGNvbmZpcm0gbXkgaW52aXRlIG9uIHRoaXMgd2FsbGV0IHRvIGEgcmVjaXBpZW50IHdobyBoYXNcbi8vIHN1YnNlcXVlbnRseSBzaWduZWQgdXAgYnkgY3JlYXRpbmcgdGhlIGFjdHVhbCB3YWxsZXQgc2hhcmVcbi8vIFBhcmFtZXRlcnM6XG4vLyAgIHdhbGxldEludml0ZUlkIC0gdGhlIHdhbGxldCBpbnZpdGUgaWRcbi8vICAgd2FsbGV0UGFzc3BocmFzZSAtIHJlcXVpcmVkIGlmIHRoZSB3YWxsZXQgc2hhcmUgc3VjY2VzcyBpcyBleHBlY3RlZFxuLy8gUmV0dXJuczpcbi8vXG5XYWxsZXQucHJvdG90eXBlLmNvbmZpcm1JbnZpdGVBbmRTaGFyZVdhbGxldCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dhbGxldEludml0ZUlkJ10sIFsnd2FsbGV0UGFzc3BocmFzZSddLCBjYWxsYmFjayk7XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLmJpdGdvLndhbGxldHMoKS5saXN0SW52aXRlcygpXG4gIC50aGVuKGZ1bmN0aW9uKGludml0ZXMpIHtcbiAgICBjb25zdCBvdXRnb2luZyA9IGludml0ZXMub3V0Z29pbmc7XG4gICAgY29uc3QgaW52aXRlID0gXy5maW5kKG91dGdvaW5nLCBmdW5jdGlvbihvdXQpIHtcbiAgICAgIHJldHVybiBvdXQuaWQgPT09IHBhcmFtcy53YWxsZXRJbnZpdGVJZDtcbiAgICB9KTtcbiAgICBpZiAoIWludml0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3YWxsZXQgaW52aXRlIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBlbWFpbDogaW52aXRlLnRvRW1haWwsXG4gICAgICBwZXJtaXNzaW9uczogaW52aXRlLnBlcm1pc3Npb25zLFxuICAgICAgbWVzc2FnZTogaW52aXRlLm1lc3NhZ2UsXG4gICAgICB3YWxsZXRQYXNzcGhyYXNlOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZVxuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZi5zaGFyZVdhbGxldChvcHRpb25zKTtcbiAgfSlcbiAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYml0Z28ucHV0KHRoaXMuYml0Z28udXJsKCcvd2FsbGV0aW52aXRlLycgKyBwYXJhbXMud2FsbGV0SW52aXRlSWQpKTtcbiAgfSlcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIHNlbmRDb2luc1xuLy8gU2VuZCBjb2lucyB0byBhIGRlc3RpbmF0aW9uIGFkZHJlc3MgZnJvbSB0aGlzIHdhbGxldCB1c2luZyB0aGUgdXNlciBrZXkuXG4vLyAxLiBHZXRzIHRoZSB1c2VyIGtleWNoYWluIGJ5IGNoZWNraW5nIHRoZSB3YWxsZXQgZm9yIGEga2V5IHdoaWNoIGhhcyBhbiBlbmNyeXB0ZWQgeHByaXZcbi8vIDIuIERlY3J5cHRzIHVzZXIga2V5XG4vLyAzLiBDcmVhdGVzIHRoZSB0cmFuc2FjdGlvbiB3aXRoIGRlZmF1bHQgZmVlXG4vLyA0LiBTaWducyB0cmFuc2FjdGlvbiB3aXRoIGRlY3J5cHRlZCB1c2VyIGtleVxuLy8gMy4gU2VuZHMgdGhlIHRyYW5zYWN0aW9uIHRvIEJpdEdvXG4vL1xuLy8gUGFyYW1ldGVyczpcbi8vICAgYWRkcmVzcyAtIHRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzXG4vLyAgIGFtb3VudCAtIHRoZSBhbW91bnQgaW4gc2F0b3NoaXMgdG8gYmUgc2VudFxuLy8gICBtZXNzYWdlIC0gb3B0aW9uYWwgbWVzc2FnZSB0byBhdHRhY2ggdG8gdHJhbnNhY3Rpb25cbi8vICAgd2FsbGV0UGFzc3BocmFzZSAtIHRoZSBwYXNzcGhyYXNlIHRvIGJlIHVzZWQgdG8gZGVjcnlwdCB0aGUgdXNlciBrZXkgb24gdGhpcyB3YWxsZXRcbi8vICAgeHBydiAtIHRoZSBwcml2YXRlIGtleSBpbiBzdHJpbmcgZm9ybSwgaWYgd2FsbGV0UGFzc3BocmFzZSBpcyBub3QgYXZhaWxhYmxlXG4vLyAgIChTZWUgdHJhbnNhY3Rpb25CdWlsZGVyLmNyZWF0ZVRyYW5zYWN0aW9uIGZvciBvdGhlciBwYXNzdGhyb3VnaCBwYXJhbXMpXG4vLyBSZXR1cm5zOlxuLy9cbldhbGxldC5wcm90b3R5cGUuc2VuZENvaW5zID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnYWRkcmVzcyddLCBbJ21lc3NhZ2UnXSwgY2FsbGJhY2spO1xuXG4gIGlmICghXy5pc051bWJlcihwYXJhbXMuYW1vdW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgYW1vdW50IC0gbnVtYmVyIGV4cGVjdGVkJyk7XG4gIH1cblxuICBwYXJhbXMucmVjaXBpZW50cyA9IHt9O1xuICBwYXJhbXMucmVjaXBpZW50c1twYXJhbXMuYWRkcmVzc10gPSBwYXJhbXMuYW1vdW50O1xuXG4gIHJldHVybiB0aGlzLnNlbmRNYW55KHBhcmFtcylcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIHNlbmRNYW55XG4vLyBTZW5kIGNvaW5zIHRvIG11bHRpcGxlIGRlc3RpbmF0aW9uIGFkZHJlc3NlcyBmcm9tIHRoaXMgd2FsbGV0IHVzaW5nIHRoZSB1c2VyIGtleS5cbi8vIDEuIEdldHMgdGhlIHVzZXIga2V5Y2hhaW4gYnkgY2hlY2tpbmcgdGhlIHdhbGxldCBmb3IgYSBrZXkgd2hpY2ggaGFzIGFuIGVuY3J5cHRlZCB4cHJpdlxuLy8gMi4gRGVjcnlwdHMgdXNlciBrZXlcbi8vIDMuIENyZWF0ZXMgdGhlIHRyYW5zYWN0aW9uIHdpdGggZGVmYXVsdCBmZWVcbi8vIDQuIFNpZ25zIHRyYW5zYWN0aW9uIHdpdGggZGVjcnlwdGVkIHVzZXIga2V5XG4vLyAzLiBTZW5kcyB0aGUgdHJhbnNhY3Rpb24gdG8gQml0R29cbi8vXG4vLyBQYXJhbWV0ZXJzOlxuLy8gICByZWNpcGllbnRzIC0gYXJyYXkgb2YgeyBhZGRyZXNzOiBzdHJpbmcsIGFtb3VudDogbnVtYmVyLCB0cmF2ZWxJbmZvOiBvYmplY3QgfSB0byBzZW5kIHRvXG4vLyAgIHdhbGxldFBhc3NwaHJhc2UgLSB0aGUgcGFzc3BocmFzZSB0byBiZSB1c2VkIHRvIGRlY3J5cHQgdGhlIHVzZXIga2V5IG9uIHRoaXMgd2FsbGV0XG4vLyAgIHhwcnYgLSB0aGUgcHJpdmF0ZSBrZXkgaW4gc3RyaW5nIGZvcm0sIGlmIHdhbGxldFBhc3NwaHJhc2UgaXMgbm90IGF2YWlsYWJsZVxuLy8gICAoU2VlIHRyYW5zYWN0aW9uQnVpbGRlci5jcmVhdGVUcmFuc2FjdGlvbiBmb3Igb3RoZXIgcGFzc3Rocm91Z2ggcGFyYW1zKVxuLy8gUmV0dXJuczpcbi8vXG5XYWxsZXQucHJvdG90eXBlLnNlbmRNYW55ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ21lc3NhZ2UnLCAnb3RwJ10sIGNhbGxiYWNrKTtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcy5yZWNpcGllbnRzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIHJlY2lwaWVudHMgb2JqZWN0Jyk7XG4gIH1cblxuICBpZiAocGFyYW1zLmZlZSAmJiAhXy5pc051bWJlcihwYXJhbXMuZmVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgZmVlIC0gbnVtYmVyIGV4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAocGFyYW1zLmZlZVJhdGUgJiYgIV8uaXNOdW1iZXIocGFyYW1zLmZlZVJhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBmZWVSYXRlIC0gbnVtYmVyIGV4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAocGFyYW1zLmluc3RhbnQgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5pbnN0YW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgaW5zdGFudCAtIGJvb2xlYW4gZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGxldCBiaXRnb0ZlZTtcbiAgbGV0IHRyYXZlbEluZm9zO1xuICBsZXQgZmluYWxSZXN1bHQ7XG4gIGxldCB1bnNwZW50c1VzZWQ7XG5cbiAgY29uc3QgYWNjZXB0ZWRCdWlsZFBhcmFtcyA9IFtcbiAgICAnbnVtQmxvY2tzJywgJ2ZlZVJhdGUnLCAnbWluQ29uZmlybXMnLCAnZW5mb3JjZU1pbkNvbmZpcm1zRm9yQ2hhbmdlJyxcbiAgICAndGFyZ2V0V2FsbGV0VW5zcGVudHMnLCAnbWVzc2FnZScsICdtaW5WYWx1ZScsICdtYXhWYWx1ZScsXG4gICAgJ25vU3BsaXRDaGFuZ2UnLCAnY29tbWVudCdcbiAgXTtcbiAgY29uc3QgcHJlc2VydmVkQnVpbGRQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBhY2NlcHRlZEJ1aWxkUGFyYW1zKTtcblxuICAvLyBHZXQgdGhlIHVzZXIga2V5Y2hhaW5cbiAgY29uc3QgcmV0UHJvbWlzZSA9IHRoaXMuY3JlYXRlQW5kU2lnblRyYW5zYWN0aW9uKHBhcmFtcylcbiAgLnRoZW4oZnVuY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAvLyBTZW5kIHRoZSB0cmFuc2FjdGlvblxuICAgIGJpdGdvRmVlID0gdHJhbnNhY3Rpb24uYml0Z29GZWU7XG4gICAgdHJhdmVsSW5mb3MgPSB0cmFuc2FjdGlvbi50cmF2ZWxJbmZvcztcbiAgICB1bnNwZW50c1VzZWQgPSB0cmFuc2FjdGlvbi51bnNwZW50cztcbiAgICByZXR1cm4gc2VsZi5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgdHg6IHRyYW5zYWN0aW9uLnR4LFxuICAgICAgbWVzc2FnZTogcGFyYW1zLm1lc3NhZ2UsXG4gICAgICBzZXF1ZW5jZUlkOiBwYXJhbXMuc2VxdWVuY2VJZCxcbiAgICAgIGluc3RhbnQ6IHBhcmFtcy5pbnN0YW50LFxuICAgICAgb3RwOiBwYXJhbXMub3RwLFxuICAgICAgLy8gVGhlIGJlbG93IHBhcmFtcyBhcmUgZm9yIGxvZ2dpbmcgb25seSwgYW5kIGRvIG5vdCBpbXBhY3QgdGhlIEFQSSBjYWxsXG4gICAgICBlc3RpbWF0ZWRTaXplOiB0cmFuc2FjdGlvbi5lc3RpbWF0ZWRTaXplLFxuICAgICAgYnVpbGRQYXJhbXM6IHByZXNlcnZlZEJ1aWxkUGFyYW1zXG4gICAgfSk7XG4gIH0pXG4gIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIGNvbnN0IHR4ID0gYml0Y29pbi5UcmFuc2FjdGlvbi5mcm9tSGV4KHJlc3VsdC50eCk7XG4gICAgY29uc3QgaW5wdXRzU3VtID0gXy5zdW1CeSh1bnNwZW50c1VzZWQsICd2YWx1ZScpO1xuICAgIGNvbnN0IG91dHB1dHNTdW0gPSBfLnN1bUJ5KHR4Lm91dHMsICd2YWx1ZScpO1xuICAgIGNvbnN0IGZlZVVzZWQgPSBpbnB1dHNTdW0gLSBvdXRwdXRzU3VtO1xuICAgIGlmIChpc05hTihmZWVVc2VkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZlZVVzZWQnKTtcbiAgICB9XG4gICAgcmVzdWx0LmZlZSA9IGZlZVVzZWQsXG4gICAgcmVzdWx0LmZlZVJhdGUgPSBmZWVVc2VkICogMTAwMCAvIHR4LnZpcnR1YWxTaXplKCk7XG4gICAgcmVzdWx0LnRyYXZlbEluZm9zID0gdHJhdmVsSW5mb3M7XG4gICAgaWYgKGJpdGdvRmVlKSB7XG4gICAgICByZXN1bHQuYml0Z29GZWUgPSBiaXRnb0ZlZTtcbiAgICB9XG4gICAgZmluYWxSZXN1bHQgPSByZXN1bHQ7XG5cbiAgICAvLyBIYW5kbGUgc2VuZGluZyB0cmF2ZWwgaW5mb3MgaWYgdGhleSBleGlzdCwgYnV0IG1ha2Ugc3VyZSB3ZSBuZXZlciBmYWlsIGhlcmUuXG4gICAgLy8gRXJyb3Igb3IgcmVzdWx0ICh3aXRoIHBvc3NpYmxlIHN1Yi1lcnJvcnMpIHdpbGwgYmUgcHJvdmlkZWQgaW4gdHJhdmVsUmVzdWx0XG4gICAgaWYgKHRyYXZlbEluZm9zICYmIHRyYXZlbEluZm9zLmxlbmd0aCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHNlbGYucG9sbEZvclRyYW5zYWN0aW9uKHsgaWQ6IHJlc3VsdC5oYXNoIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmJpdGdvLnRyYXZlbFJ1bGUoKS5zZW5kTWFueShyZXN1bHQpO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICBmaW5hbFJlc3VsdC50cmF2ZWxSZXN1bHQgPSByZXM7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAvLyBjYXRjaCBhc3luYyBlcnJvcnNcbiAgICAgICAgICBmaW5hbFJlc3VsdC50cmF2ZWxSZXN1bHQgPSB7IGVycm9yOiBlcnIubWVzc2FnZSB9O1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBjYXRjaCBzeW5jaHJvbm91cyBlcnJvcnNcbiAgICAgICAgZmluYWxSZXN1bHQudHJhdmVsUmVzdWx0ID0geyBlcnJvcjogZXJyLm1lc3NhZ2UgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmaW5hbFJlc3VsdDtcbiAgfSk7XG4gIHJldHVybiBCbHVlYmlyZC5yZXNvbHZlKHJldFByb21pc2UpLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBBY2NlbGVyYXRlIGEgc3R1Y2sgdHJhbnNhY3Rpb24gdXNpbmcgQ2hpbGQtUGF5cy1Gb3ItUGFyZW50IChDUEZQKS5cbiAqXG4gKiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHN0dWNrIHRyYW5zYWN0aW9ucyB3aGljaCBoYXZlIG5vIHVuY29uZmlybWVkIGlucHV0cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gSW5wdXQgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy50cmFuc2FjdGlvbklEIC0gSUQgb2YgdHJhbnNhY3Rpb24gdG8gYWNjZWxlcmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHBhcmFtcy5mZWVSYXRlIC0gTmV3IGVmZmVjdGl2ZSBmZWUgcmF0ZSBmb3Igc3R1Y2sgdHJhbnNhY3Rpb24gKHNhdCBwZXIgMTAwMCBieXRlcylcbiAqIEBwYXJhbSB7TnVtYmVyfSBwYXJhbXMubWF4QWRkaXRpb25hbFVuc3BlbnRzIC0gTWF4aW11bSBhZGRpdGlvbmFsIHVuc3BlbnRzIHRvIHVzZSBmcm9tIHRoZSB3YWxsZXQgdG8gY292ZXIgYW55IGNoaWxkIGZlZXMgdGhhdCB0aGUgcGFyZW50IHVuc3BlbnQgb3V0cHV0IGNhbm5vdCBjb3Zlci4gRGVmYXVsdHMgdG8gMTAwLlxuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIC0gVGhlIHBhc3NwaHJhc2Ugd2hpY2ggc2hvdWxkIGJlIHVzZWQgdG8gZGVjcnlwdCB0aGUgd2FsbGV0IHByaXZhdGUga2V5LiBPbmUgb2YgZWl0aGVyIHdhbGxldFBhc3NwaHJhc2Ugb3IgeHBydiBpcyByZXF1aXJlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMueHBydiAtIFRoZSBwcml2YXRlIGtleSBmb3IgdGhlIHdhbGxldC4gT25lIG9mIGVpdGhlciB3YWxsZXRQYXNzcGhyYXNlIG9yIHhwcnYgaXMgcmVxdWlyZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMgUmVzdWx0IG9mIHNlbmRUcmFuc2FjdGlvbigpIG9uIHRoZSBjaGlsZCB0cmFuc2FjdGlvblxuICovXG5XYWxsZXQucHJvdG90eXBlLmFjY2VsZXJhdGVUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIGFjY2VsZXJhdGVUcmFuc2FjdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZXN0aW1hdGUgYSB0cmFuc2FjdGlvbnMgc2l6ZSBpbiB2aXJ0dWFsIGJ5dGVzLlxuICAgKiBBY3R1YWwgdHJhbnNhY3Rpb25zIG1heSBiZSBzbGlnaHRseSBmZXdlciB2aXJ0dWFsIGJ5dGVzLCBkdWUgdG9cbiAgICogdGhlIGZhY3QgdGhhdCB2YWxpZCBFQ1NEQSBzaWduYXR1cmVzIGhhdmUgYSB2YXJpYWJsZSBsZW5ndGhcbiAgICogYmV0d2VlbiA4IGFuZCA3MyB2aXJ0dWFsIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXRzLnNlZ3dpdCBUaGUgbnVtYmVyIG9mIHNlZ3dpdCBpbnB1dHMgdG8gdGhlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBpbnB1dHMuUDJTSCBUaGUgbnVtYmVyIG9mIFAyU0ggaW5wdXRzIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gaW5wdXRzLlAyUEtIIFRoZSBudW1iZXIgb2YgUDJQS0ggaW5wdXRzIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgY29uc3QgZXN0aW1hdGVUeFZTaXplID0gKGlucHV0cykgPT4ge1xuICAgIGNvbnN0IHNlZ3dpdCA9IGlucHV0cy5zZWd3aXQgfHwgMDtcbiAgICBjb25zdCBQMlNIID0gaW5wdXRzLlAyU0ggfHwgMDtcbiAgICBjb25zdCBQMlBLSCA9IGlucHV0cy5QMlBLSCB8fCAwO1xuXG4gICAgY29uc3QgY2hpbGRGZWVJbmZvID0gVHJhbnNhY3Rpb25CdWlsZGVyLmNhbGN1bGF0ZU1pbmVyRmVlSW5mbyh7XG4gICAgICBuUDJzaElucHV0czogUDJTSCxcbiAgICAgIG5QMnBraElucHV0czogUDJQS0gsXG4gICAgICBuUDJzaFAyd3NoSW5wdXRzOiBzZWd3aXQsXG4gICAgICBuT3V0cHV0czogMSxcbiAgICAgIGZlZVJhdGU6IDFcbiAgICB9KTtcblxuICAgIHJldHVybiBjaGlsZEZlZUluZm8uc2l6ZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2Ygc2F0b3NoaXMgdGhhdCBzaG91bGQgYmUgcGFpZCBpbiBmZWVzIGJ5IHRoZSBjaGlsZCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXRzIElucHV0cyB0byB0aGUgY2hpbGQgdHJhbnNhY3Rpb24gd2hpY2ggYXJlIHBhc3NlZCB0byBlc3RpbWF0ZVR4VlNpemVcbiAgICogQHBhcmFtIHBhcmVudEZlZSBUaGUgbnVtYmVyIG9mIHNhdG9zaGlzIHRoZSBwYXJlbnQgdHggb3JpZ2luYWxseSBwYWlkIGluIGZlZXNcbiAgICogQHBhcmFtIHBhcmVudFZTaXplIFRoZSBudW1iZXIgb2YgdmlydHVhbCBieXRlcyBpbiB0aGUgcGFyZW50IHR4XG4gICAqIEBwYXJhbSBmZWVSYXRlIFRoZSBuZXcgZmVlIHJhdGUgd2hpY2ggc2hvdWxkIGJlIHBhaWQgYnkgdGhlIGNvbWJpbmVkIENQRlAgdHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBzYXRvc2hpcyB0aGUgY2hpbGQgdHggc2hvdWxkIHBheSBpbiBmZWVzXG4gICAqL1xuICBjb25zdCBlc3RpbWF0ZUNoaWxkRmVlID0gKHsgaW5wdXRzLCBwYXJlbnRGZWUsIHBhcmVudFZTaXplLCBmZWVSYXRlIH0pID0+IHtcbiAgICAvLyBjYWxjdWxhdGUgaG93IG11Y2ggbW9yZSB3ZSAqc2hvdWxkKiBoYXZlIHBhaWQgaW4gcGFyZW50IGZlZXMsXG4gICAgLy8gaGFkIHRoZSBwYXJlbnQgYmVlbiBvcmlnaW5hbGx5IHNlbnQgd2l0aCB0aGUgbmV3IGZlZSByYXRlXG4gICAgY29uc3QgYWRkaXRpb25hbFBhcmVudEZlZSA9IF8uY2VpbChwYXJlbnRWU2l6ZSAqIGZlZVJhdGUgLyAxMDAwKSAtIHBhcmVudEZlZTtcblxuICAgIC8vIGNhbGN1bGF0ZSBob3cgbXVjaCB3ZSB3b3VsZCBwYXkgaW4gZmVlcyBmb3IgdGhlIGNoaWxkLFxuICAgIC8vIGlmIGl0IHdlcmUgb25seSBwYXlpbmcgZm9yIGl0c2VsZiBhdCB0aGUgbmV3IGZlZSByYXRlXG4gICAgY29uc3QgY2hpbGRGZWUgPSBlc3RpbWF0ZVR4VlNpemUoaW5wdXRzKSAqIGZlZVJhdGUgLyAxMDAwO1xuXG4gICAgcmV0dXJuIF8uY2VpbChjaGlsZEZlZSArIGFkZGl0aW9uYWxQYXJlbnRGZWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZmluZCBhZGRpdGlvbmFsIHVuc3BlbnRzIHRvIHVzZSB0byBwYXkgdGhlIGNoaWxkIHR4IGZlZXMuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIHRoZSBwYXJlbnQgdHggb3V0cHV0IGlzIG5vdCBzdWZmaWNpZW50IHRvXG4gICAqIGNvdmVyIHRoZSB0b3RhbCBmZWVzIHdoaWNoIHNob3VsZCBiZSBwYWlkIGJ5IHRoZSBjaGlsZCB0eC5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0cyBJbnB1dHMgdG8gdGhlIGNoaWxkIHRyYW5zYWN0aW9uIHdoaWNoIGFyZSBwYXNzZWQgdG8gZXN0aW1hdGVUeFZTaXplXG4gICAqIEBwYXJhbSBwYXJlbnRPdXRwdXRWYWx1ZSBUaGUgdmFsdWUgb2YgdGhlIG91dHB1dCBmcm9tIHRoZSBwYXJlbnQgdHggd2hpY2ggd2UgYXJlIHVzaW5nIGFzIGFuIGlucHV0IHRvIHRoZSBjaGlsZCB0eFxuICAgKiBAcGFyYW0gcGFyZW50RmVlIFRoZSBudW1iZXIgb2Ygc2F0b3NoaXMgdGhlIHBhcmVudCB0eCBvcmlnaW5hbGx5IHBhaWQgaW4gZmVlc1xuICAgKiBAcGFyYW0gcGFyZW50VlNpemUgVGhlIG51bWJlciBvZiB2aXJ0dWFsIGJ5dGVzIGluIHRoZSBwYXJlbnQgdHhcbiAgICogQHBhcmFtIG1heFVuc3BlbnRzIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhZGRpdGlvbmFsIHVuc3BlbnRzIHdoaWNoIHNob3VsZCBiZSB1c2VkIHRvIGNvdmVyIHRoZSByZW1haW5pbmcgY2hpbGQgZmVlc1xuICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB0aGUgYWRkaXRpb25hbCB1bnNwZW50cyB0byB1c2UsIHRoZSB1cGRhdGVkIG51bWJlciBvZiBzYXRvc2hpcyB3aGljaCBzaG91bGQgYmUgcGFpZCBieVxuICAgKiAgICAgICAgICB0aGUgY2hpbGQgdHgsIGFuZCB0aGUgdXBkYXRlZCBpbnB1dHMgZm9yIHRoZSBjaGlsZCB0eC5cbiAgICovXG4gIGNvbnN0IGZpbmRBZGRpdGlvbmFsVW5zcGVudHMgPSAoeyBpbnB1dHMsIHBhcmVudE91dHB1dFZhbHVlLCBwYXJlbnRGZWUsIHBhcmVudFZTaXplLCBtYXhVbnNwZW50cyB9KSA9PiB7XG4gICAgcmV0dXJuIGNvKGZ1bmN0aW9uICpjb0ZpbmRBZGRpdGlvbmFsVW5zcGVudHMoKSB7XG5cbiAgICAgIGNvbnN0IGFkZGl0aW9uYWxVbnNwZW50czogYW55W10gPSBbXTtcblxuICAgICAgLy8gYXNrIHRoZSBzZXJ2ZXIgZm9yIGVub3VnaCB1bnNwZW50cyB0byBjb3ZlciB0aGUgY2hpbGQgZmVlLCBhc3N1bWluZ1xuICAgICAgLy8gdGhhdCBpdCBjYW4gYmUgZG9uZSB3aXRob3V0IGFkZGl0aW9uYWwgdW5zcGVudHMgKHdoaWNoIGlzIG5vdCBwb3NzaWJsZSxcbiAgICAgIC8vIHNpbmNlIGlmIHRoYXQgd2VyZSB0aGUgY2FzZSwgZmluZEFkZGl0aW9uYWxVbnNwZW50cyB3b3VsZCBub3QgaGF2ZSBiZWVuXG4gICAgICAvLyBjYWxsZWQgaW4gdGhlIGZpcnN0IHBsYWNlLiBUaGlzIHdpbGwgYmUgY29ycmVjdGVkIGJlZm9yZSByZXR1cm5pbmcpXG4gICAgICBsZXQgY3VycmVudENoaWxkRmVlRXN0aW1hdGUgPSBlc3RpbWF0ZUNoaWxkRmVlKHsgaW5wdXRzLCBwYXJlbnRGZWUsIHBhcmVudFZTaXplLCBmZWVSYXRlOiBwYXJhbXMuZmVlUmF0ZSB9KTtcbiAgICAgIGxldCB1bmNvdmVyZWRDaGlsZEZlZSA9IGN1cnJlbnRDaGlsZEZlZUVzdGltYXRlIC0gcGFyZW50T3V0cHV0VmFsdWU7XG5cbiAgICAgIHdoaWxlICh1bmNvdmVyZWRDaGlsZEZlZSA+IDAgJiYgYWRkaXRpb25hbFVuc3BlbnRzLmxlbmd0aCA8IG1heFVuc3BlbnRzKSB7XG4gICAgICAgIC8vIHRyeSB0byBnZXQgZW5vdWdoIHVuc3BlbnRzIHRvIGNvdmVyIHRoZSByZXN0IG9mIHRoZSBjaGlsZCBmZWVcbiAgICAgICAgY29uc3QgdW5zcGVudHMgPSB5aWVsZCB0aGlzLnVuc3BlbnRzKHtcbiAgICAgICAgICBtaW5Db25maXJtczogMSxcbiAgICAgICAgICB0YXJnZXQ6IHVuY292ZXJlZENoaWxkRmVlLFxuICAgICAgICAgIGxpbWl0OiBtYXhVbnNwZW50cyAtIGFkZGl0aW9uYWxVbnNwZW50cy5sZW5ndGhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHVuc3BlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vIG5vIG1vcmUgdW5zcGVudHMgYXJlIGF2YWlsYWJsZVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGFkZGl0aW9uYWxVbnNwZW50VmFsdWUgPSAwO1xuXG4gICAgICAgIC8vIGNvbnN1bWUgYWxsIHVuc3BlbnRzIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIsIGV2ZW4gaWYgd2UgZG9uJ3QgbmVlZFxuICAgICAgICAvLyBhbGwgb2YgdGhlbSB0byBjb3ZlciB0aGUgY2hpbGQgZmVlLiBUaGlzIGlzIGJlY2F1c2UgdGhlIHNlcnZlciB3aWxsXG4gICAgICAgIC8vIHJldHVybiBlbm91Z2ggdW5zcGVudCB2YWx1ZSB0byBlbnN1cmUgdGhhdCB0aGUgbWluaW11bSBjaGFuZ2UgYW1vdW50XG4gICAgICAgIC8vIGlzIGFjaGlldmVkIGZvciB0aGUgY2hpbGQgdHgsIGFuZCB3ZSBjYW4ndCBsZWF2ZSBvdXQgdGhvc2UgdW5zcGVudHNcbiAgICAgICAgLy8gb3IgZWxzZSB0aGUgbWluaW11bSBjaGFuZ2UgYW1vdW50IGNvbnN0cmFpbnQgY291bGQgYmUgdmlvbGF0ZWRcbiAgICAgICAgXy5mb3JFYWNoKHVuc3BlbnRzLCAodW5zcGVudCkgPT4ge1xuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgY2hpbGQgdHggaW5wdXRzXG4gICAgICAgICAgY29uc3QgdW5zcGVudENoYWluID0gZ2V0Q2hhaW4odW5zcGVudCk7XG4gICAgICAgICAgaWYgKHVuc3BlbnRDaGFpbiA9PT0gQ29kZXMucDJzaFAyd3NoLmV4dGVybmFsIHx8IHVuc3BlbnRDaGFpbiA9PT0gQ29kZXMucDJzaFAyd3NoLmludGVybmFsKSB7XG4gICAgICAgICAgICBpbnB1dHMuc2Vnd2l0Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0cy5QMlNIKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWRkaXRpb25hbFVuc3BlbnRzLnB1c2godW5zcGVudCk7XG4gICAgICAgICAgYWRkaXRpb25hbFVuc3BlbnRWYWx1ZSArPSB1bnNwZW50LnZhbHVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBjdXJyZW50Q2hpbGRGZWVFc3RpbWF0ZSA9IGVzdGltYXRlQ2hpbGRGZWUoeyBpbnB1dHMsIHBhcmVudEZlZSwgcGFyZW50VlNpemUsIGZlZVJhdGU6IHBhcmFtcy5mZWVSYXRlIH0pO1xuICAgICAgICB1bmNvdmVyZWRDaGlsZEZlZSA9IGN1cnJlbnRDaGlsZEZlZUVzdGltYXRlIC0gcGFyZW50T3V0cHV0VmFsdWUgLSBhZGRpdGlvbmFsVW5zcGVudFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodW5jb3ZlcmVkQ2hpbGRGZWUgPiAwKSB7XG4gICAgICAgIC8vIFVuYWJsZSB0byBmaW5kIGVub3VnaCB1bnNwZW50cyB0byBjb3ZlciB0aGUgY2hpbGQgZmVlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IGNvbmZpcm1lZCB1bnNwZW50cyBhdmFpbGFibGUgdG8gY292ZXIgdGhlIGNoaWxkIGZlZWApO1xuICAgICAgfVxuXG4gICAgICAvLyBmb3VuZCBlbm91Z2ggdW5zcGVudHNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZGl0aW9uYWw6IGFkZGl0aW9uYWxVbnNwZW50cyxcbiAgICAgICAgbmV3Q2hpbGRGZWU6IGN1cnJlbnRDaGlsZEZlZUVzdGltYXRlLFxuICAgICAgICBuZXdJbnB1dHM6IGlucHV0c1xuICAgICAgfTtcbiAgICB9KS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGEgZnVsbCBjb3B5IChpbmNsdWRpbmcgd2l0bmVzcyBkYXRhKSBvZiBhbiBhcmJpdHJhcnkgdHggdXNpbmcgb25seSB0aGUgdHggaWQuXG4gICAqXG4gICAqIFdlIGhhdmUgdG8gdXNlIGFuIGV4dGVybmFsIHNlcnZpY2UgZm9yIHRoaXMgKGN1cnJlbnRseSBibG9ja3N0cmVhbS5pbmZvKSwgc2luY2VcbiAgICogdGhlIHYxIGluZGV4ZXIgc2VydmljZSAoYmFzZWQgb24gYml0Y29pbmopIGRvZXMgbm90IGhhdmUgc2Vnd2l0IHN1cHBvcnQgYW5kXG4gICAqIGRvZXMgbm90IHJldHVybiBhbnkgc2Vnd2l0IHJlbGF0ZWQgZmllbGRzIGluIHRoZSB0eCBoZXguXG4gICAqXG4gICAqIEBwYXJhbSBwYXJlbnRUeElkIFRoZSBJRCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gZ2V0IHRoZSBmdWxsIGhleCBvZlxuICAgKiBAcmV0dXJucyB7Qmx1ZWJpcmQ8YW55Pn0gVGhlIGZ1bGwgaGV4IGZvciB0aGUgc3BlY2lmaWVkIHRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBnZXRQYXJlbnRUeEhleCh7IHBhcmVudFR4SWQgfTogeyBwYXJlbnRUeElkOiBzdHJpbmcgfSk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgZXhwbG9yZXJCYXNlVXJsID0gY29tbW9uLkVudmlyb25tZW50c1tzZWxmLmJpdGdvLmdldEVudigpXS5idGNFeHBsb3JlckJhc2VVcmw7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdC5nZXQoYCR7ZXhwbG9yZXJCYXNlVXJsfS90eC8ke3BhcmVudFR4SWR9L2hleGApO1xuXG4gICAgaWYgKCFyZXN1bHQudGV4dCB8fCAhLyhbYS1mMC05XXsyfSkrLy50ZXN0KHJlc3VsdC50ZXh0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWQgbm90IHN1Y2Nlc3NmdWxseSByZWNlaXZlIHBhcmVudCB0eCBoZXguIFJlY2VpdmVkICcke18udHJ1bmNhdGUocmVzdWx0LnRleHQsIHsgbGVuZ3RoOiAxMDAgfSl9JyBpbnN0ZWFkLmApO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQudGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBjaGFpbiBmcm9tIGFuIHVuc3BlbnQgb3IgdHggb3V0cHV0LlxuICAgKlxuICAgKiBAcGFyYW0gb3V0cHV0T3JVbnNwZW50IFRoZSBvdXRwdXQgb3IgdW5zcGVudCB3aG9zZSBjaGFpbiBzaG91bGQgYmUgZGV0ZXJtaW5lZFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY2hhaW4gZm9yIHRoZSBnaXZlbiBvdXRwdXQgb3IgdW5zcGVudFxuICAgKi9cbiAgY29uc3QgZ2V0Q2hhaW4gPSAob3V0cHV0T3JVbnNwZW50KSA9PiB7XG4gICAgaWYgKG91dHB1dE9yVW5zcGVudC5jaGFpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gb3V0cHV0T3JVbnNwZW50LmNoYWluO1xuICAgIH1cblxuICAgIGlmIChvdXRwdXRPclVuc3BlbnQuY2hhaW5QYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfLnRvTnVtYmVyKG91dHB1dE9yVW5zcGVudC5jaGFpblBhdGguc3BsaXQoJy8nKVsxXSk7XG4gICAgfVxuXG4gICAgLy8gbm8gd2F5IHRvIHRlbGwgdGhlIGNoYWluLCBsZXQncyBqdXN0IGJsb3cgdXAgbm93IGluc3RlYWRcbiAgICAvLyBvZiBibG93aW5nIHVwIGxhdGVyIHdoZW4gdGhlIHVuZGVmaW5lZCByZXR1cm4gdmFsdWUgaXMgdXNlZC5cbiAgICAvLyBOb3RlOiBmb3IgdW5zcGVudHMgdGhlIGZpZWxkIHRvIHVzZSBpcyAnYWRkcmVzcycsIGJ1dCBmb3Igb3V0cHV0c1xuICAgIC8vIHRoZSBmaWVsZCB0byB1c2UgaXMgJ2FjY291bnQnXG4gICAgdGhyb3cgRXJyb3IoYENvdWxkIG5vdCBnZXQgY2hhaW4gZm9yIG91dHB1dCBvbiBhY2NvdW50ICR7b3V0cHV0T3JVbnNwZW50LmFjY291bnQgfHwgb3V0cHV0T3JVbnNwZW50LmFkZHJlc3N9YCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIGFjdHVhbCB2YWx1ZSBjb250cmlidXRpb24gYW4gb3V0cHV0IG9yIHVuc3BlbnQgd2lsbFxuICAgKiBjb250cmlidXRlIHRvIGEgdHJhbnNhY3Rpb24sIHdlcmUgaXQgdG8gYmUgdXNlZC4gRWFjaCB0eXBlIG9mIG91dHB1dCBvciB1bnNwZW50XG4gICAqIHdpbGwgaGF2ZSBhIGRpZmZlcmVudCB2YWx1ZSBjb250cmlidXRpb24gc2luY2UgZWFjaCB0eXBlIGhhcyBhIGRpZmZlcmVudCBudW1iZXJcbiAgICogb2YgdmlydHVhbCBieXRlcywgYW5kIHRodXMgd2lsbCBjYXVzZSBhIGRpZmZlcmVudCBmZWUgdG8gYmUgcGFpZC5cbiAgICpcbiAgICogQHBhcmFtIG91dHB1dE9yVW5zcGVudCBPdXRwdXQgb3IgdW5zcGVudCB3aG9zZSBlZmZlY3RpdmUgdmFsdWUgc2hvdWxkIGJlIGRldGVybWluZWRcbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIGFjdHVhbCBudW1iZXIgb2Ygc2F0b3NoaXMgdGhhdCB0aGlzIHVuc3BlbnQgb3Igb3V0cHV0XG4gICAqICAgICAgICAgICAgICAgICAgIHdvdWxkIGNvbnRyaWJ1dGUgdG8gYSB0cmFuc2FjdGlvbiwgd2VyZSBpdCB0byBiZSB1c2VkLlxuICAgKi9cbiAgY29uc3QgZWZmZWN0aXZlVmFsdWUgPSAob3V0cHV0T3JVbnNwZW50KSA9PiB7XG4gICAgY29uc3QgY2hhaW4gPSBnZXRDaGFpbihvdXRwdXRPclVuc3BlbnQpO1xuICAgIGlmIChjaGFpbiA9PT0gQ29kZXMucDJzaFAyd3NoLmV4dGVybmFsIHx8IGNoYWluID09PSBDb2Rlcy5wMnNoUDJ3c2guaW50ZXJuYWwpIHtcbiAgICAgIC8vIFZpcnR1YWxTaXplcy50eFAyc2hQMndzaElucHV0U2l6ZSBpcyBpbiBieXRlcywgc28gd2UgbmVlZCB0byBjb252ZXJ0IHRvIGtCXG4gICAgICByZXR1cm4gb3V0cHV0T3JVbnNwZW50LnZhbHVlIC0gKFZpcnR1YWxTaXplcy50eFAyc2hQMndzaElucHV0U2l6ZSAqIHBhcmFtcy5mZWVSYXRlIC8gMTAwMCk7XG4gICAgfVxuICAgIC8vIFZpcnR1YWxTaXplcy50eFAyc2hJbnB1dFNpemUgaXMgaW4gYnl0ZXMsIHNvIHdlIG5lZWQgdG8gY29udmVydCB0byBrQlxuICAgIHJldHVybiBvdXRwdXRPclVuc3BlbnQudmFsdWUgLSAoVmlydHVhbFNpemVzLnR4UDJzaElucHV0U2l6ZSAqIHBhcmFtcy5mZWVSYXRlIC8gMTAwMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvcm91dGluZSB3aGljaCBhY3R1YWxseSBpbXBsZW1lbnRzIHRoZSBhY2NlbGVyYXRlVHJhbnNhY3Rpb24gYWxnb3JpdGhtXG4gICAqXG4gICAqIERlc2NyaWJlZCBhdCBhIGhpZ2ggbGV2ZWwsIHRoZSBhbGdvcml0aG0gaXMgYXMgZm9sbG93czpcbiAgICogMSkgRmluZCBhcHByb3ByaWF0ZSBvdXRwdXQgZnJvbSBwYXJlbnQgdHJhbnNhY3Rpb24gdG8gdXNlIGFzIGNoaWxkIHRyYW5zYWN0aW9uIGlucHV0XG4gICAqIDIpIEZpbmQgdW5zcGVudCBjb3JyZXNwb25kaW5nIHRvIHBhcmVudCB0cmFuc2FjdGlvbiBvdXRwdXQuIElmIG5vdCBmb3VuZCwgcmV0dXJuIHRvIHN0ZXAgMS5cbiAgICogMykgRGV0ZXJtaW5lIGlmIHBhcmVudCB0cmFuc2FjdGlvbiB1bnNwZW50IGNhbiBjb3ZlciBlbnRpcmUgY2hpbGQgZmVlLCBwbHVzIG1pbmltdW0gY2hhbmdlXG4gICAqIDQpIElmIHllcywgZ28gdG8gc3RlcCA2XG4gICAqIDUpIE90aGVyd2lzZSwgZmluZCBhZGRpdGlvbmFsIHVuc3BlbnRzIGZyb20gdGhlIHdhbGxldCB0byB1c2UgdG8gY292ZXIgdGhlIHJlbWFpbmluZyBjaGlsZCBmZWVcbiAgICogNikgQ3JlYXRlIGFuZCBzaWduIHRoZSBjaGlsZCB0cmFuc2FjdGlvbiwgdXNpbmcgdGhlIHBhcmVudCB0cmFuc2FjdGlvbiBvdXRwdXRcbiAgICogICAgKGFuZCwgaWYgbmVjZXNzYXJ5LCBhZGRpdGlvbmFsIHdhbGxldCB1bnNwZW50cykgYXMgaW5wdXRzXG4gICAqIDcpIEJyb2FkY2FzdCB0aGUgbmV3IGNoaWxkIHRyYW5zYWN0aW9uXG4gICAqL1xuICByZXR1cm4gY28oZnVuY3Rpb24gKmNvQWNjZWxlcmF0ZVRyYW5zYWN0aW9uKCkge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3RyYW5zYWN0aW9uSUQnXSwgW10sIGNhbGxiYWNrKTtcblxuICAgIC8vIHZhbGlkYXRlIGZlZSByYXRlXG4gICAgaWYgKHBhcmFtcy5mZWVSYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwYXJhbWV0ZXI6IGZlZVJhdGUnKTtcbiAgICB9XG4gICAgaWYgKCFfLmlzRmluaXRlKHBhcmFtcy5mZWVSYXRlKSB8fCBwYXJhbXMuZmVlUmF0ZSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGluZyBwb3NpdGl2ZSBmaW5pdGUgbnVtYmVyIGZvciBwYXJhbWV0ZXI6IGZlZVJhdGUnKTtcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBtYXhVbnNwZW50c1xuICAgIGlmIChwYXJhbXMubWF4QWRkaXRpb25hbFVuc3BlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGJ5IGRlZmF1bHQsIHVzZSBhdCBtb3N0IDEwMCBhZGRpdGlvbmFsIHVuc3BlbnRzIChub3QgaW5jbHVkaW5nIHRoZSB1bnNwZW50IG91dHB1dCBmcm9tIHRoZSBwYXJlbnQgdHgpXG4gICAgICBwYXJhbXMubWF4QWRkaXRpb25hbFVuc3BlbnRzID0gMTAwO1xuICAgIH1cblxuICAgIGlmICghXy5pc0ludGVnZXIocGFyYW1zLm1heEFkZGl0aW9uYWxVbnNwZW50cykgfHwgcGFyYW1zLm1heEFkZGl0aW9uYWxVbnNwZW50cyA8PSAwKSB7XG4gICAgICB0aHJvdyBFcnJvcignRXhwZWN0aW5nIHBvc2l0aXZlIGludGVnZXIgZm9yIHBhcmFtZXRlcjogbWF4QWRkaXRpb25hbFVuc3BlbnRzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50VHggPSB5aWVsZCB0aGlzLmdldFRyYW5zYWN0aW9uKHsgaWQ6IHBhcmFtcy50cmFuc2FjdGlvbklEIH0pO1xuICAgIGlmIChwYXJlbnRUeC5jb25maXJtYXRpb25zID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiAke3BhcmFtcy50cmFuc2FjdGlvbklEfSBpcyBhbHJlYWR5IGNvbmZpcm1lZCBhbmQgY2Fubm90IGJlIGFjY2VsZXJhdGVkYCk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBvdXRwdXRzIGZyb20gdGhlIHBhcmVudCB0eCB3aGljaCBhcmUgdG8gb3VyIHdhbGxldFxuICAgIGNvbnN0IHdhbGxldE91dHB1dHMgPSBfLmZpbHRlcihwYXJlbnRUeC5vdXRwdXRzLCAob3V0cHV0KSA9PiBvdXRwdXQuaXNNaW5lKTtcblxuICAgIGlmICh3YWxsZXRPdXRwdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiAke3BhcmFtcy50cmFuc2FjdGlvbklEfSBjb250YWlucyBubyBvdXRwdXRzIHRvIHRoaXMgd2FsbGV0LCBhbmQgdGh1cyBjYW5ub3QgYmUgYWNjZWxlcmF0ZWRgKTtcbiAgICB9XG5cbiAgICAvLyB1c2UgYW4gb3V0cHV0IGZyb20gdGhlIHBhcmVudCB3aXRoIGxhcmdlc3QgZWZmZWN0aXZlIHZhbHVlLFxuICAgIC8vIGJ1dCBjaGVjayB0byBtYWtlIHN1cmUgdGhlIG91dHB1dCBpcyBhY3R1YWxseSB1bnNwZW50LlxuICAgIC8vIEFuIG91dHB1dCBjb3VsZCBiZSBzcGVudCBhbHJlYWR5IGlmIHRoZSBvdXRwdXQgd2FzIHVzZWQgaW4gYVxuICAgIC8vIGNoaWxkIHR4IHdoaWNoIGl0c2VsZiBoYXMgYmVjb21lIHN0dWNrIGR1ZSB0byBsb3cgZmVlcyBhbmQgaXNcbiAgICAvLyBhbHNvIHVuY29uZmlybWVkLlxuICAgIGNvbnN0IHNvcnRlZE91dHB1dHMgPSBfLnNvcnRCeSh3YWxsZXRPdXRwdXRzLCBlZmZlY3RpdmVWYWx1ZSk7XG4gICAgbGV0IHBhcmVudFVuc3BlbnRUb1VzZTtcbiAgICBsZXQgb3V0cHV0VG9Vc2U7XG5cbiAgICB3aGlsZSAoc29ydGVkT3V0cHV0cy5sZW5ndGggPiAwICYmIHBhcmVudFVuc3BlbnRUb1VzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvdXRwdXRUb1VzZSA9IHNvcnRlZE91dHB1dHMucG9wKCk7XG5cbiAgICAgIC8vIGZpbmQgdGhlIHVuc3BlbnQgY29ycmVzcG9uZGluZyB0byB0aGlzIHBhcnRpY3VsYXIgb3V0cHV0XG4gICAgICAvLyBUT0RPOiBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gZ2V0IHRoaXMgdW5zcGVudD9cbiAgICAgIC8vIFRPRE86IFRoZSBiZXN0IHdlIGNhbiBkbyBoZXJlIGlzIHNldCBtaW5TaXplID0gbWF4U2l6ZSA9IG91dHB1dFRvVXNlLnZhbHVlXG4gICAgICBjb25zdCB1bnNwZW50c1Jlc3VsdCA9IHlpZWxkIHRoaXMudW5zcGVudHMoe1xuICAgICAgICBtaW5TaXplOiBvdXRwdXRUb1VzZS52YWx1ZSxcbiAgICAgICAgbWF4U2l6ZTogb3V0cHV0VG9Vc2UudmFsdWVcbiAgICAgIH0pO1xuXG4gICAgICBwYXJlbnRVbnNwZW50VG9Vc2UgPSBfLmZpbmQodW5zcGVudHNSZXN1bHQsICh1bnNwZW50KSA9PiB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB1bnNwZW50IGJlbG9uZ3MgdG8gdGhlIGdpdmVuIHR4aWRcbiAgICAgICAgaWYgKHVuc3BlbnQudHhfaGFzaCAhPT0gcGFyYW1zLnRyYW5zYWN0aW9uSUQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSBzdXJlIHVuc3BlbnQgaGFzIGNvcnJlY3Qgdl9vdXQgaW5kZXhcbiAgICAgICAgcmV0dXJuIHVuc3BlbnQudHhfb3V0cHV0X24gPT09IG91dHB1dFRvVXNlLnZvdXQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50VW5zcGVudFRvVXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgdW5zcGVudCBvdXRwdXQgZnJvbSBwYXJlbnQgdHggdG8gdXNlIGFzIGNoaWxkIGlucHV0YCk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBmdWxsIGhleCBmb3IgdGhlIHBhcmVudCB0eCBhbmQgZGVjb2RlIGl0IHRvIGdldCBpdHMgdnNpemVcbiAgICBjb25zdCBwYXJlbnRUeEhleCA9IHlpZWxkIGdldFBhcmVudFR4SGV4KHsgcGFyZW50VHhJZDogcGFyYW1zLnRyYW5zYWN0aW9uSUQgfSk7XG4gICAgY29uc3QgZGVjb2RlZFBhcmVudCA9IGJpdGNvaW4uVHJhbnNhY3Rpb24uZnJvbUhleChwYXJlbnRUeEhleCk7XG4gICAgY29uc3QgcGFyZW50VlNpemUgPSBkZWNvZGVkUGFyZW50LnZpcnR1YWxTaXplKCk7XG5cbiAgICAvLyBtYWtlIHN1cmUgaWQgZnJvbSBkZWNvZGVkIHR4IGFuZCBnaXZlbiB0eCBpZCBtYXRjaFxuICAgIC8vIHRoaXMgc2hvdWxkIGNhdGNoIHByb2JsZW1zIGVtYW5hdGluZyBmcm9tIHRoZSB1c2Ugb2YgYW4gZXh0ZXJuYWwgc2VydmljZVxuICAgIC8vIGZvciBnZXR0aW5nIHRoZSBjb21wbGV0ZSBwYXJlbnQgdHggaGV4XG4gICAgaWYgKGRlY29kZWRQYXJlbnQuZ2V0SWQoKSAhPT0gcGFyYW1zLnRyYW5zYWN0aW9uSUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRGVjb2RlZCB0cmFuc2FjdGlvbiBpZCBpcyAke2RlY29kZWRQYXJlbnQuZ2V0SWQoKX0sIHdoaWNoIGRvZXMgbm90IG1hdGNoIGdpdmVuIHR4aWQgJHtwYXJhbXMudHJhbnNhY3Rpb25JRH1gKTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgbmV3IGZlZSByYXRlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcGFyZW50J3MgY3VycmVudCBmZWUgcmF0ZVxuICAgIC8vIHZpcnR1YWxTaXplIGlzIHJldHVybmVkIGluIHZieXRlcywgc28gd2UgbmVlZCB0byBjb252ZXJ0IHRvIGt2QlxuICAgIGNvbnN0IHBhcmVudFJhdGUgPSAxMDAwICogcGFyZW50VHguZmVlIC8gcGFyZW50VlNpemU7XG4gICAgaWYgKHBhcmFtcy5mZWVSYXRlIDw9IHBhcmVudFJhdGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGxvd2VyIGZlZSByYXRlISAoUGFyZW50IHR4IGZlZSByYXRlIGlzICR7cGFyZW50UmF0ZX0gc2F0L2tCLCBhbmQgcmVxdWVzdGVkIGZlZSByYXRlIHdhcyAke3BhcmFtcy5mZWVSYXRlfSBzYXQva0IpYCk7XG4gICAgfVxuXG4gICAgLy8gZGV0ZXJtaW5lIGlmIHBhcmVudCBvdXRwdXQgY2FuIGNvdmVyIGNoaWxkIGZlZVxuICAgIGNvbnN0IGlzUGFyZW50T3V0cHV0U2Vnd2l0ID1cbiAgICAgIG91dHB1dFRvVXNlLmNoYWluID09PSBDb2Rlcy5wMnNoUDJ3c2guZXh0ZXJuYWwgfHxcbiAgICAgIG91dHB1dFRvVXNlLmNoYWluID09PSBDb2Rlcy5wMnNoUDJ3c2guaW50ZXJuYWw7XG5cbiAgICBsZXQgY2hpbGRJbnB1dHMgPSB7XG4gICAgICBzZWd3aXQ6IGlzUGFyZW50T3V0cHV0U2Vnd2l0ID8gMSA6IDAsXG4gICAgICBQMlNIOiBpc1BhcmVudE91dHB1dFNlZ3dpdCA/IDAgOiAxXG4gICAgfTtcblxuICAgIGxldCBjaGlsZEZlZSA9IGVzdGltYXRlQ2hpbGRGZWUoe1xuICAgICAgaW5wdXRzOiBjaGlsZElucHV0cyxcbiAgICAgIHBhcmVudEZlZTogcGFyZW50VHguZmVlLFxuICAgICAgZmVlUmF0ZTogcGFyYW1zLmZlZVJhdGUsXG4gICAgICBwYXJlbnRWU2l6ZVxuICAgIH0pO1xuXG4gICAgY29uc3QgdW5zcGVudHNUb1VzZSA9IFtwYXJlbnRVbnNwZW50VG9Vc2VdO1xuXG4gICAgLy8gdHJ5IHRvIGdldCB0aGUgbWluIGNoYW5nZSBzaXplIGZyb20gdGhlIHNlcnZlciwgb3RoZXJ3aXNlIGRlZmF1bHQgdG8gMC4xIEJUQ1xuICAgIC8vIFRPRE86IG1pbkNoYW5nZVNpemUgaXMgbm90IGN1cnJlbnRseSBhIGNvbnN0YW50IGRlZmluZWQgb24gdGhlIGNsaWVudCBhbmQgc2hvdWxkIGJlIGFkZGVkXG4gICAgY29uc3QgbWluQ2hhbmdlU2l6ZSA9IHRoaXMuYml0Z28uZ2V0Q29uc3RhbnRzKCkubWluQ2hhbmdlU2l6ZSB8fCAxZTc7XG5cbiAgICBpZiAob3V0cHV0VG9Vc2UudmFsdWUgPCBjaGlsZEZlZSArIG1pbkNoYW5nZVNpemUpIHtcbiAgICAgIC8vIHBhcmVudCBvdXRwdXQgY2Fubm90IGNvdmVyIGNoaWxkIGZlZSBwbHVzIHRoZSBtaW5pbXVtIGNoYW5nZSxcbiAgICAgIC8vIG11c3QgZmluZCBhZGRpdGlvbmFsIHVuc3BlbnRzIHRvIGNvdmVyIHRoZSBkaWZmZXJlbmNlXG4gICAgICBjb25zdCB7IGFkZGl0aW9uYWwsIG5ld0NoaWxkRmVlLCBuZXdJbnB1dHMgfSA9IHlpZWxkIGZpbmRBZGRpdGlvbmFsVW5zcGVudHMoe1xuICAgICAgICBpbnB1dHM6IGNoaWxkSW5wdXRzLFxuICAgICAgICBwYXJlbnRPdXRwdXRWYWx1ZTogb3V0cHV0VG9Vc2UudmFsdWUsXG4gICAgICAgIHBhcmVudEZlZTogcGFyZW50VHguZmVlLFxuICAgICAgICBtYXhVbnNwZW50czogcGFyYW1zLm1heEFkZGl0aW9uYWxVbnNwZW50cyxcbiAgICAgICAgcGFyZW50VlNpemVcbiAgICAgIH0pO1xuICAgICAgY2hpbGRGZWUgPSBuZXdDaGlsZEZlZTtcbiAgICAgIGNoaWxkSW5wdXRzID0gbmV3SW5wdXRzO1xuICAgICAgdW5zcGVudHNUb1VzZS5wdXNoKC4uLiBhZGRpdGlvbmFsKTtcbiAgICB9XG5cbiAgICAvLyBzYW5pdHkgY2hlY2sgdGhlIGZlZSByYXRlIHdlJ3JlIHBheWluZyBmb3IgdGhlIGNvbWJpbmVkIHR4XG4gICAgLy8gdG8gbWFrZSBzdXJlIGl0J3MgdW5kZXIgdGhlIG1heCBmZWUgcmF0ZS4gT25seSB0aGUgY2hpbGQgdHhcbiAgICAvLyBjYW4gYnJlYWsgdGhpcyBsaW1pdCwgYnV0IHRoZSBjb21iaW5lZCB0eCBzaGFsbCBub3RcbiAgICBjb25zdCBtYXhGZWVSYXRlID0gdGhpcy5iaXRnby5nZXRDb25zdGFudHMoKS5tYXhGZWVSYXRlO1xuICAgIGNvbnN0IGNoaWxkVlNpemUgPSBlc3RpbWF0ZVR4VlNpemUoY2hpbGRJbnB1dHMpO1xuICAgIGNvbnN0IGNvbWJpbmVkVlNpemUgPSBjaGlsZFZTaXplICsgcGFyZW50VlNpemU7XG4gICAgY29uc3QgY29tYmluZWRGZWUgPSBwYXJlbnRUeC5mZWUgKyBjaGlsZEZlZTtcbiAgICAvLyBjb21iaW5lZCBmZWUgcmF0ZSBtdXN0IGJlIGluIHNhdC9rQiwgc28gd2UgbmVlZCB0byBjb252ZXJ0XG4gICAgY29uc3QgY29tYmluZWRGZWVSYXRlID0gMTAwMCAqIGNvbWJpbmVkRmVlIC8gY29tYmluZWRWU2l6ZTtcblxuICAgIGlmIChjb21iaW5lZEZlZVJhdGUgPiBtYXhGZWVSYXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIGNhbm5vdCBiZSBhY2NlbGVyYXRlZC4gQ29tYmluZWQgZmVlIHJhdGUgb2YgJHtjb21iaW5lZEZlZVJhdGV9IHNhdC9rQiBleGNlZWRzIG1heGltdW0gZmVlIHJhdGUgb2YgJHttYXhGZWVSYXRlfSBzYXQva0JgKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYSBuZXcgY2hhbmdlIGFkZHJlc3MgYW5kIGRldGVybWluZSBjaGFuZ2UgYW1vdW50LlxuICAgIC8vIHRoZSB0eCBidWlsZGVyIHdpbGwgcmVqZWN0IHRyYW5zYWN0aW9ucyB3aGljaCBoYXZlIG5vIHJlY2lwaWVudHMsXG4gICAgLy8gYW5kIHN1Y2ggemVyby1vdXRwdXQgdHJhbnNhY3Rpb25zIGFyZSBmb3JiaWRkZW4gYnkgdGhlIEJpdGNvaW4gcHJvdG9jb2wsXG4gICAgLy8gc28gd2UgbmVlZCBhdCBsZWFzdCBhIHNpbmdsZSByZWNpcGllbnQgZm9yIHRoZSBjaGFuZ2Ugd2hpY2ggd29uJ3QgYmUgcHJ1bmVkLlxuICAgIGNvbnN0IGNoYW5nZUFtb3VudCA9IF8uc3VtQnkodW5zcGVudHNUb1VzZSwgKHVuc3BlbnQpID0+IHVuc3BlbnQudmFsdWUpIC0gY2hpbGRGZWU7XG4gICAgY29uc3QgY2hhbmdlQ2hhaW4gPSB0aGlzLmdldENoYW5nZUNoYWluKHt9KTtcbiAgICBjb25zdCBjaGFuZ2VBZGRyZXNzID0geWllbGQgdGhpcy5jcmVhdGVBZGRyZXNzKHsgY2hhaW46IGNoYW5nZUNoYWluIH0pO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBjaGlsZCB0eCBhbmQgYnJvYWRjYXN0XG4gICAgY29uc3QgdHggPSB5aWVsZCB0aGlzLmNyZWF0ZUFuZFNpZ25UcmFuc2FjdGlvbih7XG4gICAgICB1bnNwZW50czogdW5zcGVudHNUb1VzZSxcbiAgICAgIHJlY2lwaWVudHM6IFt7XG4gICAgICAgIGFkZHJlc3M6IGNoYW5nZUFkZHJlc3MuYWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBjaGFuZ2VBbW91bnRcbiAgICAgIH1dLFxuICAgICAgZmVlOiBjaGlsZEZlZSxcbiAgICAgIGJpdGdvRmVlOiB7XG4gICAgICAgIGFtb3VudDogMCxcbiAgICAgICAgYWRkcmVzczogJydcbiAgICAgIH0sXG4gICAgICB4cHJ2OiBwYXJhbXMueHBydixcbiAgICAgIHdhbGxldFBhc3NwaHJhc2U6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlXG4gICAgfSk7XG5cblxuICAgIC8vIGNoaWxkIGZlZSByYXRlIG11c3QgYmUgaW4gc2F0L2tCLCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnRcbiAgICBjb25zdCBjaGlsZEZlZVJhdGUgPSAxMDAwICogY2hpbGRGZWUgLyBjaGlsZFZTaXplO1xuICAgIGlmIChjaGlsZEZlZVJhdGUgPiBtYXhGZWVSYXRlKSB7XG4gICAgICAvLyBjb21iaW5lZCB0eCBpcyB3aXRoaW4gbWF4IGZlZSByYXRlIGxpbWl0cywgYnV0IHRoZSBjaGlsZCB0eCBpcyBub3QuXG4gICAgICAvLyBpbiB0aGlzIGNhc2UsIHdlIG5lZWQgdG8gdXNlIHRoZSBpZ25vcmVNYXhGZWVSYXRlIGZsYWcgdG8gZ2V0IHRoZSBjaGlsZCB0eCB0byBiZSBhY2NlcHRlZFxuICAgICAgdHguaWdub3JlTWF4RmVlUmF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2VuZFRyYW5zYWN0aW9uKHR4KTtcbiAgfSkuY2FsbCh0aGlzKS5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBjcmVhdGVBbmRTaWduVHJhbnNhY3Rpb25cbi8vIElOVEVSTkFMIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbmQgc2lnbiBhIHRyYW5zYWN0aW9uXG4vL1xuLy8gUGFyYW1ldGVyczpcbi8vICAgcmVjaXBpZW50cyAtIGFycmF5IG9mIHsgYWRkcmVzcywgYW1vdW50IH0gdG8gc2VuZCB0b1xuLy8gICB3YWxsZXRQYXNzcGhyYXNlIC0gdGhlIHBhc3NwaHJhc2UgdG8gYmUgdXNlZCB0byBkZWNyeXB0IHRoZSB1c2VyIGtleSBvbiB0aGlzIHdhbGxldFxuLy8gICAoU2VlIHRyYW5zYWN0aW9uQnVpbGRlci5jcmVhdGVUcmFuc2FjdGlvbiBmb3Igb3RoZXIgcGFzc3Rocm91Z2ggcGFyYW1zKVxuLy8gUmV0dXJuczpcbi8vXG5XYWxsZXQucHJvdG90eXBlLmNyZWF0ZUFuZFNpZ25UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNvKGZ1bmN0aW9uICooKSB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcy5yZWNpcGllbnRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgcmVjaXBpZW50cyBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmZlZSAmJiAhXy5pc051bWJlcihwYXJhbXMuZmVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBmZWUgLSBudW1iZXIgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmZlZVJhdGUgJiYgIV8uaXNOdW1iZXIocGFyYW1zLmZlZVJhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGZlZVJhdGUgLSBudW1iZXIgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmR5bmFtaWNGZWVDb25maXJtVGFyZ2V0ICYmICFfLmlzTnVtYmVyKHBhcmFtcy5keW5hbWljRmVlQ29uZmlybVRhcmdldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgY29uZmlybVRhcmdldCAtIG51bWJlciBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuaW5zdGFudCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmluc3RhbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGluc3RhbnQgLSBib29sZWFuIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB5aWVsZCB0aGlzLmNyZWF0ZVRyYW5zYWN0aW9uKHBhcmFtcyk7XG4gICAgY29uc3QgZmVlID0gdHJhbnNhY3Rpb24uZmVlO1xuICAgIGNvbnN0IGZlZVJhdGUgPSB0cmFuc2FjdGlvbi5mZWVSYXRlO1xuICAgIGNvbnN0IGVzdGltYXRlZFNpemUgPSB0cmFuc2FjdGlvbi5lc3RpbWF0ZWRTaXplO1xuICAgIGNvbnN0IGJpdGdvRmVlID0gdHJhbnNhY3Rpb24uYml0Z29GZWU7XG4gICAgY29uc3QgdHJhdmVsSW5mb3MgPSB0cmFuc2FjdGlvbi50cmF2ZWxJbmZvcztcbiAgICBjb25zdCB1bnNwZW50cyA9IHRyYW5zYWN0aW9uLnVuc3BlbnRzO1xuXG4gICAgLy8gU2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICB0cnkge1xuICAgICAgY29uc3Qga2V5Y2hhaW4gPSB5aWVsZCB0aGlzLmdldEFuZFByZXBhcmVTaWduaW5nS2V5Y2hhaW4ocGFyYW1zKTtcbiAgICAgIHRyYW5zYWN0aW9uLmtleWNoYWluID0ga2V5Y2hhaW47XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuY29kZSAhPT0gJ25vX2VuY3J5cHRlZF9rZXljaGFpbl9vbl93YWxsZXQnKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICAvLyB0aGlzIG1pZ2h0IGJlIGEgc2FmZSB3YWxsZXQsIHNvIGxldCdzIHJldHJpZXZlIHRoZSBwcml2YXRlIGtleSBpbmZvXG4gICAgICB5aWVsZCB0aGlzLnJlZnJlc2goeyBncGs6IHRydWUgfSk7XG4gICAgICBjb25zdCBzYWZlVXNlcktleSA9IF8uZ2V0KHRoaXMud2FsbGV0LCAncHJpdmF0ZS51c2VyUHJpdktleScpO1xuICAgICAgaWYgKF8uaXNTdHJpbmcoc2FmZVVzZXJLZXkpICYmIF8uaXNTdHJpbmcocGFyYW1zLndhbGxldFBhc3NwaHJhc2UpKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLnNpZ25pbmdLZXkgPSB0aGlzLmJpdGdvLmRlY3J5cHQoeyBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsIGlucHV0OiBzYWZlVXNlcktleSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJhbnNhY3Rpb24uZmVlU2luZ2xlS2V5V0lGID0gcGFyYW1zLmZlZVNpbmdsZUtleVdJRjtcbiAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIF8uZXh0ZW5kKHJlc3VsdCwge1xuICAgICAgZmVlLFxuICAgICAgZmVlUmF0ZSxcbiAgICAgIGluc3RhbnQ6IHBhcmFtcy5pbnN0YW50LFxuICAgICAgYml0Z29GZWUsXG4gICAgICB0cmF2ZWxJbmZvcyxcbiAgICAgIGVzdGltYXRlZFNpemUsXG4gICAgICB1bnNwZW50c1xuICAgIH0pO1xuICB9KS5jYWxsKHRoaXMpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xufTtcblxuLy9cbi8vIGdldEFuZFByZXBhcmVTaWduaW5nS2V5Y2hhaW5cbi8vIElOVEVSTkFMIGZ1bmN0aW9uIHRvIGdldCB0aGUgdXNlciBrZXljaGFpbiBmb3Igc2lnbmluZy5cbi8vIENhbGxlciBtdXN0IHByb3ZpZGVyIGVpdGhlciBhIGtleWNoYWluLCBvciB3YWxsZXRQYXNzcGhyYXNlIG9yIHhwcnYgYXMgYSBzdHJpbmdcbi8vIElmIHRoZSBjYWxsZXIgcHJvdmlkZXMgdGhlIGtleWNoYWluIHdpdGggeHBydiwgaXQgaXMgc2ltcGx5IHJldHVybmVkLlxuLy8gSWYgdGhlIGNhbGxlciBwcm92aWRlcyB0aGUgZW5jcnlwdGVkIHhwcnYgKHdhbGxldFBhc3NwaHJhc2UpLCB0aGVuIGZldGNoIHRoZSBrZXljaGFpbiBvYmplY3QgYW5kIGRlY3J5cHRcbi8vIE90aGVyd2lzZSBpZiB0aGUgeHBydiBpcyBwcm92aWRlZCwgZmV0Y2ggdGhlIGtleWNoYWluIG9iamVjdCBhbmQgYXVnbWVudCBpdCB3aXRoIHRoZSB4cHJ2LlxuLy9cbi8vIFBhcmFtZXRlcnM6XG4vLyAgIGtleWNoYWluIC0ga2V5Y2hhaW4gd2l0aCB4cHJ2XG4vLyAgIHhwcnYgLSB0aGUgcHJpdmF0ZSBrZXkgaW4gc3RyaW5nIGZvcm1cbi8vICAgd2FsbGV0UGFzc3BocmFzZSAtIHRoZSBwYXNzcGhyYXNlIHRvIGJlIHVzZWQgdG8gZGVjcnlwdCB0aGUgdXNlciBrZXkgb24gdGhpcyB3YWxsZXRcbi8vIFJldHVybnM6XG4vLyAgIEtleWNoYWluIG9iamVjdCBjb250YWluaW5nIHhwcnYsIHhwdWIgYW5kIHBhdGhzXG4vL1xuV2FsbGV0LnByb3RvdHlwZS5nZXRBbmRQcmVwYXJlU2lnbmluZ0tleWNoYWluID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgLy8gSWYga2V5Y2hhaW4gd2l0aCB4cHJ2IGlzIGFscmVhZHkgcHJvdmlkZWQsIHVzZSBpdFxuICBpZiAoXy5pc09iamVjdChwYXJhbXMua2V5Y2hhaW4pICYmIHBhcmFtcy5rZXljaGFpbi54cHJ2KSB7XG4gICAgcmV0dXJuIEJsdWViaXJkLnJlc29sdmUocGFyYW1zLmtleWNoYWluKTtcbiAgfVxuXG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ3dhbGxldFBhc3NwaHJhc2UnLCAneHBydiddLCBjYWxsYmFjayk7XG5cbiAgaWYgKChwYXJhbXMud2FsbGV0UGFzc3BocmFzZSAmJiBwYXJhbXMueHBydikgfHwgKCFwYXJhbXMud2FsbGV0UGFzc3BocmFzZSAmJiAhcGFyYW1zLnhwcnYpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHByb3ZpZGUgZXhhY3RseSBvbmUgb2YgeHBydiBvciB3YWxsZXRQYXNzcGhyYXNlJyk7XG4gIH1cblxuICBjb25zdCBzZWxmID0gdGhpcztcblxuICAvLyBDYWxsZXIgcHJvdmlkZWQgYSB3YWxsZXQgcGFzc3BocmFzZVxuICBpZiAocGFyYW1zLndhbGxldFBhc3NwaHJhc2UpIHtcbiAgICByZXR1cm4gc2VsZi5nZXRFbmNyeXB0ZWRVc2VyS2V5Y2hhaW4oKVxuICAgIC50aGVuKGZ1bmN0aW9uKGtleWNoYWluKSB7XG4gICAgICAvLyBEZWNyeXB0IHRoZSB1c2VyIGtleSB3aXRoIGEgcGFzc3BocmFzZVxuICAgICAgdHJ5IHtcbiAgICAgICAga2V5Y2hhaW4ueHBydiA9IHNlbGYuYml0Z28uZGVjcnlwdCh7IHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSwgaW5wdXQ6IGtleWNoYWluLmVuY3J5cHRlZFhwcnYgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRlY3J5cHQgdXNlciBrZXljaGFpbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleWNoYWluO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ2FsbGVyIHByb3ZpZGVkIGFuIHhwcnYgLSB2YWxpZGF0ZSBhbmQgY29uc3RydWN0IGtleWNoYWluIG9iamVjdFxuICBsZXQgeHB1YjtcbiAgdHJ5IHtcbiAgICB4cHViID0gYml0Y29pbi5IRE5vZGUuZnJvbUJhc2U1OChwYXJhbXMueHBydikubmV1dGVyZWQoKS50b0Jhc2U1OCgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgdGhlIHhwcnYnKTtcbiAgfVxuXG4gIGlmICh4cHViID09PSBwYXJhbXMueHBydikge1xuICAgIHRocm93IG5ldyBFcnJvcigneHBydiBwcm92aWRlZCB3YXMgbm90IGEgcHJpdmF0ZSBrZXkgKGZvdW5kIHhwdWIgaW5zdGVhZCknKTtcbiAgfVxuXG4gIGNvbnN0IHdhbGxldFhwdWJzID0gXy5tYXAoc2VsZi5rZXljaGFpbnMsICd4cHViJyk7XG4gIGlmICghXy5pbmNsdWRlcyh3YWxsZXRYcHVicywgeHB1YikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3hwcnYgcHJvdmlkZWQgd2FzIG5vdCBhIGtleWNoYWluIG9uIHRoaXMgd2FsbGV0IScpO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSBrZXljaGFpbiBvYmplY3QgZnJvbSBiaXRnbyB0byBmaW5kIHRoZSBwYXRoIGFuZCAocG90ZW50aWFsKSB3YWxsZXQgc3RydWN0dXJlXG4gIHJldHVybiBzZWxmLmJpdGdvLmtleWNoYWlucygpLmdldCh7IHhwdWI6IHhwdWIgfSlcbiAgLnRoZW4oZnVuY3Rpb24oa2V5Y2hhaW4pIHtcbiAgICBrZXljaGFpbi54cHJ2ID0gcGFyYW1zLnhwcnY7XG4gICAgcmV0dXJuIGtleWNoYWluO1xuICB9KTtcbn07XG5cbi8qKlxuICogVGFrZXMgYSB3YWxsZXQncyB1bnNwZW50cyBhbmQgZmFucyB0aGVtIG91dCBpbnRvIGEgbGFyZ2VyIG51bWJlciBvZiBlcXVhbGx5IHNpemVkIHVuc3BlbnRzXG4gKiBAcGFyYW0gcGFyYW1zXG4gKiAgdGFyZ2V0OiBzZXQgaG93IG1hbnkgdW5zcGVudHMgeW91IHdhbnQgdG8gaGF2ZSBpbiB0aGUgZW5kXG4gKiAgbWluQ29uZmlybXM6IG1pbmltdW0gbnVtYmVyIG9mIGNvbmZpcm1zIHRoZSB1bnNwZW50cyBtdXN0IGhhdmVcbiAqICB4cHJ2OiBwcml2YXRlIGtleSB0byBzaWduIHRyYW5zYWN0aW9uXG4gKiAgd2FsbGV0UGFzc3BocmFzZTogd2FsbGV0IHBhc3NwaHJhc2UgdG8gZGVjcnlwdCB0aGUgd2FsbGV0J3MgcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSBjYWxsYmFja1xuICogQHJldHVybnMgeyp9XG4gKi9cbldhbGxldC5wcm90b3R5cGUuZmFuT3V0VW5zcGVudHMgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICByZXR1cm4gQmx1ZWJpcmQuY29yb3V0aW5lKGZ1bmN0aW9uICooKSB7XG4gICAgLy8gbWF4aW11bSBudW1iZXIgb2YgaW5wdXRzIGZvciBmYW5vdXQgdHJhbnNhY3Rpb25cbiAgICAvLyAod2hlbiBmYW5uaW5nIG91dCwgd2UgdGFrZSBhbGwgdGhlIHVuc3BlbnRzIGFuZCBtYWtlIGEgYmlnZ2VyIG51bWJlciBvZiBvdXRwdXRzKVxuICAgIGNvbnN0IE1BWF9GQU5PVVRfSU5QVVRfQ09VTlQgPSA4MDtcbiAgICAvLyBtYXhpbXVtIG51bWJlciBvZiBvdXRwdXRzIGZvciBmYW5vdXQgdHJhbnNhY3Rpb25cbiAgICBjb25zdCBNQVhfRkFOT1VUX09VVFBVVF9DT1VOVCA9IDMwMDtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFsnd2FsbGV0UGFzc3BocmFzZScsICd4cHJ2J10sIGNhbGxiYWNrKTtcbiAgICBjb25zdCB2YWxpZGF0ZSA9IHBhcmFtcy52YWxpZGF0ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHBhcmFtcy52YWxpZGF0ZTtcblxuICAgIGNvbnN0IHRhcmdldCA9IHBhcmFtcy50YXJnZXQ7XG4gICAgLy8gdGhlIHRhcmdldCBtdXN0IGJlIGRlZmluZWQsIGJlIGEgbnVtYmVyLCBiZSBhdCBsZWFzdCB0d28sIGFuZCBiZSBhIG5hdHVyYWwgbnVtYmVyXG4gICAgaWYgKCFfLmlzTnVtYmVyKHRhcmdldCkgfHwgdGFyZ2V0IDwgMiB8fCAodGFyZ2V0ICUgMSkgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGFyZ2V0IG5lZWRzIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0ID4gTUFYX0ZBTk9VVF9PVVRQVVRfQ09VTlQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFuIG91dCB0YXJnZXQgdG9vIGhpZ2gnKTtcbiAgICB9XG5cbiAgICBsZXQgbWluQ29uZmlybXMgPSBwYXJhbXMubWluQ29uZmlybXM7XG4gICAgaWYgKG1pbkNvbmZpcm1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG1pbkNvbmZpcm1zID0gMTtcbiAgICB9XG4gICAgaWYgKCFfLmlzTnVtYmVyKG1pbkNvbmZpcm1zKSB8fCBtaW5Db25maXJtcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWluQ29uZmlybXMgbmVlZHMgdG8gYmUgYW4gaW50ZWdlciA+PSAwJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXQgYSBuYXR1cmFsIG51bWJlciBOIGludG8gbiBhbG1vc3QgZXF1YWxseSBzaXplZCAowrExKSBuYXR1cmFsIG51bWJlcnMuXG4gICAgICogSW4gb3JkZXIgdG8gY2FsY3VsYXRlIHRoZSBzaXplcyBvZiB0aGUgcGFydHMsIHdlIGNhbGN1bGF0ZSBmbG9vcihOL24pLCBhbmQgdGh1cyBoYXZlIHRoZSBiYXNlIHNpemUgb2YgYWxsIHBhcnRzLlxuICAgICAqIElmIE4gJSBuICE9PSAwLCB0aGlzIGxlYXZlcyB1cyB3aXRoIGEgcmVtYWluZGVyIHIgd2hlcmUgciA8IG4uIFdlIGRpc3RyaWJ1dGUgciBlcXVhbGx5IGFtb25nIHRoZSBuIHBhcnRzIGJ5XG4gICAgICogYWRkaW5nIDEgdG8gdGhlIGZpcnN0IHIgcGFydHMuXG4gICAgICogQHBhcmFtIHRvdGFsXG4gICAgICogQHBhcmFtIHBhcnRDb3VudFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBjb25zdCBzcGxpdE51bWJlckludG9DbG9zZU5hdHVyYWxOdW1iZXJzID0gZnVuY3Rpb24odG90YWwsIHBhcnRDb3VudCkge1xuICAgICAgY29uc3QgcGFydFNpemUgPSBNYXRoLmZsb29yKHRvdGFsIC8gcGFydENvdW50KTtcbiAgICAgIGNvbnN0IHJlbWFpbmRlciA9IHRvdGFsIC0gcGFydFNpemUgKiBwYXJ0Q291bnQ7XG4gICAgICAvLyBpbml0aWFsaXplIHBsYWNlaG9sZGVyIGFycmF5XG4gICAgICBjb25zdCBhbG1vc3RFcXVhbFBhcnRzID0gbmV3IEFycmF5KHBhcnRDb3VudCk7XG4gICAgICAvLyBmaWxsIHRoZSBmaXJzdCByZW1haW5kZXIgcGFydHMgd2l0aCB0aGUgdmFsdWUgcGFydFNpemUrMVxuICAgICAgXy5maWxsKGFsbW9zdEVxdWFsUGFydHMsIHBhcnRTaXplICsgMSwgMCwgcmVtYWluZGVyKTtcbiAgICAgIC8vIGZpbGwgdGhlIHJlbWFpbmluZyBwYXJ0cyB3aXRoIHRoZSB2YWx1ZSBwYXJ0U2l6ZVxuICAgICAgXy5maWxsKGFsbW9zdEVxdWFsUGFydHMsIHBhcnRTaXplLCByZW1haW5kZXIpO1xuICAgICAgLy8gYXNzZXJ0IHRoZSBjb3JyZWN0bmVzcyBvZiB0aGUgYWxtb3N0IGVxdWFsIHBhcnRzXG4gICAgICAvLyBUT0RPOiBhZGQgY2hlY2sgZm9yIHRoZSBiaWdnZXN0IGRldmlhdGlvbiBiZXR3ZWVuIGFueSB0d28gcGFydHMgYW5kIG1ha2Ugc3VyZSBpdCdzIDw9IDFcbiAgICAgIGlmIChfKGFsbW9zdEVxdWFsUGFydHMpLnN1bSgpICE9PSB0b3RhbCB8fCBfKGFsbW9zdEVxdWFsUGFydHMpLnNpemUoKSAhPT0gcGFydENvdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFydCBzdW0gb3IgcGFydCBjb3VudCBtaXNtYXRjaCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbW9zdEVxdWFsUGFydHM7XG4gICAgfTtcblxuICAgIC8vIGZpcnN0LCBsZXQncyB0YWtlIGFsbCB0aGUgd2FsbGV0J3MgdW5zcGVudHMgKHdpdGggbWluIGNvbmZpcm1zIGlmIG5lY2Vzc2FyeSlcbiAgICBjb25zdCBhbGxVbnNwZW50cyA9IHlpZWxkIHNlbGYudW5zcGVudHMoeyBtaW5Db25maXJtczogbWluQ29uZmlybXMgfSk7XG4gICAgaWYgKGFsbFVuc3BlbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdW5zcGVudHMgdG8gYnJhbmNoIG91dCcpO1xuICAgIH1cblxuICAgIC8vIHRoaXMgY29uc29saWRhdGlvbiBpcyBlc3NlbnRpYWxseSBqdXN0IGEgd2FzdGUgb2YgbW9uZXlcbiAgICBpZiAoYWxsVW5zcGVudHMubGVuZ3RoID49IHRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYW4gb3V0IHRhcmdldCBoYXMgdG8gYmUgYmlnZ2VyIHRoYW4gY3VycmVudCBudW1iZXIgb2YgdW5zcGVudHMnKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBoYXZlIGF0IHRoZSB2ZXJ5IG1pbmltdW0gODEgaW5wdXRzLCBhbmQgODEgb3V0cHV0cy4gVGhhdCB0cmFuc2FjdGlvbiB3aWxsIGJlIGJpZ1xuICAgIC8vIGluIHRoZSBtZWRpdW0gcnVuLCB0aGlzIGFsZ29yaXRobSBjb3VsZCBiZSByZXdvcmtlZCB0byBvbmx5IHdvcmsgd2l0aCBhIHN1YnNldCBvZiB0aGUgdHJhbnNhY3Rpb25zXG4gICAgaWYgKGFsbFVuc3BlbnRzLmxlbmd0aCA+IE1BWF9GQU5PVVRfSU5QVVRfQ09VTlQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgdW5zcGVudHMnKTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGlzIGFsbCB0aGUgbW9uZXkgdGhhdCBpcyBjdXJyZW50bHkgaW4gdGhlIHdhbGxldFxuICAgIGNvbnN0IGdyb3NzQW1vdW50ID0gXyhhbGxVbnNwZW50cykubWFwKCd2YWx1ZScpLnN1bSgpO1xuXG4gICAgLy8gaW4gb3JkZXIgdG8gbm90IG1vZGlmeSB0aGUgcGFyYW1zIG9iamVjdCwgd2UgY3JlYXRlIGEgY29weVxuICAgIGNvbnN0IHR4UGFyYW1zID0gXy5leHRlbmQoe30sIHBhcmFtcyk7XG4gICAgdHhQYXJhbXMudW5zcGVudHMgPSBhbGxVbnNwZW50cztcbiAgICB0eFBhcmFtcy5yZWNpcGllbnRzID0ge307XG5cbiAgICAvLyBjcmVhdGUgdGFyZ2V0IGFtb3VudCBvZiBuZXcgYWRkcmVzc2VzIGZvciB0aGlzIHdhbGxldFxuICAgIGNvbnN0IG5ld0FkZHJlc3NQcm9taXNlcyA9IF8ucmFuZ2UodGFyZ2V0KVxuICAgIC5tYXAoKCkgPT4gc2VsZi5jcmVhdGVBZGRyZXNzKHsgY2hhaW46IHNlbGYuZ2V0Q2hhbmdlQ2hhaW4ocGFyYW1zKSwgdmFsaWRhdGU6IHZhbGlkYXRlIH0pKTtcbiAgICBjb25zdCBuZXdBZGRyZXNzZXMgPSB5aWVsZCBCbHVlYmlyZC5hbGwobmV3QWRkcmVzc1Byb21pc2VzKTtcbiAgICAvLyBsZXQncyBmaW5kIGEgbmljZSwgZXF1YWwgZGlzdHJpYnV0aW9uIG9mIG91ciBTYXRvc2hpcyBhbW9uZyB0aGUgbmV3IGFkZHJlc3Nlc1xuICAgIGNvbnN0IHNwbGl0QW1vdW50cyA9IHNwbGl0TnVtYmVySW50b0Nsb3NlTmF0dXJhbE51bWJlcnMoZ3Jvc3NBbW91bnQsIHRhcmdldCk7XG4gICAgLy8gbWFwIHRoZSBuZXdseSBjcmVhdGVkIGFkZHJlc3NlcyB0byB0aGUgYWxtb3N0IGNvbXBvbmVudHMgYW1vdW50cyB3ZSBqdXN0IGNhbGN1bGF0ZWRcbiAgICB0eFBhcmFtcy5yZWNpcGllbnRzID0gXy56aXBPYmplY3QoXy5tYXAobmV3QWRkcmVzc2VzLCAnYWRkcmVzcycpLCBzcGxpdEFtb3VudHMpO1xuICAgIHR4UGFyYW1zLm5vU3BsaXRDaGFuZ2UgPSB0cnVlO1xuICAgIC8vIGF0dGVtcHQgdG8gY3JlYXRlIGEgdHJhbnNhY3Rpb24uIEFzIGl0IGlzIGEgd2FsbGV0LXN3ZWVwaW5nIHRyYW5zYWN0aW9uIHdpdGggbm8gZmVlLCB3ZSBleHBlY3QgaXQgdG8gZmFpbFxuICAgIHRyeSB7XG4gICAgICB5aWVsZCBzZWxmLnNlbmRNYW55KHR4UGFyYW1zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gYXMgZXhwZWN0ZWQsIHRoZSB0cmFuc2FjdGlvbiBjcmVhdGlvbiBkaWQgaW5kZWVkIGZhaWwgZHVlIHRvIGluc3VmZmljaWVudCBmZWVzXG4gICAgICAvLyB0aGUgZXJyb3Igc3VnZ2VzdHMgYSBmZWUgdmFsdWUgd2hpY2ggd2UgdGhlbiB1c2UgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgICAgLy8gaG93ZXZlciwgbGV0J3MgbWFrZSBzdXJlIGl0IHdhc24ndCBzb21ldGhpbmcgZWxzZVxuICAgICAgaWYgKCFlcnJvci5mZWUgJiYgKCFlcnJvci5yZXN1bHQgfHwgIWVycm9yLnJlc3VsdC5mZWUpKSB7XG4gICAgICAgIC8vIGlmIHRoZSBlcnJvciBkb2VzIG5vdCBjb250YWluIGEgZmVlIHByb3BlcnR5LCBpdCBpcyBzb21ldGhpbmcgZWxzZSB0aGF0IGhhcyBnb25lIGF3cnksIGFuZCB3ZSB0aHJvdyBpdFxuICAgICAgICBjb25zdCBkZWJ1Z1BhcmFtcyA9IF8ub21pdCh0eFBhcmFtcywgWyd3YWxsZXRQYXNzcGhyYXNlJywgJ3hwcnYnXSk7XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgKz0gYFxcblxcblRYIFBBUkFNUzpcXG4gJHtKU09OLnN0cmluZ2lmeShkZWJ1Z1BhcmFtcywgbnVsbCwgNCl9YDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBjb25zdCBiYXNlRmVlID0gZXJyb3IuZmVlIHx8IGVycm9yLnJlc3VsdC5mZWU7XG4gICAgICBsZXQgdG90YWxGZWUgPSBiYXNlRmVlO1xuICAgICAgaWYgKGVycm9yLnJlc3VsdC5iaXRnb0ZlZSAmJiBlcnJvci5yZXN1bHQuYml0Z29GZWUuYW1vdW50KSB7XG4gICAgICAgIHRvdGFsRmVlICs9IGVycm9yLnJlc3VsdC5iaXRnb0ZlZS5hbW91bnQ7XG4gICAgICAgIHR4UGFyYW1zLmJpdGdvRmVlID0gZXJyb3IucmVzdWx0LmJpdGdvRmVlO1xuICAgICAgfVxuXG4gICAgICAvLyBOZWVkIHRvIGNsZWFyIHRoZXNlIG91dCBzaW5jZSBvbmx5IDEgbWF5IGJlIHNldFxuICAgICAgZGVsZXRlIHR4UGFyYW1zLmZlZTtcbiAgICAgIHR4UGFyYW1zLm9yaWdpbmFsRmVlUmF0ZSA9IHR4UGFyYW1zLmZlZVJhdGU7XG4gICAgICBkZWxldGUgdHhQYXJhbXMuZmVlUmF0ZTtcbiAgICAgIGRlbGV0ZSB0eFBhcmFtcy5mZWVUeENvbmZpcm1UYXJnZXQ7XG4gICAgICB0eFBhcmFtcy5mZWUgPSBiYXNlRmVlO1xuICAgICAgLy8gaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIGVxdWFsIGRpc3RyaWJ1dGlvbiwgd2UgbmVlZCB0byBzdWJ0cmFjdCB0aGUgZmVlIGZyb20gdGhlIGN1bXVsYXRpdmUgZnVuZHNcbiAgICAgIC8vIGluIGNhc2Ugc29tZSB1bnNwZW50cyBnb3QgcHJ1bmVkLCB3ZSBuZWVkIHRvIHVzZSBlcnJvci5yZXN1bHQuYXZhaWxhYmxlXG4gICAgICBjb25zdCBuZXRBbW91bnQgPSBlcnJvci5yZXN1bHQuYXZhaWxhYmxlIC0gdG90YWxGZWU7IC8vIGFmdGVyIGZlZXNcbiAgICAgIC8vIHRoYXQgbWVhbnMgdGhhdCB0aGUgZGlzdHJpYnV0aW9uIGhhcyB0byBiZSByZWNhbGN1bGF0ZWRcbiAgICAgIGNvbnN0IHJlbWFpbmluZ1NwbGl0QW1vdW50cyA9IHNwbGl0TnVtYmVySW50b0Nsb3NlTmF0dXJhbE51bWJlcnMobmV0QW1vdW50LCB0YXJnZXQpO1xuICAgICAgLy8gYW5kIHRoZSBkaXN0cmlidXRpb24gYWdhaW4gbWFwcGVkIHRvIHRoZSBuZXcgYWRkcmVzc2VzXG4gICAgICB0eFBhcmFtcy5yZWNpcGllbnRzID0gXy56aXBPYmplY3QoXy5tYXAobmV3QWRkcmVzc2VzLCAnYWRkcmVzcycpLCByZW1haW5pbmdTcGxpdEFtb3VudHMpO1xuICAgIH1cblxuICAgIC8vIHRoaXMgdGltZSwgdGhlIHRyYW5zYWN0aW9uIGNyZWF0aW9uIHNob3VsZCB3b3JrXG4gICAgbGV0IGZhbm91dFR4O1xuICAgIHRyeSB7XG4gICAgICBmYW5vdXRUeCA9IHlpZWxkIHNlbGYuc2VuZE1hbnkodHhQYXJhbXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IGRlYnVnUGFyYW1zID0gXy5vbWl0KHR4UGFyYW1zLCBbJ3dhbGxldFBhc3NwaHJhc2UnLCAneHBydiddKTtcbiAgICAgIGUubWVzc2FnZSArPSBgXFxuXFxuVFggUEFSQU1TOlxcbiAke0pTT04uc3RyaW5naWZ5KGRlYnVnUGFyYW1zLCBudWxsLCA0KX1gO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICByZXR1cm4gQmx1ZWJpcmQucmVzb2x2ZShmYW5vdXRUeCkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG4gIH0pKCkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHRvIGZhbiBvdXQgb3IgY29hbGVzY2UgYSB3YWxsZXQncyB1bnNwZW50c1xuICogQHBhcmFtIHBhcmFtc1xuICogQHBhcmFtIGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7UmVxdWVzdHxQcm9taXNlLjxUPnwqfVxuICovXG5XYWxsZXQucHJvdG90eXBlLnJlZ3JvdXBVbnNwZW50cyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb25zdCB0YXJnZXQgPSBwYXJhbXMudGFyZ2V0O1xuICBpZiAoIV8uaXNOdW1iZXIodGFyZ2V0KSB8fCB0YXJnZXQgPCAxIHx8ICh0YXJnZXQgJSAxKSAhPT0gMCkge1xuICAgIC8vIHRoZSB0YXJnZXQgbXVzdCBiZSBkZWZpbmVkLCBiZSBhIG51bWJlciwgYmUgYXQgbGVhc3Qgb25lLCBhbmQgYmUgYSBuYXR1cmFsIG51bWJlclxuICAgIHRocm93IG5ldyBFcnJvcignVGFyZ2V0IG5lZWRzIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICB9XG5cbiAgbGV0IG1pbkNvbmZpcm1zID0gcGFyYW1zLm1pbkNvbmZpcm1zO1xuICBpZiAobWluQ29uZmlybXMgPT09IHVuZGVmaW5lZCkge1xuICAgIG1pbkNvbmZpcm1zID0gMTtcbiAgfVxuICBpZiAoKCFfLmlzTnVtYmVyKG1pbkNvbmZpcm1zKSB8fCBtaW5Db25maXJtcyA8IDApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtaW5Db25maXJtcyBuZWVkcyB0byBiZSBhbiBpbnRlZ2VyIGVxdWFsIHRvIG9yIGJpZ2dlciB0aGFuIDAnKTtcbiAgfVxuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICByZXR1cm4gc2VsZi51bnNwZW50cyh7IG1pbkNvbmZpcm1zOiBtaW5Db25maXJtcyB9KVxuICAudGhlbihmdW5jdGlvbih1bnNwZW50cykge1xuICAgIGlmICh1bnNwZW50cy5sZW5ndGggPT09IHRhcmdldCkge1xuICAgICAgcmV0dXJuIHVuc3BlbnRzO1xuICAgIH0gZWxzZSBpZiAodW5zcGVudHMubGVuZ3RoID4gdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gc2VsZi5jb25zb2xpZGF0ZVVuc3BlbnRzKHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAodW5zcGVudHMubGVuZ3RoIDwgdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gc2VsZi5mYW5PdXRVbnNwZW50cyhwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDb25zb2xpZGF0ZSBhIHdhbGxldCdzIHVuc3BlbnRzIGludG8gZmV3ZXIgdW5zcGVudHNcbiAqIEBwYXJhbSBwYXJhbXNcbiAqICB0YXJnZXQ6IHNldCBob3cgbWFueSB1bnNwZW50cyB5b3Ugd2FudCB0byBoYXZlIGluIHRoZSBlbmRcbiAqICBtYXhJbnB1dENvdW50UGVyQ29uc29saWRhdGlvbjogc2V0IGhvdyBtYW55IG1heGltdW0gaW5wdXRzIGFyZSB0byBiZSBwZXJtaXR0ZWQgcGVyIGNvbnNvbGlkYXRpb24gYmF0Y2hcbiAqICB4cHJ2OiBwcml2YXRlIGtleSB0byBzaWduIHRyYW5zYWN0aW9uXG4gKiAgd2FsbGV0UGFzc3BocmFzZTogd2FsbGV0IHBhc3NwaHJhc2UgdG8gZGVjcnlwdCB0aGUgd2FsbGV0J3MgcHJpdmF0ZSBrZXlcbiAqICBtYXhJdGVyYXRpb25Db3VudDogbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBiZSBwZXJmb3JtZWQgdW50aWwgZnVuY3Rpb24gc3RvcHNcbiAqICBwcm9ncmVzc0NhbGxiYWNrOiBtZXRob2QgdG8gYmUgY2FsbGVkIHdpdGggb2JqZWN0IG91dGxpbmluZyBjdXJyZW50IHByb2dyZXNzIGRldGFpbHNcbiAqIEBwYXJhbSBjYWxsYmFja1xuICogQHJldHVybnMgeyp9XG4gKi9cbldhbGxldC5wcm90b3R5cGUuY29uc29saWRhdGVVbnNwZW50cyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWyd3YWxsZXRQYXNzcGhyYXNlJywgJ3hwcnYnXSwgY2FsbGJhY2spO1xuICBjb25zdCB2YWxpZGF0ZSA9IHBhcmFtcy52YWxpZGF0ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHBhcmFtcy52YWxpZGF0ZTtcblxuICBsZXQgdGFyZ2V0ID0gcGFyYW1zLnRhcmdldDtcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGFyZ2V0ID0gMTtcbiAgfSBlbHNlIGlmICghXy5pc051bWJlcih0YXJnZXQpIHx8IHRhcmdldCA8IDEgfHwgKHRhcmdldCAlIDEpICE9PSAwKSB7XG4gICAgLy8gdGhlIHRhcmdldCBtdXN0IGJlIGRlZmluZWQsIGJlIGEgbnVtYmVyLCBiZSBhdCBsZWFzdCBvbmUsIGFuZCBiZSBhIG5hdHVyYWwgbnVtYmVyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgbmVlZHMgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gIH1cblxuICBpZiAocGFyYW1zLm1heFNpemUgJiYgIV8uaXNOdW1iZXIocGFyYW1zLm1heFNpemUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYXhTaXplIHNob3VsZCBiZSBhIG51bWJlcicpO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5taW5TaXplICYmICFfLmlzTnVtYmVyKHBhcmFtcy5taW5TaXplKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWluU2l6ZSBzaG91bGQgYmUgYSBudW1iZXInKTtcbiAgfVxuXG4gIC8vIG1heGltdW0gbnVtYmVyIG9mIGlucHV0cyBwZXIgdHJhbnNhY3Rpb24gZm9yIGNvbnNvbGlkYXRpb25cbiAgY29uc3QgTUFYX0lOUFVUX0NPVU5UID0gMjAwO1xuICBsZXQgbWF4SW5wdXRDb3VudCA9IHBhcmFtcy5tYXhJbnB1dENvdW50UGVyQ29uc29saWRhdGlvbjtcbiAgaWYgKG1heElucHV0Q291bnQgPT09IHVuZGVmaW5lZCkgeyAvLyBudWxsIG9yIHVuaWRlbnRpZmllZCwgYmVjYXVzZSBlcXVhbGl0eSB0byB6ZXJvIHJldHVybnMgdHJ1ZSBpbiBpZighIGNsYXVzZVxuICAgIG1heElucHV0Q291bnQgPSBNQVhfSU5QVVRfQ09VTlQ7XG4gIH1cbiAgaWYgKHR5cGVvZiAobWF4SW5wdXRDb3VudCkgIT09ICdudW1iZXInIHx8IG1heElucHV0Q291bnQgPCAyIHx8IChtYXhJbnB1dENvdW50ICUgMSkgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01heGltdW0gY29uc29saWRhdGlvbiBpbnB1dCBjb3VudCBuZWVkcyB0byBiZSBhbiBpbnRlZ2VyIGVxdWFsIHRvIG9yIGJpZ2dlciB0aGFuIDInKTtcbiAgfSBlbHNlIGlmIChtYXhJbnB1dENvdW50ID4gTUFYX0lOUFVUX0NPVU5UKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXhpbXVtIGNvbnNvbGlkYXRpb24gaW5wdXQgY291bnQgY2Fubm90IGJlIGJpZ2dlciB0aGFuICcgKyBNQVhfSU5QVVRfQ09VTlQpO1xuICB9XG5cbiAgY29uc3QgbWF4SXRlcmF0aW9uQ291bnQgPSBwYXJhbXMubWF4SXRlcmF0aW9uQ291bnQgfHwgLTE7XG4gIGlmIChwYXJhbXMubWF4SXRlcmF0aW9uQ291bnQgJiYgKCFfLmlzTnVtYmVyKG1heEl0ZXJhdGlvbkNvdW50KSB8fCBtYXhJdGVyYXRpb25Db3VudCA8IDEpIHx8IChtYXhJdGVyYXRpb25Db3VudCAlIDEpICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXhpbXVtIGl0ZXJhdGlvbiBjb3VudCBuZWVkcyB0byBiZSBhbiBpbnRlZ2VyIGVxdWFsIHRvIG9yIGJpZ2dlciB0aGFuIDEnKTtcbiAgfVxuXG4gIGxldCBtaW5Db25maXJtcyA9IHBhcmFtcy5taW5Db25maXJtcztcbiAgaWYgKG1pbkNvbmZpcm1zID09PSB1bmRlZmluZWQpIHtcbiAgICBtaW5Db25maXJtcyA9IDE7XG4gIH1cbiAgaWYgKCghXy5pc051bWJlcihtaW5Db25maXJtcykgfHwgbWluQ29uZmlybXMgPCAwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWluQ29uZmlybXMgbmVlZHMgdG8gYmUgYW4gaW50ZWdlciBlcXVhbCB0byBvciBiaWdnZXIgdGhhbiAwJyk7XG4gIH1cblxuICBsZXQgbWluU2l6ZSA9IHBhcmFtcy5taW5TaXplIHx8IDA7XG4gIGlmIChwYXJhbXMuZmVlUmF0ZSkge1xuICAgIC8vIGZlZSByYXRlIGlzIGluIHNhdG9zaGlzIHBlciBrQiwgaW5wdXQgc2l6ZSBpbiBieXRlc1xuICAgIGNvbnN0IGZlZUJhc2VkTWluU2l6ZSA9IE1hdGguY2VpbChWaXJ0dWFsU2l6ZXMudHhQMnNoSW5wdXRTaXplICogcGFyYW1zLmZlZVJhdGUgLyAxMDAwKTtcbiAgICBpZiAocGFyYW1zLm1pblNpemUgJiYgbWluU2l6ZSA8IGZlZUJhc2VkTWluU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm92aWRlZCBtaW5TaXplIHRvbyBsb3cgZHVlIHRvIHRvbyBoaWdoIGZlZSByYXRlJyk7XG4gICAgfVxuICAgIG1pblNpemUgPSBNYXRoLm1heChmZWVCYXNlZE1pblNpemUsIG1pblNpemUpO1xuXG4gICAgaWYgKCFwYXJhbXMubWluU2l6ZSkge1xuICAgICAgLy8gZmVlIHJhdGUtYmFzZWQgbWluIHNpemUgbmVlZHMgbm8gbG9nZ2luZyBpZiBpdCB3YXMgc2V0IGV4cGxpY2l0bHlcbiAgICAgIGNvbnNvbGUubG9nKCdPbmx5IGNvbnNvbGlkYXRpbmcgdW5zcGVudHMgbGFyZ2VyIHRoYW4gJyArIG1pblNpemUgKyAnIHNhdG9zaGlzIHRvIGF2b2lkIHdhc3RpbmcgbW9uZXkgb24gZmVlcy4gVG8gY29uc29saWRhdGUgc21hbGxlciB1bnNwZW50cywgdXNlIGEgbG93ZXIgZmVlIHJhdGUuJyk7XG4gICAgfVxuICB9XG5cbiAgbGV0IGl0ZXJhdGlvbkNvdW50ID0gMDtcblxuICBjb25zdCBzZWxmID0gdGhpcztcbiAgbGV0IGNvbnNvbGlkYXRpb25JbmRleCA9IDA7XG5cbiAgLyoqXG4gICAqIENvbnNvbGlkYXRlIG9uZSBiYXRjaCBvZiB1cCB0byBNQVhfSU5QVVRfQ09VTlQgdW5zcGVudHMuXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgY29uc3QgcnVuTmV4dENvbnNvbGlkYXRpb24gPSBjbyhmdW5jdGlvbiAqKCkge1xuICAgIGNvbnN0IGNvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnM6IGFueVtdID0gW107XG4gICAgbGV0IGlzRmluYWxDb25zb2xpZGF0aW9uID0gZmFsc2U7XG4gICAgaXRlcmF0aW9uQ291bnQrKztcbiAgICAvKlxuICAgICBXZSB0YWtlIGEgbWF4aW11bSBvZiB1bnNwZW50QnVsa1NpemVMaW1pdCB1bnNwZW50cyBmcm9tIHRoZSB3YWxsZXQuIFdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgd2Ugc3dpcGUgdGhlIHdhbGxldFxuICAgICBjbGVhbiBvZiBhbGwgZXhjZXNzaXZlIHVuc3BlbnRzLCBzbyB3ZSBhZGQgMSB0byB0aGUgdGFyZ2V0IHVuc3BlbnQgY291bnQgdG8gbWFrZSBzdXJlIHdlIGhhdmVuJ3QgbWlzc2VkIGFueXRoaW5nLlxuICAgICBJbiBjYXNlIHRoZXJlIGFyZSBldmVuIG1vcmUgdW5zcGVudHMgdGhhbiB0aGF0LCB0byBtYWtlIHRoZSBjb25zb2xpZGF0aW9uIGFzIGZhc3QgYXMgcG9zc2libGUsIHdlIGV4cGFuZCBvdXJcbiAgICAgc2VsZWN0aW9uIHRvIGluY2x1ZGUgYXMgbWFueSBhcyB0aGUgbWF4aW11bSBwZXJtaXNzaWJsZSBudW1iZXIgb2YgaW5wdXRzIHBlciBjb25zb2xpZGF0aW9uIGJhdGNoLlxuICAgICBTaG91bGQgdGhlIHRhcmdldCBudW1iZXIgb2YgdW5zcGVudHMgYmUgaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gbnVtYmVyIGlmIGlucHV0cyBwZXIgY29uc29saWRhdGlvbixcbiAgICAgd2Ugc3RpbGwgd2FudCB0byBmZXRjaCB0aGVtIGFsbCBzaW1wbHkgdG8gYmUgYWJsZSB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBjb25zb2xpZGF0aW9uIGNhbiBiZSBwZXJmb3JtZWRcbiAgICAgYXQgYWxsLCB3aGljaCBpcyBkZXBlbmRlbnQgb24gdGhlIG51bWJlciBvZiBhbGwgdW5zcGVudHMgYmVpbmcgaGlnaGVyIHRoYW4gdGhlIHRhcmdldC5cbiAgICAgSW4gdGhlIG5leHQgdmVyc2lvbiBvZiB0aGUgdW5zcGVudHMgdmVyc2lvbiBTREssIHdlIHdpbGwga25vdyB0aGUgdG90YWwgbnVtYmVyIG9mIHVuc3BlbnRzIHdpdGhvdXQgaGF2aW5nIHRvIGZldGNoXG4gICAgIHRoZW0sIGFuZCB0aGVyZWZvcmUgd2lsbCBiZSBhYmxlIHRvIHNpbXBsaWZ5IHRoaXMgbWV0aG9kLlxuICAgICAqL1xuXG4gICAgY29uc3QgcXVlcnlQYXJhbXM6IGFueSA9IHtcbiAgICAgIGxpbWl0OiB0YXJnZXQgKyBtYXhJbnB1dENvdW50LFxuICAgICAgbWluQ29uZmlybXM6IG1pbkNvbmZpcm1zLFxuICAgICAgbWluU2l6ZTogbWluU2l6ZVxuICAgIH07XG4gICAgaWYgKHBhcmFtcy5tYXhTaXplKSB7XG4gICAgICBxdWVyeVBhcmFtcy5tYXhTaXplID0gcGFyYW1zLm1heFNpemU7XG4gICAgfVxuICAgIGNvbnN0IGFsbFVuc3BlbnRzID0geWllbGQgc2VsZi51bnNwZW50cyhxdWVyeVBhcmFtcyk7XG4gICAgLy8gdGhpcyBjb25zb2xpZGF0aW9uIGlzIGVzc2VudGlhbGx5IGp1c3QgYSB3YXN0ZSBvZiBtb25leVxuICAgIGlmIChhbGxVbnNwZW50cy5sZW5ndGggPD0gdGFyZ2V0KSB7XG4gICAgICBpZiAoaXRlcmF0aW9uQ291bnQgPD0gMSkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBmaXJzdCBpdGVyYXRpb24sIHNvIHRoZSBtZXRob2QgaXMgaW5jb3JyZWN0XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmV3ZXIgdW5zcGVudHMgdGhhbiBjb25zb2xpZGF0aW9uIHRhcmdldC4gVXNlIGZhbk91dFVuc3BlbnRzIGluc3RlYWQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpdCdzIGEgbGF0ZXIgaXRlcmF0aW9uLCBzbyB0aGUgdGFyZ2V0IG1heSBoYXZlIGJlZW4gc3VycGFzc2VkIChkdWUgdG8gY29uZmlybWF0aW9ucyBpbiB0aGUgYmFja2dyb3VuZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb25lJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYWxsVW5zcGVudHNDb3VudCA9IGFsbFVuc3BlbnRzLmxlbmd0aDtcblxuICAgIC8vIGhvdyBtYW55IG9mIHRoZSB1bnNwZW50cyBkbyB3ZSB3YW50IHRvIGNvbnNvbGlkYXRlP1xuICAgIC8vIHRoZSArMSBpcyBiZWNhdXNlIHRoZSBjb25zb2xpZGF0ZWQgYmxvY2sgYmVjb21lcyBhIG5ldyB1bnNwZW50IGxhdGVyXG4gICAgbGV0IHRhcmdldElucHV0Q291bnQgPSBhbGxVbnNwZW50c0NvdW50IC0gdGFyZ2V0ICsgMTtcbiAgICB0YXJnZXRJbnB1dENvdW50ID0gTWF0aC5taW4odGFyZ2V0SW5wdXRDb3VudCwgYWxsVW5zcGVudHMubGVuZ3RoKTtcblxuICAgIC8vIGlmIHRoZSB0YXJnZXRJbnB1dENvdW50IHJlcXVpcmVzIG1vcmUgaW5wdXRzIHRoYW4gd2UgYWxsb3cgcGVyIGJhdGNoLCB3ZSByZWR1Y2UgdGhlIG51bWJlclxuICAgIGNvbnN0IGlucHV0Q291bnQgPSBNYXRoLm1pbih0YXJnZXRJbnB1dENvdW50LCBtYXhJbnB1dENvdW50KTtcblxuICAgIC8vIGlmIGVpdGhlciB0aGUgbnVtYmVyIG9mIGlucHV0cyBsZWZ0IHRvIGNvYWxlc2NlIGVxdWFscyB0aGUgbnVtYmVyIHdlIHdpbGwgY29hbGVzY2UgaW4gdGhpcyBpdGVyYXRpb25cbiAgICAvLyBvciBpZiB0aGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgbWF0Y2hlcyB0aGUgbWF4aW11bSBwZXJtaXR0ZWQgbnVtYmVyXG4gICAgaXNGaW5hbENvbnNvbGlkYXRpb24gPSAoaW5wdXRDb3VudCA9PT0gdGFyZ2V0SW5wdXRDb3VudCB8fCBpdGVyYXRpb25Db3VudCA9PT0gbWF4SXRlcmF0aW9uQ291bnQpO1xuXG4gICAgY29uc3QgY3VycmVudENodW5rID0gYWxsVW5zcGVudHMuc3BsaWNlKDAsIGlucHV0Q291bnQpO1xuICAgIGNvbnN0IGNoYW5nZUNoYWluID0gc2VsZi5nZXRDaGFuZ2VDaGFpbihwYXJhbXMpO1xuICAgIGNvbnN0IG5ld0FkZHJlc3MgPSB5aWVsZCBzZWxmLmNyZWF0ZUFkZHJlc3MoeyBjaGFpbjogY2hhbmdlQ2hhaW4sIHZhbGlkYXRlOiB2YWxpZGF0ZSB9KTtcbiAgICBjb25zdCB0eFBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBwYXJhbXMpO1xuICAgIGNvbnN0IGN1cnJlbnRBZGRyZXNzID0gbmV3QWRkcmVzcztcbiAgICAvLyB0aGUgdG90YWwgYW1vdW50IHRoYXQgd2UgYXJlIGNvbnNvbGlkYXRpbmcgd2l0aGluIHRoaXMgYmF0Y2hcbiAgICBjb25zdCBncm9zc0Ftb3VudCA9IF8oY3VycmVudENodW5rKS5tYXAoJ3ZhbHVlJykuc3VtKCk7IC8vIGJlZm9yZSBmZWVzXG5cbiAgICB0eFBhcmFtcy51bnNwZW50cyA9IGN1cnJlbnRDaHVuaztcbiAgICB0eFBhcmFtcy5yZWNpcGllbnRzID0ge307XG4gICAgdHhQYXJhbXMucmVjaXBpZW50c1tuZXdBZGRyZXNzLmFkZHJlc3NdID0gZ3Jvc3NBbW91bnQ7XG4gICAgdHhQYXJhbXMubm9TcGxpdENoYW5nZSA9IHRydWU7XG5cbiAgICBpZiAodHhQYXJhbXMudW5zcGVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRG9uZScpO1xuICAgIH1cblxuICAgIC8vIGxldCdzIGF0dGVtcHQgdG8gY3JlYXRlIHRoaXMgdHJhbnNhY3Rpb24uIFdlIGV4cGVjdCBpdCB0byBmYWlsIGJlY2F1c2Ugbm8gZmVlIGlzIHNldC5cbiAgICB0cnkge1xuICAgICAgeWllbGQgc2VsZi5zZW5kTWFueSh0eFBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHRoaXMgZXJyb3Igc2hvdWxkIG9jY3VyIGR1ZSB0byBpbnN1ZmZpY2llbnQgZnVuZHNcbiAgICAgIC8vIGhvd2V2ZXIsIGxldCdzIG1ha2Ugc3VyZSBpdCB3YXNuJ3Qgc29tZXRoaW5nIGVsc2VcbiAgICAgIGlmICghZXJyb3IuZmVlICYmICghZXJyb3IucmVzdWx0IHx8ICFlcnJvci5yZXN1bHQuZmVlKSkge1xuICAgICAgICAvLyBpZiB0aGUgZXJyb3IgZG9lcyBub3QgY29udGFpbiBhIGZlZSBwcm9wZXJ0eSwgaXQgaXMgc29tZXRoaW5nIGVsc2UgdGhhdCBoYXMgZ29uZSBhd3J5LCBhbmQgd2UgdGhyb3cgaXRcbiAgICAgICAgY29uc3QgZGVidWdQYXJhbXMgPSBfLm9taXQodHhQYXJhbXMsIFsnd2FsbGV0UGFzc3BocmFzZScsICd4cHJ2J10pO1xuICAgICAgICBlcnJvci5tZXNzYWdlICs9IGBcXG5cXG5UWCBQQVJBTVM6XFxuICR7SlNPTi5zdHJpbmdpZnkoZGVidWdQYXJhbXMsIG51bGwsIDQpfWA7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgY29uc3QgYmFzZUZlZSA9IGVycm9yLmZlZSB8fCBlcnJvci5yZXN1bHQuZmVlO1xuICAgICAgbGV0IGJpdGdvRmVlID0gMDtcbiAgICAgIGxldCB0b3RhbEZlZSA9IGJhc2VGZWU7XG4gICAgICBpZiAoZXJyb3IucmVzdWx0LmJpdGdvRmVlICYmIGVycm9yLnJlc3VsdC5iaXRnb0ZlZS5hbW91bnQpIHtcbiAgICAgICAgYml0Z29GZWUgPSBlcnJvci5yZXN1bHQuYml0Z29GZWUuYW1vdW50O1xuICAgICAgICB0b3RhbEZlZSArPSBiaXRnb0ZlZTtcbiAgICAgICAgdHhQYXJhbXMuYml0Z29GZWUgPSBlcnJvci5yZXN1bHQuYml0Z29GZWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSBuZXQgYW1vdW50IGlzIG5lZ2F0aXZlLCBpdCBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCB0aGUgbWluaW11bSBvdXRwdXQgc2l6ZVxuICAgICAgY29uc3QgbmV0QW1vdW50ID0gTWF0aC5tYXgoZXJyb3IucmVzdWx0LmF2YWlsYWJsZSAtIHRvdGFsRmVlLCBzZWxmLmJpdGdvLmdldENvbnN0YW50cygpLm1pbk91dHB1dFNpemUpO1xuICAgICAgLy8gTmVlZCB0byBjbGVhciB0aGVzZSBvdXQgc2luY2Ugb25seSAxIG1heSBiZSBzZXRcbiAgICAgIGRlbGV0ZSB0eFBhcmFtcy5mZWU7XG4gICAgICB0eFBhcmFtcy5vcmlnaW5hbEZlZVJhdGUgPSB0eFBhcmFtcy5mZWVSYXRlO1xuICAgICAgZGVsZXRlIHR4UGFyYW1zLmZlZVJhdGU7XG4gICAgICBkZWxldGUgdHhQYXJhbXMuZmVlVHhDb25maXJtVGFyZ2V0O1xuXG4gICAgICAvLyB3ZSBzZXQgdGhlIGZlZSBleHBsaWNpdGx5XG4gICAgICB0eFBhcmFtcy5mZWUgPSBlcnJvci5yZXN1bHQuYXZhaWxhYmxlIC0gbmV0QW1vdW50IC0gYml0Z29GZWU7XG4gICAgICB0eFBhcmFtcy5yZWNpcGllbnRzW25ld0FkZHJlc3MuYWRkcmVzc10gPSBuZXRBbW91bnQ7XG4gICAgfVxuICAgIC8vIHRoaXMgdHJhbnNhY3Rpb24sIG9uIHRoZSBvdGhlciBoYW5kLCBzaG91bGQgYmUgY3JlYXRlZCB3aXRoIG5vIGlzc3VlcywgYmVjYXVzZSBhbiBhcHByb3ByaWF0ZSBmZWUgaXMgc2V0XG4gICAgbGV0IHNlbnRUeDtcbiAgICB0cnkge1xuICAgICAgc2VudFR4ID0geWllbGQgc2VsZi5zZW5kTWFueSh0eFBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgZGVidWdQYXJhbXMgPSBfLm9taXQodHhQYXJhbXMsIFsnd2FsbGV0UGFzc3BocmFzZScsICd4cHJ2J10pO1xuICAgICAgZS5tZXNzYWdlICs9IGBcXG5cXG5UWCBQQVJBTVM6XFxuICR7SlNPTi5zdHJpbmdpZnkoZGVidWdQYXJhbXMsIG51bGwsIDQpfWA7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zLnB1c2goc2VudFR4KTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHBhcmFtcy5wcm9ncmVzc0NhbGxiYWNrKSkge1xuICAgICAgcGFyYW1zLnByb2dyZXNzQ2FsbGJhY2soe1xuICAgICAgICB0eGlkOiBzZW50VHguaGFzaCxcbiAgICAgICAgZGVzdGluYXRpb246IGN1cnJlbnRBZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IGdyb3NzQW1vdW50LFxuICAgICAgICBmZWU6IHNlbnRUeC5mZWUsXG4gICAgICAgIGlucHV0Q291bnQ6IGlucHV0Q291bnQsXG4gICAgICAgIGluZGV4OiBjb25zb2xpZGF0aW9uSW5kZXhcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zb2xpZGF0aW9uSW5kZXgrKztcbiAgICBpZiAoIWlzRmluYWxDb25zb2xpZGF0aW9uKSB7XG4gICAgICAvLyB0aGlzIGxhc3QgY29uc29saWRhdGlvbiBoYXMgbm90IHlldCBicm91Z2h0IHRoZSB1bnNwZW50cyBjb3VudCBkb3duIHRvIHRoZSB0YXJnZXQgdW5zcGVudCBjb3VudFxuICAgICAgLy8gdGhlcmVmb3JlLCB3ZSBwcm9jZWVkIGJ5IGNvbnNvbGlkYXRpbmcgeWV0IGFub3RoZXIgYmF0Y2hcbiAgICAgIC8vIGJlZm9yZSB3ZSBkbyB0aGF0LCB3ZSB3YWl0IDEgc2Vjb25kIHNvIHRoYXQgdGhlIG5ld2x5IGNyZWF0ZWQgdW5zcGVudCB3aWxsIGJlIGZldGNoZWQgaW4gdGhlIG5leHQgYmF0Y2hcbiAgICAgIHlpZWxkIEJsdWViaXJkLmRlbGF5KDEwMDApO1xuICAgICAgY29uc29saWRhdGlvblRyYW5zYWN0aW9ucy5wdXNoKC4uLnlpZWxkIHJ1bk5leHRDb25zb2xpZGF0aW9uKCkpO1xuICAgIH1cbiAgICAvLyB0aGlzIGlzIHRoZSBmaW5hbCBjb25zb2xpZGF0aW9uIHRyYW5zYWN0aW9uLiBXZSByZXR1cm4gYWxsIHRoZSBvbmVzIHdlJ3ZlIGhhZCBzbyBmYXJcbiAgICByZXR1cm4gY29uc29saWRhdGlvblRyYW5zYWN0aW9ucztcbiAgfSk7XG5cbiAgcmV0dXJuIHJ1bk5leHRDb25zb2xpZGF0aW9uKHRoaXMsIHRhcmdldClcbiAgLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChlcnIubWVzc2FnZSA9PT0gJ0RvbmUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfSlcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5zaGFyZVdhbGxldCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2VtYWlsJywgJ3Blcm1pc3Npb25zJ10sIFsnd2FsbGV0UGFzc3BocmFzZScsICdtZXNzYWdlJ10sIGNhbGxiYWNrKTtcblxuICBpZiAocGFyYW1zLnJlc2hhcmUgIT09IHVuZGVmaW5lZCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLnJlc2hhcmUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZXNoYXJlIHRvIGJlIGEgYm9vbGVhbi4nKTtcbiAgfVxuXG4gIGlmIChwYXJhbXMuc2tpcEtleWNoYWluICE9PSB1bmRlZmluZWQgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5za2lwS2V5Y2hhaW4pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBza2lwS2V5Y2hhaW4gdG8gYmUgYSBib29sZWFuLiAnKTtcbiAgfVxuICBjb25zdCBuZWVkc0tleWNoYWluID0gIXBhcmFtcy5za2lwS2V5Y2hhaW4gJiYgcGFyYW1zLnBlcm1pc3Npb25zLmluZGV4T2YoJ3NwZW5kJykgIT09IC0xO1xuXG4gIGlmIChwYXJhbXMuZGlzYWJsZUVtYWlsICE9PSB1bmRlZmluZWQgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5kaXNhYmxlRW1haWwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBkaXNhYmxlRW1haWwgdG8gYmUgYSBib29sZWFuLicpO1xuICB9XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGxldCBzaGFyaW5nO1xuICBsZXQgc2hhcmVkS2V5Y2hhaW47XG4gIHJldHVybiB0aGlzLmJpdGdvLmdldFNoYXJpbmdLZXkoeyBlbWFpbDogcGFyYW1zLmVtYWlsLnRvTG93ZXJDYXNlKCkgfSlcbiAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgc2hhcmluZyA9IHJlc3VsdDtcblxuICAgIGlmIChuZWVkc0tleWNoYWluKSB7XG4gICAgICByZXR1cm4gc2VsZi5nZXRFbmNyeXB0ZWRVc2VyS2V5Y2hhaW4oe30pXG4gICAgICAudGhlbihmdW5jdGlvbihrZXljaGFpbikge1xuICAgICAgICAvLyBEZWNyeXB0IHRoZSB1c2VyIGtleSB3aXRoIGEgcGFzc3BocmFzZVxuICAgICAgICBpZiAoa2V5Y2hhaW4uZW5jcnlwdGVkWHBydikge1xuICAgICAgICAgIGlmICghcGFyYW1zLndhbGxldFBhc3NwaHJhc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB3YWxsZXRQYXNzcGhyYXNlIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBrZXljaGFpbi54cHJ2ID0gc2VsZi5iaXRnby5kZWNyeXB0KHsgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLCBpbnB1dDoga2V5Y2hhaW4uZW5jcnlwdGVkWHBydiB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZWNyeXB0IHVzZXIga2V5Y2hhaW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBlY2tleSA9IG1ha2VSYW5kb21LZXkoKTtcbiAgICAgICAgICBjb25zdCBzZWNyZXQgPSBzZWxmLmJpdGdvLmdldEVDREhTZWNyZXQoeyBlY2tleTogZWNrZXksIG90aGVyUHViS2V5SGV4OiBzaGFyaW5nLnB1YmtleSB9KTtcbiAgICAgICAgICBjb25zdCBuZXdFbmNyeXB0ZWRYcHJ2ID0gc2VsZi5iaXRnby5lbmNyeXB0KHsgcGFzc3dvcmQ6IHNlY3JldCwgaW5wdXQ6IGtleWNoYWluLnhwcnYgfSk7XG5cbiAgICAgICAgICBzaGFyZWRLZXljaGFpbiA9IHtcbiAgICAgICAgICAgIHhwdWI6IGtleWNoYWluLnhwdWIsXG4gICAgICAgICAgICBlbmNyeXB0ZWRYcHJ2OiBuZXdFbmNyeXB0ZWRYcHJ2LFxuICAgICAgICAgICAgZnJvbVB1YktleTogZWNrZXkuZ2V0UHVibGljS2V5QnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICAgICAgdG9QdWJLZXk6IHNoYXJpbmcucHVia2V5LFxuICAgICAgICAgICAgcGF0aDogc2hhcmluZy5wYXRoXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KVxuICAudGhlbihmdW5jdGlvbigpIHtcbiAgICBpbnRlcmZhY2UgT3B0aW9ucyB7XG4gICAgICB1c2VyOiBhbnk7XG4gICAgICBwZXJtaXNzaW9uczogc3RyaW5nO1xuICAgICAgcmVzaGFyZTogYm9vbGVhbjtcbiAgICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICAgIGRpc2FibGVFbWFpbDogYW55O1xuICAgICAga2V5Y2hhaW4/OiBhbnk7XG4gICAgICBza2lwS2V5Y2hhaW4/OiBib29sZWFuXG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9uczogT3B0aW9ucyA9IHtcbiAgICAgIHVzZXI6IHNoYXJpbmcudXNlcklkLFxuICAgICAgcGVybWlzc2lvbnM6IHBhcmFtcy5wZXJtaXNzaW9ucyxcbiAgICAgIHJlc2hhcmU6IHBhcmFtcy5yZXNoYXJlLFxuICAgICAgbWVzc2FnZTogcGFyYW1zLm1lc3NhZ2UsXG4gICAgICBkaXNhYmxlRW1haWw6IHBhcmFtcy5kaXNhYmxlRW1haWxcbiAgICB9O1xuICAgIGlmIChzaGFyZWRLZXljaGFpbikge1xuICAgICAgb3B0aW9ucy5rZXljaGFpbiA9IHNoYXJlZEtleWNoYWluO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLnNraXBLZXljaGFpbikge1xuICAgICAgb3B0aW9ucy5rZXljaGFpbiA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLmNyZWF0ZVNoYXJlKG9wdGlvbnMpO1xuICB9KVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLnJlbW92ZVVzZXIgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd1c2VyJ10sIFtdLCBjYWxsYmFjayk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZGVsKHRoaXMudXJsKCcvdXNlci8nICsgcGFyYW1zLnVzZXIpKVxuICAuc2VuZCgpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLmdldFBvbGljeSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgW10sIGNhbGxiYWNrKTtcblxuICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy51cmwoJy9wb2xpY3knKSlcbiAgLnNlbmQoKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5nZXRQb2xpY3lTdGF0dXMgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMudXJsKCcvcG9saWN5L3N0YXR1cycpKVxuICAuc2VuZCgpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLnNldFBvbGljeVJ1bGUgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCcsICd0eXBlJ10sIFsnbWVzc2FnZSddLCBjYWxsYmFjayk7XG5cbiAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcy5jb25kaXRpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBhcmFtZXRlcjogY29uZGl0aW9ucyBvYmplY3QnKTtcbiAgfVxuXG4gIGlmICghXy5pc09iamVjdChwYXJhbXMuYWN0aW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwYXJhbWV0ZXI6IGFjdGlvbiBvYmplY3QnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmJpdGdvLnB1dCh0aGlzLnVybCgnL3BvbGljeS9ydWxlJykpXG4gIC5zZW5kKHBhcmFtcylcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbldhbGxldC5wcm90b3R5cGUucmVtb3ZlUG9saWN5UnVsZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2lkJ10sIFsnbWVzc2FnZSddLCBjYWxsYmFjayk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZGVsKHRoaXMudXJsKCcvcG9saWN5L3J1bGUnKSlcbiAgLnNlbmQocGFyYW1zKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuV2FsbGV0LnByb3RvdHlwZS5saXN0V2ViaG9va3MgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgW10sIFtdLCBjYWxsYmFjayk7XG5cbiAgcmV0dXJuIHRoaXMuYml0Z28uZ2V0KHRoaXMudXJsKCcvd2ViaG9va3MnKSlcbiAgLnNlbmQoKVxuICAucmVzdWx0KClcbiAgLm5vZGVpZnkoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTaW11bGF0ZSB3YWxsZXQgd2ViaG9vaywgY3VycmVudGx5IGZvciB3ZWJob29rcyBvZiB0eXBlIHRyYW5zYWN0aW9uIGFuZCBwZW5kaW5nIGFwcHJvdmFsXG4gKiBAcGFyYW0gcGFyYW1zXG4gKiAtIHdlYmhvb2tJZCAocmVxdWlyZWQpOiBpZCBvZiB0aGUgd2ViaG9vayB0byBiZSBzaW11bGF0ZWRcbiAqIC0gdHhIYXNoIChvcHRpb25hbCBidXQgcmVxdWlyZWQgZm9yIHRyYW5zYWN0aW9uIHdlYmhvb2tzKSBoYXNoIG9mIHRoZSBzaW11bGF0ZWQgdHJhbnNhY3Rpb25cbiAqIC0gcGVuZGluZ0FwcHJvdmFsSWQgKG9wdGlvbmFsIGJ1dCByZXF1aXJlZCBmb3IgcGVuZGluZyBhcHByb3ZhbCB3ZWJob29rcykgaWQgb2YgdGhlIHNpbXVsYXRlZCBwZW5kaW5nIGFwcHJvdmFsXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHsqfVxuICovXG5XYWxsZXQucHJvdG90eXBlLnNpbXVsYXRlV2ViaG9vayA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dlYmhvb2tJZCddLCBbJ3R4SGFzaCcsICdwZW5kaW5nQXBwcm92YWxJZCddLCBjYWxsYmFjayk7XG5cbiAgY29uc3QgaGFzVHhIYXNoID0gISFwYXJhbXMudHhIYXNoO1xuICBjb25zdCBoYXNQZW5kaW5nQXBwcm92YWxJZCA9ICEhcGFyYW1zLnBlbmRpbmdBcHByb3ZhbElkO1xuXG4gIGlmICgoaGFzVHhIYXNoICYmIGhhc1BlbmRpbmdBcHByb3ZhbElkKSB8fCAoIWhhc1R4SGFzaCAmJiAhaGFzUGVuZGluZ0FwcHJvdmFsSWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHN1cHBseSBlaXRoZXIgdHhIYXNoIG9yIHBlbmRpbmdBcHByb3ZhbElkLCBidXQgbm90IGJvdGgnKTtcbiAgfVxuXG4gIC8vIGRlcGVuZGluZyBvbiB0aGUgY29pbiB0eXBlIG9mIHRoZSB3YWxsZXQsIHRoZSB0eEhhc2ggaGFzIHRvIGFkaGVyZSB0byBpdHMgcmVzcGVjdGl2ZSBmb3JtYXRcbiAgLy8gYnV0IHRoZSBzZXJ2ZXIgdGFrZXMgY2FyZSBvZiB0aGF0XG5cbiAgLy8gb25seSB0YWtlIHRoZSB0eEhhc2ggYW5kIHBlbmRpbmdBcHByb3ZhbElkIHByb3BlcnRpZXNcbiAgY29uc3QgZmlsdGVyZWRQYXJhbXMgPSBfLnBpY2socGFyYW1zLCBbJ3R4SGFzaCcsICdwZW5kaW5nQXBwcm92YWxJZCddKTtcblxuICBjb25zdCB3ZWJob29rSWQgPSBwYXJhbXMud2ViaG9va0lkO1xuICByZXR1cm4gdGhpcy5iaXRnby5wb3N0KHRoaXMudXJsKCcvd2ViaG9va3MvJyArIHdlYmhvb2tJZCArICcvc2ltdWxhdGUnKSlcbiAgLnNlbmQoZmlsdGVyZWRQYXJhbXMpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLmFkZFdlYmhvb2sgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd1cmwnLCAndHlwZSddLCBbXSwgY2FsbGJhY2spO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLnBvc3QodGhpcy51cmwoJy93ZWJob29rcycpKVxuICAuc2VuZChwYXJhbXMpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLnJlbW92ZVdlYmhvb2sgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd1cmwnLCAndHlwZSddLCBbXSwgY2FsbGJhY2spO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLmRlbCh0aGlzLnVybCgnL3dlYmhvb2tzJykpXG4gIC5zZW5kKHBhcmFtcylcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbldhbGxldC5wcm90b3R5cGUuZXN0aW1hdGVGZWUgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuXG4gIGlmIChwYXJhbXMuYW1vdW50ICYmIHBhcmFtcy5yZWNpcGllbnRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3BlY2lmeSBib3RoIGFtb3VudCBhcyB3ZWxsIGFzIHJlY2lwaWVudHMnKTtcbiAgfVxuICBpZiAocGFyYW1zLnJlY2lwaWVudHMgJiYgIV8uaXNPYmplY3QocGFyYW1zLnJlY2lwaWVudHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZWNpcGllbnRzIG11c3QgYmUgYXJyYXkgb2YgeyBhZGRyZXNzOiBhYmMsIGFtb3VudDogMTAwMDAwIH0gb2JqZWN0cycpO1xuICB9XG4gIGlmIChwYXJhbXMuYW1vdW50ICYmICFfLmlzTnVtYmVyKHBhcmFtcy5hbW91bnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFtb3VudCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICB9XG5cbiAgY29uc3QgcmVjaXBpZW50cyA9IHBhcmFtcy5yZWNpcGllbnRzIHx8IFtdO1xuXG4gIGlmIChwYXJhbXMuYW1vdW50KSB7XG4gICAgLy8gb25seSB0aGUgYW1vdW50IHdhcyBwYXNzZWQgaW4sIHNvIHdlIG5lZWQgdG8gbWFrZSBhIGZhbHNlIHJlY2lwaWVudCB0byBydW4gY3JlYXRlVHJhbnNhY3Rpb24gd2l0aFxuICAgIHJlY2lwaWVudHMucHVzaCh7XG4gICAgICBhZGRyZXNzOiBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZW52XS5zaWduaW5nQWRkcmVzcywgLy8gYW55IGFkZHJlc3Mgd2lsbCBkb1xuICAgICAgYW1vdW50OiBwYXJhbXMuYW1vdW50XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCB0cmFuc2FjdGlvblBhcmFtcyA9IF8uZXh0ZW5kKHt9LCBwYXJhbXMpO1xuICB0cmFuc2FjdGlvblBhcmFtcy5hbW91bnQgPSB1bmRlZmluZWQ7XG4gIHRyYW5zYWN0aW9uUGFyYW1zLnJlY2lwaWVudHMgPSByZWNpcGllbnRzO1xuXG4gIHJldHVybiB0aGlzLmNyZWF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uUGFyYW1zKVxuICAudGhlbihmdW5jdGlvbih0eCkge1xuICAgIHJldHVybiB7XG4gICAgICBlc3RpbWF0ZWRTaXplOiB0eC5lc3RpbWF0ZWRTaXplLFxuICAgICAgZmVlOiB0eC5mZWUsXG4gICAgICBmZWVSYXRlOiB0eC5mZWVSYXRlXG4gICAgfTtcbiAgfSk7XG59O1xuXG4vLyBOb3QgZnVsbHkgaW1wbGVtZW50ZWQgLyByZWxlYXNlZCBvbiBTREsuIFRlc3RpbmcgZm9yIG5vdy5cbldhbGxldC5wcm90b3R5cGUudXBkYXRlUG9saWN5UnVsZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2lkJywgJ3R5cGUnXSwgW10sIGNhbGxiYWNrKTtcblxuICByZXR1cm4gdGhpcy5iaXRnby5wdXQodGhpcy51cmwoJy9wb2xpY3kvcnVsZScpKVxuICAuc2VuZChwYXJhbXMpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG5XYWxsZXQucHJvdG90eXBlLmRlbGV0ZVBvbGljeVJ1bGUgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCddLCBbXSwgY2FsbGJhY2spO1xuXG4gIHJldHVybiB0aGlzLmJpdGdvLmRlbCh0aGlzLnVybCgnL3BvbGljeS9ydWxlJykpXG4gIC5zZW5kKHBhcmFtcylcbiAgLnJlc3VsdCgpXG4gIC5ub2RlaWZ5KGNhbGxiYWNrKTtcbn07XG5cbi8vXG4vLyBnZXRCaXRHb0ZlZVxuLy8gR2V0IHRoZSByZXF1aXJlZCBvbi10cmFuc2FjdGlvbiBCaXRHbyBmZWVcbi8vXG5XYWxsZXQucHJvdG90eXBlLmdldEJpdEdvRmVlID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbXSwgY2FsbGJhY2spO1xuICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLmFtb3VudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYW1vdW50IGFyZ3VtZW50Jyk7XG4gIH1cbiAgaWYgKHBhcmFtcy5pbnN0YW50ICYmICFfLmlzQm9vbGVhbihwYXJhbXMuaW5zdGFudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdGFudCBhcmd1bWVudCcpO1xuICB9XG4gIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL2JpbGxpbmcvZmVlJykpXG4gIC5xdWVyeShwYXJhbXMpXG4gIC5yZXN1bHQoKVxuICAubm9kZWlmeShjYWxsYmFjayk7XG59O1xuXG5leHBvcnQgPSBXYWxsZXQ7XG4iXX0=