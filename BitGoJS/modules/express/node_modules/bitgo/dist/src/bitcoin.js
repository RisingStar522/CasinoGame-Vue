"use strict";
/**
 * @hidden
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 */
var common = require("./common");
var bitcoin = require("@bitgo/utxo-lib");
var errors_1 = require("./errors");
var ecurve = require('ecurve');
var curve = ecurve.getCurveByName('secp256k1');
var BigInteger = require('bigi');
var createHmac = require('create-hmac');
var secp256k1;
try {
    secp256k1 = require('secp256k1');
}
catch (err) {
    console.log('running without secp256k1 acceleration');
}
function getNetwork(network) {
    network = network || common.getNetwork();
    return bitcoin.networks[network];
}
exports.getNetwork = getNetwork;
function makeRandomKey() {
    return bitcoin.ECPair.makeRandom({ network: getNetwork() });
}
exports.makeRandomKey = makeRandomKey;
function getKey(network) {
    network = network || getNetwork();
    var k = this.keyPair;
    var result = new bitcoin.ECPair(k.d, k.d ? null : k.Q, { network: network, compressed: k.compressed });
    // Creating Q from d takes ~25ms, so if it's not created, use native bindings to pre-compute
    if (!result.__Q && secp256k1) {
        result.__Q = ecurve.Point.decodeFrom(curve, secp256k1.publicKeyCreate(k.d.toBuffer(32), false));
    }
    return result;
}
bitcoin.HDNode.prototype.getKey = getKey;
/**
 * Given a key and a path, derive the child key.
 * @param {bitcoin.HDNode} userKey
 * @param {string} path
 * @returns {bitcoin.HDNode}
 */
function deriveKeyByPath(userKey, path) {
    var key = userKey;
    var splitPath = path.split('/');
    // if a key path starts with "m", it is the path for a master node. derivePath() is used specifically for
    // deriving master node and we can call it directly.
    if (splitPath[0] === 'm') {
        key = userKey.derivePath(path);
    }
    else {
        // if the path does not start with "m", it typically looks like "/x/y/...", and the splitPath
        // would look like ['', 'x', 'y',...], and we need to get ride of the empty string at index 0.
        // Then we continue deriving the child by calling derive() on the new child at each subsequent level.
        splitPath = splitPath.slice(1);
        for (var _i = 0, splitPath_1 = splitPath; _i < splitPath_1.length; _i++) {
            var p = splitPath_1[_i];
            var index = parseInt(p, 10);
            if (isNaN(index) || index.toString() != p) {
                throw new errors_1.InvalidKeyPathError(path);
            }
            key = key.derive(index);
        }
    }
    return key;
}
exports.deriveKeyByPath = deriveKeyByPath;
/**
 * Derive a child HDNode from a parent HDNode and index. Uses secp256k1 to speed
 * up public key derivations by 100x vs. bitcoinjs-lib implementation.
 *
 * @param   {HDNode} hdnode  parent HDNode
 * @param   {Number} index   child index
 * @returns {HDNode}         derived HDNode
 */
function deriveFast(hdnode, index) {
    // no fast path for private key derivations -- delegate to standard method
    if (!secp256k1 || hdnode.keyPair.d) {
        return hdnode.derive(index);
    }
    var isHardened = index >= bitcoin.HDNode.HIGHEST_BIT;
    if (isHardened) {
        throw new Error('cannot derive hardened key from public key');
    }
    var indexBuffer = Buffer.alloc(4);
    indexBuffer.writeUInt32BE(index, 0);
    // data = serP(point(kpar)) || ser32(index)
    //      = serP(Kpar) || ser32(index)
    var data = Buffer.concat([
        hdnode.keyPair.getPublicKeyBuffer(),
        indexBuffer,
    ]);
    var I = createHmac('sha512', hdnode.chainCode).update(data).digest();
    var IL = I.slice(0, 32);
    var IR = I.slice(32);
    var pIL = BigInteger.fromBuffer(IL);
    // In case parse256(IL) >= n, proceed with the next value for i
    if (pIL.compareTo(curve.n) >= 0) {
        return deriveFast(hdnode, index + 1);
    }
    // Private parent key -> private child key
    // Ki = point(parse256(IL)) + Kpar
    //    = G*IL + Kpar
    // The expensive op is the point multiply -- use secp256k1 lib to do that
    var Ki = ecurve.Point.decodeFrom(curve, secp256k1.publicKeyCreate(IL, false)).add(hdnode.keyPair.Q);
    // In case Ki is the point at infinity, proceed with the next value for i
    if (curve.isInfinity(Ki)) {
        return deriveFast(hdnode, index + 1);
    }
    var keyPair = new bitcoin.ECPair(null, Ki, { network: hdnode.keyPair.network });
    var hd = new bitcoin.HDNode(keyPair, IR);
    hd.depth = hdnode.depth + 1;
    hd.index = index;
    hd.parentFingerprint = hdnode.getFingerprint().readUInt32BE(0);
    return hd;
}
/**
 * Derive a BIP32 path, given a root key
 * We cache keys at each level of hierarchy we derive, to avoid re-deriving (approx 25ms per derivation)
 * @param rootKey key to derive off
 * @returns {*} function which can be used to derive a new HDNode from the root HDNode on a given path
 */
function hdPath(rootKey) {
    var cache = {};
    var derive = function (path) {
        var components = path.split('/').filter(function (c) {
            return c !== '';
        });
        // strip any extraneous / characters
        path = components.join('/');
        if (cache[path]) {
            return cache[path];
        }
        var len = components.length;
        if (len === 0 || len === 1 && components[0] === 'm') {
            return rootKey;
        }
        var parentPath = components.slice(0, len - 1).join('/');
        var parentKey = derive(parentPath);
        var el = components[len - 1];
        var hardened = false;
        if (el[el.length - 1] === "'") {
            hardened = true;
        }
        var index = parseInt(el, 10);
        var derived;
        if (hardened) {
            derived = parentKey.deriveHardened(index);
        }
        else {
            derived = deriveFast(parentKey, index);
        }
        cache[path] = derived;
        return derived;
    };
    function deriveKey(path) {
        var hdNode = derive(path);
        return hdNode.keyPair;
    }
    return {
        derive: derive,
        deriveKey: deriveKey,
    };
}
exports.hdPath = hdPath;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYml0Y29pbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9iaXRjb2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7R0FFRzs7QUFFSDtHQUNHO0FBQ0gsaUNBQW1DO0FBQ25DLHlDQUEyQztBQUUzQyxtQ0FBK0M7QUFDL0MsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ2pDLElBQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDakQsSUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ25DLElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUUxQyxJQUFJLFNBQVMsQ0FBQztBQUVkLElBQUk7SUFDRixTQUFTLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0NBQ2xDO0FBQUMsT0FBTyxHQUFHLEVBQUU7SUFDWixPQUFPLENBQUMsR0FBRyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7Q0FDdkQ7QUFFRCxTQUFnQixVQUFVLENBQUMsT0FBbUI7SUFDNUMsT0FBTyxHQUFHLE9BQU8sSUFBSSxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDekMsT0FBTyxPQUFPLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ25DLENBQUM7QUFIRCxnQ0FHQztBQUVELFNBQWdCLGFBQWE7SUFDM0IsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDOUQsQ0FBQztBQUZELHNDQUVDO0FBRUQsU0FBUyxNQUFNLENBQUMsT0FBeUI7SUFDdkMsT0FBTyxHQUFHLE9BQU8sSUFBSSxVQUFVLEVBQUUsQ0FBQztJQUNsQyxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3ZCLElBQU0sTUFBTSxHQUFH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QUFDLENBQUM7UUFFL0IsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxFQUFFO1lBQzdCLFFBQVEsR0FBRyxJQUFJLENBQUM7U0FDakI7UUFDRCxJQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQy9CLElBQUksT0FBTyxDQUFDO1FBQ1osSUFBSSxRQUFRLEVBQUU7WUFDWixPQUFPLEdBQUcsU0FBUyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMzQzthQUFNO1lBQ0wsT0FBTyxHQUFHLFVBQVUsQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDeEM7UUFDRCxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDO1FBQ3RCLE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUMsQ0FBQztJQUVGLFNBQVMsU0FBUyxDQUFDLElBQVk7UUFDN0IsSUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVCLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQztJQUN4QixDQUFDO0lBRUQsT0FBTztRQUNMLE1BQU0sRUFBRSxNQUFNO1FBQ2QsU0FBUyxFQUFFLFNBQVM7S0FDckIsQ0FBQztBQUNKLENBQUM7QUEzQ0Qsd0JBMkNDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaGlkZGVuXG4gKi9cblxuLyoqXG4gKi9cbmltcG9ydCAqIGFzIGNvbW1vbiBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgKiBhcyBiaXRjb2luIGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgeyBWMU5ldHdvcmsgfSBmcm9tICcuL3YyL3R5cGVzJztcbmltcG9ydCB7IEludmFsaWRLZXlQYXRoRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5jb25zdCBlY3VydmUgPSByZXF1aXJlKCdlY3VydmUnKTtcbmNvbnN0IGN1cnZlID0gZWN1cnZlLmdldEN1cnZlQnlOYW1lKCdzZWNwMjU2azEnKTtcbmNvbnN0IEJpZ0ludGVnZXIgPSByZXF1aXJlKCdiaWdpJyk7XG5jb25zdCBjcmVhdGVIbWFjID0gcmVxdWlyZSgnY3JlYXRlLWhtYWMnKTtcblxubGV0IHNlY3AyNTZrMTtcblxudHJ5IHtcbiAgc2VjcDI1NmsxID0gcmVxdWlyZSgnc2VjcDI1NmsxJyk7XG59IGNhdGNoIChlcnIpIHtcbiAgY29uc29sZS5sb2coJ3J1bm5pbmcgd2l0aG91dCBzZWNwMjU2azEgYWNjZWxlcmF0aW9uJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXR3b3JrKG5ldHdvcms/OiBWMU5ldHdvcmspOiBiaXRjb2luLk5ldHdvcmsge1xuICBuZXR3b3JrID0gbmV0d29yayB8fCBjb21tb24uZ2V0TmV0d29yaygpO1xuICByZXR1cm4gYml0Y29pbi5uZXR3b3Jrc1tuZXR3b3JrXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VSYW5kb21LZXkoKTogYml0Y29pbi5FQ1BhaXIge1xuICByZXR1cm4gYml0Y29pbi5FQ1BhaXIubWFrZVJhbmRvbSh7IG5ldHdvcms6IGdldE5ldHdvcmsoKSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0S2V5KG5ldHdvcms/OiBiaXRjb2luLk5ldHdvcmspOiBiaXRjb2luLkVDUGFpciB7XG4gIG5ldHdvcmsgPSBuZXR3b3JrIHx8IGdldE5ldHdvcmsoKTtcbiAgY29uc3QgayA9IHRoaXMua2V5UGFpcjtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IGJpdGNvaW4uRUNQYWlyKGsuZCwgay5kID8gbnVsbCA6IGsuUSwgeyBuZXR3b3JrOiBuZXR3b3JrLCBjb21wcmVzc2VkOiBrLmNvbXByZXNzZWQgfSk7XG4gIC8vIENyZWF0aW5nIFEgZnJvbSBkIHRha2VzIH4yNW1zLCBzbyBpZiBpdCdzIG5vdCBjcmVhdGVkLCB1c2UgbmF0aXZlIGJpbmRpbmdzIHRvIHByZS1jb21wdXRlXG4gIGlmICghcmVzdWx0Ll9fUSAmJiBzZWNwMjU2azEpIHtcbiAgICByZXN1bHQuX19RID0gZWN1cnZlLlBvaW50LmRlY29kZUZyb20oY3VydmUsIHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUoay5kLnRvQnVmZmVyKDMyKSwgZmFsc2UpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5iaXRjb2luLkhETm9kZS5wcm90b3R5cGUuZ2V0S2V5ID0gZ2V0S2V5O1xuXG4vKipcbiAqIEdpdmVuIGEga2V5IGFuZCBhIHBhdGgsIGRlcml2ZSB0aGUgY2hpbGQga2V5LlxuICogQHBhcmFtIHtiaXRjb2luLkhETm9kZX0gdXNlcktleVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHtiaXRjb2luLkhETm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZUtleUJ5UGF0aCh1c2VyS2V5OiBiaXRjb2luLkhETm9kZSwgcGF0aDogc3RyaW5nKTogYml0Y29pbi5IRE5vZGUge1xuICBsZXQga2V5ID0gdXNlcktleTtcbiAgbGV0IHNwbGl0UGF0aCA9IHBhdGguc3BsaXQoJy8nKTtcbiAgLy8gaWYgYSBrZXkgcGF0aCBzdGFydHMgd2l0aCBcIm1cIiwgaXQgaXMgdGhlIHBhdGggZm9yIGEgbWFzdGVyIG5vZGUuIGRlcml2ZVBhdGgoKSBpcyB1c2VkIHNwZWNpZmljYWxseSBmb3JcbiAgLy8gZGVyaXZpbmcgbWFzdGVyIG5vZGUgYW5kIHdlIGNhbiBjYWxsIGl0IGRpcmVjdGx5LlxuICBpZiAoc3BsaXRQYXRoWzBdID09PSAnbScpIHtcbiAgICBrZXkgPSB1c2VyS2V5LmRlcml2ZVBhdGgocGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgdGhlIHBhdGggZG9lcyBub3Qgc3RhcnQgd2l0aCBcIm1cIiwgaXQgdHlwaWNhbGx5IGxvb2tzIGxpa2UgXCIveC95Ly4uLlwiLCBhbmQgdGhlIHNwbGl0UGF0aFxuICAgIC8vIHdvdWxkIGxvb2sgbGlrZSBbJycsICd4JywgJ3knLC4uLl0sIGFuZCB3ZSBuZWVkIHRvIGdldCByaWRlIG9mIHRoZSBlbXB0eSBzdHJpbmcgYXQgaW5kZXggMC5cbiAgICAvLyBUaGVuIHdlIGNvbnRpbnVlIGRlcml2aW5nIHRoZSBjaGlsZCBieSBjYWxsaW5nIGRlcml2ZSgpIG9uIHRoZSBuZXcgY2hpbGQgYXQgZWFjaCBzdWJzZXF1ZW50IGxldmVsLlxuICAgIHNwbGl0UGF0aCA9IHNwbGl0UGF0aC5zbGljZSgxKTtcbiAgICBmb3IgKGNvbnN0IHAgb2Ygc3BsaXRQYXRoKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KHAsIDEwKTtcbiAgICAgIGlmIChpc05hTihpbmRleCkgfHwgaW5kZXgudG9TdHJpbmcoKSAhPSBwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkS2V5UGF0aEVycm9yKHBhdGgpO1xuICAgICAgfVxuICAgICAga2V5ID0ga2V5LmRlcml2ZShpbmRleCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXk7XG59XG5cbi8qKlxuICogRGVyaXZlIGEgY2hpbGQgSEROb2RlIGZyb20gYSBwYXJlbnQgSEROb2RlIGFuZCBpbmRleC4gVXNlcyBzZWNwMjU2azEgdG8gc3BlZWRcbiAqIHVwIHB1YmxpYyBrZXkgZGVyaXZhdGlvbnMgYnkgMTAweCB2cy4gYml0Y29pbmpzLWxpYiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0gICB7SEROb2RlfSBoZG5vZGUgIHBhcmVudCBIRE5vZGVcbiAqIEBwYXJhbSAgIHtOdW1iZXJ9IGluZGV4ICAgY2hpbGQgaW5kZXhcbiAqIEByZXR1cm5zIHtIRE5vZGV9ICAgICAgICAgZGVyaXZlZCBIRE5vZGVcbiAqL1xuZnVuY3Rpb24gZGVyaXZlRmFzdChoZG5vZGU6IGJpdGNvaW4uSEROb2RlLCBpbmRleDogbnVtYmVyKTogYml0Y29pbi5IRE5vZGUge1xuICAvLyBubyBmYXN0IHBhdGggZm9yIHByaXZhdGUga2V5IGRlcml2YXRpb25zIC0tIGRlbGVnYXRlIHRvIHN0YW5kYXJkIG1ldGhvZFxuICBpZiAoIXNlY3AyNTZrMSB8fCBoZG5vZGUua2V5UGFpci5kKSB7XG4gICAgcmV0dXJuIGhkbm9kZS5kZXJpdmUoaW5kZXgpO1xuICB9XG5cbiAgY29uc3QgaXNIYXJkZW5lZCA9IGluZGV4ID49IGJpdGNvaW4uSEROb2RlLkhJR0hFU1RfQklUO1xuICBpZiAoaXNIYXJkZW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGRlcml2ZSBoYXJkZW5lZCBrZXkgZnJvbSBwdWJsaWMga2V5Jyk7XG4gIH1cblxuICBjb25zdCBpbmRleEJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgaW5kZXhCdWZmZXIud3JpdGVVSW50MzJCRShpbmRleCwgMCk7XG5cbiAgLy8gZGF0YSA9IHNlclAocG9pbnQoa3BhcikpIHx8IHNlcjMyKGluZGV4KVxuICAvLyAgICAgID0gc2VyUChLcGFyKSB8fCBzZXIzMihpbmRleClcbiAgY29uc3QgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgIGhkbm9kZS5rZXlQYWlyLmdldFB1YmxpY0tleUJ1ZmZlcigpLFxuICAgIGluZGV4QnVmZmVyLFxuICBdKTtcblxuICBjb25zdCBJID0gY3JlYXRlSG1hYygnc2hhNTEyJywgaGRub2RlLmNoYWluQ29kZSkudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xuICBjb25zdCBJTCA9IEkuc2xpY2UoMCwgMzIpO1xuICBjb25zdCBJUiA9IEkuc2xpY2UoMzIpO1xuXG4gIGNvbnN0IHBJTCA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihJTCk7XG5cbiAgLy8gSW4gY2FzZSBwYXJzZTI1NihJTCkgPj0gbiwgcHJvY2VlZCB3aXRoIHRoZSBuZXh0IHZhbHVlIGZvciBpXG4gIGlmIChwSUwuY29tcGFyZVRvKGN1cnZlLm4pID49IDApIHtcbiAgICByZXR1cm4gZGVyaXZlRmFzdChoZG5vZGUsIGluZGV4ICsgMSk7XG4gIH1cblxuICAvLyBQcml2YXRlIHBhcmVudCBrZXkgLT4gcHJpdmF0ZSBjaGlsZCBrZXlcbiAgLy8gS2kgPSBwb2ludChwYXJzZTI1NihJTCkpICsgS3BhclxuICAvLyAgICA9IEcqSUwgKyBLcGFyXG5cbiAgLy8gVGhlIGV4cGVuc2l2ZSBvcCBpcyB0aGUgcG9pbnQgbXVsdGlwbHkgLS0gdXNlIHNlY3AyNTZrMSBsaWIgdG8gZG8gdGhhdFxuICBjb25zdCBLaSA9IGVjdXJ2ZS5Qb2ludC5kZWNvZGVGcm9tKGN1cnZlLCBzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKElMLCBmYWxzZSkpLmFkZChoZG5vZGUua2V5UGFpci5RKTtcblxuICAvLyBJbiBjYXNlIEtpIGlzIHRoZSBwb2ludCBhdCBpbmZpbml0eSwgcHJvY2VlZCB3aXRoIHRoZSBuZXh0IHZhbHVlIGZvciBpXG4gIGlmIChjdXJ2ZS5pc0luZmluaXR5KEtpKSkge1xuICAgIHJldHVybiBkZXJpdmVGYXN0KGhkbm9kZSwgaW5kZXggKyAxKTtcbiAgfVxuXG4gIGNvbnN0IGtleVBhaXIgPSBuZXcgYml0Y29pbi5FQ1BhaXIobnVsbCwgS2ksIHsgbmV0d29yazogaGRub2RlLmtleVBhaXIubmV0d29yayB9KTtcbiAgY29uc3QgaGQgPSBuZXcgYml0Y29pbi5IRE5vZGUoa2V5UGFpciwgSVIpO1xuXG4gIGhkLmRlcHRoID0gaGRub2RlLmRlcHRoICsgMTtcbiAgaGQuaW5kZXggPSBpbmRleDtcbiAgaGQucGFyZW50RmluZ2VycHJpbnQgPSBoZG5vZGUuZ2V0RmluZ2VycHJpbnQoKS5yZWFkVUludDMyQkUoMCk7XG5cbiAgcmV0dXJuIGhkO1xufVxuXG4vKipcbiAqIERlcml2ZSBhIEJJUDMyIHBhdGgsIGdpdmVuIGEgcm9vdCBrZXlcbiAqIFdlIGNhY2hlIGtleXMgYXQgZWFjaCBsZXZlbCBvZiBoaWVyYXJjaHkgd2UgZGVyaXZlLCB0byBhdm9pZCByZS1kZXJpdmluZyAoYXBwcm94IDI1bXMgcGVyIGRlcml2YXRpb24pXG4gKiBAcGFyYW0gcm9vdEtleSBrZXkgdG8gZGVyaXZlIG9mZlxuICogQHJldHVybnMgeyp9IGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlcml2ZSBhIG5ldyBIRE5vZGUgZnJvbSB0aGUgcm9vdCBIRE5vZGUgb24gYSBnaXZlbiBwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZFBhdGgocm9vdEtleSk6IHsgZGVyaXZlOiAocGF0aDogc3RyaW5nKSA9PiBiaXRjb2luLkhETm9kZTsgZGVyaXZlS2V5OiAocGF0aDogc3RyaW5nKSA9PiBiaXRjb2luLkVDUGFpcjsgfSB7XG4gIGNvbnN0IGNhY2hlID0ge307XG4gIGNvbnN0IGRlcml2ZSA9IGZ1bmN0aW9uKHBhdGg6IHN0cmluZyk6IGJpdGNvaW4uSEROb2RlIHtcbiAgICBjb25zdCBjb21wb25lbnRzID0gcGF0aC5zcGxpdCgnLycpLmZpbHRlcihmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gYyAhPT0gJyc7XG4gICAgfSk7XG4gICAgLy8gc3RyaXAgYW55IGV4dHJhbmVvdXMgLyBjaGFyYWN0ZXJzXG4gICAgcGF0aCA9IGNvbXBvbmVudHMuam9pbignLycpO1xuICAgIGlmIChjYWNoZVtwYXRoXSkge1xuICAgICAgcmV0dXJuIGNhY2hlW3BhdGhdO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aDtcbiAgICBpZiAobGVuID09PSAwIHx8IGxlbiA9PT0gMSAmJiBjb21wb25lbnRzWzBdID09PSAnbScpIHtcbiAgICAgIHJldHVybiByb290S2V5O1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRQYXRoID0gY29tcG9uZW50cy5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcvJyk7XG4gICAgY29uc3QgcGFyZW50S2V5ID0gZGVyaXZlKHBhcmVudFBhdGgpO1xuICAgIGNvbnN0IGVsID0gY29tcG9uZW50c1tsZW4gLSAxXTtcblxuICAgIGxldCBoYXJkZW5lZCA9IGZhbHNlO1xuICAgIGlmIChlbFtlbC5sZW5ndGggLSAxXSA9PT0gXCInXCIpIHtcbiAgICAgIGhhcmRlbmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBwYXJzZUludChlbCwgMTApO1xuICAgIGxldCBkZXJpdmVkO1xuICAgIGlmIChoYXJkZW5lZCkge1xuICAgICAgZGVyaXZlZCA9IHBhcmVudEtleS5kZXJpdmVIYXJkZW5lZChpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlcml2ZWQgPSBkZXJpdmVGYXN0KHBhcmVudEtleSwgaW5kZXgpO1xuICAgIH1cbiAgICBjYWNoZVtwYXRoXSA9IGRlcml2ZWQ7XG4gICAgcmV0dXJuIGRlcml2ZWQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gZGVyaXZlS2V5KHBhdGg6IHN0cmluZyk6IGJpdGNvaW4uRUNQYWlyIHtcbiAgICBjb25zdCBoZE5vZGUgPSBkZXJpdmUocGF0aCk7XG4gICAgcmV0dXJuIGhkTm9kZS5rZXlQYWlyO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkZXJpdmU6IGRlcml2ZSxcbiAgICBkZXJpdmVLZXk6IGRlcml2ZUtleSxcbiAgfTtcbn1cbiJdfQ==